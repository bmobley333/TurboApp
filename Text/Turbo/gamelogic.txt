<!-- gamelogic.html -->


<script>




// ==========================================================================
// === Message Box             (End of ...) ===
// ==========================================================================




// gUI addition needed (add this within the gUI object in scripts.html or here if you prefer)
// gUI.messagePromiseResolve = null; // Function to resolve the message promise


// fShowMessage ///////////////////////////////////////////////////////////////////
// Purpose -> Displays the message modal box and returns a Promise that resolves when closed.
// Inputs -> message (String): The text or HTML to display in the message box.
// Outputs -> (Promise): Resolves when the modal is hidden.
// MODIFIED: Now async, returns a Promise, stores resolve function in gUI.
async function fShowMessage(message) {
    // --- Try to cache elements if not already done ---
    if (!gUI.messageModalOverlay) {
        gUI.messageModalOverlay = document.getElementById('messageModal');
        // If caching now, log it for debugging timing issues
        if (gUI.messageModalOverlay) console.log("fShowMessage: Just-in-time cache for #messageModal");
    }
    if (!gUI.messageModalText) {
        gUI.messageModalText = document.getElementById('messageText');
        if (gUI.messageModalText) console.log("fShowMessage: Just-in-time cache for #messageText");
    }
    // --- End Caching Attempt ---

    // Now, re-check if elements exist *after* attempting to cache
    if (!gUI.messageModalOverlay || !gUI.messageModalText) {
        // Log the original error if elements are *still* not found
        console.error("Message modal elements not cached or found in the DOM!");
        if (!gUI.messageModalOverlay) console.error("Missing: #messageModal");
        if (!gUI.messageModalText) console.error("Missing: #messageText");
        // Optionally: Fallback to a simpler alert if modal isn't ready
        // alert("Modal Error!\n" + message);
        return Promise.reject(new Error("Message modal elements not found.")); // Reject if elements missing
    }

    // Set message content (using innerHTML allows basic tags like <br>)
    gUI.messageModalText.innerHTML = message;

    // Show the modal
    gUI.messageModalOverlay.style.display = 'flex'; // Using flex as defined in CSS

    // Create and return a new Promise
    return new Promise((resolve) => {
        gUI.messagePromiseResolve = resolve; // Store the resolve function globally
    });

} // END fShowMessage




// fHideMessage ///////////////////////////////////////////////////////////////////
// Purpose -> Hides the message modal box and resolves the pending promise.
// Inputs -> None
// Outputs -> None
// MODIFIED: Calls the stored resolve function if it exists.
function fHideMessage() {
    if (gUI.messageModalOverlay) {
        gUI.messageModalOverlay.style.display = 'none';
    } else {
        // This shouldn't happen if elements were cached, but log just in case
        console.error("Message modal overlay element (#messageModal) not found when trying to hide.");
    }

    // Resolve the promise if a resolve function is stored
    if (typeof gUI.messagePromiseResolve === 'function') {
        gUI.messagePromiseResolve();          // Call the stored resolve function
        gUI.messagePromiseResolve = null; // Clear the stored function
        fLogStatus("Message Promise Resolved"); // Optional log
    }
} // END fHideMessage




// fSetupMessageModalListeners /////////////////////////////////////////////////////
// Purpose -> Sets up event listeners for the message modal close mechanisms.
// Inputs -> None
// Outputs -> None
// NOTE: No changes needed here, as the listeners already call fHideMessage,
//       which now handles resolving the promise.
function fSetupMessageModalListeners() {

    fLogStatus("🖱️ Setting up Message Modal Listeners...");
    // --- Get elements directly here, don't rely solely on gUI cache ---
    const overlayElement = document.getElementById('messageModal');
    const closeButtonElement = document.getElementById('closeMessageModal');
    // We still need the overlay for the other listeners, might as well fetch it too.

    // Check if elements were found *now*
    if (!overlayElement) {
        console.error("Setup failed: Message modal overlay element (#messageModal) not found *during listener setup*.");
        fLogStatus("⚠️ Message Modal Listeners NOT Attached (overlay missing).");
        return;
    }
    if (!closeButtonElement) {
        console.error("Setup failed: Message modal close button (#closeMessageModal) not found *during listener setup*.");
        fLogStatus("⚠️ Message Modal Listeners NOT Attached (button missing).");
        return; // Don't add listeners if button is missing
    }
    // --- End direct element fetching ---


    // Listener for the close button - Attach to the element we just found
    closeButtonElement.addEventListener('click', fHideMessage); // Calls the (now modified) hide function


    // Listener for clicking the background overlay - Attach to the element we just found
    overlayElement.addEventListener('click', (event) => {
        if (event.target === overlayElement) { // Check directly against the fetched element
            fHideMessage(); // Calls the (now modified) hide function
        }
    });

    // Listener for the Escape key (uses document, and checks overlay visibility)
    document.addEventListener('keydown', (event) => {
        // Check overlay visibility using the fetched element reference
        if (overlayElement.style.display !== 'none' && event.key === 'Escape') {
             fHideMessage(); // Calls the (now modified) hide function
        }
    });

    fLogStatus("✅ Message Modal Listeners Attached.");

} // END fSetupMessageModalListeners



// ==========================================================================
// === Die Roll Button         (End of Message Box) ===
// ==========================================================================




// scripts.html

// fHandleRollDiceAction /////////////////////////////////////////////////////////////////////////
// Purpose -> Top-level handler for "Roll Dice" action. Populates gUI.roll, validates inputs,
//            runs morph/roll/resolution logic, and posts result.
// Inputs  -> None (uses gUI.currentSkRadioChecked).
// Outputs -> None (updates gUI and DOM).
async function fHandleRollDiceAction() { // <<< Added async
    fLogStatus("🎲 Roll Dice Action Triggered");

    const { r, c } = gUI.currentSkRadioChecked;

    // Validate target is a valid Sk1/Sk2 checkbox
    // Must await as fValidateAbilityCB is now async
    if (!await fValidateAbilityCB(r, c)) return; // <<< Added await

    // Populate gUI.roll from sheet and clean it
    // Must await if fResetPopulateNCleanGUIRoll becomes async (due to its catch block)
    if (!await fResetPopulateNCleanGUIRoll(r, c)) return; // <<< Added await (assuming fResetPopulateNCleanGUIRoll is made async)

    // Confirm ability has valid name and type
    // Must await as fVerifyAbility is now async
    if (!await fVerifyAbility()) return; // <<< Added await

    // Core calculation pipeline
    // Must await as fProcessMorph is now async
    await fProcessMorph(); // <<< Added await
    fCalcGUIRollResSk();
    fCalcGUIRollRoll();
    fCalcGUIRollResRoll();
    fCalcRollLogPrepend();
} // END fHandleRollDiceAction




// fValidateAbilityCB /////////////////////////////////////////////////////////////////////////
// Purpose -> Confirms that (row, col) is a valid Sk1/Sk2 checkbox based on gUI.sk1sk2CheckBoxes.
// Inputs  -> row (Number), col (Number): 0-based indices.
// Outputs -> (Boolean): true if valid, false otherwise.
// MODIFIED: Made async to await fShowMessage
async function fValidateAbilityCB(row, col) {             // <<< Added async
    const isValid = fIsSkRadioGroupMember(row, col);
    if (!isValid) {
        await fShowMessage("⚠️ Please select a valid Ability checkbox first!"); // <<< Added await
    }
    return isValid;
} // END fValidateAbilityCB




// fResetPopulateNCleanGUIRoll //////////////////////////////////////////////////////////////////
// Purpose -> Extracts and cleans ability row data into gUI.roll based on Sk1 or Sk2 checkbox.
// Inputs  -> r (Number), c (Number): Row and column from selected radio.
// Outputs -> (Boolean): true if success, false if extraction/cleaning fails.
async function fResetPopulateNCleanGUIRoll(r, c) { 
    try {
        const getVal = tag => gUI.arr[r]?.[resolveCol(tag)] ?? '';
        const isSk1 = (c === resolveCol('Sk1ChkBox'));

        // --- Initial Population ---
        gUI.roll = {
            sk1CB: isSk1,
            skMorph: isSk1 ? getVal('Morph1') : getVal('Morph2'),
            skTyp: isSk1 ? getVal('Sk1Typ') : getVal('Sk2Typ'),
            skSk: isSk1 ? getVal('Sk1') : getVal('Sk2'),
            skIsOn: getVal('On'),
            skNameID: getVal('Ability'),
            skName: '',
            skAct: isSk1 ? getVal('Act') : '',
            skDur: isSk1 ? getVal('Dur') : '',
            skMeta: isSk1 ? getVal('Meta') : '',
            skUses: isSk1 ? getVal('Uses') : '',
            resTyp: '',
            resSk: '',
            resFlatBase: '',
            resFlatResult: '',
            resDif: '',
            resFocus: '',
            resPlus: '',
            resPlusPlus: '',
            resdctMult: '', 
            resMult: '',
            resMultMult: '',
            resCombine: '',
            isUnSk: false,
            roll: '',
            resRoll: ''
         };

        const rData = gUI.roll;
        // --- Clean string fields ---
        rData.skName = String(rData.skNameID || '').replace(/\s{2,}_\w{6}$/, '').trim();
        rData.skMorph = String(rData.skMorph || '').trim().replace(/^,+/, '');
        rData.skTyp = String(rData.skTyp || '').trim();
        rData.skIsOn = String(rData.skIsOn || '').trim();
        rData.skDur = String(rData.skDur || '').trim();
        rData.skMeta = String(rData.skMeta || '').trim();
        // --- Clean numeric fields ---
        const sk = parseInt(rData.skSk, 10);
        rData.skSk = (!isNaN(sk) && sk >= 1) ? sk : '';

        const act = parseInt(String(rData.skAct || '').trim(), 10);
        rData.skAct = (!isNaN(act) && act >= 1) ? act : '';

        const uses = parseInt(rData.skUses, 10);
        rData.skUses = (!isNaN(uses) && uses >= 0) ? uses : '';
        // --- Default resTyp to skTyp ---
        rData.resTyp = rData.skTyp;
        // --- Final status log ---
        fLogStatus(`⚙️ Populated & Cleaned gUI.roll for row ${r} (isSk1: ${isSk1})`);
        return true;

    } catch (err) {
        // --- Error Handling ---
        console.error("❌ Error populating/cleaning gUI.roll:", err);
        fPrependToSidebar(`❌ Error processing skill data: ${err.message}`);
        fShowSidebar();
        return false;
    }
} // END fResetPopulateNCleanGUIRoll



// fVerifyAbility /////////////////////////////////////////////////////////////////////////
// Purpose -> Validates current gUI.roll by checking name and skill type.
// Inputs  -> None (uses gUI.roll and gUI.list).
// Outputs -> (Boolean): true if ability is valid, false otherwise.
// MODIFIED: Made async to await fShowMessage
async function fVerifyAbility() {                           // <<< Added async
    const { skName, skTyp, sk1CB } = gUI.roll;

    // --- Check: Ability name must exist ---
    if (!skName) {
        await fShowMessage("⚠️ Please select an Ability with a name!"); // <<< Added await
        return false;
    }

    // --- Check: Skill Typ must be a string ---
    if (!skTyp || typeof skTyp !== 'string') {
        const is2ndCol = !sk1CB;
        await fShowMessage(`⚠️ No skill Typ found${is2ndCol ? '<br><br>You may have wanted the 1st column.' : ''}`); // <<< Added await
        return false;
    }

    // --- Check: Skill type must match known types (case-insensitive) ---
    const skTypLower = skTyp.trim().toLowerCase();
    const isValidSkTyp = gUI.list.skTyp.some(type => type.toLowerCase() === skTypLower);
    if (!isValidSkTyp) {
        await fShowMessage(`⚠️ ${skTyp} is an invalid Skill Type!`); // <<< Added await
        return false;
    }

    // --- Passed all checks ---
    return true;
} // END fVerifyAbility



// fProcessMorph /////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Processes gUI.roll.skMorph string to extract modifiers and flags into res* fields.
// Inputs  -> None (reads gUI.roll.skMorph, gUI.roll.skSk, gUI.list).
// Outputs -> None (updates gUI.roll directly).
async function fProcessMorph() { // <<< Added async
    const skMorph = gUI.roll.skMorph || '';
    if (!skMorph) {
        fLogStatus("ℹ️ No skMorph string to process.");
        return;
    }

    // Split morph string and compile lowercased version
    const morphComponents = skMorph.split(',').map(x => x.trim()).filter(Boolean);
    const morphLower = morphComponents.map(x => x.toLowerCase());

    // Accumulator object for temp results
    const acc = {
        foundResTyp: false,
        lastResTypMatch: '',
        lastFocusIndex: -1,
        foundResPlus: false,
        totalPlus: 0,
        combineNumbers: [],
        foundResPlusPlus: false,
        totalPlusPlus: 0,
        foundResMult: false,
        totalMult: 1.0,
        foundResMultMult: false,
        totalMultMult: 1.0,
        lastFlatBaseMatch: '',
        lastFlatResultMatch: '',
        lastDifMatch: '',
        foundResdctMult: false,
        totalResdctMult: 1.0
    };
    // Await the parsing function which now handles async messages
    await fParseMorphComponents(morphComponents, morphLower, acc);

    fApplyMorphResults(acc);

    fLogStatus("⚙️ Processed skMorph string.");
} // END fProcessMorph




// fParseMorphComponents ////////////////////////////////////////////////////////////////////////////////
// Purpose -> Parses each morph component and mutates gUI.roll and acc accordingly.
// MODIFIED: Made async, changed forEach to for...of, added await to fShowMessage, added DCT logic
async function fParseMorphComponents(morphComponents, morphLower, acc) { 
    const plusMinusRegex = /^([-+])(\d+)$/;
    const numberOnlyRegex = /^\d+$/;
    const plusPlusMinusMinusRegex = /^(?:(\+\+)|(--))(\d+)$/;
    const multDivRegex = /^([*\/])(\d+(\.\d+)?)$/;
    const multMultDivDivRegex = /^(?:(\*\*)|(\/\/))(\d+(\.\d+)?)$/;
    const equalsRegex = /^=(\d+)$/;
    const equalsEqualsRegex = /^==(\d+)$/;
    const caretRegex = /^\^(\d+)$/;
    const dctRegex = /^([-+])(\d+)([dct])$/i; // <<< ADDED: Case-insensitive

    // Use for...of loop instead of forEach to allow await
    let index = 0;
    // Manual index tracking needed for morphLower
    for (const component of morphComponents) {
        const lower = morphLower[index];
        // --- isUnSk Check
        if (lower === 'un' || lower === 'unsk') gUI.roll.isUnSk = true;
        // --- resTyp Check (find LAST match)
        if (gUI.list.skTyp.includes(lower)) {
            acc.lastResTypMatch = component;
            acc.foundResTyp = true;
        }

        // --- resFocus Check (find index of LAST match)
        const focusIndex = gUI.list.metaColor.indexOf(lower);
        if (focusIndex > -1) acc.lastFocusIndex = focusIndex;

        // --- resPlus Check
        const plusMatch = component.match(plusMinusRegex);
        if (plusMatch) {
            const val = parseInt(plusMatch[2], 10);
            acc.totalPlus += (plusMatch[1] === '+' ? val : -val);
            acc.foundResPlus = true;
        }

        // --- resCombine Check (collect numbers)
        if (numberOnlyRegex.test(component)) acc.combineNumbers.push(parseInt(component, 10));
        // --- resPlusPlus Check
        const ppMatch = component.match(plusPlusMinusMinusRegex);
        if (ppMatch) {
            const val = parseInt(ppMatch[3], 10);
            acc.totalPlusPlus += (ppMatch[1] === '++' ? val : -val);
            acc.foundResPlusPlus = true;
        }

        // --- resMult Check
        const m1 = component.match(multDivRegex);
        if (m1) {
            const val = parseFloat(m1[2]);
            if (m1[1] === '*') {
                 acc.totalMult *= val;
            } else if (val !== 0) {
                 acc.totalMult /= val;
            } else {
                // Use await here
                await fShowMessage("❌ Morph includes illegal '/0'. Please correct and try again.");
                // <<< Added await
                console.warn("resMult divide by zero:", component);
                // Consider adding 'return;' or 'throw new Error(...);' here if this error should halt processing
            }
            acc.foundResMult = true;
        }

        // --- resMultMult Check
        const m2 = component.match(multMultDivDivRegex);
        if (m2) {
            const val = parseFloat(m2[3]);
            if (m2[1] === '**') {
                acc.totalMultMult *= val;
            } else if (val !== 0) {
                acc.totalMultMult /= val;
            } else {
                // Use await here
                await fShowMessage("❌ Morph includes illegal '//0'. Please correct and try again.");
                // <<< Added await
                console.warn("resMultMult divide by zero:", component);
                // Consider adding 'return;' or 'throw new Error(...);' here if this error should halt processing
            }
            acc.foundResMultMult = true;
        }

        // --- resdctMult Check
        const dctMatch = component.match(dctRegex);
        if (dctMatch) {
            const sign = dctMatch[1];
            const num = parseInt(dctMatch[2], 10);
            const type = dctMatch[3].toLowerCase();
            let multiplier = 1.0;

            if (num !== 0) { // Ignore if number is 0
                const isPositive = (sign === '+');
                switch (type) {
                    case 'c':
                        const critFactor = 2 * num;
                        if (critFactor === 0) { // Avoid division by zero
                            console.warn("DCT Morph resulted in divide by zero (critFactor):", component);
                            multiplier = 1; // Or handle as error
                        } else {
                             multiplier = isPositive ? critFactor : (1 / critFactor);
                        }
                        break;
                    case 't':
                        // 10^0 is 1, so 1/1 is 1. Handle large numbers if needed.
                        const tremFactor = Math.pow(10, num);
                        multiplier = isPositive ? tremFactor : (1 / tremFactor);
                        break;
                    case 'd':
                        const dTierTerm = (1 + (num / 3));
                         if (dTierTerm === 0) { // Avoid division by zero
                             console.warn("DCT Morph resulted in divide by zero (dTierTerm):", component);
                             multiplier = 1;  // Or handle as error
                         } else {
                              multiplier = isPositive ? dTierTerm : (1 / dTierTerm);
                         }
                        break;
                }

                 // Additional check for invalid multipliers (NaN, Infinity) before applying
                 if (!isNaN(multiplier) && isFinite(multiplier) && multiplier > 0) {
                     // Apply the multiplier cumulatively
                     acc.totalResdctMult *= multiplier;
                     acc.foundResdctMult = true;
                 } else {
                      console.warn(`Invalid DCT multiplier calculated for "${component}": ${multiplier}. Skipping this morph.`);
                      // Optional await fShowMessage(`⚠️ Invalid result for morph "${component}". Check value.`);
                 }
            }
        }
        // --- End resdctMult Check ---

        // --- resFlatBase Check (find LAST match)
        const eq1 = component.match(equalsRegex);
        if (eq1) acc.lastFlatBaseMatch = eq1[1];

        // 10. resFlatResult Check (find LAST match)
        const eq2 = component.match(equalsEqualsRegex);
        if (eq2) acc.lastFlatResultMatch = eq2[1];

        // --- resDif Check (find LAST match)
        const dif = component.match(caretRegex);
        if (dif) acc.lastDifMatch = dif[1];

        index++; // Increment manual index
    } // <<< End of for...of loop
} // END fParseMorphComponents




// fApplyMorphResults ////////////////////////////////////////////////////////////////////////////////
// Purpose -> Applies accumulated morph data to gUI.roll.
function fApplyMorphResults(acc) {
    const r = gUI.roll;
    // MUST BE FIRST: Assign resFlatBase (also sets skSk)
    if (acc.lastFlatBaseMatch !== '') {
        const num = parseInt(acc.lastFlatBaseMatch, 10);
        if (!isNaN(num)) {
            r.resFlatBase = num;
            r.skSk = num;
        }
    }

    // Assign resTyp (last match found else gUI.roll.skTyp)
    if (acc.foundResTyp) {
        r.resTyp = acc.lastResTypMatch || r.skTyp;
    }

    // Assign resFocus (index of last match found)
    if (acc.lastFocusIndex > -1) {
        r.resFocus = acc.lastFocusIndex;
    }

    // Assign resPlus
    if (acc.foundResPlus) {
        r.resPlus = acc.totalPlus;
    }

    // Assign resCombine
    if (typeof r.skSk === 'number' && r.skSk >= 1) { // Ensure skSk is a valid number before adding
        acc.combineNumbers.push(r.skSk);
    }
    if (acc.combineNumbers.length > 0) {
        acc.combineNumbers.sort((a, b) => b - a);
        let value = 0, divisor = 1;
        for (const num of acc.combineNumbers) {
            value += num / divisor;
            divisor *= 2;
        }
        r.resCombine = Math.round(value);
    }

    // Assign resPlusPlus
    if (acc.foundResPlusPlus) {
        r.resPlusPlus = acc.totalPlusPlus;
    }

    // Assign resMult
    if (acc.foundResMult) {
        r.resMult = Number(acc.totalMult.toFixed(6)); // Use more precision if needed
    }

    // Assign resMultMult
    if (acc.foundResMultMult) {
        r.resMultMult = Number(acc.totalMultMult.toFixed(6)); // Use more precision if needed
    }

    // Assign resdctMult
    if (acc.foundResdctMult) {
        // Rounding dct to 6 decimal places, adjust if needed
        r.resdctMult = Number(acc.totalResdctMult.toFixed(6));
    }

    // Assign resFlatResult (convert last match to integer)
    if (acc.lastFlatResultMatch !== '') {
        const num = parseInt(acc.lastFlatResultMatch, 10);
        if (!isNaN(num)) r.resFlatResult = num;
    }

    // Assign resDif (convert last match to integer)
    if (acc.lastDifMatch !== '') {
        const num = parseInt(acc.lastDifMatch, 10);
        if (!isNaN(num)) r.resDif = num;
    }
} // END fApplyMorphResults





// fCalcGUIRollResSk /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Calculates final resulting skill value (gUI.roll.resSk) using morph-derived modifiers.
// Inputs  -> None (reads from gUI.roll).
// Outputs -> None (writes gUI.roll.resSk).
function fCalcGUIRollResSk() {
    let currentResSk;

    // Use resCombine if it's a valid number; fallback to skSk if needed
    if (typeof gUI.roll.resCombine === 'number') {
        currentResSk = gUI.roll.resCombine;
        fLogStatus("   -> Using resCombine as base for resSk calculation.");
    } else if (typeof gUI.roll.skSk === 'number') {
        currentResSk = gUI.roll.skSk;
    } else {
        currentResSk = NaN;
    }

    // --- Modifier Application Pipeline ---
    // Only proceed if we have a valid numeric base
    if (!isNaN(currentResSk)) {

        // Apply resMult (multiplicative)
        if (typeof gUI.roll.resMult === 'number' && gUI.roll.resMult !== '') {
            currentResSk *= gUI.roll.resMult;
        }

        // Apply resdctMult (multiplicative)
        if (typeof gUI.roll.resdctMult === 'number' && gUI.roll.resdctMult !== '') {
             currentResSk *= gUI.roll.resdctMult;
        }

        // Apply resPlus (additive)
        if (typeof gUI.roll.resPlus === 'number' && gUI.roll.resPlus !== '') {
            currentResSk += gUI.roll.resPlus;
        }

        // Apply resFocus (focus index adds 5 * (1 + index))
        if (typeof gUI.roll.resFocus === 'number' && gUI.roll.resFocus >= 0) {
            currentResSk += 5 * (1 + gUI.roll.resFocus);
        }


        // Apply isUnSk (cut in half) AFTER all multipliers and additions
        if (gUI.roll.isUnSk === true) {
            currentResSk *= 0.5;
        }

        // --- Final Adjustment: Clamp Tiny Positive Values ---
        // Only clamp if it's positive but less than 1
        if (currentResSk > 0 && currentResSk < 1) {
            currentResSk = 1;
        }

        // --- Diagnostic Output ---
        // console.log(`DEBUG fCalcGUIRollResSk: Value before final check/assignment:`, currentResSk);

        // --- Final Assignment: Round valid positive results, else empty ---
        // Ensure result is a number and >= 1 after all calculations
        if (!isNaN(currentResSk) && currentResSk >= 1) {
            gUI.roll.resSk = Math.round(currentResSk);
        } else {
            gUI.roll.resSk = ''; // Set to empty if result is NaN, less than 1, etc.
        }
    } else {
        // Invalid input or no valid base found, leave resSk empty
        gUI.roll.resSk = '';
    }

    fLogStatus(`⚙️ Calculated final resSk: ${gUI.roll.resSk}`);
} // END fCalcGUIRollResSk




// fCalcGUIRollRoll /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Determines dice roll result (gUI.roll.roll) based on resSk and resTyp.
// Inputs  -> None (reads gUI.roll.resSk, gUI.roll.resTyp).
// Outputs -> None (writes gUI.roll.roll).
function fCalcGUIRollRoll() {
    const resSkValue = gUI.roll.resSk;
    const resTypValue = (typeof gUI.roll.resTyp === 'string')
        ? gUI.roll.resTyp.trim().toLowerCase()
        : '';


    // --- Validate resSk (must be a number >= 1) ---
    if (typeof resSkValue !== 'number' || resSkValue < 1) {
        gUI.roll.roll = '';
        fLogStatus(`ℹ️ Cannot calculate roll: Invalid resSk value (${resSkValue}).`);
        return;
    }


    // --- Determine roll function based on resTyp ---
    switch (resTypValue) {


        // No type → skip rolling
        case '': gUI.roll.roll = ''; break;


        // Skill or Attribute roll
        case 'sk':
        case 'atr': gUI.roll.roll = fCSDSk(resSkValue); break;


        // Attack roll
        case 'atk': gUI.roll.roll = fCSAtk(resSkValue); break;


        // Damage roll
        case 'dmg': gUI.roll.roll = fCSDDmg(resSkValue); break;


        // Defense roll
        case 'def': gUI.roll.roll = fCSDef(resSkValue); break;


        // Armor roll (may return decimal)
        case 'ar': gUI.roll.roll = fCSDArmor(resSkValue); break;


        // Unexpected usage of 'unsk' as final roll type
        case 'un':
        case 'unsk':
            console.warn(`fCalcGUIRollRoll: Roll type '${resTypValue}' used directly. Consider adjusting morph.`);
            gUI.roll.roll = fCSDSk(resSkValue);
            break;


        // Unknown roll type
        default:
            console.warn(`fCalcGUIRollRoll: Unknown resTyp '${resTypValue}'. Cannot calculate roll.`);
            gUI.roll.roll = '';
            break;
    }


    // --- Final Logging ---
    fLogStatus(`⚙️ Calculated roll (${resTypValue}): ${gUI.roll.roll}`);
} // END fCalcGUIRollRoll



// fCalcGUIRollResRoll /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Calculates final gUI.roll.resRoll using overrides or morph-based modifiers.
// Inputs  -> None (reads gUI.roll).
// Outputs -> None (writes gUI.roll.resRoll).
function fCalcGUIRollResRoll() {

    // --- Check for Flat Result Override ---
    // Check if resFlatResult is a number and not empty string
    const flatResult = (typeof gUI.roll.resFlatResult === 'number' && gUI.roll.resFlatResult !== '')
         ? gUI.roll.resFlatResult : null;

    if (flatResult !== null) {
        const isArType = (typeof gUI.roll.resTyp === 'string') && gUI.roll.resTyp.trim().toLowerCase() === 'ar';
        // Round appropriately based on type (AR needs decimals)
        const roundedFlatResult = isArType ? Number(flatResult.toFixed(2)) : Math.round(flatResult);
        gUI.roll.resRoll = Math.max(0, roundedFlatResult); // Clamp at 0 minimum
        fLogStatus(`⚙️ Calculated resRoll (override, ${isArType ? 'AR-rounded' : 'INT-rounded'}): ${gUI.roll.resRoll}`);
        return; // Exit early as override takes precedence
    }

    // --- Validate Base Roll ---
    // Check if initial roll is a number and not empty string
    const initialRoll = gUI.roll.roll;
    if (typeof initialRoll !== 'number' || initialRoll === '' || isNaN(initialRoll)) { // Added isNaN check
        gUI.roll.resRoll = '';
        fLogStatus(`ℹ️ Cannot calculate resRoll: Invalid initial roll value (${initialRoll}).`);
        return;
    }

    // --- Apply Modifiers ---
    let currentResRoll = initialRoll;

    // Apply resMultMult
    if (typeof gUI.roll.resMultMult === 'number' && gUI.roll.resMultMult !== '') {
        currentResRoll *= gUI.roll.resMultMult;
    }

    // Apply resPlusPlus
    if (typeof gUI.roll.resPlusPlus === 'number' && gUI.roll.resPlusPlus !== '') {
        currentResRoll += gUI.roll.resPlusPlus;
    }

    // Apply resdctMult (multiplicative) <<< ADDED BLOCK ---
    if (typeof gUI.roll.resdctMult === 'number' && gUI.roll.resdctMult !== '') {
        currentResRoll *= gUI.roll.resdctMult;
    }
    // --- End resdctMult Block ---

    // --- Final Rounding, Clamping, and Assignment ---
    if (!isNaN(currentResRoll)) {
        const isArType = (typeof gUI.roll.resTyp === 'string') && gUI.roll.resTyp.trim().toLowerCase() === 'ar';
        // Round appropriately
        const roundedResRoll = isArType ? Number(currentResRoll.toFixed(2)) : Math.round(currentResRoll);
        gUI.roll.resRoll = Math.max(0, roundedResRoll); // Clamp at 0 minimum
    } else {
        gUI.roll.resRoll = ''; // Set to empty if calculation resulted in NaN
        console.warn("fCalcGUIRollResRoll: Calculation resulted in NaN.");
    }

    fLogStatus(`⚙️ Calculated final resRoll: ${gUI.roll.resRoll}`);
} // END fCalcGUIRollResRoll





// fCalcGUIRollResRoll /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Calculates final gUI.roll.resRoll using overrides or morph-based modifiers.
// Inputs  -> None (reads gUI.roll).
// Outputs -> None (writes gUI.roll.resRoll).
function fCalcGUIRollResRoll() {

    // --- Check for Flat Result Override ---
    const flatResult = (typeof gUI.roll.resFlatResult === 'number' && gUI.roll.resFlatResult !== '') ? gUI.roll.resFlatResult : null;

    if (flatResult !== null) {
        const isArType = (typeof gUI.roll.resTyp === 'string') && gUI.roll.resTyp.trim().toLowerCase() === 'ar';
        const roundedFlatResult = isArType ? Number(flatResult.toFixed(2)) : Math.round(flatResult);
        gUI.roll.resRoll = Math.max(0, roundedFlatResult);
        fLogStatus(`⚙️ Calculated resRoll (override, ${isArType ? 'AR-rounded' : 'INT-rounded'}): ${gUI.roll.resRoll}`);
        return;
    }

    // --- Validate Base Roll ---
    const initialRoll = gUI.roll.roll;
    if (typeof initialRoll !== 'number' || initialRoll === '') {
        gUI.roll.resRoll = '';
        fLogStatus(`ℹ️ Cannot calculate resRoll: Invalid initial roll value (${initialRoll}).`);
        return;
    }

    // --- Apply Modifiers ---
    let currentResRoll = initialRoll;
    if (typeof gUI.roll.resMultMult === 'number' && gUI.roll.resMultMult !== '') currentResRoll *= gUI.roll.resMultMult;
    if (typeof gUI.roll.resPlusPlus === 'number' && gUI.roll.resPlusPlus !== '') currentResRoll += gUI.roll.resPlusPlus;

    // --- Final Rounding, Clamping, and Assignment ---
    if (!isNaN(currentResRoll)) {
        const isArType = (typeof gUI.roll.resTyp === 'string') && gUI.roll.resTyp.trim().toLowerCase() === 'ar';
        const roundedResRoll = isArType ? Number(currentResRoll.toFixed(2)) : Math.round(currentResRoll);
        gUI.roll.resRoll = Math.max(0, roundedResRoll);
    } else {
        gUI.roll.resRoll = '';
        console.warn("fCalcGUIRollResRoll: Calculation resulted in NaN.");
    }

    fLogStatus(`⚙️ Calculated final resRoll: ${gUI.roll.resRoll}`);
} // END fCalcGUIRollResRoll






// fCalcRollLogPrepend /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Builds final roll result log message and prepends it to the sidebar.
// Inputs  -> None (reads gUI.roll).
// Outputs -> None (calls fPrependToSidebar, fShowSidebar).
function fCalcRollLogPrepend() {
    const html = fBuildRollLogHTML();
    fPrependToSidebar(html);
    fShowSidebar();
    fLogStatus("📰 Roll Log message prepended.");
} // END fCalcRollLogPrepend




// fBuildRollLogHTML /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Constructs and returns the formatted HTML log line based on gUI.roll data.
// Inputs  -> None (reads gUI.roll).
// Outputs -> (String): HTML string to insert in sidebar.
function fBuildRollLogHTML() {

    // --- Build Title ---
    const skTyp = (typeof gUI.roll.skTyp === 'string') ? gUI.roll.skTyp.trim() : '';
    const resTyp = (typeof gUI.roll.resTyp === 'string') ? gUI.roll.resTyp.trim() : '';
    let title = gUI.roll.skName || 'Unknown Ability';
    if (skTyp) title += ` ${skTyp}`;
    if (resTyp && resTyp !== skTyp) title += ` (now ${resTyp})`;

    // --- Get Morph String ---
    const morph = (typeof gUI.roll.skMorph === 'string' && gUI.roll.skMorph !== ',') ? gUI.roll.skMorph.trim() : '';

    // --- Build Roll Base String (Type(Sk->ResSk)) ---
    let rollBase = resTyp || skTyp;
    const skSk = gUI.roll.skSk;
    const resSk = gUI.roll.resSk;
    if (typeof skSk === 'number' && skSk !== '') {
        rollBase += `(${skSk}${(typeof resSk === 'number' && resSk !== '' && resSk !== skSk) ? `->${resSk}` : ''})`;
    } else if (typeof resSk === 'number' && resSk !== '') {
        rollBase += `(${resSk})`;
    }

    // --- Build Roll Result String (~Roll->ResRoll) ---
    const roll = gUI.roll.roll;
    const resRoll = gUI.roll.resRoll;
    let rollResult = '';
    if ((typeof roll === 'number' || (typeof roll === 'string' && roll !== '')) && roll != null) {
        rollResult += ` ~${roll}`;
        if ((typeof resRoll === 'number' || (typeof resRoll === 'string' && resRoll !== '')) && resRoll != null && resRoll !== roll) {
            rollResult += `->${resRoll}`;
        }
    } else if ((typeof resRoll === 'number' || (typeof resRoll === 'string' && resRoll !== '')) && resRoll != null) {
        rollResult += ` ~${resRoll}`;
    }

    // --- Build Difficulty (^Dif) ---
    const dif = gUI.roll.resDif;
    let rollDif = (typeof dif === 'number' || (typeof dif === 'string' && dif !== '')) && dif != null ? `^${dif}` : '';

    // --- Build Success Delta (=/+Δ) ---
    let rollSuccess = '';
    if (typeof resRoll === 'number' && typeof dif === 'number') {
        const delta = resRoll - dif;
        rollSuccess = delta > 0 ? ` =+${delta}` : ` =${delta}`;
    }

    // --- Combine Roll Summary ---
    const roll1 = `${rollBase}${rollResult}${rollDif}${rollSuccess}`.trim();

    // --- Build Final HTML ---
    let html = `<span class="sidebar-ability-name">${title}</span>`;
    if (morph) html += `<br>morph: ${morph}`;
    if (roll1) html += `<br>${roll1}`;
    return html;
} // END fBuildRollLogHTML



// ==========================================================================
// === Base Die Rolling          (End of Die Roll Button ) ===
// ========================================================================== 


// fCSd //////////////////////////////////////////////////////////////////////
// Purpose -> Standard linear distribution die roll.
// Inputs  -> die (Number): The number of sides on the die.
// Outputs -> (Number): The result of the roll (1 to die).
function fCSd(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSd received invalid die size: ${die}`);
    return 1; // Return 1 for invalid input
  }
  return Math.floor(Math.random() * numDie) + 1;
} // END fCSd



// fCSD //////////////////////////////////////////////////////////////////////
// Purpose -> Make an old fashioned, but smooth, MetaScape d(die) roll (no T or C).
//            Uses a non-linear distribution.
// Inputs  -> die (Number): The base value for the roll.
// Outputs -> (Number): The result of the roll.
function fCSD(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSD received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  // Prevent division by zero or near-zero in Math.random()
  let randomDivisor = Math.random();
  if (randomDivisor < 0.0001) randomDivisor = 0.0001; // Set a minimum divisor

  return Math.floor((numDie * Math.random()) / randomDivisor) + 1;
} // END fCSD



// fCStc /////////////////////////////////////////////////////////////////////
// Purpose -> Rolls 1d16 to determine Tremendous ('T') or Critical ('C') result.
// Inputs  -> None.
// Outputs -> (String): "T", "C", or "".
function fCStc() {
  const roll = fCSd(16); // Use the translated fCSd
  // Fetch color formatting from gUI if available, otherwise use plain text
  const treS = gUI?.style?.treS ?? '';   // Tremendous Start
  const redBS = gUI?.style?.redBS ?? ''; // Red Bold Start
  const endS = gUI?.style?.endS ?? '';   // Span End

  return roll === 1
    ? `${treS}T${endS}`
    : roll === 2
    ? `${redBS}C${endS}`
    : "";
} // END fCStc




// fCSdBetween ///////////////////////////////////////////////////////////////
// Purpose -> Rolls d(high - low + 1) + (low - 1). e.g., fCSdBetween(6,8) = 6, 7, or 8.
// Inputs  -> low (Number): The lowest possible result.
//         -> high (Number): The highest possible result.
// Outputs -> (Number): Random integer between low and high (inclusive).
function fCSdBetween(low, high) {
  const numLow = Number(low);
  const numHigh = Number(high);
  if (isNaN(numLow) || isNaN(numHigh) || numLow > numHigh) {
    console.error(`fCSdBetween received invalid range: ${low}-${high}`);
    return numLow; // Return low value on error
  }
  // Roll d(high - low + 1) then add (low - 1)
  return fCSd(numHigh - numLow + 1) + (numLow - 1);
} // END fCSdBetween




// fCSDSk ////////////////////////////////////////////////////////////////////
// Purpose -> Returns the average of a d(die * 2) and an fCSD(die) roll.
// Inputs  -> die (Number): The base skill value.
// Outputs -> (Number): The result of the skill roll.
function fCSDSk(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSDSk received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  return Math.round((fCSd(numDie * 2) + fCSD(numDie)) / 2);
} // END fCSDSk




// fCSAtk ////////////////////////////////////////////////////////////////////
// Purpose -> Returns the average of a d(die * 2) and an fCSD(die) roll.
// Inputs  -> die (Number): The base skill value.
// Outputs -> (Number): The result of the skill roll.
// For 'now' is identical to fCSDSk
function fCSAtk(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSAtk received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  return Math.round((fCSd(numDie * 2) + fCSD(numDie)) / 2);
} // END fCSAtk



// fCSDef ////////////////////////////////////////////////////////////////////
// Purpose -> Returns a PC Defense roll (based on fCSD).
// Inputs  -> die (Number): The base defense value.
// Outputs -> (Number): The result of the defense roll.
function fCSDef(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSDef received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  // Formula from MSGLib: fCSD(die) * 0.75
  return Math.round(fCSD(numDie) * 0.75);
} // END fCSDef




// fCSRollUnSkilled //////////////////////////////////////////////////////////
// Purpose -> Rolls an ability as UnSkilled. Reduces base die value first.
// Inputs  -> die (Number): The original base skill value.
// Outputs -> (Number): The result of the unskilled roll.
function fCSRollUnSkilled(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSRollUnSkilled received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  // Calculate the reduced die value for unskilled rolls
  const newDie = Math.max(2, Math.min(numDie / 2, 5 + Math.sqrt(numDie)));
  // Formula from MSGLib: avg(d(newDie*2), d(newDie*2), fCSD(newDie)) / 3
  return Math.round((fCSd(newDie * 2) + fCSd(newDie * 2) + fCSD(newDie)) / 3);
} // END fCSRollUnSkilled




// fCSRollUnSkilledDmg ///////////////////////////////////////////////////////
// Purpose -> Rolls PC Unskilled Damage (currently uses standard unskilled roll).
// Inputs  -> pcDmg (Number): The base damage value.
// Outputs -> (Number): The result of the unskilled damage roll.
function fCSRollUnSkilledDmg(pcDmg) {
  // Simply calls the standard unskilled function for now
  return fCSRollUnSkilled(pcDmg);
} // END fCSRollUnSkilledDmg




// fCSRollUnSkilledArmor /////////////////////////////////////////////////////
// Purpose -> Rolls PC Unskilled Armor.
// Inputs  -> pcAR (Number): The base armor value.
// Outputs -> (Number): The result of the unskilled armor roll (min 1, rounded to tenth).
function fCSRollUnSkilledArmor(pcAR) {
  // Formula from MSGLib: max(1, trunc( (fCSRollUnSkilled(pcAR) / 8) * 10 ) / 10 )
  const unskilledRoll = fCSRollUnSkilled(pcAR);
  // MSGLib uses 8 here, not 15 like fCSDArmor
  const result = Math.trunc((unskilledRoll / 8) * 10) / 10;
  return Math.max(1, result); // Ensure minimum of 1
} // END fCSRollUnSkilledArmor




// fCSDDmg ///////////////////////////////////////////////////////////////////
// Purpose -> Rolls PC Damage (currently uses standard fCSDSk roll).
// Inputs  -> pcDmg (Number): The base damage value.
// Outputs -> (Number): The result of the damage roll.
function fCSDDmg(pcDmg) {
  // Simply calls the standard skill roll function for now
  return fCSDSk(pcDmg);
} // END fCSDDmg




// fCSDArmor /////////////////////////////////////////////////////////////////
// Purpose -> Rolls PC Armor.
// Inputs  -> pcAR (Number): The base armor value.
// Outputs -> (Number): The result of the armor roll (min 1, rounded to tenth).
function fCSDArmor(pcAR) {
  // Formula from MSGLib: max(1, trunc( (fCSDSk(pcAR) / 15) * 10 ) / 10 )
  const skillRoll = fCSDSk(pcAR);
  // MSGLib uses 15 here, not 8 like fCSRollUnSkilledArmor
  const result = Math.trunc((skillRoll / 15) * 100) / 100;
  return Math.max(1, result); // Ensure minimum of 1
} // END fCSDArmor



// ==========================================================================
// === Derived Dice Rolls         (End of CBase Die Rolling ) ===
// ==========================================================================


</script>