<!-- gamelogic.html -->


<script>




// ==========================================================================
// === Die Roll Button         (End of Top) ===
// ==========================================================================




// fHandleRollDiceAction ////////////////////////////////////////////////////////////
// Purpose -> Top-level handler for "Roll Dice" action. Populates gUI.roll,
//            validates, calculates roll using basic fCSD, and displays result.
// Inputs  -> None (uses gUI)
// Outputs -> None (DOM + gUI changes)
function fHandleRollDiceAction() {
    fLogStatus("üé≤ Roll Dice Action Triggered");

    const r = gUI.currentSkRadioChecked.r;
    const c = gUI.currentSkRadioChecked.c;

    if (!fValidateAbilityCB(r, c)) return;
    if (!fResetNPopulateGUIRoll(r, c)) return;


    fPerformBasicRoll();
} // END fHandleRollDiceAction




// fValidateAbilityCB //////////////////////////////////////////////////////
// Purpose -> Ensure the provided row and column indices correspond to a valid
//            Sk1/Sk2 checkbox cell as defined in gUI.sk1sk2CheckBoxes.
// Inputs  -> row (Number): The 0-based row index to check.
//         -> col (Number): The 0-based column index to check.
// Outputs -> (Boolean): true if (row, col) is a valid Sk1/Sk2 checkbox location, false otherwise.
function fValidateAbilityCB(row, col) {
  // Use the existing helper function from scripts.html to check ranges
  const isValid = fIsSkRadioGroupMember(row, col);

  // If it's not a valid location, log/display an error message
  if (!isValid) {
    // Use the new helper function for logging/displaying
    fRollLogMsg("‚ö†Ô∏è Please select a valid Ability checkbox first!");
  }

  // Return the validation result
  return isValid;
} // END fValidateAbilityCB



// fResetNPopulateGUIRoll //////////////////////////////////////////////////////////////////
// Purpose -> Resets and Extracts data from row and fills gUI.roll object.
// Inputs  -> r (Number), c (Number): Row and column from selected radio.
// Outputs -> true if successful, false otherwise
function fResetNPopulateGUIRoll(r, c) {
    try {
        const getVal = (tag) => gUI.arr[r]?.[resolveCol(tag)] ?? '';
        const isSk1 = (c === resolveCol('Sk1ChkBox'));

        gUI.roll.sk1CB    = isSk1;
        gUI.roll.skMorph  = isSk1 ? getVal('Morph1') : getVal('Morph2');
        gUI.roll.skTyp    = isSk1 ? getVal('Sk1Typ') : getVal('Sk2Typ');
        gUI.roll.skSk     = isSk1 ? getVal('Sk1') : getVal('Sk2');
        gUI.roll.skIsOn   = getVal('On');
        gUI.roll.skNameID = getVal('Ability');
        gUI.roll.skName   = gUI.roll.skNameID.replace(/(\s{2,}_\w{6})$/, '').trim();
        gUI.roll.skAct    = getVal('Act');
        gUI.roll.skDur    = getVal('Dur');
        gUI.roll.skMeta   = getVal('Meta');
        gUI.roll.skUses   = getVal('Uses');
        gUI.roll.resTyp   = '';
        gUI.roll.resSk    = '';


        if (!gUI.roll.skName) {
            fRollLogMsg("‚ö†Ô∏è Please select an Ability with a name!");
            return false;
        }

        fLogStatus(`‚öôÔ∏è Populated gUI.roll for row ${r} (isSk1: ${isSk1})`);
        return true;

    } catch (error) {
        console.error("‚ùå Error populating gUI.roll:", error);
        fPrependToSidebar(`‚ùå Error processing skill data: ${error.message}`);
        fShowSidebar();
        return false;
    }
} // END fResetNPopulateGUIRoll




// fPerformBasicRoll //////////////////////////////////////////////////////////////////
// Purpose -> Rolls the base skill value and displays a basic result.
// Inputs  -> None (uses gUI.roll)
// Outputs -> None (updates DOM)
function fPerformBasicRoll() {
    fLogStatus(` -> Selected ${gUI.roll.skTyp}${gUI.roll.skSk}`);

    const baseValue = Number(gUI.roll.skSk);
    if (isNaN(baseValue)) {
        console.error(`Invalid base skill value for roll: ${gUI.roll.skSk}`);
        fPrependToSidebar(`‚ùå Invalid base skill value: ${gUI.roll.skSk}`);
        fShowSidebar();
        return;
    }

    const rollResult = fCSD(baseValue);
    const morph = (gUI.roll.skMorph === '' || gUI.roll.skMorph === ',') ? '' : gUI.roll.skMorph;

    let html = `${gUI.roll.skName} as ${gUI.roll.skTyp}`;
    html += morph ? `<br>morph: ${morph}` : '';
    html += `<br>${gUI.roll.skTyp}(${gUI.roll.skSk})~${rollResult}`;

    fPrependToSidebar(html);
    fShowSidebar();
} // END fPerformBasicRoll





// ==========================================================================
// === Base Die Rolling          (End of Die Roll Button ) ===
// ========================================================================== 


// fCSd //////////////////////////////////////////////////////////////////////
// Purpose -> Standard linear distribution die roll.
// Inputs  -> die (Number): The number of sides on the die.
// Outputs -> (Number): The result of the roll (1 to die).
function fCSd(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSd received invalid die size: ${die}`);
    return 1; // Return 1 for invalid input
  }
  return Math.floor(Math.random() * numDie) + 1;
} // END fCSd



// fCSD //////////////////////////////////////////////////////////////////////
// Purpose -> Make an old fashioned, but smooth, MetaScape d(die) roll (no T or C).
//            Uses a non-linear distribution.
// Inputs  -> die (Number): The base value for the roll.
// Outputs -> (Number): The result of the roll.
function fCSD(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSD received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  // Prevent division by zero or near-zero in Math.random()
  let randomDivisor = Math.random();
  if (randomDivisor < 0.0001) randomDivisor = 0.0001; // Set a minimum divisor

  return Math.floor((numDie * Math.random()) / randomDivisor) + 1;
} // END fCSD



// fCStc /////////////////////////////////////////////////////////////////////
// Purpose -> Rolls 1d16 to determine Tremendous ('T') or Critical ('C') result.
// Inputs  -> None.
// Outputs -> (String): "T", "C", or "".
function fCStc() {
  const roll = fCSd(16); // Use the translated fCSd
  // Fetch color formatting from gUI if available, otherwise use plain text
  const treS = gUI?.style?.treS ?? '';   // Tremendous Start
  const redBS = gUI?.style?.redBS ?? ''; // Red Bold Start
  const endS = gUI?.style?.endS ?? '';   // Span End

  return roll === 1
    ? `${treS}T${endS}`
    : roll === 2
    ? `${redBS}C${endS}`
    : "";
} // END fCStc




// fCSdBetween ///////////////////////////////////////////////////////////////
// Purpose -> Rolls d(high - low + 1) + (low - 1). e.g., fCSdBetween(6,8) = 6, 7, or 8.
// Inputs  -> low (Number): The lowest possible result.
//         -> high (Number): The highest possible result.
// Outputs -> (Number): Random integer between low and high (inclusive).
function fCSdBetween(low, high) {
  const numLow = Number(low);
  const numHigh = Number(high);
  if (isNaN(numLow) || isNaN(numHigh) || numLow > numHigh) {
    console.error(`fCSdBetween received invalid range: ${low}-${high}`);
    return numLow; // Return low value on error
  }
  // Roll d(high - low + 1) then add (low - 1)
  return fCSd(numHigh - numLow + 1) + (numLow - 1);
} // END fCSdBetween




// fCSDSk ////////////////////////////////////////////////////////////////////
// Purpose -> Returns the average of a d(die * 2) and an fCSD(die) roll.
// Inputs  -> die (Number): The base skill value.
// Outputs -> (Number): The result of the skill roll.
function fCSDSk(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSDSk received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  return Math.round((fCSd(numDie * 2) + fCSD(numDie)) / 2);
} // END fCSDSk




// fCSDef ////////////////////////////////////////////////////////////////////
// Purpose -> Returns a PC Defense roll (based on fCSD).
// Inputs  -> die (Number): The base defense value.
// Outputs -> (Number): The result of the defense roll.
function fCSDef(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSDef received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  // Formula from MSGLib: fCSD(die) * 0.75
  return Math.round(fCSD(numDie) * 0.75);
} // END fCSDef




// fCSRollUnSkilled //////////////////////////////////////////////////////////
// Purpose -> Rolls an ability as UnSkilled. Reduces base die value first.
// Inputs  -> die (Number): The original base skill value.
// Outputs -> (Number): The result of the unskilled roll.
function fCSRollUnSkilled(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSRollUnSkilled received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  // Calculate the reduced die value for unskilled rolls
  const newDie = Math.max(2, Math.min(numDie / 2, 5 + Math.sqrt(numDie)));
  // Formula from MSGLib: avg(d(newDie*2), d(newDie*2), fCSD(newDie)) / 3
  return Math.round((fCSd(newDie * 2) + fCSd(newDie * 2) + fCSD(newDie)) / 3);
} // END fCSRollUnSkilled




// fCSRollUnSkilledDmg ///////////////////////////////////////////////////////
// Purpose -> Rolls PC Unskilled Damage (currently uses standard unskilled roll).
// Inputs  -> pcDmg (Number): The base damage value.
// Outputs -> (Number): The result of the unskilled damage roll.
function fCSRollUnSkilledDmg(pcDmg) {
  // Simply calls the standard unskilled function for now
  return fCSRollUnSkilled(pcDmg);
} // END fCSRollUnSkilledDmg




// fCSRollUnSkilledArmor /////////////////////////////////////////////////////
// Purpose -> Rolls PC Unskilled Armor.
// Inputs  -> pcAR (Number): The base armor value.
// Outputs -> (Number): The result of the unskilled armor roll (min 1, rounded to tenth).
function fCSRollUnSkilledArmor(pcAR) {
  // Formula from MSGLib: max(1, trunc( (fCSRollUnSkilled(pcAR) / 8) * 10 ) / 10 )
  const unskilledRoll = fCSRollUnSkilled(pcAR);
  // MSGLib uses 8 here, not 15 like fCSDArmor
  const result = Math.trunc((unskilledRoll / 8) * 10) / 10;
  return Math.max(1, result); // Ensure minimum of 1
} // END fCSRollUnSkilledArmor




// fCSDDmg ///////////////////////////////////////////////////////////////////
// Purpose -> Rolls PC Damage (currently uses standard fCSDSk roll).
// Inputs  -> pcDmg (Number): The base damage value.
// Outputs -> (Number): The result of the damage roll.
function fCSDDmg(pcDmg) {
  // Simply calls the standard skill roll function for now
  return fCSDSk(pcDmg);
} // END fCSDDmg




// fCSDArmor /////////////////////////////////////////////////////////////////
// Purpose -> Rolls PC Armor.
// Inputs  -> pcAR (Number): The base armor value.
// Outputs -> (Number): The result of the armor roll (min 1, rounded to tenth).
function fCSDArmor(pcAR) {
  // Formula from MSGLib: max(1, trunc( (fCSDSk(pcAR) / 15) * 10 ) / 10 )
  const skillRoll = fCSDSk(pcAR);
  // MSGLib uses 15 here, not 8 like fCSRollUnSkilledArmor
  const result = Math.trunc((skillRoll / 15) * 10) / 10;
  return Math.max(1, result); // Ensure minimum of 1
} // END fCSDArmor




// fCSCalcdTiers /////////////////////////////////////////////////////////////
// Purpose -> Calculates applying +/- X number of d-tiers to a base value.
//            e.g., +2d increases base, -1d decreases base, using a multiplier.
// Inputs  -> dieBase (Number): The starting base value.
//         -> numOfd (Number): The number of tiers to apply (positive or negative integer).
// Outputs -> (Number): The adjusted base value (min 1).
function fCSCalcdTiers(dieBase, numOfd) {
  const numDieBase = Number(dieBase);
  const numNumOfd = Number(numOfd);

  if (isNaN(numDieBase) || numDieBase < 1) {
    console.error(`fCSCalcdTiers received invalid dieBase: ${dieBase}`);
    return 1;
  }
  if (!Number.isInteger(numNumOfd)) {
    // Allow 0 as valid input
    if (numNumOfd === 0) return numDieBase;
    console.error(`fCSCalcdTiers requires an integer for numOfd, received: ${numOfd}`);
    return numDieBase; // Return original base if numOfd is invalid
  }

  let newBase = numDieBase;
  const isPositive = numNumOfd > 0;
  const absNumOfd = Math.abs(numNumOfd);

  // Constants from MSGLib
  const oneDVal = 1 + 1 / 3; // Multiplier for +1d
  const divOneDVal = 1 / oneDVal; // Multiplier for -1d

  for (let i = 0; i < absNumOfd; i++) {
    // Special handling for base 1 and 2 from MSGLib
    if (newBase === 1 && isPositive) {
      newBase = 2;
    } else if (newBase === 2 && !isPositive) {
      newBase = 1;
    } else {
      newBase *= isPositive ? oneDVal : divOneDVal;
    }
    newBase = Math.round(newBase); // Round after each tier application
  }

  return Math.max(1, newBase); // Ensure the result is at least 1
} // END fCSCalcdTiers



// ==========================================================================
// === Derived Dice Rolls         (End of CBase Die Rolling ) ===
// ==========================================================================


</script>