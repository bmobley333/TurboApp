<!-- gamelogic.html -->


<script>




// ==========================================================================
// === Die Roll Button         (End of Top) ===
// ==========================================================================




// fHandleRollDiceAction ////////////////////////////////////////////////////////////
// Purpose -> Top-level handler for "Roll Dice" action. Validates, rolls, displays.
// Inputs  -> None (uses gUI)
// Outputs -> None (DOM + gUI changes)
function fHandleRollDiceAction() {
    fLogStatus("🎲 Roll Dice Action Triggered");

    const r = gUI.currentSkRadioChecked.r;
    const c = gUI.currentSkRadioChecked.c;
    if (!fValidateRollSelection(r, c)) return;

    const colRefs = {
        cAbility: resolveCol('Ability'),
        cSk1Typ: resolveCol('Sk1Typ'),
        cSk1: resolveCol('Sk1'),
        cSk2Typ: resolveCol('Sk2Typ'),
        cSk2: resolveCol('Sk2'),
        cSk1ChkBox: resolveCol('Sk1ChkBox'),
        cSk2ChkBox: resolveCol('Sk2ChkBox')
    };
    if (!fValidateRollColumnIndices(Object.values(colRefs))) return;

    const abilityVal = (gUI.arr[r]?.[colRefs.cAbility] ?? '').replace(/\s{2,}_\w{6}$/, '');

    const skillData = fExtractSkillInfo(r, c, colRefs);
    if (!skillData) return;

    fLogStatus(skillData.logMsg);
    const { rollStr } = fGetRollResult(skillData.skillTarget);
    const html = fBuildRollHTML(abilityVal, skillData.skillType, skillData.skillVal, rollStr);

    fPrependToSidebar(html);
    fShowSidebar();
};



// fValidateRollSelection ///////////////////////////////////////////////////////////
// Purpose -> Ensure a radio checkbox is selected (Sk1/Sk2).
// Inputs  -> row, col indices
// Outputs -> true if valid, false otherwise
function fValidateRollSelection(row, col) {
    const isValid = row !== null && !isNaN(row) && col !== null && !isNaN(col);
    if (!isValid) {
        const msg = "⚠️ Please select an Ability/Skill first!";
        console.warn(msg);
        fPrependToSidebar(msg);
        fShowSidebar();
    }
    return isValid;
};




// fValidateRollColumnIndices ////////////////////////////////////////////////////////
// Purpose -> Check if all critical column tags are resolved.
// Inputs  -> array of column indices
// Outputs -> true if valid, false otherwise
function fValidateRollColumnIndices(cols) {
    const allResolved = cols.every(col => !isNaN(col));
    if (!allResolved) {
        const msg = "❌ Error: Could not resolve required column tags.";
        console.error(msg);
        fPrependToSidebar(msg);
        fShowSidebar();
    }
    return allResolved;
};




// fExtractSkillInfo /////////////////////////////////////////////////////////////////
// Purpose -> Given selected skill col and row, extract type, value, and target.
// Inputs  -> row index, selected col index, col references
// Outputs -> { skillType, skillVal, skillTarget, logMsg }
function fExtractSkillInfo(r, selectedC, cols) {
    const idPattern = /\s{2,}_\w{6}$/;
    let skillType = '', skillVal = '', skillTarget = NaN;
    let logMsg = '';

    if (selectedC === cols.cSk1ChkBox) {
        skillType = (gUI.arr[r]?.[cols.cSk1Typ] ?? '').replace(idPattern, '');
        skillVal = String(gUI.arr[r]?.[cols.cSk1] ?? '').replace(idPattern, '');
        skillTarget = parseInt(skillVal, 10);
        logMsg = ` -> Selected Sk1: ${skillType}${skillVal} (Target: ${skillTarget})`;
    } else if (selectedC === cols.cSk2ChkBox) {
        skillType = (gUI.arr[r]?.[cols.cSk2Typ] ?? '').replace(idPattern, '');
        skillVal = String(gUI.arr[r]?.[cols.cSk2] ?? '').replace(idPattern, '');
        skillTarget = parseInt(skillVal, 10);
        logMsg = ` -> Selected Sk2: ${skillType}${skillVal} (Target: ${skillTarget})`;
    } else {
        const msg = `⚠️ Internal Warning: Selected checkbox column (${selectedC}) mismatch. Cannot determine roll type.`;
        console.warn(msg);
        fPrependToSidebar(msg);
        fShowSidebar();
        return null;
    }

    return { skillType, skillVal, skillTarget, logMsg };
};




// fGetRollResult ////////////////////////////////////////////////////////////////////
// Purpose -> Roll a number using fCSD against the skillTarget and return formatted string.
// Inputs  -> skillTarget (Number): The base value for the fCSD roll.
// Outputs -> { roll (Number), rollStr (String) }
function fGetRollResult(skillTarget) {
  // Ensure skillTarget is a valid number greater than 0
  const numSkillTarget = Number(skillTarget);
  if (!isNaN(numSkillTarget) && numSkillTarget > 0) {

    // --- MODIFIED LINE: Use fCSD instead of Math.random() ---
    const roll = fCSD(numSkillTarget);
    // --- END MODIFICATION ---

    const rollStr = `~${roll}`; // Keep the existing formatting
    fLogStatus(` -> Roll Result (fCSD): ${roll} (vs Target: ${numSkillTarget})`);
    return { roll, rollStr };
  }

  // Handle invalid target case
  fLogStatus(` -> Skipping roll: Invalid or zero target (${skillTarget}).`);
  return { roll: 0, rollStr: '' };
} // END fGetRollResult




// fBuildRollHTML ////////////////////////////////////////////////////////////////////
// Purpose -> Construct sidebar output HTML from ability, skill, roll.
// Inputs  -> abilityStr, skillType, skillVal, rollStr
// Outputs -> HTML string
function fBuildRollHTML(abilityStr, skillType, skillVal, rollStr) {
    const abilityHTML = `<span class="sidebar-ability-name">${abilityStr}</span>`;
    let line1 = abilityHTML;
    let line2 = '';

    if (skillType) line1 += ` as ${skillType}`;

    if (skillType && skillVal) line2 = `${skillType}(${skillVal})${rollStr}`;
    else if (skillVal && rollStr) line2 = `Value(${skillVal})${rollStr}`;
    else if (rollStr) line2 = `Roll${rollStr}`;

    const html = line2 ? `${line1}<br>${line2}` : line1;
    fLogStatus(` -> Sidebar Output: ${html.replace('<br>', ' | ')}`);
    return html;
};



// ==========================================================================
// === Base Die Rolling          (End of Die Roll Button ) ===
// ========================================================================== 


// fCSd //////////////////////////////////////////////////////////////////////
// Purpose -> Standard linear distribution die roll.
// Inputs  -> die (Number): The number of sides on the die.
// Outputs -> (Number): The result of the roll (1 to die).
function fCSd(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSd received invalid die size: ${die}`);
    return 1; // Return 1 for invalid input
  }
  return Math.floor(Math.random() * numDie) + 1;
} // END fCSd



// fCSD //////////////////////////////////////////////////////////////////////
// Purpose -> Make an old fashioned, but smooth, MetaScape d(die) roll (no T or C).
//            Uses a non-linear distribution.
// Inputs  -> die (Number): The base value for the roll.
// Outputs -> (Number): The result of the roll.
function fCSD(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSD received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  // Prevent division by zero or near-zero in Math.random()
  let randomDivisor = Math.random();
  if (randomDivisor < 0.0001) randomDivisor = 0.0001; // Set a minimum divisor

  return Math.floor((numDie * Math.random()) / randomDivisor) + 1;
} // END fCSD



// fCStc /////////////////////////////////////////////////////////////////////
// Purpose -> Rolls 1d16 to determine Tremendous ('T') or Critical ('C') result.
// Inputs  -> None.
// Outputs -> (String): "T", "C", or "".
function fCStc() {
  const roll = fCSd(16); // Use the translated fCSd
  // Fetch color formatting from gUI if available, otherwise use plain text
  const treS = gUI?.style?.treS ?? '';   // Tremendous Start
  const redBS = gUI?.style?.redBS ?? ''; // Red Bold Start
  const endS = gUI?.style?.endS ?? '';   // Span End

  return roll === 1
    ? `${treS}T${endS}`
    : roll === 2
    ? `${redBS}C${endS}`
    : "";
} // END fCStc




// fCSdBetween ///////////////////////////////////////////////////////////////
// Purpose -> Rolls d(high - low + 1) + (low - 1). e.g., fCSdBetween(6,8) = 6, 7, or 8.
// Inputs  -> low (Number): The lowest possible result.
//         -> high (Number): The highest possible result.
// Outputs -> (Number): Random integer between low and high (inclusive).
function fCSdBetween(low, high) {
  const numLow = Number(low);
  const numHigh = Number(high);
  if (isNaN(numLow) || isNaN(numHigh) || numLow > numHigh) {
    console.error(`fCSdBetween received invalid range: ${low}-${high}`);
    return numLow; // Return low value on error
  }
  // Roll d(high - low + 1) then add (low - 1)
  return fCSd(numHigh - numLow + 1) + (numLow - 1);
} // END fCSdBetween




// fCSDSk ////////////////////////////////////////////////////////////////////
// Purpose -> Returns the average of a d(die * 2) and an fCSD(die) roll.
// Inputs  -> die (Number): The base skill value.
// Outputs -> (Number): The result of the skill roll.
function fCSDSk(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSDSk received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  return Math.round((fCSd(numDie * 2) + fCSD(numDie)) / 2);
} // END fCSDSk




// fCSDef ////////////////////////////////////////////////////////////////////
// Purpose -> Returns a PC Defense roll (based on fCSD).
// Inputs  -> die (Number): The base defense value.
// Outputs -> (Number): The result of the defense roll.
function fCSDef(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSDef received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  // Formula from MSGLib: fCSD(die) * 0.75
  return Math.round(fCSD(numDie) * 0.75);
} // END fCSDef




// fCSRollUnSkilled //////////////////////////////////////////////////////////
// Purpose -> Rolls an ability as UnSkilled. Reduces base die value first.
// Inputs  -> die (Number): The original base skill value.
// Outputs -> (Number): The result of the unskilled roll.
function fCSRollUnSkilled(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSRollUnSkilled received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  // Calculate the reduced die value for unskilled rolls
  const newDie = Math.max(2, Math.min(numDie / 2, 5 + Math.sqrt(numDie)));
  // Formula from MSGLib: avg(d(newDie*2), d(newDie*2), fCSD(newDie)) / 3
  return Math.round((fCSd(newDie * 2) + fCSd(newDie * 2) + fCSD(newDie)) / 3);
} // END fCSRollUnSkilled




// fCSRollUnSkilledDmg ///////////////////////////////////////////////////////
// Purpose -> Rolls PC Unskilled Damage (currently uses standard unskilled roll).
// Inputs  -> pcDmg (Number): The base damage value.
// Outputs -> (Number): The result of the unskilled damage roll.
function fCSRollUnSkilledDmg(pcDmg) {
  // Simply calls the standard unskilled function for now
  return fCSRollUnSkilled(pcDmg);
} // END fCSRollUnSkilledDmg




// fCSRollUnSkilledArmor /////////////////////////////////////////////////////
// Purpose -> Rolls PC Unskilled Armor.
// Inputs  -> pcAR (Number): The base armor value.
// Outputs -> (Number): The result of the unskilled armor roll (min 1, rounded to tenth).
function fCSRollUnSkilledArmor(pcAR) {
  // Formula from MSGLib: max(1, trunc( (fCSRollUnSkilled(pcAR) / 8) * 10 ) / 10 )
  const unskilledRoll = fCSRollUnSkilled(pcAR);
  // MSGLib uses 8 here, not 15 like fCSDArmor
  const result = Math.trunc((unskilledRoll / 8) * 10) / 10;
  return Math.max(1, result); // Ensure minimum of 1
} // END fCSRollUnSkilledArmor




// fCSDDmg ///////////////////////////////////////////////////////////////////
// Purpose -> Rolls PC Damage (currently uses standard fCSDSk roll).
// Inputs  -> pcDmg (Number): The base damage value.
// Outputs -> (Number): The result of the damage roll.
function fCSDDmg(pcDmg) {
  // Simply calls the standard skill roll function for now
  return fCSDSk(pcDmg);
} // END fCSDDmg




// fCSDArmor /////////////////////////////////////////////////////////////////
// Purpose -> Rolls PC Armor.
// Inputs  -> pcAR (Number): The base armor value.
// Outputs -> (Number): The result of the armor roll (min 1, rounded to tenth).
function fCSDArmor(pcAR) {
  // Formula from MSGLib: max(1, trunc( (fCSDSk(pcAR) / 15) * 10 ) / 10 )
  const skillRoll = fCSDSk(pcAR);
  // MSGLib uses 15 here, not 8 like fCSRollUnSkilledArmor
  const result = Math.trunc((skillRoll / 15) * 10) / 10;
  return Math.max(1, result); // Ensure minimum of 1
} // END fCSDArmor




// fCSCalcdTiers /////////////////////////////////////////////////////////////
// Purpose -> Calculates applying +/- X number of d-tiers to a base value.
//            e.g., +2d increases base, -1d decreases base, using a multiplier.
// Inputs  -> dieBase (Number): The starting base value.
//         -> numOfd (Number): The number of tiers to apply (positive or negative integer).
// Outputs -> (Number): The adjusted base value (min 1).
function fCSCalcdTiers(dieBase, numOfd) {
  const numDieBase = Number(dieBase);
  const numNumOfd = Number(numOfd);

  if (isNaN(numDieBase) || numDieBase < 1) {
    console.error(`fCSCalcdTiers received invalid dieBase: ${dieBase}`);
    return 1;
  }
  if (!Number.isInteger(numNumOfd)) {
    // Allow 0 as valid input
    if (numNumOfd === 0) return numDieBase;
    console.error(`fCSCalcdTiers requires an integer for numOfd, received: ${numOfd}`);
    return numDieBase; // Return original base if numOfd is invalid
  }

  let newBase = numDieBase;
  const isPositive = numNumOfd > 0;
  const absNumOfd = Math.abs(numNumOfd);

  // Constants from MSGLib
  const oneDVal = 1 + 1 / 3; // Multiplier for +1d
  const divOneDVal = 1 / oneDVal; // Multiplier for -1d

  for (let i = 0; i < absNumOfd; i++) {
    // Special handling for base 1 and 2 from MSGLib
    if (newBase === 1 && isPositive) {
      newBase = 2;
    } else if (newBase === 2 && !isPositive) {
      newBase = 1;
    } else {
      newBase *= isPositive ? oneDVal : divOneDVal;
    }
    newBase = Math.round(newBase); // Round after each tier application
  }

  return Math.max(1, newBase); // Ensure the result is at least 1
} // END fCSCalcdTiers



// ==========================================================================
// === Derived Dice Rolls         (End of CBase Die Rolling ) ===
// ==========================================================================


</script>