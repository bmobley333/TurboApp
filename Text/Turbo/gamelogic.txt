<!-- gamelogic.html -->


<script>



// ==========================================================================
// === Die Roll Button         (End of N/A) ===
// ==========================================================================




// fHandleRollDiceAction /////////////////////////////////////////////////////////////////////////
// Purpose -> Top-level handler for "Roll Dice" action. Handles single or multi-rolls (# morph).
//            Verifies target, populates gUI.roll, processes morphs (incl. #, 'free', 'luck').
//            Handles Luck cost FIRST if applicable.
//            Verifies and applies standard costs *before* looping IF NOT free/lucked roll.
//            Loops for calculations.
//            Builds a single log entry string (incl. Free/Lucked Roll notice) and prepends it ONCE after the loop.
// Inputs  -> None (uses gUI.currentSkRadioChecked, gUI.roll).
// Outputs -> None (updates gUI, DOM, and logs to sidebar).
// MODIFIED: Skips cost verification and application if gUI.roll.isFreeRoll OR isLuckedRoll is true.
// MODIFIED: Adds "Free Roll" / "Lucked Roll" indicator to the log header if applicable.
// MODIFIED: Handles Luck cost immediately if isLuckedRoll is true.
async function fHandleRollDiceAction() {
    fMyConsoleLog("üé≤ Roll Dice Action Triggered");

    // --- 1. Initial Validation & Setup ---
    const { r, c } = gUI.currentSkRadioChecked;
    if (!await fValidateAbilityCB(r, c)) return;
    if (!await fResetPopulateNCleanGUIRoll(r, c)) return; // Populates gUI.roll
    if (!await fVerifyAbility()) return;
    await fProcessMorph(); // Processes morphs, populates gUI.roll flags (isFreeRoll, isLuckedRoll) & multiRollCount

    const multiRollCount = gUI.roll.multiRollCount;
    const isFreeRoll = gUI.roll.isFreeRoll;
    const isLuckedRoll = gUI.roll.isLuckedRoll; // <<< Get the luck flag
    fMyConsoleLog(`   -> Multi-Roll Count: ${multiRollCount}`);
    fMyConsoleLog(`   -> Is Free Roll: ${isFreeRoll}`);
    fMyConsoleLog(`   -> Is Lucked Roll: ${isLuckedRoll}`);

    // --- Initialize shared variables for standard costs ---
    const pendingHeaders = []; // Holds standard cost headers
    let allCostsMet = true; // Assume true, verification block might set to false
    let userCancelled = false; // Track if prompts are cancelled


    // --- 1a. Handle Luck Cost (Upfront, If Applicable) --- <<< NEW BLOCK
    if (isLuckedRoll) {
        fMyConsoleLog("üçÄ Applying Luck Cost Upfront...");
        const luckCost = 1;
        const currentLuck = fGetGridValue('LuckBox', 'LuckBox', true);

        if (isNaN(currentLuck)) {
             await fShowMessage("‚ùå Error reading current Luck value. Cannot perform Lucked Roll.");
             fMyConsoleLog("üö´ Failed Lucked Roll: Could not read LuckBox value.");
             return; // Halt
        }

        if (currentLuck < luckCost) {
            await fShowMessage("‚ùå Not Enough Luck!");
            fMyConsoleLog("üö´ Failed Lucked Roll: Insufficient Luck.");
            return; // Halt
        }

        // Sufficient luck, apply cost immediately
        const newLuck = currentLuck - luckCost;
        if (!fSetGridValue('LuckBox', 'LuckBox', newLuck)) {
            await fShowMessage("‚ùå Error applying Luck cost to the grid.");
            fMyConsoleLog("üö´ Failed Lucked Roll: Error setting LuckBox value.");
            return; // Halt if setting grid fails
        }
        fMyConsoleLog(`   -> Luck Cost Applied: ${currentLuck} -> ${newLuck}`);
        fAppendToHTMLHeader('‚ö†Ô∏è <span class="blue-bold">Lucked Roll Below:</span>'); // Add log header line

    }
    // --- End Luck Cost Block ---


    // --- 2. Standard Cost Verification & Preparation (Upfront, SKIPPED if Free OR Lucked Roll) --- <<< MODIFIED CONDITION
    if (!isFreeRoll && !isLuckedRoll) {
        fMyConsoleLog("üõ°Ô∏è Verifying Standard Costs Upfront...");
        gUI.pendingChangesMap = {}; // Initialize map only if checking standard costs

        // Helper to add changes to the map (remains the same)
        const addChangesToMap = (changesArray) => {
            if (!Array.isArray(changesArray)) return;
            changesArray.forEach(change => {
                if (change && typeof change.r !== 'undefined' && typeof change.c !== 'undefined') {
                    const key = `${change.r},${change.c}`;
                    gUI.pendingChangesMap[key] = change.value;
                } else {
                     console.warn("addChangesToMap received invalid change:", change);
                }
            });
        };

        // --- Verify standard costs ---
        const usesResult = await fUses_VerifyAndProcessCost(multiRollCount); // Uses cost depends on multi-roll
        if (!usesResult.success) { allCostsMet = false; userCancelled = true; }
        else { addChangesToMap(usesResult.changes); pendingHeaders.push(...usesResult.headers); }

        if (allCostsMet) { // Only proceed if Uses check passed/cancelled
            const actResult = await fAct_VerifyAndProcessCost(); // Action cost is per activation (not per roll)
            if (!actResult.success) { allCostsMet = false; userCancelled = true; }
            else { addChangesToMap(actResult.changes); pendingHeaders.push(...actResult.headers); }

            const isOnResult = await fIsOn_VerifyAndProcessCost(); // IsOn is per activation
            addChangesToMap(isOnResult.changes); pendingHeaders.push(...isOnResult.headers);

            const skMetaResult = await fSkMeta_VerifyAndProcessCost(gUI.pendingChangesMap); // SkMeta is per activation
            if (!skMetaResult.success) { allCostsMet = false; } // Fail silently (message shown in helper)
            else { addChangesToMap(skMetaResult.changes); pendingHeaders.push(...skMetaResult.headers); }

            const focusMetaResult = await fFocus_VerifyAndProcessCost(gUI.pendingChangesMap); // Focus Meta is per activation
            if (!focusMetaResult.success) { allCostsMet = false; } // Fail silently
            else { addChangesToMap(focusMetaResult.changes); pendingHeaders.push(...focusMetaResult.headers); }
        }

        // --- Halt if Costs Failed or User Cancelled ---
        if (!allCostsMet || userCancelled) {
            const reason = userCancelled ?
                "cost verification failure or cancellation" : "insufficient Meta/Focus";
            fMyConsoleLog(`üö¶ Halting Roll Dice Action due to ${reason}.`);
            gUI.pendingChangesMap = {}; // Clear map if halting
            return;
        }

    } else {
        const skipReason = isLuckedRoll ? "Lucked Roll" : "Free Roll";
        fMyConsoleLog(`‚úÖ Skipping Standard Cost Verification (${skipReason}).`);
        gUI.pendingChangesMap = {}; // Ensure map is empty
    }
    // --- End Standard Cost Verification Block ---


    // --- 3. Build Initial Log Header String ---
    // Start with base header (from morphs), add Lucked/Free Roll notice if needed, then cost headers (if any)
    let combinedLogHtml = gUI.roll.htmlHeader; // Contains Lucked header if applicable (added by fAppendToHTMLHeader)

    // --- Add Free Roll Indicator (if free AND NOT lucked) --- <<< MODIFIED CONDITION
    if (isFreeRoll && !isLuckedRoll) {
        combinedLogHtml += `‚ö†Ô∏è <span class="blue-bold">Free Roll</span>.<br>`; // Add indicator with line break
    }
    // --- End Free Roll Indicator ---

    // Add standard cost headers (will be empty if free/lucked)
    pendingHeaders.forEach(header => combinedLogHtml += `${header}<br>`);

    // Add ability title/type
    let title = `<span class="sidebar-ability-name">${gUI.roll.skName || 'Unknown Ability'}</span>`;
    if (gUI.roll.skTyp) title += ` ${gUI.roll.skTyp}`;
    if (gUI.roll.resTyp && gUI.roll.resTyp !== gUI.roll.skTyp) title += ` (<span class="red-bold">now</span> ${gUI.roll.resTyp})`;
    combinedLogHtml += title;

    // Add morph string if present
    const morph = (typeof gUI.roll.skMorph === 'string' && gUI.roll.skMorph !== ',') ?
        gUI.roll.skMorph.trim() : '';
    if (morph) combinedLogHtml += `<br>morph: ${morph}`;
    combinedLogHtml = combinedLogHtml.trim(); // Trim any leading/trailing whitespace


    // --- 4. Apply ALL Pending STANDARD Costs *Before* the Loop (SKIPPED if Free OR Lucked Roll) --- <<< MODIFIED CONDITION
    let applyErrors = false;
    if (!isFreeRoll && !isLuckedRoll && Object.keys(gUI.pendingChangesMap).length > 0) { // Only apply if standard costs were checked AND map has changes
        fMyConsoleLog("‚úÖ Standard Costs Verified Upfront. Applying Pending Changes...");
        const changeEntries = Object.entries(gUI.pendingChangesMap);
        fMyConsoleLog(`   -> Applying ${changeEntries.length} changes from map...`);
        for (const [key, value] of changeEntries) {
            try {
                const keyParts = key.split(',');
                if (keyParts.length !== 2) { console.warn(`Invalid key format: "${key}"`); applyErrors = true; continue; }
                const [rowPart, colPart] = keyParts;
                let rowRef = parseInt(rowPart, 10);
                if (isNaN(rowRef) || rowRef < 0) { rowRef = rowPart; }
                if (!fSetGridValue(rowRef, colPart, value)) { applyErrors = true; /* fSetGridValue logs error */ }
            } catch (parseError) { console.error(`Error processing change key "${key}":`, parseError); applyErrors = true; }
        }
        gUI.pendingChangesMap = {}; // Clean up map

        if (applyErrors) {
            fMyConsoleLog("‚ùå Errors occurred while applying standard cost/state changes.");
            await fShowMessage("Error applying some standard cost/state changes. Please check grid state.");
            return; // Halt if application failed critically
        }
        fMyConsoleLog("‚úÖ Standard Costs Applied Successfully.");

    } else if (!isFreeRoll && !isLuckedRoll) {
         fMyConsoleLog("‚úÖ No Pending Standard Cost Changes to Apply.");
    } else {
         // Already logged skipping verification
    }
    // --- End Standard Cost Application Block ---


    // --- 5. Perform Rolls in a Loop & Collect Results ---
    fMyConsoleLog(`üîÑ Starting Roll Loop (${multiRollCount} rolls)...`);
    const rollResultLines = []; // Array to collect individual roll HTML lines

    for (let rollNum = 1; rollNum <= multiRollCount; rollNum++) {
        const isFirstRoll = (rollNum === 1);
        fMyConsoleLog(`   --- Roll ${rollNum} of ${multiRollCount} ---`);

        // Recalculate roll-dependent values (needed for each roll)
        fCalcGUIRollResSk();
        fCalcGUIRollRoll();
        fCalcGUIRollResRoll();

        // Build individual roll result line HTML
        const rollLineHtml = fBuildRollLogHTML(rollNum, multiRollCount, isFirstRoll); // Pass necessary args
        rollResultLines.push(rollLineHtml); // Add line to array
    } // --- End Roll Loop ---


    // --- 6. Combine Header and Results, Prepend ONCE ---
    // Add collected roll lines to the initial header string, joined by <br>
    if (rollResultLines.length > 0) {
        // Add a line break after the header only if there are roll results following
        if (combinedLogHtml) combinedLogHtml += '<br>';
        combinedLogHtml += rollResultLines.join('<br>');
    }

    // Prepend the single, complete log entry
    if (combinedLogHtml) { // Check if there's anything to log
      fPrependToSidebar(combinedLogHtml);
      fShowSidebar(); // Ensure sidebar is visible
    }
    gUI.roll.htmlHeader = ''; // Clear header base for next time


    fMyConsoleLog(`‚úÖ Roll Dice Action Completed (${multiRollCount} rolls).`);
} // END fHandleRollDiceAction




// fAppendToHTMLHeader /////////////////////////////////////////////////////////////
// Purpose -> Appends a new line (with <br> separator for next newHeader or Title section) to the gUI.roll.htmlHeader string.
// Inputs  -> newHeader (String): The string to append.
// Outputs -> None (modifies gUI.roll.htmlHeader).
function fAppendToHTMLHeader(newHeader) {
        gUI.roll.htmlHeader += `${newHeader}<br>`;
} // END fAppendToHTMLHeader





// fValidateAbilityCB /////////////////////////////////////////////////////////////////////////
// Purpose -> Confirms that (row, col) is a valid Sk1/Sk2 checkbox based on gUI.sk1sk2CheckBoxes.
// Inputs  -> row (Number), col (Number): 0-based indices.
// Outputs -> (Boolean): true if valid, false otherwise.
// MODIFIED: Made async to await fShowMessage
async function fValidateAbilityCB(row, col) {
    const isValid = fIsSkRadioGroupMember(row, col);
    if (!isValid) {
        await fShowMessage("‚ö†Ô∏è Please select a valid Ability checkbox first!");
    }
    return isValid;
} // END fValidateAbilityCB




// fResetPopulateNCleanGUIRoll //////////////////////////////////////////////////////////////////
// Purpose -> Extracts and cleans ability row data into gUI.roll based on Sk1 or Sk2 checkbox.
//            Initializes multiRollCount to 1.
// Inputs  -> r (Number), c (Number): Row and column from selected radio.
// Outputs -> (Boolean): true if success, false if extraction/cleaning fails.
async function fResetPopulateNCleanGUIRoll(r, c) {
    try {
        const getVal = tag => gUI.arr[r]?.[resolveCol(tag)] ?? '';
        const isSk1 = (c === resolveCol('Sk1ChkBox'));

        // --- Initial Population ---
        gUI.roll = {
            ability_R: r,
            sk1CB: isSk1,
            skMorph: isSk1 ? getVal('Morph1') : getVal('Morph2'),
            skTyp: isSk1 ? getVal('Sk1Typ') : getVal('Sk2Typ'),
            skSk: isSk1 ? getVal('Sk1') : getVal('Sk2'),
            skIsOn: getVal('On'),
            skNameID: getVal('Ability'),
            skName: '',
            skAct: isSk1 ? getVal('Act') : '',
            skDur: isSk1 ? getVal('Dur') : '',
            skMeta: isSk1 ? getVal('Meta') : '',
            skUses: isSk1 ? getVal('Uses') : '',
            resTyp: '',
            resSk: '',
            resFlatBase: '',
            resFlatResult: '',
            resDif: '',
            resFocus: '',
            resPlus: '',
            resPlusPlus: '',
            resdctMult: '',
            resMult: '',
            resMultMult: '',
            resCombine: '',
            isUnSk: false,
            multiRollCount: 1,
            roll: '',
            resRoll: '',
            htmlHeader: ''
           };
        const rData = gUI.roll; // Alias for easier access

        // --- Clean string fields ---
        rData.skName = String(rData.skNameID || '').replace(/\s{2,}_\w{6}$/, '').trim();
        rData.skMorph = String(rData.skMorph || '').trim().replace(/^,+/, '');
        rData.skTyp = String(rData.skTyp || '').trim();
        rData.skIsOn = String(rData.skIsOn || '').trim();
        rData.skDur = String(rData.skDur || '').trim();
        rData.skMeta = String(rData.skMeta || '').trim();
        // Ensure skMeta is either in the allowed list or empty
        if (rData.skMeta && !gUI.list.metaColor.includes(rData.skMeta)) {
             rData.skMeta = '';
        }

        // --- Clean numeric fields ---
        const sk = parseInt(rData.skSk, 10);
        rData.skSk = (!isNaN(sk) && sk >= 1) ? sk : '';

        const act = parseInt(String(rData.skAct || '').trim(), 10);
        rData.skAct = (!isNaN(act) && act >= 1) ? act : '';

        const uses = parseInt(rData.skUses, 10);
        rData.skUses = !isNaN(uses) ? uses : ''; // Allow any valid number (including negatives)

        // --- Default resTyp to skTyp ---
        rData.resTyp = rData.skTyp;
        // --- Final status log ---
        fMyConsoleLog(`‚öôÔ∏è Populated & Cleaned gUI.roll for row ${r} (isSk1: ${isSk1})`);
        return true;

    } catch (err) {
        // --- Error Handling ---
        console.error("‚ùå Error populating/cleaning gUI.roll:", err);
        fPrependToSidebar(`‚ùå Error processing skill data: ${err.message}`);
        fShowSidebar();
        return false;
    }
} // END fResetPopulateNCleanGUIRoll



// fVerifyAbility /////////////////////////////////////////////////////////////////////////
// Purpose -> Validates current gUI.roll by checking name and skill type.
// Inputs  -> None (uses gUI.roll and gUI.list).
// Outputs -> (Boolean): true if ability is valid, false otherwise.
// MODIFIED: Made async to await fShowMessage
async function fVerifyAbility() {
    const { skName, skTyp, sk1CB } = gUI.roll;
    // --- Check: Ability name must exist ---
    if (!skName) {
        await fShowMessage("‚ö†Ô∏è Please select an Ability with a name!");
        return false;
    }

    // --- Check: Skill Typ must be a string ---
    if (!skTyp || typeof skTyp !== 'string') {
        const is2ndCol = !sk1CB;
        await fShowMessage(`‚ö†Ô∏è No skill Typ found${is2ndCol ? '<br><br>You may have wanted the 1st column.' : ''}`);
        return false;
    }

    // --- Check: Skill type must match known types (case-insensitive) ---
    const skTypLower = skTyp.trim().toLowerCase();
    const isValidSkTyp = gUI.list.skTyp.some(type => type.toLowerCase() === skTypLower);
    if (!isValidSkTyp) {
        await fShowMessage(`‚ö†Ô∏è ${skTyp} is an invalid Skill Type!`);
        return false;
    }

    // --- Passed all checks ---
    return true;
} // END fVerifyAbility



// fProcessMorph /////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Processes gUI.roll.skMorph string to extract modifiers and flags into res* fields.
// Inputs  -> None (reads gUI.roll.skMorph, gUI.roll.skSk, gUI.list).
// Outputs -> None (updates gUI.roll directly).
async function fProcessMorph() {
    const skMorph = gUI.roll.skMorph || '';
    if (!skMorph) {
        fMyConsoleLog("‚ÑπÔ∏è No skMorph string to process.");
        return;
    }

    // Split morph string and compile lowercased version
    const morphComponents = skMorph.split(',').map(x => x.trim()).filter(Boolean);
    const morphLower = morphComponents.map(x => x.toLowerCase());

    // Accumulator object for temp results
    const acc = {
        foundResTyp: false,
        lastResTypMatch: '',
        lastFocusIndex: -1,
        foundResPlus: false,
        totalPlus: 0,
        combineNumbers: [],
        foundResPlusPlus: false,
        totalPlusPlus: 0,
        foundResMult: false,
        totalMult: 1.0,
        foundResMultMult: false,
        totalMultMult: 1.0,
        lastFlatBaseMatch: '',
        lastFlatResultMatch: '',
        lastDifMatch: '',
        foundResdctMult: false,
        totalResdctMult: 1.0
    };
    // Await the parsing function which now handles async messages
    await fParseMorphComponents(morphComponents, morphLower, acc);

    fApplyMorphResults(acc);
    fMyConsoleLog("‚öôÔ∏è Processed skMorph string.");
} // END fProcessMorph




// fParseMorphComponents ////////////////////////////////////////////////////////////////////////////////
// Purpose -> Parses each morph component and mutates gUI.roll and acc accordingly.
//            Checks for 'free' or 'luck' morphs to set corresponding flags.
// Inputs  -> morphComponents (Array): Trimmed components of the skMorph string.
//         -> morphLower (Array): Lowercased version of morphComponents.
//         -> acc (Object): Accumulator for temporary results during parsing.
// Outputs -> None (mutates gUI.roll and acc).
// MODIFIED: Added handling for '#N' multi-roll morph, capped at 30.
// MODIFIED: Added handling for 'free' morph (case-insensitive) to set gUI.roll.isFreeRoll.
// MODIFIED: Added handling for 'luck' morph (case-insensitive) to set gUI.roll.isLuckedRoll.
async function fParseMorphComponents(morphComponents, morphLower, acc) {
    const plusMinusRegex = /^([-+])(\d+)$/;
    const numberOnlyRegex = /^\d+$/;
    const plusPlusMinusMinusRegex = /^(?:(\+\+)|(--))(\d+)$/;
    const multDivRegex = /^([*\/])(\d+(\.\d+)?)$/;
    const multMultDivDivRegex = /^(?:(\*\*)|(\/\/))(\d+(\.\d+)?)$/;
    const equalsRegex = /^=(\d+)$/;
    const equalsEqualsRegex = /^==(\d+)$/;
    const caretRegex = /^\^(\d+)$/;
    const dctRegex = /^([-+])(\d+)([dct])$/i;
    const multiRollRegex = /^#(\d+)$/;

    // Use for...of loop instead of forEach to allow await
    let index = 0;
    for (const component of morphComponents) {

        const lower = morphLower[index];

        // --- Free Roll Check ---
        if (lower === 'free') {
            gUI.roll.isFreeRoll = true;
            fMyConsoleLog(`   -> Free Roll detected.`);
        }
        // --- End Free Roll Check ---

        // --- Lucked Roll Check --- <<< NEW BLOCK
        if (lower === 'luck') {
            gUI.roll.isLuckedRoll = true;
            fMyConsoleLog(`   -> Lucked Roll detected.`);
        }
        // --- End Lucked Roll Check ---


        // --- isUnSk Check
        if (lower === 'un' || lower === 'unsk') gUI.roll.isUnSk = true;

        // --- resTyp Check (find LAST match)
        if (gUI.list.skTyp.some(t => t.toLowerCase() === lower)) {
            acc.lastResTypMatch = component;
            acc.foundResTyp = true;
        }

        // --- resFocus Check (find LAST matching TAG) ---
        const focusTag = lower.toUpperCase();
        if (gUI.list.metaColor.includes(focusTag)) {
            acc.lastFocusTag = focusTag;
        }
        // --- End resFocus Check ---

        // --- Multi-Roll Check ---
        const multiRollMatch = component.match(multiRollRegex);
        if (multiRollMatch) {
            let count = parseInt(multiRollMatch[1], 10);
            if (!isNaN(count)) { // Check if it's a number first
                if (count > 30) { // Cap the count at 30
                    count = 30;
                    fMyConsoleLog(`   -> Multi-Roll Morph capped at 30 (Original: ${multiRollMatch[1]})`);
                }
                if (count >= 2) { // Now check if the (potentially capped) count is >= 2
                    gUI.roll.multiRollCount = count;
                    fMyConsoleLog(`   -> Multi-Roll Count set to: ${count}`);
                } else {
                    // This case handles parsed numbers less than 2 (e.g., #0, #1)
                     fMyConsoleLog(`   -> Multi-Roll Morph ignored: Count ${count} is less than 2.`);
                }
            } else {
                // This case handles if parseInt failed (e.g., ##)
                fMyConsoleLog(`   -> Multi-Roll Morph ignored: Invalid number "${multiRollMatch[1]}".`);
            }
        }
        // --- End Multi-Roll Check ---


        // --- resPlus Check
        const plusMatch = component.match(plusMinusRegex);
        if (plusMatch) {
            const val = parseInt(plusMatch[2], 10);
            acc.totalPlus += (plusMatch[1] === '+' ? val : -val);
            acc.foundResPlus = true;
        }

        // --- resCombine Check (collect numbers)
        if (numberOnlyRegex.test(component)) acc.combineNumbers.push(parseInt(component, 10));

        // --- resPlusPlus Check
        const ppMatch = component.match(plusPlusMinusMinusRegex);
        if (ppMatch) {
            const val = parseInt(ppMatch[3], 10);
            acc.totalPlusPlus += (ppMatch[1] === '++' ? val : -val);
            acc.foundResPlusPlus = true;
        }

        // --- resMult Check
        const m1 = component.match(multDivRegex);
        if (m1) {
            const val = parseFloat(m1[2]);
            if (m1[1] === '*') {
                 acc.totalMult *= val;
            } else if (val !== 0) {
                 acc.totalMult /= val;
            } else {
                await fShowMessage("‚ùå Morph includes illegal '/0'. Please correct and try again.");
                console.warn("resMult divide by zero:", component);
            }
            acc.foundResMult = true;
        }

        // --- resMultMult Check
        const m2 = component.match(multMultDivDivRegex);
        if (m2) {
            const val = parseFloat(m2[3]);
            if (m2[1] === '**') {
                acc.totalMultMult *= val;
            } else if (val !== 0) {
                acc.totalMultMult /= val;
            } else {
                await fShowMessage("‚ùå Morph includes illegal '//0'. Please correct and try again.");
                console.warn("resMultMult divide by zero:", component);
            }
            acc.foundResMultMult = true;
        }

        // --- resdctMult Check
        const dctMatch = component.match(dctRegex);
        if (dctMatch) {
            const sign = dctMatch[1];
            const num = parseInt(dctMatch[2], 10);
            const type = dctMatch[3].toLowerCase();
            let multiplier = 1.0;
            if (num !== 0) {
                const isPositive = (sign === '+');
                switch (type) {
                    case 'c':
                        const critFactor = 2 * num;
                        if (critFactor === 0) { console.warn("DCT critFactor zero:", component); multiplier = 1; }
                        else { multiplier = isPositive ? critFactor : (1 / critFactor); }
                        break;
                    case 't':
                        const tremFactor = Math.pow(10, num);
                        multiplier = isPositive ? tremFactor : (1 / tremFactor);
                        break;
                    case 'd':
                        const dTierTerm = (1 + (num / 3));
                        if (dTierTerm === 0) { console.warn("DCT dTierTerm zero:", component); multiplier = 1; }
                        else { multiplier = isPositive ? dTierTerm : (1 / dTierTerm); }
                        break;
                }
                 if (!isNaN(multiplier) && isFinite(multiplier) && multiplier > 0) {
                     acc.totalResdctMult *= multiplier;
                     acc.foundResdctMult = true;
                 } else { console.warn(`Invalid DCT multiplier for "${component}": ${multiplier}.`); }
            }
        }
        // --- End resdctMult Check ---

        // --- resFlatBase Check (find LAST match)
        const eq1 = component.match(equalsRegex);
        if (eq1) acc.lastFlatBaseMatch = eq1[1];

        // --- resFlatResult Check (find LAST match)
        const eq2 = component.match(equalsEqualsRegex);
        if (eq2) acc.lastFlatResultMatch = eq2[1];

        // --- resDif Check (find LAST match)
        const dif = component.match(caretRegex);
        if (dif) acc.lastDifMatch = dif[1];

        index++; // Increment manual index
    } // <<< End of for...of loop
} // END fParseMorphComponents




// fApplyMorphResults ////////////////////////////////////////////////////////////////////////////////
// Purpose -> Applies accumulated morph data to gUI.roll.
// MODIFIED: Changed gUI.roll.resFocus assignment to use acc.lastFocusTag.
function fApplyMorphResults(acc) {
    const r = gUI.roll;
    // MUST BE FIRST: Assign resFlatBase (also sets skSk)
    if (acc.lastFlatBaseMatch !== '') {
        const num = parseInt(acc.lastFlatBaseMatch, 10);
        if (!isNaN(num)) {
            r.resFlatBase = num;
            r.skSk = num;
        }
    }

    // Assign resTyp (last match found else gUI.roll.skTyp)
    if (acc.foundResTyp) {
        r.resTyp = acc.lastResTypMatch || r.skTyp;
    }

    // Assign resFocus (last matching TAG found) --- <<< MODIFIED
    // Check if lastFocusTag exists and is not empty
    if (acc.lastFocusTag && acc.lastFocusTag !== '') {
        r.resFocus = acc.lastFocusTag; // Assign the tag ('R', 'O', etc.)
    } else {
        // Ensure resFocus is explicitly cleared if no tag was found
        r.resFocus = '';
    }
    // --- End resFocus Assignment ---

    // Assign resPlus
    if (acc.foundResPlus) {
        r.resPlus = acc.totalPlus;
    }

    // Assign resCombine
    if (typeof r.skSk === 'number' && r.skSk >= 1) { // Ensure skSk is a valid number before adding
        acc.combineNumbers.push(r.skSk);
    }
    if (acc.combineNumbers.length > 0) {
        acc.combineNumbers.sort((a, b) => b - a);
        let value = 0, divisor = 1;
        for (const num of acc.combineNumbers) {
            value += num / divisor;
            divisor *= 2;
        }
        r.resCombine = Math.round(value);
    }

    // Assign resPlusPlus
    if (acc.foundResPlusPlus) {
        r.resPlusPlus = acc.totalPlusPlus;
    }

    // Assign resMult
    if (acc.foundResMult) {
        r.resMult = Number(acc.totalMult.toFixed(6)); // Use more precision if needed
    }

    // Assign resMultMult
    if (acc.foundResMultMult) {
        r.resMultMult = Number(acc.totalMultMult.toFixed(6)); // Use more precision if needed
    }

    // Assign resdctMult
    if (acc.foundResdctMult) {
        // Rounding dct to 6 decimal places, adjust if needed
        r.resdctMult = Number(acc.totalResdctMult.toFixed(6));
    }

    // Assign resFlatResult (convert last match to integer)
    if (acc.lastFlatResultMatch !== '') {
        const num = parseInt(acc.lastFlatResultMatch, 10);
        if (!isNaN(num)) r.resFlatResult = num;
    }

    // Assign resDif (convert last match to integer)
    if (acc.lastDifMatch !== '') {
        const num = parseInt(acc.lastDifMatch, 10);
        if (!isNaN(num)) r.resDif = num;
    }
} // END fApplyMorphResults




// fVerifyNSetActMetaLuckUsesOnEtc ///////////////////////////////////////////////////////////
// Purpose -> Verify ability costs (Act, Meta, Luck, Uses) and process 'Is On' state.
//            Prompts user if insufficient Action Points. Halts if insufficient Meta/Luck/Uses.
//            Applies *all* decrements/changes *only* after *all* checks pass or are overridden,
//            using gUI.pendingChangesMap to track changes during verification.
// MODIFIED: Uses gUI.pendingChangesMap. Corrected final application loop key parsing.
// Inputs  -> None (uses gUI.roll and grid helpers).
// Outputs -> (Promise<Boolean>): Resolves true if costs are met/overridden and applied,
//                                resolves false if cancelled by user or insufficient resources.
async function fVerifyNSetActMetaLuckUsesOnEtc() {
    fMyConsoleLog("üõ°Ô∏è Verifying Costs & Processing 'Is On' (using Change Map)...");

    // --- Initialize Map and Header for Pending Changes ---
    gUI.pendingChangesMap = {}; // Holds {'rTagOrIndex,cTag': newValue}
    const pendingHeaders = []; // Array to hold strings for fAppendToHTMLHeader

    // Helper to add changes from verification functions to the map
    const addChangesToMap = (changesArray) => {
        if (!Array.isArray(changesArray)) return;
        changesArray.forEach(change => {
            if (change && typeof change.r !== 'undefined' && typeof change.c !== 'undefined') {
                // Key can be combination of tags or indices depending on source function
                const key = `${change.r},${change.c}`;
                gUI.pendingChangesMap[key] = change.value;
                fMyConsoleLog(`   -> Pending Change Added/Updated: ${key} = ${change.value}`);
            } else {
                console.warn("addChangesToMap: Invalid change object received:", change);
            }
        });
    };

    // --- Sequentially Verify Costs & Collect Changes/Headers ---

    // --- 1. Action Points (Act) ---
    const actResult = await fAct_VerifyAndProcessCost();
    if (!actResult.success) return false;
    addChangesToMap(actResult.changes);
    pendingHeaders.push(...actResult.headers);

    // --- 2. Uses ---
    const usesResult = await fUses_VerifyAndProcessCost();
    if (!usesResult.success) return false;
    addChangesToMap(usesResult.changes);
    pendingHeaders.push(...usesResult.headers);

    // --- 3. Is On (Copy Duration if Sk1) ---
    // Note: This often provides a numeric 'r' (ability_R) and string 'c' ('On')
    const isOnResult = await fIsOn_VerifyAndProcessCost();
    addChangesToMap(isOnResult.changes);
    pendingHeaders.push(...isOnResult.headers);

    // --- 4. SkMeta Cost (if Sk1) ---
    const skMetaResult = await fSkMeta_VerifyAndProcessCost(gUI.pendingChangesMap);
    if (!skMetaResult.success) return false;
    addChangesToMap(skMetaResult.changes);
    pendingHeaders.push(...skMetaResult.headers);

    // --- 5. Focus Meta Cost (if resFocus set) ---
    const focusMetaResult = await fFocus_VerifyAndProcessCost(gUI.pendingChangesMap);
    if (!focusMetaResult.success) return false;
    addChangesToMap(focusMetaResult.changes);
    pendingHeaders.push(...focusMetaResult.headers);


    // --- If all checks passed or were overridden, apply all *collected* changes from the Map ---
    fMyConsoleLog("‚úÖ All Verifications Passed. Applying Pending Changes from Map...");
    // Apply pending header messages
    pendingHeaders.forEach(header => fAppendToHTMLHeader(header));

    // Apply pending grid changes from the map --- <<< MODIFIED LOOP LOGIC
    let applyErrors = false;
    const changeEntries = Object.entries(gUI.pendingChangesMap);
    fMyConsoleLog(`   -> Applying ${changeEntries.length} changes from map...`);

    for (const [key, value] of changeEntries) {
        try {
            const keyParts = key.split(',');
            if (keyParts.length !== 2) {
                 console.warn(`Invalid key format in pendingChangesMap: "${key}"`);
                 applyErrors = true;
                 continue; // Skip this invalid key
            }
            const [rowPart, colPart] = keyParts;
            const colRef = colPart; // Column part is likely always a tag or string index

            // Attempt to parse rowPart as number, fallback to using it as a tag string
            let rowRef = parseInt(rowPart, 10);
            if (isNaN(rowRef) || rowRef < 0) { // Check if parsing failed or resulted in negative
                rowRef = rowPart; // Treat as a string tag if not a valid non-negative number
                // fMyConsoleLog(`      -> Using rowPart "${rowPart}" as tag`); // Debug if needed
            } else {
                // fMyConsoleLog(`      -> Using rowPart "${rowPart}" as index ${rowRef}`); // Debug if needed
            }
            // Now rowRef is either the numeric index or the original string tag

            // Now call fSetGridValue with either the numeric index or the string tag for the row
            if (!fSetGridValue(rowRef, colRef, value)) {
                 // fSetGridValue logs specific errors (e.g., invalid refs, cell not found)
                 applyErrors = true;
                 fMyConsoleLog(`      -> Error applying change via fSetGridValue for: ${key} = ${value}`);
            } else {
                 // fMyConsoleLog(`      -> Applied: ${key} = ${value}`); // Optional success log
            }
        } catch (parseError) {
             console.error(`Error processing change key "${key}":`, parseError);
             applyErrors = true;
        }
    }
    // --- End Modified Loop ---

    // Clean up the map after application
    gUI.pendingChangesMap = {};

    if (applyErrors) {
        fMyConsoleLog("‚ùå Errors occurred while applying cost/state changes from the map.");
        await fShowMessage("Error applying some cost/state changes. Please check grid state.");
        return false; // Indicate failure if final application had errors
    }

    fMyConsoleLog("‚úÖ Costs Verified & Changes Applied Successfully using Change Map.");
    return true; // Signal success

} // END fVerifyNSetActMetaLuckUsesOnEtc





// fAct_VerifyAndProcessCost /////////////////////////////////////////////////////////
// Purpose -> Helper for fVerifyNSetActMetaLuckUsesOnEtc: Checks Action Point cost.
//            Prompts user if insufficient. Calculates changes but does NOT apply them.
// Inputs  -> None (reads gUI.roll.skAct, gUI.roll.skName, and uses grid helpers).
// Outputs -> (Promise<Object>): { success: Boolean, changes: Array, headers: Array }
//            'changes' contains { r, c, value } objects for grid updates.
//            'headers' contains strings for sidebar messages.
async function fAct_VerifyAndProcessCost() {
    const { skAct, skName } = gUI.roll;
    const actCost = Number(skAct);
    const changes = []; // Initialize empty array for pending changes
    const headers = []; // Initialize empty array for pending headers

    // Only process if there is an actual Action Point cost
    if (actCost > 0) {
        // Get current Action Points total
        let currentAct = fGetGridValue('Act', 'ActTot', true);

        // Check if reading the value failed (returns NaN)
        if (isNaN(currentAct)) {
            await fShowMessage(`‚ùå Error reading current Action Points from cell ('Act', 'ActTot'). Cannot proceed.`);
            fMyConsoleLog("üö´ Failed to verify Act cost: Could not read Action Points.");
            return { success: false, changes: [], headers: [] }; // Return failure
        }

        // Check if cost exceeds current points
        if (actCost > currentAct) {
            fMyConsoleLog(`‚ö†Ô∏è Insufficient Action Points (Need ${actCost}, Have ${currentAct})`);
            // Prompt user if they want to proceed (go negative)
            const proceed = await fShowPrompt(`Not Enough Action Points (${currentAct}) to use '${skName}' (Cost: ${actCost})<br><br>Do you want to go negative?`);
            if (!proceed) {
                fMyConsoleLog("üö´ User cancelled Act cost due to insufficient points.");
                return { success: false, changes: [], headers: [] }; // User chose No
            }
            // User chose Yes, log it and add header note
            fMyConsoleLog("‚úÖ User chose to proceed despite insufficient Action Points.");
            headers.push(`‚ö†Ô∏è NEGATIVE ACT POINTS: ${currentAct - actCost}`); // Add header to pending list
        }

        // Calculate the new Action Points total
        const newActTotal = currentAct - actCost;
        // Add the intended change to the pending list
        changes.push({ r: 'Act', c: 'ActTot', value: newActTotal });
        fMyConsoleLog(`   -> Action Points: ${currentAct} -> ${newActTotal} (Pending)`);
    } else {
        // No action cost, trivially succeed this check
        fMyConsoleLog("   -> No Action Point cost for this ability.");
    }

    // If we reached here, the cost was 0, met, or overridden successfully. Return success and pending changes/headers.
    return { success: true, changes: changes, headers: headers };
} // END fAct_VerifyAndProcessCost




// fUses_VerifyAndProcessCost ////////////////////////////////////////////////////////
// Purpose -> Helper for cost verification: Checks Uses cost based on multiRollCount.
//            Prompts user if insufficient. Calculates change but does NOT apply it.
// Inputs  -> multiRollCount (Number): The total number of rolls being made.
// Outputs -> (Promise<Object>): { success: Boolean, changes: Array, headers: Array }
//            'changes' contains { r, c, value } objects for grid updates.
//            'headers' contains strings for sidebar messages.
async function fUses_VerifyAndProcessCost(multiRollCount) {
    const { skUses, skName, ability_R } = gUI.roll;
    const changes = []; // Initialize empty array for pending changes
    const headers = []; // Initialize empty array for pending headers

    // Check if skUses exists and is a valid number
    const currentUses = Number(skUses);
    if (skUses === '' || isNaN(currentUses)) {
        // If skUses is empty string, null, undefined, or NaN, assume no 'Uses' cost applies.
        fMyConsoleLog("   -> No 'Uses' cost defined for this ability.");
        return { success: true, changes: [], headers: [] }; // Pass the check if no uses are defined
    }

    // Calculate the TOTAL cost based on multiRollCount (minimum cost is 1)
    const totalUsesCost = Math.max(1, multiRollCount);
    fMyConsoleLog(`   -> Uses Check: Current=${currentUses}, Total Cost for ${multiRollCount} rolls=${totalUsesCost}`);

    // Calculate the new value after decrementing by total cost
    const newUses = currentUses - totalUsesCost;

    // Check if uses are already depleted or if cost exceeds current uses
    if (currentUses < totalUsesCost) {
        fMyConsoleLog(`‚ö†Ô∏è Insufficient Uses Left (Need ${totalUsesCost}, Have ${currentUses})`);
        // Prompt user if they want to proceed (go negative)
        const proceed = await fShowPrompt(`Not Enough Uses Left (${currentUses}) to use '${skName}' ${multiRollCount} times (Cost: ${totalUsesCost})<br><br>Do you want to go negative?`);
        if (!proceed) {
            fMyConsoleLog("üö´ User cancelled Uses cost due to insufficient points.");
            return { success: false, changes: [], headers: [] }; // User chose No
        }
        // User chose Yes, log it and add header note if needed
        fMyConsoleLog("‚úÖ User chose to proceed despite insufficient Uses.");
        headers.push(`‚ö†Ô∏è NEGATIVE USES: ${newUses}`); // Add header to pending list
    }

    // Add the intended change (decrementing by TOTAL cost) to the pending list
    // Use gUI.roll.ability_R (the original row index) for the row reference
    changes.push({ r: ability_R, c: 'Uses', value: newUses });
    fMyConsoleLog(`   -> Uses: ${currentUses} -> ${newUses} (Pending, cost: ${totalUsesCost})`);

    // If we reached here, the cost was met or overridden successfully.
    // Return success and pending changes/headers.
    return { success: true, changes: changes, headers: headers };
} // END fUses_VerifyAndProcessCost






// fIsOn_VerifyAndProcessCost ////////////////////////////////////////////////////////
// Purpose -> Helper for fVerifyNSetActMetaLuckUsesOnEtc: Prepares to copy Duration to Is On
//            *if* the roll originated from the Sk1 checkbox (gUI.roll.sk1CB === true).
//            There is no other verification, just prepares the change object conditionally.
// Inputs  -> None (reads gUI.roll.sk1CB, gUI.roll.skDur, gUI.roll.ability_R).
// Outputs -> (Promise<Object>): { success: Boolean, changes: Array, headers: Array }
//            'changes' contains { r, c, value } objects for grid updates if condition met.
//            'headers' is always empty for this function.
// NOTE: Made async for consistency with other helpers, though not strictly required now.
async function fIsOn_VerifyAndProcessCost() {
    const { skDur, ability_R, sk1CB } = gUI.roll; // Destructure sk1CB
    const changes = []; // Initialize empty array for pending changes
    const headers = []; // Always empty for this function

    // --- Add conditional check for sk1CB ---
    if (sk1CB === true) {
        // Condition met: Prepare the change object to copy skDur to the 'On' column
        // skDur is already cleaned in fResetPopulateNCleanGUIRoll
        changes.push({ r: ability_R, c: 'On', value: skDur });
        fMyConsoleLog(`   -> Is On: Set to Dur value '${skDur}' (Pending, Sk1 condition met)`);
    } else {
        // Condition not met: Do nothing, just log
        fMyConsoleLog(`   -> Is On: No change (Condition sk1CB === true not met)`);
    }
    // --- End conditional check ---

    // This function always succeeds as there's no verification step beyond the condition
    return { success: true, changes: changes, headers: headers };
} // END fIsOn_VerifyAndProcessCost




// fSkMeta_VerifyAndProcessCost ////////////////////////////////////////////////////
// Purpose -> Helper for fVerifyNSetActMetaLuckUsesOnEtc: Processes the skMeta cost
//            if sk1CB is true. Reads the meta color TAG directly from gUI.roll.skMeta,
//            calls fSpendOneMeta to find/prepare the decrement, and handles success/failure.
// MODIFIED: Accepts pendingChangesMap and passes it to fSpendOneMeta.
// Inputs  -> pendingChangesMap (Object): Map of pending changes.
// Outputs -> (Promise<Object>): { success: Boolean, changes: Array, headers: Array }
//            'success' is false if skMeta cost cannot be paid.
//            'changes' contains the single change object if successful.
//            'headers' is always empty.
async function fSkMeta_VerifyAndProcessCost(pendingChangesMap) { // <<< Added pendingChangesMap param
    const { sk1CB, skMeta } = gUI.roll;
    const changes = [];
    const headers = [];

    // --- 1. Check sk1CB condition ---
    if (sk1CB !== true) {
        fMyConsoleLog("   -> SkMeta Cost: Skipped (Condition sk1CB === true not met)");
        return { success: true, changes: [], headers: [] }; // Not an error, just no cost to apply
    }

    // --- 2. Check if there is an skMeta cost defined ---
    const metaColorTag = String(skMeta || '').trim().toUpperCase(); // Get color tag from skMeta field
    if (!metaColorTag) {
        fMyConsoleLog("   -> SkMeta Cost: Skipped (No Meta Color Tag defined in skMeta field).");
        return { success: true, changes: [], headers: [] }; // No cost to pay
    }

    // --- 3. Call fSpendOneMeta to find/prepare the decrement ---
    // fSpendOneMeta handles validation of the metaColorTag internally
    fMyConsoleLog(`   -> SkMeta Cost: Attempting to spend 1 unit of '${metaColorTag}'...`);
    const spendResult = await fSpendOneMeta(metaColorTag, pendingChangesMap); // <<< Pass map to fSpendOneMeta

    // --- 4. Handle Result ---
    if (spendResult.success) {
        // Successfully found and prepared the change
        fMyConsoleLog("      -> Success: Found 1 unit to spend.");
        changes.push(spendResult.change); // Add the single change object
        return { success: true, changes: changes, headers: headers };
    } else {
        // Failed to find 1 unit OR input color was invalid (fSpendOneMeta shows message for invalid color)
        // Only show the "Not enough Meta" message if the color was valid but couldn't be found.
        const metaColors = gUI.list?.metaColor || [];
        const isValidColor = metaColors.some(c => c.toUpperCase() === metaColorTag);
        if (isValidColor) {
            // Color was valid, but couldn't find 1 unit after cycling
             fMyConsoleLog(`      -> ‚ùå Failed: Could not find 1 unit of ${metaColorTag} starting from ${metaColorTag}.`);
             await fShowMessage(`‚ùå Not enough Meta.<br>${gUI.roll.skName} needs @${metaColorTag}.`);
        }
        // If color was invalid, fSpendOneMeta already showed the message.
        return { success: false, changes: [], headers: [] }; // Indicate failure
    }

} // END fSkMeta_VerifyAndProcessCost




// fFocus_VerifyAndProcessCost ///////////////////////////////////////////////////
// Purpose -> Helper for fVerifyNSetActMetaLuckUsesOnEtc: Processes the Focus meta cost
//            if gUI.roll.resFocus is a valid meta color TAG ('R'...'B').
// MODIFIED: Accepts pendingChangesMap and passes it to fSpendOneMeta.
//            Runs regardless of sk1CB. Reads tag directly from gUI.roll.resFocus, validates it.
// Inputs  -> pendingChangesMap (Object): Map of pending changes.
// Outputs -> (Promise<Object>): { success: Boolean, changes: Array, headers: Array }
//            'success' is false if focus meta cost cannot be paid or tag is invalid.
//            'changes' contains the single change object if successful.
//            'headers' is always empty.
async function fFocus_VerifyAndProcessCost(pendingChangesMap) { // <<< Added pendingChangesMap param
    const focusColorTag = gUI.roll.resFocus; // Now holds the tag ('R', 'O', etc.) or ''
    const changes = [];
    const headers = [];
    const metaColors = gUI.list?.metaColor; // e.g., ['R','O','Y','G','B']

    // --- 1. Check if there is a Focus cost defined ---
    if (!focusColorTag || typeof focusColorTag !== 'string') {
        fMyConsoleLog("   -> Focus Meta Cost: Skipped (No resFocus tag defined).");
        return { success: true, changes: [], headers: [] }; // No focus cost to apply
    }

    // --- 2. Validate the Focus Color Tag ---
    if (!Array.isArray(metaColors) || metaColors.length === 0) {
        console.error("fFocus_VerifyAndProcessCost: gUI.list.metaColor is not defined or empty.");
        await fShowMessage("‚ùå Internal Error: Meta color list not defined.");
        return { success: false, changes: [], headers: [] }; // Indicate failure
    }
    const isValidFocusTag = metaColors.includes(focusColorTag.toUpperCase());
    if (!isValidFocusTag) {
        const msg = `Invalid Focus Meta tag specified in morph: '${focusColorTag}'. Allowed: ${metaColors.join(', ')}.`;
        console.warn(`fFocus_VerifyAndProcessCost: ${msg}`);
        fMyConsoleLog(`   -> ‚ùå Focus Meta Cost Failed: ${msg}`);
        await fShowMessage(`‚ùå ${msg}`);
        return { success: false, changes: [], headers: [] }; // Indicate failure due to invalid tag
    }

    // --- 3. Call fSpendOneMeta with the validated tag ---
    fMyConsoleLog(`   -> Focus Meta Cost: Attempting to spend 1 unit of '${focusColorTag}' (Focus)...`);
    const spendResult = await fSpendOneMeta(focusColorTag, pendingChangesMap); // <<< Pass map to fSpendOneMeta

    // --- 4. Handle Result ---
    if (spendResult.success) {
        // Successfully found and prepared the change
        fMyConsoleLog(`      -> Success: Found 1 unit of Focus Meta (${focusColorTag}) to spend.`);
        changes.push(spendResult.change); // Add the single change object
        return { success: true, changes: changes, headers: headers };
    } else {
        // Failed to find 1 unit
        fMyConsoleLog(`      -> ‚ùå Failed: Could not find 1 unit of ${focusColorTag} (or higher) to spend.`);
        const errorMsg = `‚ùå Not enough Meta.<br>In addition to possible ability meta cost,<br>you are also trying to Focus @${focusColorTag}.`;
        await fShowMessage(errorMsg);
        return { success: false, changes: [], headers: [] }; // Indicate failure
    }

} // END fFocus_VerifyAndProcessCost




// fSpendOneMeta /////////////////////////////////////////////////////////////////////
// Purpose -> Helper function to find 1 available unit of Meta and prepare the change object
//            for its decrement. Starts check from specified color, cycles upwards (R->O->Y->G->B...).
//            Checks Channel pool first, then Main pool. Checks pending changes map.
//            Ensures the resulting change value is '' if the new numeric value would be < 1.
// Inputs  -> metaColor (String): The preferred Meta color ('R','O','Y','G','B') to start spending from.
//         -> pendingChangesMap (Object): Map holding pending changes {'rTag,cTag': newValue}.
// Outputs -> (Promise<Object>): Resolves to { success: true, change: { r, c, value } } if 1 unit found,
//                               or { success: false } if invalid color or no unit found.
// MODIFIED: Sets change value to '' if decremented value < 1.
async function fSpendOneMeta(metaColor, pendingChangesMap) {
    fMyConsoleLog(`   -> Attempting to spend 1 Meta unit, starting check from: ${metaColor}`);
    // --- 1. Validate Input Color ---
    const metaColors = gUI.list?.metaColor;
    if (!Array.isArray(metaColors) || metaColors.length === 0) {
        console.error("fSpendOneMeta: gUI.list.metaColor is not defined or empty.");
        await fShowMessage("‚ùå Internal Error: Meta color list not defined.");
        return { success: false };
    }
    const inputColorUpper = metaColor?.toUpperCase();
    const startIndex = metaColors.findIndex(color => color.toUpperCase() === inputColorUpper);
    if (startIndex === -1) {
        fMyConsoleLog(`      -> ‚ùå Invalid input: Meta Color '${metaColor}' is not allowed.`);
        await fShowMessage(`‚ùå Meta Color '${metaColor}' is not allowed.`);
        return { success: false };
    }
    const validMetaColorTag = metaColors[startIndex];
    fMyConsoleLog(`      -> Validated start color: ${validMetaColorTag} (Index: ${startIndex})`);

    // --- Helper function to get current value, considering pending changes ---
    const getCurrentValue = (rowTag, colTag) => {
        const key = `${rowTag},${colTag}`;
        if (pendingChangesMap.hasOwnProperty(key)) {
            const pendingValue = Number(pendingChangesMap[key]);
            // fMyConsoleLog(`         - Found pending value for ${key}: ${pendingValue}`); // Keep commented unless debugging
            // Treat pending non-numbers or < 1 as 0 for calculation purposes here
            return (!isNaN(pendingValue) && pendingValue >= 1) ? pendingValue : 0;
        } else {
            // Read from grid, default invalid/blank/< 1 to 0
            const gridVal = fGetGridValue(rowTag, colTag, true); // Get as number
            return (gridVal >= 1) ? gridVal : 0; // Ensure we only consider values >= 1
        }
    };
    // --- End Helper ---

    // --- 2. Cycle Through Colors to Find 1 Unit ---
    const numColors = metaColors.length;
    const loopLeft = numColors - startIndex;
    for (let i = 0; i < loopLeft; i++) {
        const currentColorIndex = (startIndex + i);
        if (currentColorIndex >= numColors) continue;
        const currentColorTag = metaColors[currentColorIndex];
        fMyConsoleLog(`         - Checking Color: ${currentColorTag}`);

        // Check Channel Pool
        const chnlVal = getCurrentValue('chnl', currentColorTag);
        if (chnlVal >= 1) {
            const newVal = chnlVal - 1;
            // <<< MODIFIED: Set value to '' if newVal < 1
            const change = { r: 'chnl', c: currentColorTag, value: newVal >= 1 ? newVal : '' };
            fMyConsoleLog(`           - Found in Channel pool. Preparing change: ${JSON.stringify(change)}`);
            return { success: true, change: change };
        }

        // Check Main Pool (if Channel was < 1)
        const metaVal = getCurrentValue('meta', currentColorTag);
        if (metaVal >= 1) {
            const newVal = metaVal - 1;
            // <<< MODIFIED: Set value to '' if newVal < 1
            const change = { r: 'meta', c: currentColorTag, value: newVal >= 1 ? newVal : '' };
            fMyConsoleLog(`           - Found in Main pool. Preparing change: ${JSON.stringify(change)}`);
            return { success: true, change: change };
        }

         fMyConsoleLog(`           - Not found in ${currentColorTag} pools.`);
    } // --- End Color Cycle Loop ---

    // --- 3. If Loop Completes: Not Found ---
    fMyConsoleLog(`      -> ‚ùå Failed: Could not find 1 unit of Meta to spend after checking valid colors starting from ${validMetaColorTag}.`);
    return { success: false }; // Indicate failure

} // END fSpendOneMeta




// fCalcGUIRollResSk /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Calculates final resulting skill value (gUI.roll.resSk) using morph-derived modifiers.
// MODIFIED: Calculates focus bonus based on the index of the gUI.roll.resFocus TAG within gUI.list.metaColor.
// Inputs  -> None (reads from gUI.roll).
// Outputs -> None (writes gUI.roll.resSk).
function fCalcGUIRollResSk() {
    let currentResSk;

    // Use resCombine if it's a valid number; fallback to skSk if needed
    if (typeof gUI.roll.resCombine === 'number') {
        currentResSk = gUI.roll.resCombine;
        fMyConsoleLog("   -> Using resCombine as base for resSk calculation.");
    } else if (typeof gUI.roll.skSk === 'number') {
        currentResSk = gUI.roll.skSk;
    } else {
        currentResSk = NaN;
    }

    // --- Modifier Application Pipeline ---
    // Only proceed if we have a valid numeric base
    if (!isNaN(currentResSk)) {

        // Apply resMult (multiplicative)
        if (typeof gUI.roll.resMult === 'number' && gUI.roll.resMult !== '') {
            currentResSk *= gUI.roll.resMult;
        }

        // Apply resdctMult (multiplicative)
        if (typeof gUI.roll.resdctMult === 'number' && gUI.roll.resdctMult !== '') {
             currentResSk *= gUI.roll.resdctMult;
        }

        // Apply resPlus (additive)
        if (typeof gUI.roll.resPlus === 'number' && gUI.roll.resPlus !== '') {
            currentResSk += gUI.roll.resPlus;
        }

        // Apply resFocus --- <<< MODIFIED
        // Check if resFocus holds a valid TAG ('R'...'B')
        const focusTag = gUI.roll.resFocus;
        if (focusTag && typeof focusTag === 'string' && gUI.list.metaColor) {
            const focusIndex = gUI.list.metaColor.indexOf(focusTag.toUpperCase()); // Find index of the tag
            if (focusIndex > -1) { // Check if tag was found
                const focusBonus = 5 * (1 + focusIndex);
                currentResSk += focusBonus;
                fMyConsoleLog(`      -> Applying Focus Bonus: +${focusBonus} (Tag: ${focusTag}, Index: ${focusIndex})`);
            }
            // else: Tag wasn't found in metaColor list, no bonus applied (should have been caught earlier if invalid tag)
        }
        // --- End resFocus Modification ---


        // Apply isUnSk (cut in half) AFTER all multipliers and additions
        if (gUI.roll.isUnSk === true) {
            currentResSk *= 0.5;
        }

        // --- Final Adjustment: Clamp Tiny Positive Values ---
        // Only clamp if it's positive but less than 1
        if (currentResSk > 0 && currentResSk < 1) {
            currentResSk = 1;
        }

        // --- Diagnostic Output ---
        // console.log(`DEBUG fCalcGUIRollResSk: Value before final check/assignment:`, currentResSk);
        // --- Final Assignment: Round valid positive results, else empty ---
        // Ensure result is a number and >= 1 after all calculations
        if (!isNaN(currentResSk) && currentResSk >= 1) {
            gUI.roll.resSk = Math.round(currentResSk);
        } else {
            gUI.roll.resSk = ''; // Set to empty if result is NaN, less than 1, etc.
        }
    } else {
        // Invalid input or no valid base found, leave resSk empty
        gUI.roll.resSk = '';
    }

    fMyConsoleLog(`‚öôÔ∏è Calculated final resSk: ${gUI.roll.resSk}`);
} // END fCalcGUIRollResSk





// fCalcGUIRollRoll /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Determines dice roll result (gUI.roll.roll) based on resSk and resTyp.
// Inputs  -> None (reads gUI.roll.resSk, gUI.roll.resTyp).
// Outputs -> None (writes gUI.roll.roll).
function fCalcGUIRollRoll() {
    const resSkValue = gUI.roll.resSk;
    const resTypValue = (typeof gUI.roll.resTyp === 'string') ? gUI.roll.resTyp.trim().toLowerCase() : '';
    // --- Validate resSk (must be a number >= 1) ---
    if (typeof resSkValue !== 'number' || resSkValue < 1) {
        gUI.roll.roll = '';
        fMyConsoleLog(`‚ÑπÔ∏è Cannot calculate roll: Invalid resSk value (${resSkValue}).`);
        return;
    }


    // --- Determine roll function based on resTyp ---
    switch (resTypValue) {


        // No type ‚Üí skip rolling
        case '': gUI.roll.roll = ''; break;


        // Skill or Attribute or Str roll
        case 'sk':
        case 'atr':
        case 'str': gUI.roll.roll = fCSDSk(resSkValue); break;


        // Attack roll
        case 'atk': gUI.roll.roll = fCSAtk(resSkValue); break;
        // Damage roll
        case 'dmg': gUI.roll.roll = fCSDDmg(resSkValue); break;
        // Defense roll
        case 'def': gUI.roll.roll = fCSDef(resSkValue); break;
        // Armor roll (may return decimal)
        case 'ar': gUI.roll.roll = fCSDArmor(resSkValue); break;
        // Unexpected usage of 'unsk' as final roll type
        case 'un':
        case 'unsk':
            console.warn(`fCalcGUIRollRoll: Roll type '${resTypValue}' used directly. Consider adjusting morph.`);
            gUI.roll.roll = fCSDSk(resSkValue);
            break;


        // Unknown roll type
        default:
            console.warn(`fCalcGUIRollRoll: Unknown resTyp '${resTypValue}'. Cannot calculate roll.`);
            gUI.roll.roll = '';
            break;
    }


    // --- Final Logging ---
    fMyConsoleLog(`‚öôÔ∏è Calculated roll (${resTypValue}): ${gUI.roll.roll}`);
} // END fCalcGUIRollRoll



// fCalcGUIRollResRoll /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Calculates final gUI.roll.resRoll using overrides or morph-based modifiers.
// Inputs  -> None (reads gUI.roll).
// Outputs -> None (writes gUI.roll.resRoll).
function fCalcGUIRollResRoll() {

    // --- Check for Flat Result Override ---
    // Check if resFlatResult is a number and not empty string
    const flatResult = (typeof gUI.roll.resFlatResult === 'number' && gUI.roll.resFlatResult !== '')
         ? gUI.roll.resFlatResult : null;

    if (flatResult !== null) {
        const isArType = (typeof gUI.roll.resTyp === 'string') && gUI.roll.resTyp.trim().toLowerCase() === 'ar';
        // Round appropriately based on type (AR needs decimals)
        const roundedFlatResult = isArType ? Number(flatResult.toFixed(2)) : Math.round(flatResult);
        gUI.roll.resRoll = Math.max(0, roundedFlatResult); // Clamp at 0 minimum
        fMyConsoleLog(`‚öôÔ∏è Calculated resRoll (override, ${isArType ? 'AR-rounded' : 'INT-rounded'}): ${gUI.roll.resRoll}`);
        return; // Exit early as override takes precedence
    }

    // --- Validate Base Roll ---
    // Check if initial roll is a number and not empty string
    const initialRoll = gUI.roll.roll;
    if (typeof initialRoll !== 'number' || initialRoll === '' || isNaN(initialRoll)) { // Added isNaN check
        gUI.roll.resRoll = '';
        fMyConsoleLog(`‚ÑπÔ∏è Cannot calculate resRoll: Invalid initial roll value (${initialRoll}).`);
        return;
    }

    // --- Apply Modifiers ---
    let currentResRoll = initialRoll;
    // Apply resMultMult
    if (typeof gUI.roll.resMultMult === 'number' && gUI.roll.resMultMult !== '') {
        currentResRoll *= gUI.roll.resMultMult;
    }

    // Apply resPlusPlus
    if (typeof gUI.roll.resPlusPlus === 'number' && gUI.roll.resPlusPlus !== '') {
        currentResRoll += gUI.roll.resPlusPlus;
    }

    // Apply resdctMult (multiplicative) <<< ADDED BLOCK ---
    if (typeof gUI.roll.resdctMult === 'number' && gUI.roll.resdctMult !== '') {
        currentResRoll *= gUI.roll.resdctMult;
    }
    // --- End resdctMult Block ---

    // --- Final Rounding, Clamping, and Assignment ---
    if (!isNaN(currentResRoll)) {
        const isArType = (typeof gUI.roll.resTyp === 'string') && gUI.roll.resTyp.trim().toLowerCase() === 'ar';
        // Round appropriately
        const roundedResRoll = isArType ? Number(currentResRoll.toFixed(2)) : Math.round(currentResRoll);
        gUI.roll.resRoll = Math.max(0, roundedResRoll); // Clamp at 0 minimum
    } else {
        gUI.roll.resRoll = ''; // Set to empty if calculation resulted in NaN
        console.warn("fCalcGUIRollResRoll: Calculation resulted in NaN.");
    }

    fMyConsoleLog(`‚öôÔ∏è Calculated final resRoll: ${gUI.roll.resRoll}`);
} // END fCalcGUIRollResRoll





// fCalcGUIRollResRoll /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Calculates final gUI.roll.resRoll using overrides or morph-based modifiers.
// Inputs  -> None (reads gUI.roll).
// Outputs -> None (writes gUI.roll.resRoll).
function fCalcGUIRollResRoll() {

    // --- Check for Flat Result Override ---
    const flatResult = (typeof gUI.roll.resFlatResult === 'number' && gUI.roll.resFlatResult !== '') ? gUI.roll.resFlatResult : null;

    if (flatResult !== null) {
        const isArType = (typeof gUI.roll.resTyp === 'string') && gUI.roll.resTyp.trim().toLowerCase() === 'ar';
        const roundedFlatResult = isArType ? Number(flatResult.toFixed(2)) : Math.round(flatResult);
        gUI.roll.resRoll = Math.max(0, roundedFlatResult);
        fMyConsoleLog(`‚öôÔ∏è Calculated resRoll (override, ${isArType ? 'AR-rounded' : 'INT-rounded'}): ${gUI.roll.resRoll}`);
        return;
    }

    // --- Validate Base Roll ---
    const initialRoll = gUI.roll.roll;
    if (typeof initialRoll !== 'number' || initialRoll === '') {
        gUI.roll.resRoll = '';
        fMyConsoleLog(`‚ÑπÔ∏è Cannot calculate resRoll: Invalid initial roll value (${initialRoll}).`);
        return;
    }

    // --- Apply Modifiers ---
    let currentResRoll = initialRoll;
    if (typeof gUI.roll.resMultMult === 'number' && gUI.roll.resMultMult !== '') currentResRoll *= gUI.roll.resMultMult;
    if (typeof gUI.roll.resPlusPlus === 'number' && gUI.roll.resPlusPlus !== '') currentResRoll += gUI.roll.resPlusPlus;
    // --- Final Rounding, Clamping, and Assignment ---
    if (!isNaN(currentResRoll)) {
        const isArType = (typeof gUI.roll.resTyp === 'string') && gUI.roll.resTyp.trim().toLowerCase() === 'ar';
        const roundedResRoll = isArType ? Number(currentResRoll.toFixed(2)) : Math.round(currentResRoll);
        gUI.roll.resRoll = Math.max(0, roundedResRoll);
    } else {
        gUI.roll.resRoll = '';
        console.warn("fCalcGUIRollResRoll: Calculation resulted in NaN.");
    }

    fMyConsoleLog(`‚öôÔ∏è Calculated final resRoll: ${gUI.roll.resRoll}`);
} // END fCalcGUIRollResRoll






// fCalcRollLogPrepend /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Builds final roll result log message and prepends it to the sidebar.
// Inputs  -> None (reads gUI.roll).
// Outputs -> None (calls fPrependToSidebar, fShowSidebar).
function fCalcRollLogPrepend() {
    const html = fBuildRollLogHTML();
    fPrependToSidebar(html);
    fShowSidebar();
    fMyConsoleLog("üì∞ Roll Log message prepended.");
} // END fCalcRollLogPrepend




// fBuildRollLogHTML /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Constructs and returns the formatted HTML log line for a *single roll* based on gUI.roll data.
//            Handles multi-roll prefix ('#> ') and conditional T/C roll.
// Inputs  -> rollNum (Number): The current roll number in the sequence (e.g., 1, 2, ...).
//         -> totalRolls (Number): The total number of rolls in the sequence (gUI.roll.multiRollCount).
//         -> isFirstRoll (Boolean): True if this is the first roll in the sequence.
// Outputs -> (String): HTML string for one roll line to insert in sidebar.
// MODIFIED: Accepts rollNum, totalRolls, isFirstRoll. Adds prefix. Conditional T/C. Simplified scope.
// MODIFIED: Removed !isFreeRoll check from T/C condition to allow T/C on Lucked Rolls.
function fBuildRollLogHTML(rollNum, totalRolls, isFirstRoll) {

    // --- Get relevant data from gUI.roll ---
    const resTyp = (typeof gUI.roll.resTyp === 'string') ? gUI.roll.resTyp.trim() : '';
    const skSk = gUI.roll.skSk;
    const resSk = gUI.roll.resSk;
    const roll = gUI.roll.roll;
    const resRoll = gUI.roll.resRoll;
    const dif = gUI.roll.resDif;
    // No need to get isFreeRoll or isLuckedRoll here anymore for T/C logic

    // --- Build Roll Base String (Type(Sk->ResSk)) ---
    let rollBase = resTyp; // Start with the resulting type
    if (typeof skSk === 'number' && skSk !== '') {
        rollBase += `(${skSk}${(typeof resSk === 'number' && resSk !== '' && resSk !== skSk) ? `->${resSk}` : ''})`;
    } else if (typeof resSk === 'number' && resSk !== '') {
        rollBase += `(${resSk})`;
    }

    // --- Build Roll Result String (~Roll->ResRoll) ---
    let rollResult = '';
    if ((typeof roll === 'number' || (typeof roll === 'string' && roll !== '')) && roll != null) {
        rollResult += ` ~${roll}`;
        // Show arrow only if resRoll is different and valid
        if ((typeof resRoll === 'number' || (typeof resRoll === 'string' && resRoll !== '')) && resRoll != null && String(resRoll) !== String(roll)) {
            rollResult += `->${resRoll}`;
        }
    } else if ((typeof resRoll === 'number' || (typeof resRoll === 'string' && resRoll !== '')) && resRoll != null) {
        // If only resRoll is valid, show it directly
        rollResult += ` ~${resRoll}`;
    }


    // --- Build Difficulty (^Dif) ---
    let rollDif = (typeof dif === 'number' || (typeof dif === 'string' && dif !== '')) && dif != null ? `^${dif}` : '';

    // --- Build Success Delta (=/+Œî) ---
    let rollSuccess = '';
    // Only calculate success if BOTH resRoll and dif are valid numbers
    if (typeof resRoll === 'number' && typeof dif === 'number') {
        const delta = resRoll - dif;
        rollSuccess = delta >= 0 ? ` =+${delta} ‚úÖ` : ` =${delta} ‚ùå`;
    }

    // --- Combine Roll1 Summary (Base + Result + Diff + Success) ---
    let roll1 = `${rollBase}${rollResult}${rollDif}${rollSuccess}`.trim();

    // --- Add T/C Result (ONLY for the first roll) --- <<< MODIFIED CONDITION
    const tc = isFirstRoll ? fCStc() : ""; // Call fCStc only if isFirstRoll is true
    if (roll1 && tc) roll1 += `   ${tc}`;

    // --- Prepend Multi-Roll Prefix if needed ---
    if (totalRolls > 1) {
      roll1 = `<span class="roll-prefix">${rollNum}></span> ${roll1}`; // Add prefix span
    }

    // --- Build Final HTML (Only the roll line itself) ---
    // The header (Costs, Title, Morph, Free/Lucked notice) is now handled separately before the loop
    const html = roll1; // This function now only returns the formatted roll line

    return html;
} // END fBuildRollLogHTML



// ==========================================================================
// === Base Die Rolling          (End of Die Roll Button ) ===
// ==========================================================================


// fCSd //////////////////////////////////////////////////////////////////////
// Purpose -> Standard linear distribution die roll.
// Inputs  -> die (Number): The number of sides on the die.
// Outputs -> (Number): The result of the roll (1 to die).
function fCSd(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSd received invalid die size: ${die}`);
    return 1; // Return 1 for invalid input
  }
  return Math.floor(Math.random() * numDie) + 1;
} // END fCSd



// fCSD //////////////////////////////////////////////////////////////////////
// Purpose -> Make an old fashioned, but smooth, MetaScape d(die) roll (no T or C).
//            Uses a non-linear distribution.
// Inputs  -> die (Number): The base value for the roll.
// Outputs -> (Number): The result of the roll.
function fCSD(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSD received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  // Prevent division by zero or near-zero in Math.random()
  let randomDivisor = Math.random();
  if (randomDivisor < 0.0001) randomDivisor = 0.0001; // Set a minimum divisor

  return Math.floor((numDie * Math.random()) / randomDivisor) + 1;
} // END fCSD



// fCStc /////////////////////////////////////////////////////////////////////
// Purpose -> Rolls 1d16 to determine Tremendous ('T') or Critical ('C') result.
// Inputs  -> None.
// Outputs -> (String): "T", "C", or "".
function fCStc() {
  const roll = fCSd(16); // Use the translated fCSd
  // Fetch color formatting from gUI if available, otherwise use plain text
  const treS = gUI?.style?.treS ?? '';   // Tremendous Start
  const redBS = gUI?.style?.redBS ?? ''; // Red Bold Start
  const endS = gUI?.style?.endS ?? '';   // Span End

  return roll === 1
    ? `<span class="tremendous">T</span>`
    : roll === 2
    ? `<span class="red-bold">C</span>`
    : "";
} // END fCStc




// fCSdBetween ///////////////////////////////////////////////////////////////
// Purpose -> Rolls d(high - low + 1) + (low - 1). e.g., fCSdBetween(6,8) = 6, 7, or 8.
// Inputs  -> low (Number): The lowest possible result.
//         -> high (Number): The highest possible result.
// Outputs -> (Number): Random integer between low and high (inclusive).
function fCSdBetween(low, high) {
  const numLow = Number(low);
  const numHigh = Number(high);
  if (isNaN(numLow) || isNaN(numHigh) || numLow > numHigh) {
    console.error(`fCSdBetween received invalid range: ${low}-${high}`);
    return numLow; // Return low value on error
  }
  // Roll d(high - low + 1) then add (low - 1)
  return fCSd(numHigh - numLow + 1) + (numLow - 1);
} // END fCSdBetween




// fCSDSk ////////////////////////////////////////////////////////////////////
// Purpose -> Returns the average of a d(die * 2) and an fCSD(die) roll.
// Inputs  -> die (Number): The base skill value.
// Outputs -> (Number): The result of the skill roll.
function fCSDSk(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSDSk received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  return Math.round((fCSd(numDie * 2) + fCSD(numDie)) / 2);
} // END fCSDSk




// fCSAtk ////////////////////////////////////////////////////////////////////
// Purpose -> Returns the average of a d(die * 2) and an fCSD(die) roll.
// Inputs  -> die (Number): The base skill value.
// Outputs -> (Number): The result of the skill roll.
// For 'now' is identical to fCSDSk
function fCSAtk(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSAtk received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  return Math.round((fCSd(numDie * 2) + fCSD(numDie)) / 2);
} // END fCSAtk



// fCSDef ////////////////////////////////////////////////////////////////////
// Purpose -> Returns a PC Defense roll (based on fCSD).
// Inputs  -> die (Number): The base defense value.
// Outputs -> (Number): The result of the defense roll.
function fCSDef(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSDef received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  // Formula from MSGLib: fCSD(die) * 0.75
  return Math.round(fCSD(numDie) * 0.75);
} // END fCSDef




// fCSRollUnSkilled //////////////////////////////////////////////////////////
// Purpose -> Rolls an ability as UnSkilled. Reduces base die value first.
// Inputs  -> die (Number): The original base skill value.
// Outputs -> (Number): The result of the unskilled roll.
function fCSRollUnSkilled(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSRollUnSkilled received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  // Calculate the reduced die value for unskilled rolls
  const newDie = Math.max(2, Math.min(numDie / 2, 5 + Math.sqrt(numDie)));
  // Formula from MSGLib: avg(d(newDie*2), d(newDie*2), fCSD(newDie)) / 3
  return Math.round((fCSd(newDie * 2) + fCSd(newDie * 2) + fCSD(newDie)) / 3);
} // END fCSRollUnSkilled




// fCSRollUnSkilledDmg ///////////////////////////////////////////////////////
// Purpose -> Rolls PC Unskilled Damage (currently uses standard unskilled roll).
// Inputs  -> pcDmg (Number): The base damage value.
// Outputs -> (Number): The result of the unskilled damage roll.
function fCSRollUnSkilledDmg(pcDmg) {
  // Simply calls the standard unskilled function for now
  return fCSRollUnSkilled(pcDmg);
} // END fCSRollUnSkilledDmg




// fCSRollUnSkilledArmor /////////////////////////////////////////////////////
// Purpose -> Rolls PC Unskilled Armor.
// Inputs  -> pcAR (Number): The base armor value.
// Outputs -> (Number): The result of the unskilled armor roll (min 1, rounded to tenth).
function fCSRollUnSkilledArmor(pcAR) {
  // Formula from MSGLib: max(1, trunc( (fCSRollUnSkilled(pcAR) / 8) * 10 ) / 10 )
  const unskilledRoll = fCSRollUnSkilled(pcAR);
  // MSGLib uses 8 here, not 15 like fCSDArmor
  const result = Math.trunc((unskilledRoll / 8) * 10) / 10;
  return Math.max(1, result); // Ensure minimum of 1
} // END fCSRollUnSkilledArmor




// fCSDDmg ///////////////////////////////////////////////////////////////////
// Purpose -> Rolls PC Damage (currently uses standard fCSDSk roll).
// Inputs  -> pcDmg (Number): The base damage value.
// Outputs -> (Number): The result of the damage roll.
function fCSDDmg(pcDmg) {
  // Simply calls the standard skill roll function for now
  return fCSDSk(pcDmg);
} // END fCSDDmg




// fCSDArmor /////////////////////////////////////////////////////////////////
// Purpose -> Rolls PC Armor.
// Inputs  -> pcAR (Number): The base armor value.
// Outputs -> (Number): The result of the armor roll (min 1, rounded to tenth).
function fCSDArmor(pcAR) {
  // Formula from MSGLib: max(1, trunc( (fCSDSk(pcAR) / 15) * 10 ) / 10 )
  const skillRoll = fCSDSk(pcAR);
  // MSGLib uses 15 here, not 8 like fCSRollUnSkilledArmor
  const result = Math.trunc((skillRoll / 15) * 100) / 100;
  return Math.max(1, result); // Ensure minimum of 1
} // END fCSDArmor



// ==========================================================================
// === Message Box             (End of Base Die Rolling ) ===
// ==========================================================================


// fShowMessage ///////////////////////////////////////////////////////////////////
// Purpose -> Displays the message modal box and returns a Promise that resolves when closed.
// Inputs -> message (String): The text or HTML to display in the message box.
// Outputs -> (Promise): Resolves when the modal is hidden.
// MODIFIED: Now async, returns a Promise, stores resolve function in gUI.
async function fShowMessage(message) {
    // --- Try to cache elements if not already done ---
    if (!gUI.messageModalOverlay) {
        gUI.messageModalOverlay = document.getElementById('messageModal');
        // If caching now, log it for debugging timing issues
        if (gUI.messageModalOverlay) console.log("fShowMessage: Just-in-time cache for #messageModal");
    }
    if (!gUI.messageModalText) {
        gUI.messageModalText = document.getElementById('messageText');
        if (gUI.messageModalText) console.log("fShowMessage: Just-in-time cache for #messageText");
    }
    // --- End Caching Attempt ---

    // Now, re-check if elements exist *after* attempting to cache
    if (!gUI.messageModalOverlay || !gUI.messageModalText) {
        // Log the original error if elements are *still* not found
        console.error("Message modal elements not cached or found in the DOM!");
        if (!gUI.messageModalOverlay) console.error("Missing: #messageModal");
        if (!gUI.messageModalText) console.error("Missing: #messageText");
        // Optionally: Fallback to a simpler alert if modal isn't ready
        // alert("Modal Error!\n" + message);
        return Promise.reject(new Error("Message modal elements not found.")); // Reject if elements missing
    }

    // Set message content (using innerHTML allows basic tags like <br>)
    gUI.messageModalText.innerHTML = message;
    // Show the modal
    gUI.messageModalOverlay.style.display = 'flex'; // Using flex as defined in CSS

    // Create and return a new Promise
    return new Promise((resolve) => {
        gUI.messagePromiseResolve = resolve; // Store the resolve function globally
    });
} // END fShowMessage




// fHideMessage ///////////////////////////////////////////////////////////////////
// Purpose -> Hides the message modal box and resolves the pending promise.
// Inputs -> None
// Outputs -> None
// MODIFIED: Calls the stored resolve function if it exists.
function fHideMessage() {
    if (gUI.messageModalOverlay) {
        gUI.messageModalOverlay.style.display = 'none';
    } else {
        // This shouldn't happen if elements were cached, but log just in case
        console.error("Message modal overlay element (#messageModal) not found when trying to hide.");
    }

    // Resolve the promise if a resolve function is stored
    if (typeof gUI.messagePromiseResolve === 'function') {
        gUI.messagePromiseResolve(); // Call the stored resolve function
        gUI.messagePromiseResolve = null; // Clear the stored function
        fMyConsoleLog("Message Promise Resolved"); // Optional log
    }
} // END fHideMessage




// fSetupMessageModalListeners /////////////////////////////////////////////////////
// Purpose -> Sets up event listeners for the message modal close mechanisms.
// Inputs -> None
// Outputs -> None
// NOTE: No changes needed here, as the listeners already call fHideMessage,
//       which now handles resolving the promise.
function fSetupMessageModalListeners() {

    fMyConsoleLog("üñ±Ô∏è Setting up Message Modal Listeners...");
    // --- Get elements directly here, don't rely solely on gUI cache ---
    const overlayElement = document.getElementById('messageModal');
    const closeButtonElement = document.getElementById('closeMessageModal');
    // We still need the overlay for the other listeners, might as well fetch it too.
    // Check if elements were found *now*
    if (!overlayElement) {
        console.error("Setup failed: Message modal overlay element (#messageModal) not found *during listener setup*.");
        fMyConsoleLog("‚ö†Ô∏è Message Modal Listeners NOT Attached (overlay missing).");
        return;
    }
    if (!closeButtonElement) {
        console.error("Setup failed: Message modal close button (#closeMessageModal) not found *during listener setup*.");
        fMyConsoleLog("‚ö†Ô∏è Message Modal Listeners NOT Attached (button missing).");
        return; // Don't add listeners if button is missing
    }
    // --- End direct element fetching ---


    // Listener for the close button - Attach to the element we just found
    closeButtonElement.addEventListener('click', fHideMessage); // Calls the (now modified) hide function


    // Listener for clicking the background overlay - Attach to the element we just found
    overlayElement.addEventListener('click', (event) => {
        if (event.target === overlayElement) { // Check directly against the fetched element
            fHideMessage(); // Calls the (now modified) hide function
        }
    });
    // Listener for the Escape key (uses document, and checks overlay visibility)
    document.addEventListener('keydown', (event) => {
        // Check overlay visibility using the fetched element reference
        if (overlayElement.style.display !== 'none' && event.key === 'Escape') {
             fHideMessage(); // Calls the (now modified) hide function
        }
    });
    fMyConsoleLog("‚úÖ Message Modal Listeners Attached.");

} // END fSetupMessageModalListeners



// ==========================================================================
// === Prompt Box              (End of Message Box) ===
// ==========================================================================


// fShowPrompt ///////////////////////////////////////////////////////////////////
// Purpose -> Displays the prompt modal box and returns a Promise that resolves with true (Yes) or false (No).
// Inputs -> message (String): The text or HTML to display in the prompt box.
// Outputs -> (Promise): Resolves with true if 'Yes' clicked, false if 'No' clicked.
async function fShowPrompt(message) {
    // --- Try to cache elements if not already done ---
    if (!gUI.promptModalOverlay) gUI.promptModalOverlay = document.getElementById('promptModal');
    if (!gUI.promptModalText) gUI.promptModalText = document.getElementById('promptText');
    // --- End Caching Attempt ---

    // Check if elements exist *after* attempting to cache
    if (!gUI.promptModalOverlay || !gUI.promptModalText) {
        console.error("Prompt modal elements not cached or found in the DOM!");
        if (!gUI.promptModalOverlay) console.error("Missing: #promptModal");
        if (!gUI.promptModalText) console.error("Missing: #promptText");
        return Promise.reject(new Error("Prompt modal elements not found.")); // Reject if elements missing
    }

    // Set prompt content
    gUI.promptModalText.innerHTML = message;
    // Show the modal
    gUI.promptModalOverlay.style.display = 'flex';
    // Create and return a new Promise
    // We store both resolve and reject, although reject might not be used often for simple Yes/No
    return new Promise((resolve, reject) => {
        gUI.promptPromiseResolve = resolve; // Store the resolve function
        gUI.promptPromiseReject = reject;   // Store the reject function
    });
} // END fShowPrompt




// fHandlePromptResponse ///////////////////////////////////////////////////////////
// Purpose -> Hides the prompt modal and resolves the pending promise with the user's choice.
// Inputs -> userResponse (Boolean): true for 'Yes', false for 'No'.
// Outputs -> None
function fHandlePromptResponse(userResponse) {
    // Hide the modal first
    if (gUI.promptModalOverlay) {
        gUI.promptModalOverlay.style.display = 'none';
    } else {
        console.error("Prompt modal overlay element (#promptModal) not found when trying to hide.");
    }

    // Resolve the promise if a resolve function is stored
    if (typeof gUI.promptPromiseResolve === 'function') {
        gUI.promptPromiseResolve(userResponse); // Call the stored resolve function with the response
        fMyConsoleLog(`Prompt Promise Resolved with: ${userResponse}`); // Optional log
    } else {
        console.error("Prompt promise resolve function not found when trying to resolve.");
    }

    // Clear the stored functions after use
    gUI.promptPromiseResolve = null;
    gUI.promptPromiseReject = null;
} // END fHandlePromptResponse




// fSetupPromptModalListeners //////////////////////////////////////////////////////
// Purpose -> Sets up event listeners for the prompt modal 'Yes' and 'No' buttons.
// Inputs -> None
// Outputs -> None
function fSetupPromptModalListeners() {
    fMyConsoleLog("üñ±Ô∏è Setting up Prompt Modal Listeners...");
    // --- Cache elements if not already done (or get directly) ---
    if (!gUI.promptYesButton) gUI.promptYesButton = document.getElementById('promptYesButton');
    if (!gUI.promptNoButton) gUI.promptNoButton = document.getElementById('promptNoButton');
    // We don't necessarily need the overlay reference here unless adding Escape/background click handling

    // Check if buttons were found *now*
    if (!gUI.promptYesButton) {
        console.error("Setup failed: Prompt 'Yes' button (#promptYesButton) not found *during listener setup*.");
        fMyConsoleLog("‚ö†Ô∏è Prompt Modal Listeners NOT Attached (Yes button missing).");
        return;
    }
    if (!gUI.promptNoButton) {
        console.error("Setup failed: Prompt 'No' button (#promptNoButton) not found *during listener setup*.");
        fMyConsoleLog("‚ö†Ô∏è Prompt Modal Listeners NOT Attached (No button missing).");
        return;
    }
    // --- End direct element fetching/caching ---

    // Listener for the 'Yes' button
    gUI.promptYesButton.addEventListener('click', () => fHandlePromptResponse(true));
    // Listener for the 'No' button
    gUI.promptNoButton.addEventListener('click', () => fHandlePromptResponse(false));
    // @@Optional: Add Escape key listener here if needed (could call fHandlePromptResponse(false) or reject)
    // document.addEventListener('keydown', (event) => {
    //   if (gUI.promptModalOverlay && gUI.promptModalOverlay.style.display !== 'none' && event.key === 'Escape') {
    //     fHandlePromptResponse(false); // Or potentially reject if you use the reject function
    //   }
    // });
    fMyConsoleLog("‚úÖ Prompt Modal Listeners Attached.");
} // END fSetupPromptModalListeners






</script>