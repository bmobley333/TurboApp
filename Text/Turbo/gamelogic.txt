<!-- gamelogic.html -->


<script>




// ==========================================================================
// === Die Roll Button         (End of Top) ===
// ==========================================================================




// fHandleRollDiceAction /////////////////////////////////////////////////////////////////////////
// Purpose -> Top-level handler for "Roll Dice" action. Populates gUI.roll, validates inputs,
//            runs morph/roll/resolution logic, and posts result.
// Inputs  -> None (uses gUI.currentSkRadioChecked).
// Outputs -> None (updates gUI and DOM).
function fHandleRollDiceAction() {
    fLogStatus("üé≤ Roll Dice Action Triggered");

    const { r, c } = gUI.currentSkRadioChecked;

    // Validate target is a valid Sk1/Sk2 checkbox
    if (!fValidateAbilityCB(r, c)) return;

    // Populate gUI.roll from sheet and clean it
    if (!fResetPopulateNCleanGUIRoll(r, c)) return;

    // Confirm ability has valid name and type
    if (!fVerifyAbility()) return;

    // Core calculation pipeline
    fProcessMorph();
    fCalcGUIRollResSk();
    fCalcGUIRollRoll();
    fCalcGUIRollResRoll();
    fCalcRollLogPrepend();
} // END fHandleRollDiceAction





// fValidateAbilityCB /////////////////////////////////////////////////////////////////////////
// Purpose -> Confirms that (row, col) is a valid Sk1/Sk2 checkbox based on gUI.sk1sk2CheckBoxes.
// Inputs  -> row (Number), col (Number): 0-based indices.
// Outputs -> (Boolean): true if valid, false otherwise.
function fValidateAbilityCB(row, col) {
    const isValid = fIsSkRadioGroupMember(row, col);
    if (!isValid) fShowMessage("‚ö†Ô∏è Please select a valid Ability checkbox first!");
    return isValid;
} // END fValidateAbilityCB




// fResetPopulateNCleanGUIRoll //////////////////////////////////////////////////////////////////
// Purpose -> Extracts and cleans ability row data into gUI.roll based on Sk1 or Sk2 checkbox.
// Inputs  -> r (Number), c (Number): Row and column from selected radio.
// Outputs -> (Boolean): true if success, false if extraction/cleaning fails.
function fResetPopulateNCleanGUIRoll(r, c) {
    try {
        const getVal = tag => gUI.arr[r]?.[resolveCol(tag)] ?? '';
        const isSk1 = (c === resolveCol('Sk1ChkBox'));

        // --- Initial Population ---
        gUI.roll = {
            sk1CB: isSk1,
            skMorph: isSk1 ? getVal('Morph1') : getVal('Morph2'),
            skTyp: isSk1 ? getVal('Sk1Typ') : getVal('Sk2Typ'),
            skSk: isSk1 ? getVal('Sk1') : getVal('Sk2'),
            skIsOn: getVal('On'),
            skNameID: getVal('Ability'),
            skName: '',
            skAct: isSk1 ? getVal('Act') : '',
            skDur: isSk1 ? getVal('Dur') : '',
            skMeta: isSk1 ? getVal('Meta') : '',
            skUses: isSk1 ? getVal('Uses') : '',
            resTyp: '',
            resSk: '',
            resFlatBase: '',
            resFlatResult: '',
            resDif: '',
            resFocus: '',
            resPlus: '',
            resPlusPlus: '',
            resMult: '',
            resMultMult: '',
            resCombine: '',
            isUnSk: false,
            roll: '',
            resRoll: ''
        };

        const rData = gUI.roll;

        // --- Clean string fields ---
        rData.skName = String(rData.skNameID || '').replace(/\s{2,}_\w{6}$/, '').trim();
        rData.skMorph = String(rData.skMorph || '').trim().replace(/^,+/, '');
        rData.skTyp = String(rData.skTyp || '').trim();
        rData.skIsOn = String(rData.skIsOn || '').trim();
        rData.skDur = String(rData.skDur || '').trim();
        rData.skMeta = String(rData.skMeta || '').trim();

        // --- Clean numeric fields ---
        const sk = parseInt(rData.skSk, 10);
        rData.skSk = (!isNaN(sk) && sk >= 1) ? sk : '';

        const act = parseInt(String(rData.skAct || '').trim(), 10);
        rData.skAct = (!isNaN(act) && act >= 1) ? act : '';

        const uses = parseInt(rData.skUses, 10);
        rData.skUses = (!isNaN(uses) && uses >= 0) ? uses : '';

        // --- Default resTyp to skTyp ---
        rData.resTyp = rData.skTyp;

        // --- Final status log ---
        fLogStatus(`‚öôÔ∏è Populated & Cleaned gUI.roll for row ${r} (isSk1: ${isSk1})`);
        return true;

    } catch (err) {
        // --- Error Handling ---
        console.error("‚ùå Error populating/cleaning gUI.roll:", err);
        fPrependToSidebar(`‚ùå Error processing skill data: ${err.message}`);
        fShowSidebar();
        return false;
    }
} // END fResetPopulateNCleanGUIRoll




// fVerifyAbility /////////////////////////////////////////////////////////////////////////
// Purpose -> Validates current gUI.roll by checking name and skill type.
// Inputs  -> None (uses gUI.roll and gUI.list).
// Outputs -> (Boolean): true if ability is valid, false otherwise.
function fVerifyAbility() {
    const { skName, skTyp, sk1CB } = gUI.roll;

    // --- Check: Ability name must exist ---
    if (!skName) {
        fShowMessage("‚ö†Ô∏è Please select an Ability with a name!");
        return false;
    }

    // --- Check: Skill Typ must be a string ---
    if (!skTyp || typeof skTyp !== 'string') {
        const is2ndCol = !sk1CB;
        fShowMessage(`‚ö†Ô∏è No skill Typ found${is2ndCol ? '<br><br>You may have wanted the 1st column.' : ''}`);
        return false;
    }

    // --- Check: Skill type must match known types (case-insensitive) ---
    const skTypLower = skTyp.trim().toLowerCase();
    const isValidSkTyp = gUI.list.skTyp.some(type => type.toLowerCase() === skTypLower);
    if (!isValidSkTyp) {
        fShowMessage(`‚ö†Ô∏è ${skTyp} is an invalid Skill Type!`);
        return false;
    }

    // --- Passed all checks ---
    return true;
} // END fVerifyAbility



// fProcessMorph /////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Processes gUI.roll.skMorph string to extract modifiers and flags into res* fields.
// Inputs  -> None (reads gUI.roll.skMorph, gUI.roll.skSk, gUI.list).
// Outputs -> None (updates gUI.roll directly).
function fProcessMorph() {
    const skMorph = gUI.roll.skMorph || '';
    if (!skMorph) {
        fLogStatus("‚ÑπÔ∏è No skMorph string to process.");
        return;
    }

    // Split morph string and compile lowercased version
    const morphComponents = skMorph.split(',').map(x => x.trim()).filter(Boolean);
    const morphLower = morphComponents.map(x => x.toLowerCase());

    // Accumulator object for temp results
    const acc = {
        foundResTyp: false,
        lastResTypMatch: '',
        lastFocusIndex: -1,
        foundResPlus: false,
        totalPlus: 0,
        combineNumbers: [],
        foundResPlusPlus: false,
        totalPlusPlus: 0,
        foundResMult: false,
        totalMult: 1.0,
        foundResMultMult: false,
        totalMultMult: 1.0,
        lastFlatBaseMatch: '',
        lastFlatResultMatch: '',
        lastDifMatch: ''
    };

    fParseMorphComponents(morphComponents, morphLower, acc);
    fApplyMorphResults(acc);

    fLogStatus("‚öôÔ∏è Processed skMorph string.");
} // END fProcessMorph




// fParseMorphComponents ////////////////////////////////////////////////////////////////////////////////
// Purpose -> Parses each morph component and mutates gUI.roll and acc accordingly.
function fParseMorphComponents(morphComponents, morphLower, acc) {
    const plusMinusRegex = /^([-+])(\d+)$/;
    const numberOnlyRegex = /^\d+$/;
    const plusPlusMinusMinusRegex = /^(?:(\+\+)|(--))(\d+)$/;
    const multDivRegex = /^([*\/])(\d+(\.\d+)?)$/;
    const multMultDivDivRegex = /^(?:(\*\*)|(\/\/))(\d+(\.\d+)?)$/;
    const equalsRegex = /^=(\d+)$/;
    const equalsEqualsRegex = /^==(\d+)$/;
    const caretRegex = /^\^(\d+)$/;

    morphComponents.forEach((component, index) => {
        const lower = morphLower[index];

        // --- isUnSk Check
        if (lower === 'un' || lower === 'unsk') gUI.roll.isUnSk = true;

        // --- resTyp Check (find LAST match)
        if (gUI.list.skTyp.includes(lower)) {
            acc.lastResTypMatch = component;
            acc.foundResTyp = true;
        }

        // --- resFocus Check (find index of LAST match)
        const focusIndex = gUI.list.metaColor.indexOf(lower);
        if (focusIndex > -1) acc.lastFocusIndex = focusIndex;

        // --- resPlus Check
        const plusMatch = component.match(plusMinusRegex);
        if (plusMatch) {
            const val = parseInt(plusMatch[2], 10);
            acc.totalPlus += (plusMatch[1] === '+' ? val : -val);
            acc.foundResPlus = true;
        }

        // --- resCombine Check (collect numbers)
        if (numberOnlyRegex.test(component)) acc.combineNumbers.push(parseInt(component, 10));

        // --- resPlusPlus Check
        const ppMatch = component.match(plusPlusMinusMinusRegex);
        if (ppMatch) {
            const val = parseInt(ppMatch[3], 10);
            acc.totalPlusPlus += (ppMatch[1] === '++' ? val : -val);
            acc.foundResPlusPlus = true;
        }

        // --- resMult Check
        const m1 = component.match(multDivRegex);
        if (m1) {
            const val = parseFloat(m1[2]);
            if (m1[1] === '*') acc.totalMult *= val;
            else if (val !== 0) acc.totalMult /= val;
            else {
                fShowMessage("‚ùå Morph includes illegal '/0'. Please correct and try again.");
                console.warn("resMult divide by zero:", component);
            }
            acc.foundResMult = true;
        }

        // --- resMultMult Check
        const m2 = component.match(multMultDivDivRegex);
        if (m2) {
            const val = parseFloat(m2[3]);
            if (m2[1] === '**') acc.totalMultMult *= val;
            else if (val !== 0) acc.totalMultMult /= val;
            else {
                fShowMessage("‚ùå Morph includes illegal '//0'. Please correct and try again.");
                console.warn("resMultMult divide by zero:", component);
            }
            acc.foundResMultMult = true;
        }

        // --- resFlatBase Check (find LAST match)
        const eq1 = component.match(equalsRegex);
        if (eq1) acc.lastFlatBaseMatch = eq1[1];

        // 10. resFlatResult Check (find LAST match)
        const eq2 = component.match(equalsEqualsRegex);
        if (eq2) acc.lastFlatResultMatch = eq2[1];

        // --- resDif Check (find LAST match)
        const dif = component.match(caretRegex);
        if (dif) acc.lastDifMatch = dif[1];
    });
} // END fParseMorphComponents




// fApplyMorphResults ////////////////////////////////////////////////////////////////////////////////
// Purpose -> Applies accumulated morph data to gUI.roll.
function fApplyMorphResults(acc) {
    const r = gUI.roll;

    // MUST BE FIRST: Assign resFlatBase (also sets skSk)
    if (acc.lastFlatBaseMatch !== '') {
        const num = parseInt(acc.lastFlatBaseMatch, 10);
        if (!isNaN(num)) {
            r.resFlatBase = num;
            r.skSk = num;
        }
    }

    // Assign resTyp (last match found else gUI.roll.skTyp)
    if (acc.foundResTyp) {
        r.resTyp = acc.lastResTypMatch || r.skTyp;
    }

    // Assign resFocus (index of last match found)
    if (acc.lastFocusIndex > -1) {
        r.resFocus = acc.lastFocusIndex;
    }

    // Assign resPlus
    if (acc.foundResPlus) {
        r.resPlus = acc.totalPlus;
    }

    // Assign resCombine
    if (typeof r.skSk === 'number' && r.skSk >= 1) {
        acc.combineNumbers.push(r.skSk);
    }
    if (acc.combineNumbers.length > 0) {
        acc.combineNumbers.sort((a, b) => b - a);
        let value = 0, divisor = 1;
        for (const num of acc.combineNumbers) {
            value += num / divisor;
            divisor *= 2;
        }
        r.resCombine = Math.round(value);
    }

    // Assign resPlusPlus
    if (acc.foundResPlusPlus) {
        r.resPlusPlus = acc.totalPlusPlus;
    }

    // Assign resMult
    if (acc.foundResMult) {
        r.resMult = Number(acc.totalMult.toFixed(2));
    }

    // Assign resMultMult
    if (acc.foundResMultMult) {
        r.resMultMult = Number(acc.totalMultMult.toFixed(2));
    }

    // Assign resFlatResult (convert last match to integer)
    if (acc.lastFlatResultMatch !== '') {
        const num = parseInt(acc.lastFlatResultMatch, 10);
        if (!isNaN(num)) r.resFlatResult = num;
    }

    // Assign resDif (convert last match to integer)
    if (acc.lastDifMatch !== '') {
        const num = parseInt(acc.lastDifMatch, 10);
        if (!isNaN(num)) r.resDif = num;
    }
} // END fApplyMorphResults





// fCalcGUIRollResSk /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Calculates final resulting skill value (gUI.roll.resSk) using morph-derived modifiers.
// Inputs  -> None (reads from gUI.roll).
// Outputs -> None (writes gUI.roll.resSk).
function fCalcGUIRollResSk() {
    let currentResSk;

    // --- Determine Initial Base Value ---
    if (typeof gUI.roll.skSk === 'number' && gUI.roll.skSk !== '') {
        currentResSk = gUI.roll.skSk;
    } else {
        currentResSk = NaN;
    }

    // --- Fallback to Combine Value ---
    if (typeof gUI.roll.resCombine === 'number' && gUI.roll.resCombine !== '') {
        currentResSk = gUI.roll.resCombine;
        fLogStatus("   -> Using resCombine as fallback for resSk calculation.");
    }

    // --- Modifier Application Pipeline ---
    if (!isNaN(currentResSk)) {
        // Apply resMult (multiplicative)
        if (typeof gUI.roll.resMult === 'number' && gUI.roll.resMult !== '') {
            currentResSk *= gUI.roll.resMult;
        }

        // Apply resPlus (additive)
        if (typeof gUI.roll.resPlus === 'number' && gUI.roll.resPlus !== '') {
            currentResSk += gUI.roll.resPlus;
        }

        // Apply resFocus (focus index adds 5 * (1 + index))
        if (typeof gUI.roll.resFocus === 'number' && gUI.roll.resFocus >= 0) {
            currentResSk += 5 * (1 + gUI.roll.resFocus);
        }

        // Apply isUnSk (cut in half)
        if (gUI.roll.isUnSk === true) {
            currentResSk *= 0.5;
        }

        // --- Final Adjustment: Clamp Tiny Values ---
        if (currentResSk > 0 && currentResSk < 1) {
            currentResSk = 1;
        }

        // --- Diagnostic Output ---
        console.log(`DEBUG fCalcGUIRollResSk: Value before final check/assignment:`, currentResSk);

        // --- Final Assignment ---
        if (currentResSk >= 1) {
            gUI.roll.resSk = Math.round(currentResSk);
        } else {
            gUI.roll.resSk = '';
        }
    } else {
        // Invalid input, leave resSk empty
        gUI.roll.resSk = '';
    }

    fLogStatus(`‚öôÔ∏è Calculated final resSk: ${gUI.roll.resSk}`);
} // END fCalcGUIRollResSk




// fCalcGUIRollRoll /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Determines dice roll result (gUI.roll.roll) based on resSk and resTyp.
// Inputs  -> None (reads gUI.roll.resSk, gUI.roll.resTyp).
// Outputs -> None (writes gUI.roll.roll).
function fCalcGUIRollRoll() {
    const resSkValue = gUI.roll.resSk;
    const resTypValue = (typeof gUI.roll.resTyp === 'string')
        ? gUI.roll.resTyp.trim().toLowerCase()
        : '';

    // --- Validate resSk (must be a number >= 1) ---
    if (typeof resSkValue !== 'number' || resSkValue < 1) {
        gUI.roll.roll = '';
        fLogStatus(`‚ÑπÔ∏è Cannot calculate roll: Invalid resSk value (${resSkValue}).`);
        return;
    }

    // --- Determine roll function based on resTyp ---
    switch (resTypValue) {

        // No type ‚Üí skip rolling
        case '': gUI.roll.roll = ''; break;

        // Skill or Attribute roll
        case 'sk':
        case 'atr': gUI.roll.roll = fCSDSk(resSkValue); break;

        // Attack roll
        case 'atk': gUI.roll.roll = fCSAtk(resSkValue); break;

        // Damage roll
        case 'dmg': gUI.roll.roll = fCSDDmg(resSkValue); break;

        // Defense roll
        case 'def': gUI.roll.roll = fCSDef(resSkValue); break;

        // Armor roll (may return decimal)
        case 'ar': gUI.roll.roll = fCSDArmor(resSkValue); break;

        // Unexpected usage of 'unsk' as final roll type
        case 'un':
        case 'unsk':
            console.warn(`fCalcGUIRollRoll: Roll type '${resTypValue}' used directly. Consider adjusting morph.`);
            gUI.roll.roll = fCSDSk(resSkValue);
            break;

        // Unknown roll type
        default:
            console.warn(`fCalcGUIRollRoll: Unknown resTyp '${resTypValue}'. Cannot calculate roll.`);
            gUI.roll.roll = '';
            break;
    }

    // --- Final Logging ---
    fLogStatus(`‚öôÔ∏è Calculated roll (${resTypValue}): ${gUI.roll.roll}`);
} // END fCalcGUIRollRoll





// fCalcGUIRollResRoll /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Calculates final gUI.roll.resRoll using overrides or morph-based modifiers.
// Inputs  -> None (reads gUI.roll).
// Outputs -> None (writes gUI.roll.resRoll).
function fCalcGUIRollResRoll() {

    // --- Check for Flat Result Override ---
    const flatResult = (typeof gUI.roll.resFlatResult === 'number' && gUI.roll.resFlatResult !== '') ? gUI.roll.resFlatResult : null;

    if (flatResult !== null) {
        const isArType = (typeof gUI.roll.resTyp === 'string') && gUI.roll.resTyp.trim().toLowerCase() === 'ar';
        const roundedFlatResult = isArType ? Number(flatResult.toFixed(2)) : Math.round(flatResult);
        gUI.roll.resRoll = Math.max(0, roundedFlatResult);
        fLogStatus(`‚öôÔ∏è Calculated resRoll (override, ${isArType ? 'AR-rounded' : 'INT-rounded'}): ${gUI.roll.resRoll}`);
        return;
    }

    // --- Validate Base Roll ---
    const initialRoll = gUI.roll.roll;
    if (typeof initialRoll !== 'number' || initialRoll === '') {
        gUI.roll.resRoll = '';
        fLogStatus(`‚ÑπÔ∏è Cannot calculate resRoll: Invalid initial roll value (${initialRoll}).`);
        return;
    }

    // --- Apply Modifiers ---
    let currentResRoll = initialRoll;
    if (typeof gUI.roll.resMultMult === 'number' && gUI.roll.resMultMult !== '') currentResRoll *= gUI.roll.resMultMult;
    if (typeof gUI.roll.resPlusPlus === 'number' && gUI.roll.resPlusPlus !== '') currentResRoll += gUI.roll.resPlusPlus;

    // --- Final Rounding, Clamping, and Assignment ---
    if (!isNaN(currentResRoll)) {
        const isArType = (typeof gUI.roll.resTyp === 'string') && gUI.roll.resTyp.trim().toLowerCase() === 'ar';
        const roundedResRoll = isArType ? Number(currentResRoll.toFixed(2)) : Math.round(currentResRoll);
        gUI.roll.resRoll = Math.max(0, roundedResRoll);
    } else {
        gUI.roll.resRoll = '';
        console.warn("fCalcGUIRollResRoll: Calculation resulted in NaN.");
    }

    fLogStatus(`‚öôÔ∏è Calculated final resRoll: ${gUI.roll.resRoll}`);
} // END fCalcGUIRollResRoll






// fCalcRollLogPrepend /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Builds final roll result log message and prepends it to the sidebar.
// Inputs  -> None (reads gUI.roll).
// Outputs -> None (calls fPrependToSidebar, fShowSidebar).
function fCalcRollLogPrepend() {
    const html = fBuildRollLogHTML();
    fPrependToSidebar(html);
    fShowSidebar();
    fLogStatus("üì∞ Roll Log message prepended.");
} // END fCalcRollLogPrepend




// fBuildRollLogHTML /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Constructs and returns the formatted HTML log line based on gUI.roll data.
// Inputs  -> None (reads gUI.roll).
// Outputs -> (String): HTML string to insert in sidebar.
function fBuildRollLogHTML() {

    // --- Build Title ---
    const skTyp = (typeof gUI.roll.skTyp === 'string') ? gUI.roll.skTyp.trim() : '';
    const resTyp = (typeof gUI.roll.resTyp === 'string') ? gUI.roll.resTyp.trim() : '';
    let title = gUI.roll.skName || 'Unknown Ability';
    if (skTyp) title += ` ${skTyp}`;
    if (resTyp && resTyp !== skTyp) title += ` (now ${resTyp})`;

    // --- Get Morph String ---
    const morph = (typeof gUI.roll.skMorph === 'string' && gUI.roll.skMorph !== ',') ? gUI.roll.skMorph.trim() : '';

    // --- Build Roll Base String (Type(Sk->ResSk)) ---
    let rollBase = resTyp || skTyp;
    const skSk = gUI.roll.skSk;
    const resSk = gUI.roll.resSk;
    if (typeof skSk === 'number' && skSk !== '') {
        rollBase += `(${skSk}${(typeof resSk === 'number' && resSk !== '' && resSk !== skSk) ? `->${resSk}` : ''})`;
    } else if (typeof resSk === 'number' && resSk !== '') {
        rollBase += `(${resSk})`;
    }

    // --- Build Roll Result String (~Roll->ResRoll) ---
    const roll = gUI.roll.roll;
    const resRoll = gUI.roll.resRoll;
    let rollResult = '';
    if ((typeof roll === 'number' || (typeof roll === 'string' && roll !== '')) && roll != null) {
        rollResult += ` ~${roll}`;
        if ((typeof resRoll === 'number' || (typeof resRoll === 'string' && resRoll !== '')) && resRoll != null && resRoll !== roll) {
            rollResult += `->${resRoll}`;
        }
    } else if ((typeof resRoll === 'number' || (typeof resRoll === 'string' && resRoll !== '')) && resRoll != null) {
        rollResult += ` ~${resRoll}`;
    }

    // --- Build Difficulty (^Dif) ---
    const dif = gUI.roll.resDif;
    let rollDif = (typeof dif === 'number' || (typeof dif === 'string' && dif !== '')) && dif != null ? `^${dif}` : '';

    // --- Build Success Delta (=/+Œî) ---
    let rollSuccess = '';
    if (typeof resRoll === 'number' && typeof dif === 'number') {
        const delta = resRoll - dif;
        rollSuccess = delta > 0 ? ` =+${delta}` : ` =${delta}`;
    }

    // --- Combine Roll Summary ---
    const roll1 = `${rollBase}${rollResult}${rollDif}${rollSuccess}`.trim();

    // --- Build Final HTML ---
    let html = `<span class="sidebar-ability-name">${title}</span>`;
    if (morph) html += `<br>morph: ${morph}`;
    if (roll1) html += `<br>${roll1}`;
    return html;
} // END fBuildRollLogHTML



// ==========================================================================
// === Base Die Rolling          (End of Die Roll Button ) ===
// ========================================================================== 


// fCSd //////////////////////////////////////////////////////////////////////
// Purpose -> Standard linear distribution die roll.
// Inputs  -> die (Number): The number of sides on the die.
// Outputs -> (Number): The result of the roll (1 to die).
function fCSd(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSd received invalid die size: ${die}`);
    return 1; // Return 1 for invalid input
  }
  return Math.floor(Math.random() * numDie) + 1;
} // END fCSd



// fCSD //////////////////////////////////////////////////////////////////////
// Purpose -> Make an old fashioned, but smooth, MetaScape d(die) roll (no T or C).
//            Uses a non-linear distribution.
// Inputs  -> die (Number): The base value for the roll.
// Outputs -> (Number): The result of the roll.
function fCSD(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSD received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  // Prevent division by zero or near-zero in Math.random()
  let randomDivisor = Math.random();
  if (randomDivisor < 0.0001) randomDivisor = 0.0001; // Set a minimum divisor

  return Math.floor((numDie * Math.random()) / randomDivisor) + 1;
} // END fCSD



// fCStc /////////////////////////////////////////////////////////////////////
// Purpose -> Rolls 1d16 to determine Tremendous ('T') or Critical ('C') result.
// Inputs  -> None.
// Outputs -> (String): "T", "C", or "".
function fCStc() {
  const roll = fCSd(16); // Use the translated fCSd
  // Fetch color formatting from gUI if available, otherwise use plain text
  const treS = gUI?.style?.treS ?? '';   // Tremendous Start
  const redBS = gUI?.style?.redBS ?? ''; // Red Bold Start
  const endS = gUI?.style?.endS ?? '';   // Span End

  return roll === 1
    ? `${treS}T${endS}`
    : roll === 2
    ? `${redBS}C${endS}`
    : "";
} // END fCStc




// fCSdBetween ///////////////////////////////////////////////////////////////
// Purpose -> Rolls d(high - low + 1) + (low - 1). e.g., fCSdBetween(6,8) = 6, 7, or 8.
// Inputs  -> low (Number): The lowest possible result.
//         -> high (Number): The highest possible result.
// Outputs -> (Number): Random integer between low and high (inclusive).
function fCSdBetween(low, high) {
  const numLow = Number(low);
  const numHigh = Number(high);
  if (isNaN(numLow) || isNaN(numHigh) || numLow > numHigh) {
    console.error(`fCSdBetween received invalid range: ${low}-${high}`);
    return numLow; // Return low value on error
  }
  // Roll d(high - low + 1) then add (low - 1)
  return fCSd(numHigh - numLow + 1) + (numLow - 1);
} // END fCSdBetween




// fCSDSk ////////////////////////////////////////////////////////////////////
// Purpose -> Returns the average of a d(die * 2) and an fCSD(die) roll.
// Inputs  -> die (Number): The base skill value.
// Outputs -> (Number): The result of the skill roll.
function fCSDSk(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSDSk received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  return Math.round((fCSd(numDie * 2) + fCSD(numDie)) / 2);
} // END fCSDSk




// fCSAtk ////////////////////////////////////////////////////////////////////
// Purpose -> Returns the average of a d(die * 2) and an fCSD(die) roll.
// Inputs  -> die (Number): The base skill value.
// Outputs -> (Number): The result of the skill roll.
// For 'now' is identical to fCSDSk
function fCSAtk(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSAtk received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  return Math.round((fCSd(numDie * 2) + fCSD(numDie)) / 2);
} // END fCSAtk



// fCSDef ////////////////////////////////////////////////////////////////////
// Purpose -> Returns a PC Defense roll (based on fCSD).
// Inputs  -> die (Number): The base defense value.
// Outputs -> (Number): The result of the defense roll.
function fCSDef(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSDef received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  // Formula from MSGLib: fCSD(die) * 0.75
  return Math.round(fCSD(numDie) * 0.75);
} // END fCSDef




// fCSRollUnSkilled //////////////////////////////////////////////////////////
// Purpose -> Rolls an ability as UnSkilled. Reduces base die value first.
// Inputs  -> die (Number): The original base skill value.
// Outputs -> (Number): The result of the unskilled roll.
function fCSRollUnSkilled(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSRollUnSkilled received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  // Calculate the reduced die value for unskilled rolls
  const newDie = Math.max(2, Math.min(numDie / 2, 5 + Math.sqrt(numDie)));
  // Formula from MSGLib: avg(d(newDie*2), d(newDie*2), fCSD(newDie)) / 3
  return Math.round((fCSd(newDie * 2) + fCSd(newDie * 2) + fCSD(newDie)) / 3);
} // END fCSRollUnSkilled




// fCSRollUnSkilledDmg ///////////////////////////////////////////////////////
// Purpose -> Rolls PC Unskilled Damage (currently uses standard unskilled roll).
// Inputs  -> pcDmg (Number): The base damage value.
// Outputs -> (Number): The result of the unskilled damage roll.
function fCSRollUnSkilledDmg(pcDmg) {
  // Simply calls the standard unskilled function for now
  return fCSRollUnSkilled(pcDmg);
} // END fCSRollUnSkilledDmg




// fCSRollUnSkilledArmor /////////////////////////////////////////////////////
// Purpose -> Rolls PC Unskilled Armor.
// Inputs  -> pcAR (Number): The base armor value.
// Outputs -> (Number): The result of the unskilled armor roll (min 1, rounded to tenth).
function fCSRollUnSkilledArmor(pcAR) {
  // Formula from MSGLib: max(1, trunc( (fCSRollUnSkilled(pcAR) / 8) * 10 ) / 10 )
  const unskilledRoll = fCSRollUnSkilled(pcAR);
  // MSGLib uses 8 here, not 15 like fCSDArmor
  const result = Math.trunc((unskilledRoll / 8) * 10) / 10;
  return Math.max(1, result); // Ensure minimum of 1
} // END fCSRollUnSkilledArmor




// fCSDDmg ///////////////////////////////////////////////////////////////////
// Purpose -> Rolls PC Damage (currently uses standard fCSDSk roll).
// Inputs  -> pcDmg (Number): The base damage value.
// Outputs -> (Number): The result of the damage roll.
function fCSDDmg(pcDmg) {
  // Simply calls the standard skill roll function for now
  return fCSDSk(pcDmg);
} // END fCSDDmg




// fCSDArmor /////////////////////////////////////////////////////////////////
// Purpose -> Rolls PC Armor.
// Inputs  -> pcAR (Number): The base armor value.
// Outputs -> (Number): The result of the armor roll (min 1, rounded to tenth).
function fCSDArmor(pcAR) {
  // Formula from MSGLib: max(1, trunc( (fCSDSk(pcAR) / 15) * 10 ) / 10 )
  const skillRoll = fCSDSk(pcAR);
  // MSGLib uses 15 here, not 8 like fCSRollUnSkilledArmor
  const result = Math.trunc((skillRoll / 15) * 100) / 100;
  return Math.max(1, result); // Ensure minimum of 1
} // END fCSDArmor




// fCSCalcdTiers /////////////////////////////////////////////////////////////
// Purpose -> Calculates applying +/- X number of d-tiers to a base value.
//            e.g., +2d increases base, -1d decreases base, using a multiplier.
// Inputs  -> dieBase (Number): The starting base value.
//         -> numOfd (Number): The number of tiers to apply (positive or negative integer).
// Outputs -> (Number): The adjusted base value (min 1).
function fCSCalcdTiers(dieBase, numOfd) {
  const numDieBase = Number(dieBase);
  const numNumOfd = Number(numOfd);

  if (isNaN(numDieBase) || numDieBase < 1) {
    console.error(`fCSCalcdTiers received invalid dieBase: ${dieBase}`);
    return 1;
  }
  if (!Number.isInteger(numNumOfd)) {
    // Allow 0 as valid input
    if (numNumOfd === 0) return numDieBase;
    console.error(`fCSCalcdTiers requires an integer for numOfd, received: ${numOfd}`);
    return numDieBase; // Return original base if numOfd is invalid
  }

  let newBase = numDieBase;
  const isPositive = numNumOfd > 0;
  const absNumOfd = Math.abs(numNumOfd);

  // Constants from MSGLib
  const oneDVal = 1 + 1 / 3; // Multiplier for +1d
  const divOneDVal = 1 / oneDVal; // Multiplier for -1d

  for (let i = 0; i < absNumOfd; i++) {
    // Special handling for base 1 and 2 from MSGLib
    if (newBase === 1 && isPositive) {
      newBase = 2;
    } else if (newBase === 2 && !isPositive) {
      newBase = 1;
    } else {
      newBase *= isPositive ? oneDVal : divOneDVal;
    }
    newBase = Math.round(newBase); // Round after each tier application
  }

  return Math.max(1, newBase); // Ensure the result is at least 1
} // END fCSCalcdTiers



// ==========================================================================
// === Derived Dice Rolls         (End of CBase Die Rolling ) ===
// ==========================================================================


</script>