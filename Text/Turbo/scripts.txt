<script>
// scripts.html //


// ==========================================================================
// === Global Variables ===
// ==========================================================================




// scripts.html //


// ==========================================================================
// === Global Variables ===
// ==========================================================================




const gUI = {
  // === Core Data Arrays ===
  arr: [],        // 2D array of data from the sheet
  rowTag: {},     // Map of row tags to 0-based row indices
  colTag: {},     // Map of column tags to 0-based column indices
  format: {},     // Object containing formatting arrays (bg, fonts, borders, merges, etc.)
  notes: [],
  grid2D: [],
  // 2D array holding references to the created cell DOM elements

  // === State Management ===
  pendingChangesMap: {}, // Holds { 'r,c': newValue } during ability roll cost verification steps
  cellClickInfo: { r: null, c: null, text: null, focusText: null }, // Info about the last clicked cell
  monsterRollResultsHistory: {}, // Stores { rollId: { results: [...], originalAbilityRow: r, allTargetedRows_R: [...] } }
  currentSkRadioChecked: { r: null, c: null }, // Tracks coords of the single checked Sk1/Sk2 box
  buttonOrMenu: { // Tracks the source of the current button or
    // menu action
    isNish: false, // Nish button pressed
    isRoll: false, // Standard Roll button pressed
    isFree: false, // Free button pressed
    isLuck: false // Luck button pressed
  },
  hiddenColumns: new Set(), // Stores indices of currently hidden columns
  hiddenRows: new Set(),    // Stores indices of currently hidden rows
  plainTextLogEntries: [],  // Array to store plain text log entries for GMScreen update
  isSendingLog: false,      // Flag/Lock to prevent concurrent log sends
  isDesignerMode: false,    // Flag for designer mode access >>>

  //
  // === Character RaceClass Info ===
  characterInfo: {
    slotNum: '',
    raceClass: '',
    level: '',
    playerName: '',
    charName: ''
  },

  // === Roll Object State ===
  roll: {
    // --- Input values from Sheet (populated by fResetPopulateNCleanGUIRoll) ---
    sk1CB: false,          // Flag: True if roll originated from Sk1 CheckBox column, false if Sk2
    ability_R: '',
    // 0-based row index of the ability/gear being rolled
    skMorph: '',           // Raw morph string from sheet ('Morph1' or 'Morph2' col)
    skTyp: '',             // Base skill type string ('Sk', 'Atr', 'Atk', etc.) from sheet ('Sk1Typ' or 'Sk2Typ' col)
    skSk: '',              // Base skill value (numeric >= 1 or '') from sheet ('Sk1' or 'Sk2' col)

    skIsOn: '',            // Raw 'Is On' status from sheet
    skNameID: '',          // Raw ability/gear name from sheet, may include ID ('Ability' col)
    skName: '',
    skAct: '',             // Action Point cost
    skDur: '',             // Raw duration value from sheet

    skMeta: '',            // Raw Meta cost value from sheet
    skUses: '',            // Remaining uses (numeric >= 0 or '') from sheet

    // --- Result values calculated after processing morphs (fProcessMorph, fApplyMorphResults) ---
    resTyp: '',            // Resulting roll type after morphs (defaults to skTyp)
    resSk: '',
    // Resulting skill value after skill morphs (base for roll calculation)
    resFlatBase: '',       // Skill override value from '=' morph
    resFlatResult: '',     // Final roll result override from '==' morph
    resDif: '',            // Difficulty value from '^' morph
    resFocus: '',          // Raw Focus Meta color tag ('R'...'B')
    resPlus: '',
    // Sum of '+/-[num]' morphs (additive modifier to resSk)
    resPlusPlus: '',       // Sum of '++/--[num]' morphs (additive modifier to final roll)
    resdctMult: '',
    resMult: '',           // Cumulative multiplier from '* / /[num]' morphs (applies to resSk)
    resMultMult: '',       // Cumulative multiplier from '** // //[num]' morphs (applies to final roll)
    resCombine: '',
    // Combined skill value calculated from numeric morphs + skSk

    // --- Dice roll results (calculated by fCalcGUIRollRoll, fCalcGUIRollResRoll) ---
    roll: '',              // Raw dice roll result based on resSk and resTyp
    resRoll: '',           // Final roll result after applying roll morphs or override

    // --- Flags & Multi-Roll ---
    isUnSk: false,
    // Flag: true if 'un' or 'unsk' morph was present
    isFreeRoll: false,     // Flag: true if 'free' morph or Free button used
    isLuckedRoll: false,   // Flag: true if 'luck' morph or Luck button used
    multiRollCount: 1,     // Number of times to roll (defaults to 1)

    // --- Output Formatting ---
    htmlHeader: ''         // Stores the header HTML string for the roll log entry
  },

  //
  // === Configuration & Definitions ===
  manualBorderSections: [ // Defines sections for applying manual borders post-render
    // Each object: { r1, c1, r2, c2 (tags/indices), edges ('t'op, 'b'ottom, 'l'eft, 'r'ight), style? (CSS string) }
    { r1: 'Nish', c1: 'ULNish', r2: 'Nish', c2: 'Nish', edges: 'br' },
    { r1: 'MR', c1: 'ULMR', r2: 'MR', c2: 'MR', edges: 'br' },
    { r1: 'meta', c1: 'ULMeta', r2: 'chnl', c2: 'B', edges: 'r' },
    { r1: 'LuckBox', c1: 'ULLuckBox', r2: 'LuckPlus', c2: 'LuckBox', edges: 'r' },
    { r1: 'Act', c1: 'ULAct', r2: 'ActPlus', c2: 'ActTot', edges: 'r' },
    { r1: 'Health', c1: 'vitPlus', r2: 'VitTbl', c2: 'VitNowPercent', edges: 'br' },
    { r1: 'VerUL', c1:
      'Ver', r2: 'FrozenHeader', c2: 'Ver', edges: 'r' },
    { r1: 'FrozenHeader', c1: 'PermMorph1', r2: 'AbilTblEnd_R', c2: 'Regain', edges: 'br' },
    { r1: 'FrozenHeader', c1: 'PossNum', r2: 'AbilTblEnd_R', c2: 'PossAPTot', edges: 'br' },
    { r1: 'ULMonsterTbl', c1: 'NumMon', r2: 'LastMon_R', c2: 'MonSize', edges: 'br' },
    { r1: 'AstralGauntHeader_R', c1: 'AstralGauntletSlot', r2: 'AstralGauntHeader_R', c2: 'AstralGauntletHeaderEndC', edges: 'r' },
    { r1: 'Chaos2ndHeader', c1: 'AstralGauntletSlot', r2: 'ChaosWrist', c2: 'LastC', edges: 'br' },
    { r1: 'SocketedGearHeader', c1: 'SocketedGearSlot', r2: 'SocketTblEnd', c2: 'LastC', edges: 'br' },

    { r1: 'GearTblHeaderStartR', c1: 'PermMorph1', r2: 'GearTblEnd_R', c2: 'Regain', edges: 'br' },
    { r1: 'GearTblHeaderStartR', c1: 'PossNum', r2: 'GearTblEnd_R', c2: 'PossAPTot', edges: 'br' },
    { r1: 'GearSpe', c1: 'SpeedHeader', r2: 'GearStr', c2: 'GearPlusMR', edges: 'br' },
    { r1: 'GearMRTbl', c1: 'MRHeader', r2: 'GearMRTbl', c2: 'MRHeaderEndC', edges: 'b' },
    { r1: 'GearCarryTbl', c1: 'MRHeader', r2: 'GearCarryTbl', c2: 'MRHeaderEndC', edges: 'b' },
    { r1: 'GearMRTbl', c1: 'GearMRCol1', r2: 'GearCarryTbl', c2: 'LastC', edges: 'br' },
    { r1: 'PossAPTot', c1: 'CurrentEncHeader', r2: 'PossAPTot', c2: 'PossEncTotEndC',
    edges: 'br' },
    { r1: 'PossEncTot', c1: 'GearAPTotHeader', r2: 'PossEncTot', c2: 'LastC', edges: 'br' }
    // Add { style: '1px solid #888' } to specific objects if dark grey is desired
  ],
  initialHiddenCols: [ // Defines columns initially hidden on load
    { c1: 'Key', c2: 'PermMorph1' },
    { c1: 'PermMorph2', c2: 'PermMorph2' }
    // { c1: 0, c2: 0 }, // Example: Single column using index
  ],
  gearTblCols: [ // Defines columns belonging to the Gear section (for toggling)

    { c1: 'PossNum', c2: 'GearTblEndC' },
  ],
  initialHiddenRows: [ // Defines rows initially hidden on load
    { r1: 'Agi', r2: 'Arc' }
    // { r1: 0, r2: 1 } // Example: Range using indices
  ],
  dropDownBox: [ // Defines ranges for dropdown cells and their choices
    { // Is On column
      choices: ['','Y','N',1,2,3,4,5,6,7,8,9,10,'P','I','~','E','*'],
      ranges: [ { r1: 'AbilTblStart_R', c1: 'On', r2: 'AbilTblEnd_R', c2: 'On' } ]
    },
    { // Monster
      // # column
      choices: ['',1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30],
      ranges: [ { r1: 'CustMon', c1: 'NumMon', r2: 'LastMon_R', c2: 'NumMon' } ]
    }
  ],
  fontColorRange: [ // Defines ranges for applying specific font colors post-render
    { color: '#FF0000', // Red
      ranges: [ { r1: 'FrozenHeader', c1: 'R', r2: 'FrozenHeader', c2: 'R' },
                { r1: 'ULMonsterTbl', c1: 'MonAtk', r2: 'LastMon_R', c2: 'MonDmg' } ]
    },

    { color: '#FFA500', // Orange
      ranges: [ { r1: 'FrozenHeader', c1: 'O', r2: 'FrozenHeader', c2: 'O' } ]
    },
    { color: '#fcba03', // Gold
      ranges: [ { r1: 'FrozenHeader', c1: 'Y', r2: 'FrozenHeader', c2: 'Y' } ]
    },
    { color: '#008000', // Green
      ranges: [ { r1: 'FrozenHeader', c1: 'G', r2: 'FrozenHeader', c2: 'G' } ]
    },
    { color: '#0000FF', // Blue

      ranges: [ { r1: 'FrozenHeader', c1: 'B', r2: 'FrozenHeader', c2: 'B' } ]
    }
  ],
  range: { // Named ranges for easy access to specific cells/areas
    entireAbiliyNGearTables: [
      { r1: 'AbilTblStart_R', c1: 'PermMorph1', r2: 'AbilTblEnd_R', c2: 'Regain' },
      { r1: 'GearTblStart_R', c1: 'PermMorph1', r2: 'GearTblEnd_R', c2: 'Regain' }
    ],
    morphs: [
      { r1: 'AbilTblStart_R', c1: 'Morph1', r2: 'AbilTblEnd_R', c2: 'Morph1' },
      { r1:
      'GearTblStart_R', c1: 'Morph1', r2: 'GearTblEnd_R', c2: 'Morph1' },
      { r1: 'AbilTblStart_R', c1: 'Morph2', r2: 'AbilTblEnd_R', c2: 'Morph2' },
      { r1: 'GearTblStart_R', c1: 'Morph2', r2: 'GearTblEnd_R', c2: 'Morph2' }
    ],
    isONDur: [
      { r1: 'NishAtr_R', c1: 'On', r2: 'AbilTblEnd_R', c2: 'On' },
      { r1: 'GearTblStart_R', c1: 'On', r2: 'GearTblEnd_R', c2: 'On' }
    ],
    sk1sk2CheckBoxes: [ // Defines the Sk1/Sk2 checkbox columns (treated as radio buttons)

      { r1: 'NishAtr_R', c1: 'Sk1ChkBox', r2: 'AbilTblEnd_R', c2: 'Sk1ChkBox'},
      { r1: 'NishAtr_R', c1: 'Sk2ChkBox', r2: 'AbilTblEnd_R', c2: 'Sk2ChkBox'},
      { r1: 'GearTblStart_R', c1: 'Sk1ChkBox', r2: 'GearTblEnd_R', c2: 'Sk1ChkBox'},
      { r1: 'GearTblStart_R', c1: 'Sk2ChkBox', r2: 'GearTblEnd_R', c2: 'Sk2ChkBox'}
    ],
    monsters: { r1: 'CustMon', c1: 'NumMon', r2: 'LastMon_R', c2: 'MonSize' },
    currentNish: { r1: 'Nish', c1: 'Nish', r2: 'Nish', c2: 'Nish' },
    meta: { r1: 'meta', c1: 'R', r2: 'meta', c2: 'B' },

    metaChannel: { r1: 'chnl', c1: 'R', r2: 'chnl', c2: 'B' },
    luckBox: { r1: 'LuckBox', c1: 'LuckBox', r2: 'LuckBox', c2: 'LuckBox' },
    luckBoxPlus: { r1: 'LuckPlus', c1: 'LuckBox', r2: 'LuckPlus', c2: 'LuckBox' },
    actTotal: { r1: 'Act', c1: 'ActTot', r2: 'Act', c2: 'ActTot' },
    actPlus: { r1: 'ActPlus', c1: 'ActTot', r2: 'ActPlus', c2: 'ActTot' },
    fortitudeSk1: { r1: 'For', c1: 'Sk1', r2: 'For', c2: 'Sk1' },
    vitMax: { r1: 'VitTbl', c1: 'vitMax', r2: 'VitTbl', c2: 'vitMax' },
    vitMaxPlus:
    { r1: 'VitTbl', c1: 'vitPlus', r2: 'VitTbl', c2: 'vitPlus' },
    vit1stWnds: { r1: 'VitTbl', c1: 'vit1st', r2: 'VitTbl', c2: 'vit1st' },
    vit2ndWnds: { r1: 'VitTbl', c1: 'vit2nd', r2: 'VitTbl', c2: 'vit2nd' },
    vit3rdWnds: { r1: 'VitTbl', c1: 'vit3rd', r2: 'VitTbl', c2: 'vit3rd' },
    vitNow: { r1: 'VitTbl', c1: 'vitNow', r2: 'VitTbl', c2: 'vitNow' },
    vitNowPercent: { r1: 'VitTbl', c1: 'VitNowPercent', r2: 'VitTbl', c2: 'VitNowPercent' },
    chaosGems: { r1: 'Chaos1', c1: 'ChaosUses', r2: 'ChaosWrist', c2: 'ChaosAbility' },
    socketedGear: { r1:
    'SocketTblStart', c1: 'SocketedGear', r2: 'SocketTblEnd', c2: 'SocketedGems' },
    currentEnc: { r1: 'PossEncTot', c1: 'PossEncTot', r2: 'PossEncTot', c2: 'PossEncTot' },
    gearAPTotal: { r1: 'PossAPTot', c1: 'PossGrandAPTot', r2: 'PossAPTot', c2: 'PossGrandAPTot' }
  },
  rangeDB: {
    monstersDB: { r1: 'MonTblFirst_R', c1: 'ActiveMonTF', r2: 'MonTblLast_R', c2: 'Notes' }
  },
  list: { // Static lists and values
    skTyp: ['Atr','Sk','Atk','DMG','Def','AR','Str'], // Note free, luck, un, unSk are not skill Types and dealth with elsewhere
    metaColor: ['R','O','Y','G','B'],
    metaFull: [5,4,3,2,1], // Maximums for each meta color

    luckBoxMax: 5,
    actMax: 5,
  },

  // === UI Element References ===
  tooltipElement: null,      // Reference to the #cell-tooltip div
  modalElement: null,        // Reference to #image-modal container
  modalImageElement: null,   // Reference to #modal-image img tag
  modalCloseBtn: null,       // Reference to #modal-close-btn span
  modalBackdrop: null,       // Reference to #modal-backdrop div
  messageModalOverlay: null, // Reference to #messageModal div
  messageModalText: null,
  // Reference to #messageText p tag
  messageModalCloseButton: null, // Reference to #closeMessageModal button
  promptModalOverlay: null,    // Reference to #promptModal div
  promptModalText: null,       // Reference to #promptText p tag
  promptYesButton: null,       // Reference to #promptYesButton button
  promptNoButton: null,        // Reference to #promptNoButton button

  // === Async/Timing State ===
  startTime: 0,              // Timestamp for tracking load/render time
  lastLogTime:
  0,            // Timestamp for tracking delta time between logs
  tooltipTimeoutId: null,    // Stores the timeout ID for the hover delay
  messagePromiseResolve: null, // Function to resolve the message promise
  promptPromiseResolve: null,  // Function to resolve the prompt promise
  promptPromiseReject: null,   // Function to reject the prompt promise

  // === Constants & Settings ===
  HOVER_DELAY_MS: 300,       // Delay before showing tooltip (milliseconds)
  TOOLTIP_OFFSET_Y: 15,      // Tooltip
  // vertical offset from cursor (px)
  TOOLTIP_OFFSET_X: 10,      // Tooltip horizontal offset from cursor (px)
  ROW_HEIGHT_PX: 20,         // Matches grid-auto-rows in style.html, used for sticky offset calculation
  isDebugMode: true,         // Turns console logging on (true) or off (false)
  GMSCREEN_LOG_MAX_CHARS: 40000 // Max characters for GMScreen log cell
};



// ==========================================================================
// === Low-Level Utilities              (End of Global Variables) ===
// ==========================================================================




// fMyConsoleLog ///////////////////////////////////////////////////////////////////
// Purpose -> Logs messages to the console with timestamps, only if gUI.isDebugMode is true.
// Inputs  -> msg (String): The message to log.
// Outputs -> None (Logs to console).
function fMyConsoleLog(msg) {
    if (!gUI.isDebugMode) return; // Exit early if debug mode is off

    // Calculate timestamps
    const now = performance.now();
    const delta = ((now - gUI.lastLogTime) / 1000).toFixed(2);
    const total = ((now - gUI.startTime) / 1000).toFixed(2);
    gUI.lastLogTime = now;

    // Log the formatted message
    console.log(`Status Log: [${total}s] ${msg} (+${delta}s)`);
} // END fMyConsoleLog




// resolveRow ////////////////////////////////////////////////////////////////////
// Purpose -> Converts a string tag (from gUI.rowTag) or numeric index to a 0-based row index.
// Inputs  -> v (String | Number): Row tag string or 0-based numeric index.
// Outputs -> (Number): The 0-based row index, or NaN if resolution fails.
const resolveRow = v => {
    if (typeof v === 'string') return gUI.rowTag[v]; // Lookup tag
    if (typeof v === 'number' && v >= 0) return v;   // Assume valid index

    console.warn(`resolveRow failed for value:`, v); // Log warning if invalid
    return NaN; // Return NaN for errors
}; // END resolveRow




// resolveCol ////////////////////////////////////////////////////////////////////
// Purpose -> Converts a string tag (from gUI.colTag) or numeric index to a 0-based col index.
// Inputs  -> v (String | Number): Column tag string or 0-based numeric index.
// Outputs -> (Number): The 0-based column index, or NaN if resolution fails.
const resolveCol = v => {
     if (typeof v === 'string') return gUI.colTag[v]; // Lookup tag
     if (typeof v === 'number' && v >= 0) return v;   // Assume valid index

     console.warn(`resolveCol failed for value:`, v); // Log warning if invalid
     return NaN; // Return NaN for errors
}; // END resolveCol




// fGetContrastColor ///////////////////////////////////////////////////////////////
// Purpose -> Determines if black ('#000000') or white ('#ffffff') text has better
//            contrast against a given background hex color.
// Inputs  -> hexColor (String): The background color (e.g., '#FF0000', '03F').
// Outputs -> (String): '#000000' or '#ffffff' for the best contrast.
function fGetContrastColor(hexColor) {
    const defaultColor = '#000000'; // Default to black text

    // Basic validation
    if (!hexColor || typeof hexColor !== 'string') return defaultColor;

    try {
        // Remove # if present
        let hex = hexColor.startsWith('#') ? hexColor.substring(1) : hexColor;

        // Expand shorthand hex (e.g., "03F" -> "0033FF")
        if (hex.length === 3) {
            hex = hex.split('').map(char => char + char).join('');
        } else if (hex.length !== 6) {
            return defaultColor; // Invalid hex length
        }

        // Convert hex to RGB
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);

        if (isNaN(r) || isNaN(g) || isNaN(b)) return defaultColor; // Invalid hex characters

        // Calculate luminance using the YIQ formula
        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

        // Return black text for light backgrounds (luminance > 0.5), white text for dark backgrounds
        return luminance > 0.5 ? '#000000' : '#ffffff';

    } catch (e) {
        console.error("Error calculating contrast color for:", hexColor, e);
        return defaultColor; // Fallback on error
    }
} // END fGetContrastColor




// fIndicesToA1 ////////////////////////////////////////////////////////////////////
// Purpose -> Converts 0-based row/column indices to standard A1 notation string.
// Inputs  -> r1, c1, r2, c2 (Number): 0-based start/end row and column indices.
// Outputs -> (String | null): A1 notation string (e.g., "C5:F10"), or null on invalid input.
function fIndicesToA1(r1, c1, r2, c2) {
    // Validate inputs are non-negative numbers
    if ([r1, c1, r2, c2].some(idx => typeof idx !== 'number' || idx < 0 || isNaN(idx))) {
        console.error(`fIndicesToA1: Invalid indices provided (${r1},${c1},${r2},${c2})`);
        return null; // Return null for invalid indices
    }

    // Convert column indices to A1 letters
    const startColA1 = fColToA1(c1);
    const endColA1 = fColToA1(c2);

    // Add 1 to row indices for 1-based A1 notation
    const startRowA1 = r1 + 1;
    const endRowA1 = r2 + 1;

    // Format: Top-left cell : Bottom-right cell
    return `${startColA1}${startRowA1}:${endColA1}${endRowA1}`;

} // END fIndicesToA1




// fColToA1 ////////////////////////////////////////////////////////////////////
// Purpose -> Converts a 0-based column index to A1 notation (e.g., 0->A, 26->AA).
// Inputs  -> col (Number): The 0-based column index.
// Outputs -> (String): The A1 notation label.
function fColToA1(col) {
    let label = '';
    let c = col;

    // Build the label character by character
    while (c >= 0) {
        label = String.fromCharCode((c % 26) + 65) + label;
        c = Math.floor(c / 26) - 1;
    }

    return label;
} // END fColToA1




// getBorderStyleCSS ///////////////////////////////////////////////////////////////
// Purpose -> Generates a CSS border string (e.g., "1px solid #000000") from Google
//            Sheet border style data.
// Inputs  -> borderSideData (Object): { style: String, color?: String }
// Outputs -> (String | null): CSS border string or null if no style provided.
function getBorderStyleCSS(borderSideData) {
    if (!borderSideData || !borderSideData.style) return null; // No explicit border style

    const styleStr = borderSideData.style;
    const color = borderSideData.color || '#000000'; // Default to black if color missing
    let cssStyle = 'solid', cssWidth = '1px'; // Default CSS values

    // Map Google Sheet BorderStyle enum strings to CSS border properties
    switch (styleStr) {
        case 'DOTTED':       cssStyle = 'dotted';                  break;
        case 'DASHED':       cssStyle = 'dashed';                  break;
        case 'SOLID':        cssStyle = 'solid';                   break; // Default, but explicit
        case 'SOLID_MEDIUM': cssStyle = 'solid'; cssWidth = '2px'; break;
        case 'SOLID_THICK':  cssStyle = 'solid'; cssWidth = '3px'; break;
        case 'DOUBLE':       cssStyle = 'double'; cssWidth = '3px'; break;
        // default: 'solid', '1px' already set
    }

    return `${cssWidth} ${cssStyle} ${color}`;
} // END getBorderStyleCSS




// fIsCellInRangeArray /////////////////////////////////////////////////////////////
// Purpose -> Checks if given coordinates (r, c) fall within ANY of the range objects
//            defined in the provided rangeArray.
// Inputs  -> r (Number): 0-based row index.
//         -> c (Number): 0-based column index.
//         -> rangeArray (Array<Object> | Object): An array of range definition objects,
//                                                 or a single range object.
// Outputs -> (Boolean): True if (r, c) is inside any valid range, false otherwise.
function fIsCellInRangeArray(r, c, rangeArray) {
    // Validate input coordinates
    if (typeof r !== 'number' || typeof c !== 'number' || isNaN(r) || isNaN(c)) {
        console.warn("fIsCellInRangeArray: Invalid input coordinates provided.");
        return false;
    }

    // Handle if rangeArray is a single range object OR an array
    const rangesToCheck = Array.isArray(rangeArray) ? rangeArray : [rangeArray];

    // Check if there are any ranges to process
    if (rangesToCheck.length === 0 || !rangesToCheck[0]) {
        return false;
    }

    // Iterate through each range definition
    for (const rangeDef of rangesToCheck) {
        // Validate the range definition object structure
        if (!fIsValidRangeObject(rangeDef)) {
             console.warn("fIsCellInRangeArray: Skipping invalid range definition object:", rangeDef);
             continue;
        }

        // Resolve tags/indices for the current range
        const resolved = fResolveRangeIndices(rangeDef);
        if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
             console.warn("fIsCellInRangeArray: Skipping range due to unresolved indices:", rangeDef);
             continue;
        }

        // Determine min/max row and column for the current range
        const rMin = Math.min(resolved.r1, resolved.r2);
        const rMax = Math.max(resolved.r1, resolved.r2);
        const cMin = Math.min(resolved.c1, resolved.c2);
        const cMax = Math.max(resolved.c1, resolved.c2);

        // Check if the input (r, c) falls within this resolved range
        if (r >= rMin && r <= rMax && c >= cMin && c <= cMax) {
            return true; // Found a match
        }
    }

    // No range contained the cell after checking all of them
    return false;
} // END fIsCellInRangeArray



// ==========================================================================
// === Core Cell Creation Helpers       (End of Low-Level Utilities) ===
// ==========================================================================




// fIsSkRadioGroupMember ////////////////////////////////////////////////////////////
// Purpose -> Checks if a cell (r, c) is part of the Sk1/Sk2 checkbox 'radio group'.
// Inputs  -> r (Number): 0-based row index.
//         -> c (Number): 0-based column index.
// Outputs -> (Boolean): True if the cell is within any range defined in
//                       gUI.range.sk1sk2CheckBoxes, false otherwise.
function fIsSkRadioGroupMember(r, c) {
    const ranges = gUI.range.sk1sk2CheckBoxes;

    // Validate the range definition array
    if (!Array.isArray(ranges)) {
        console.warn("fIsSkRadioGroupMember: gUI.range.sk1sk2CheckBoxes is not a valid array.");
        return false;
    }

    // Validate input coordinates
    if (typeof r !== 'number' || typeof c !== 'number' || isNaN(r) || isNaN(c)) {
         console.warn(`fIsSkRadioGroupMember: Invalid input coordinates (${r}, ${c})`);
         return false;
    }

    // Loop through each defined range for the Sk1/Sk2 checkboxes
    for (const range of ranges) {
        // Validate the range object structure
        if (!fIsValidRangeObject(range)) { // Use existing helper function
             console.warn("fIsSkRadioGroupMember: Skipping invalid range object", range);
             continue;
        }

        // Resolve the tags/indices for the current range
        const resolved = fResolveRangeIndices(range); // Use existing helper function
        if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
             console.warn("fIsSkRadioGroupMember: Skipping range due to unresolved indices", range);
             continue;
        }

        // Determine min/max row and column
        const rMin = Math.min(resolved.r1, resolved.r2);
        const rMax = Math.max(resolved.r1, resolved.r2);
        const cMin = Math.min(resolved.c1, resolved.c2);
        const cMax = Math.max(resolved.c1, resolved.c2);

        // Check if the input r, c falls within this range
        if (r >= rMin && r <= rMax && c >= cMin && c <= cMax) {
            return true; // Found a match
        }
    }

    // No range matched after checking all of them
    return false;
} // END fIsSkRadioGroupMember



// fMakeCheckBox ///////////////////////////////////////////////////////////////////
// Purpose -> Returns a checkbox input element reflecting boolean value in gUI.arr[r][c].
//            Disables checkbox if background color is not white/default.
//            Adds 'data-sk-group' attribute if part of the Sk1/Sk2 radio group.
// Inputs  -> r (Number): 0-based row index.
//         -> c (Number): 0-based column index.
// Outputs -> (HTMLInputElement): The configured checkbox element.
function fMakeCheckBox(r, c) {
    const value = gUI.arr[r]?.[c];
    const checkbox = document.createElement("input");

    // Set basic properties and data attributes
    checkbox.type = "checkbox";
    checkbox.dataset.r = r;
    checkbox.dataset.c = c;

    // Check background color to set disabled state
    const bgColor = gUI.format?.bg?.[r]?.[c];
    const isNonWhite = bgColor && bgColor.toLowerCase() !== '#ffffff' && bgColor.toLowerCase() !== '#fff';
    checkbox.disabled = isNonWhite;

    // Set checked state based on boolean or string "TRUE" (case-insensitive)
    const valStr = String(value).toUpperCase();
    checkbox.checked = value === true || valStr === "TRUE";

    // Add data attribute if this checkbox is part of the Sk radio group
    if (fIsSkRadioGroupMember(r, c)) {
        checkbox.dataset.skGroup = 'true';
    }

    return checkbox;
} // END fMakeCheckBox




// ==========================================================================
// === Core Rendering & Grid Tag Setup  (End of Core Cell Creation Helpers) ===
// ==========================================================================


////////////////////////////////////////////////////////////////////////////////////////////////////////// START fCreateAndFormatCell and helpers




// fCreateAndFormatCell //////////////////////////////////////////////////////////////
// Purpose -> Creates and formats a single grid cell div element. Handles content
//            (text, checkbox, dropdown), URL/image/note tags, editability, and styling.
// Inputs  -> r (Number): 0-based row index.
//         -> c (Number): 0-based column index.
//         -> value (Any): The raw value for the cell from gUI.arr.
//         -> rowFormat (Object): Formatting object for this specific row.
// Outputs -> (HTMLElement): The configured cell div element.
function fCreateAndFormatCell(r, c, value, rowFormat) {
    // === Initialization ===
    const cell = document.createElement("div");
    cell.className = "cell";

    const originalValue = value ?? "";
    const valStr = String(originalValue).toUpperCase();
    const isCheckbox = value === true || value === false || valStr === "TRUE" || valStr === "FALSE";

    // === Set Base Attributes & Check Editability/Note ===
    const bgColor = rowFormat.bg?.[c];
    const isEditable = fCheckIfEditable(bgColor, isCheckbox);
    fSetCellAttributes(cell, r, c, isEditable);
    fCheckAndTagNote(cell, r, c);

    // === Determine Content Type (Dropdown or Standard) ===
    const dropConfig = fFindDropdownMatch(r, c);
    if (dropConfig) {
        // Create and append dropdown
        const select = fMakeDropdown(r, c, dropConfig, value);
        cell.appendChild(select);
    } else {
        // Handle standard content (URL/Image/Checkbox/Text)
        const { displayValue, isUrl } = fCheckAndTagUrl(cell, originalValue);
        fPopulateCellContent(cell, r, c, displayValue, isCheckbox);
    }

    // === Apply Final Formatting ===
    fApplyCellFormatting(cell, c, bgColor, rowFormat);

    return cell;
} // END fCreateAndFormatCell




// fFindDropdownMatch //////////////////////////////////////////////////////////////
// Purpose -> Checks if coordinates (r,c) fall within any dropdown range defined in
//            gUI.dropDownBox and returns the matching configuration object.
// Inputs  -> r (Number): 0-based row index.
//         -> c (Number): 0-based column index.
// Outputs -> (Object | null): The dropdown config object if found, otherwise null.
function fFindDropdownMatch(r, c) {
    // Iterate through each dropdown configuration
    for (const config of gUI.dropDownBox) {
        // Iterate through the ranges defined for this configuration
        for (const range of config.ranges) {
            // Resolve range tags/indices
            const r1 = resolveRow(range.r1), r2 = resolveRow(range.r2);
            const c1 = resolveCol(range.c1), c2 = resolveCol(range.c2);

            // Check if resolved indices are valid and if (r, c) is within the range
            if (
                !isNaN(r1) && !isNaN(r2) && !isNaN(c1) && !isNaN(c2) &&
                r >= Math.min(r1, r2) && r <= Math.max(r1, r2) &&
                c >= Math.min(c1, c2) && c <= Math.max(c1, c2)
            ) {
                return config; // Found a match, return the config
            }
        }
    }

    // No match found after checking all configurations
    return null;
} // END fFindDropdownMatch




// fMakeDropdown ///////////////////////////////////////////////////////////////////
// Purpose -> Builds a <select> element populated with choices for a grid dropdown.
// Inputs  -> r (Number): 0-based row index for data attributes.
//         -> c (Number): 0-based column index for data attributes.
//         -> config (Object): Dropdown configuration object from gUI.dropDownBox.
//         -> currentVal (Any): The current value in gUI.arr[r][c] to pre-select.
// Outputs -> (HTMLSelectElement): The configured <select> element.
function fMakeDropdown(r, c, config, currentVal) {
    const select = document.createElement("select");
    select.dataset.r = r;
    select.dataset.c = c;

    // Populate options
    for (const choice of config.choices) {
        const option = document.createElement("option");
        option.value = String(choice);
        option.textContent = String(choice);
        // Select the current value
        if (String(choice) === String(currentVal)) {
            option.selected = true;
        }
        select.appendChild(option);
    }

    // Add styling class
    select.classList.add("dropdown-cell");

    return select;
} // END fMakeDropdown





// fCheckIfEditable //////////////////////////////////////////////////////////////
// Purpose -> Determines if a cell should be contentEditable based on background
//            color (must be white/default) and type (must not be a checkbox).
// Inputs  -> bgColor (String | null): Background color hex string or null.
//         -> isCheckbox (Boolean): True if the cell contains a checkbox.
// Outputs -> (Boolean): True if the cell should be editable, false otherwise.
function fCheckIfEditable(bgColor, isCheckbox) {
    const isWhiteBg = (!bgColor || bgColor.toLowerCase() === '#ffffff' || bgColor === 'white');

    return isWhiteBg && !isCheckbox;
} // END fCheckIfEditable


// fSetCellAttributes //////////////////////////////////////////////////////////////
// Purpose -> Sets the data-r and data-c attributes on a cell element. Also sets
//            contentEditable and related styles if the cell is designated as editable.
// Inputs  -> cell (HTMLElement): The cell div element.
//         -> r (Number): 0-based row index.
//         -> c (Number): 0-based column index.
//         -> isEditable (Boolean): True if the cell should be contentEditable.
// Outputs -> None (Modifies the input cell element).
function fSetCellAttributes(cell, r, c, isEditable) {
    cell.dataset.r = r;
    cell.dataset.c = c;

    if (isEditable) {
        cell.contentEditable = true;
        cell.style.justifyContent = 'flex-start'; // Align text left for editing
        cell.style.textAlign = 'left';
    }
} // END fSetCellAttributes




// fCheckAndTagNote ////////////////////////////////////////////////////////////////
// Purpose -> Adds the 'has-note' CSS class to a cell element if a corresponding
//            note exists in gUI.notes.
// Inputs  -> cell (HTMLElement): The cell div element.
//         -> r (Number): 0-based row index.
//         -> c (Number): 0-based column index.
// Outputs -> None (Modifies the input cell element's classList).
function fCheckAndTagNote(cell, r, c) {
    const noteText = gUI.notes?.[r]?.[c]?.trim();

    // Add class only if there's trimmed note text
    if (noteText) {
        cell.classList.add('has-note');
    }
} // END fCheckAndTagNote



// fCheckAndTagUrl /////////////////////////////////////////////////////////////////
// Purpose -> Checks if a cell's value is a URL. If so, adds 'url-link' class and
//            data-url attribute. Further checks for Drive image links or standard
//            image extensions, adding 'image-link' class and data-image-src if found.
// Inputs  -> cell (HTMLElement): The cell div element.
//         -> value (Any): The raw value for the cell from gUI.arr.
// Outputs -> (Object): { displayValue: Any, isUrl: Boolean }
function fCheckAndTagUrl(cell, value) {
    const trimmed = typeof value === 'string' ? value.trim() : '';
    const isUrl = trimmed.startsWith('http://') || trimmed.startsWith('https://');
    let displayValue = value; // Return original value by default

    if (!isUrl) {
        return { displayValue, isUrl }; // Not a URL, exit early
    }

    // It is a URL, add base class and data attribute
    cell.classList.add('url-link');
    cell.dataset.url = trimmed;

    // Check for specific URL types (Drive image or standard image extension)
    const driveMatch = trimmed.match(/drive\.google\.com\/file\/d\/([-\w]+)/);
    const imgExts = /\.(png|jpg|jpeg|gif|webp|svg)$/i;

    if (driveMatch && driveMatch[1]) {
        // Handle Google Drive image link
        const fileId = driveMatch[1];
        const imageUrl = 'https://drive.google.com/uc?export=view&id=' + fileId;
        cell.classList.add('image-link');
        cell.dataset.imageSrc = imageUrl;
    } else if (imgExts.test(trimmed)) {
        // Handle standard image link (by extension)
        cell.classList.add('image-link');
        cell.dataset.imageSrc = trimmed;
    }

    return { displayValue, isUrl };
} // END fCheckAndTagUrl



// fPopulateCellContent ////////////////////////////////////////////////////////////
// Purpose -> Populates a cell element with either a checkbox (using fMakeCheckBox)
//            or text content. Strips trailing ID patterns from text content.
// Inputs  -> cell (HTMLElement): The cell div element.
//         -> r (Number): 0-based row index (passed to fMakeCheckBox).
//         -> c (Number): 0-based column index (passed to fMakeCheckBox).
//         -> displayValue (Any): The value to display (used for text content).
//         -> isCheckbox (Boolean): True if the cell should contain a checkbox.
// Outputs -> None (Modifies the input cell element's content).
function fPopulateCellContent(cell, r, c, displayValue, isCheckbox) {
    if (isCheckbox) {
        // Append a checkbox if required
        cell.appendChild(fMakeCheckBox(r, c));
    } else {
        // Otherwise, set text content, stripping any trailing ID
        const idPattern = /\s{2,}_\w{6}$/; // Matches '  _XXXXXX' at end of string
        const text = (typeof displayValue === 'string' && idPattern.test(displayValue))
            ? displayValue.replace(idPattern, '') // Strip ID if found
            : displayValue; // Use original value otherwise
        cell.textContent = text;
    }
} // END fPopulateCellContent





// fApplyCellFormatting ////////////////////////////////////////////////////////////
// Purpose -> Applies styles (background, font weight/size/style/family, wrap)
//            to a cell element based on the provided row formatting data.
// Inputs  -> cell (HTMLElement): The cell div element to style.
//         -> c (Number): 0-based column index to lookup format specific to the column.
//         -> bgColor (String | null): Background color hex string.
//         -> rowFormat (Object): Object containing formatting arrays for the row
//                                (e.g., weight, fontSize, fontStyle, fontFamily, wrap).
//         -> isUrl (Boolean): (Currently unused) Indicates if the cell contains a URL.
// Outputs -> None (Modifies the input cell element's style and classList).
function fApplyCellFormatting(cell, c, bgColor, rowFormat, isUrl) {
    // Apply background color if provided
    if (bgColor) {
        cell.style.backgroundColor = bgColor;
    }

    // Apply font color (placeholder logic, currently does nothing)
    const finalFontColor = null;
    cell.style.color = finalFontColor || ''; // Default to browser default if null/empty

    // Destructure font/wrap properties from rowFormat for the specific column `c`
    const { weight, fontSize, fontStyle, fontFamily, wrap } = rowFormat;

    // Apply specific font styles if they exist for this column
    if (weight?.[c]) cell.style.fontWeight = weight[c];
    if (fontSize?.[c]) cell.style.fontSize = `${fontSize[c]}px`;
    if (fontStyle?.[c]) cell.style.fontStyle = fontStyle[c];
    if (fontFamily?.[c]) cell.style.fontFamily = fontFamily[c];

    // Apply wrap class if wrapping is enabled for this column
    if (wrap?.[c]) {
        cell.classList.add('wrap');
    }
} // END fApplyCellFormatting




////////////////////////////////////////////////////////////////////////////////////////////////////////// END fCreateAndFormatCell and helpers



////////////////////////////////////////////////////////////////////////////////////////////////////////// START fRenderFullGrid and helpers




// fRenderFullGrid /////////////////////////////////////////////////////////////////
// Purpose -> Main controller function to render the entire grid dynamically.
//            Initializes grid, sets up columns/tags, then renders cells in chunks
//            using requestAnimationFrame for better performance. Calls a callback
//            function after rendering is complete for post-processing.
// Inputs  -> callback (Function): Function to execute after the grid is fully rendered.
// Outputs -> None (Modifies DOM, populates gUI.grid2D).
function fRenderFullGrid(callback) {
    fMyConsoleLog("⚙️ Rendering Full Grid...");

    // === Get DOM Elements and Data ===
    const grid = document.getElementById("grid");
    const gameArr = gUI.arr;
    const format = gUI.format || {};

    // === Initial Grid Setup & Validation ===
    if (!fInitGridAndSettings(grid, gameArr)) {
        return; // Stop if grid container or data is invalid
    }

    // === Grid Configuration ===
    const numRows = gameArr.length;
    const numCols = gameArr[0].length;
    fSetGridColumnWidths(grid, format, numCols); // Apply column widths from format object
    fSetGridTagsFromHeaders(); // Populate gUI.rowTag and gUI.colTag

    // Initialize the 2D array to hold cell DOM element references
    gUI.grid2D = Array.from({ length: numRows }, () => Array(numCols).fill(null));

    // === Chunked Rendering ===
    fMyConsoleLog(`🏎️ Rendering ${numRows} rows in chunks of 50...`);
    const renderChunk = fRenderChunkFactory(grid, gameArr, format, 50, callback);
    requestAnimationFrame(renderChunk); // Start the chunked rendering process

} // END fRenderFullGrid





// fInitGridAndSettings ////////////////////////////////////////////////////////////
// Purpose -> Validates the grid container element and data array (gUI.arr) exist
//            and are correctly formatted. Clears existing grid content if valid.
// Inputs  -> grid (HTMLElement): The grid container element (#grid).
//         -> gameArr (Array[][]): The 2D array of grid data (gUI.arr).
// Outputs -> (Boolean): True if grid and data are valid, false otherwise.
function fInitGridAndSettings(grid, gameArr) {
    // Validate grid container element
    if (!grid) {
        console.error("❌ Grid container #grid not found!");
        return false;
    }

    // Validate data array structure
    if (!Array.isArray(gameArr) || gameArr.length === 0 || !Array.isArray(gameArr[0])) {
        console.error("❌ gUI.arr is empty or malformed. Cannot render grid.");
        grid.innerHTML = '<p style="color:red;">Error: Invalid data array for rendering.</p>';
        return false;
    }

    // Clear old grid content if validation passed
    grid.innerHTML = "";

    return true;
} // END fInitGridAndSettings




// fSetGridColumnWidths ////////////////////////////////////////////////////////////
// Purpose -> Applies the 'grid-template-columns' CSS style to the grid container
//            based on the column widths provided in the format object.
// Inputs  -> grid (HTMLElement): The grid container element (#grid).
//         -> format (Object): The formatting object containing 'colWidths' array.
//         -> numCols (Number): The total number of columns in the grid.
// Outputs -> None (Modifies the grid element's style).
function fSetGridColumnWidths(grid, format, numCols) {
    const colWidths = format.colWidths || []; // Use provided widths or empty array

    // Create the CSS string (e.g., "60px 100px 80px...") using provided widths or a default of 60px
    const gridTemplateColumns = colWidths.map(w => `${w || 60}px`).join(' ');

    // Apply the style to the grid container
    grid.style.gridTemplateColumns = gridTemplateColumns;

    fMyConsoleLog(`📐 Applied ${numCols} column widths`);
} // END fSetGridColumnWidths



// fBuildRowFormat /////////////////////////////////////////////////////////////////
// Purpose -> Extracts and returns a formatting object specific to a single row index
//            from the main format object.
// Inputs  -> format (Object): The main grid format object (gUI.format).
//         -> rowIdx (Number): The 0-based row index for which to extract formats.
// Outputs -> (Object): An object containing formatting arrays (bg, fontColorHex,
//                       weight, fontSize, fontStyle, fontFamily, wrap) for the specified row.
function fBuildRowFormat(format, rowIdx) {
    // Use optional chaining (?.) to safely access properties, returning undefined if format or sub-property is missing
    return {
        bg: format.bg?.[rowIdx],
        fontColorHex: format.fontColorHex?.[rowIdx],
        weight: format.weight?.[rowIdx],
        fontSize: format.fontSize?.[rowIdx],
        fontStyle: format.fontStyle?.[rowIdx],
        fontFamily: format.fontFamily?.[rowIdx],
        wrap: format.wrap?.[rowIdx]
    };
} // END fBuildRowFormat


// fAppendRowCells /////////////////////////////////////////////////////////////////
// Purpose -> Creates all cell elements for a single row using fCreateAndFormatCell,
//            appends them to a document fragment, and stores references in gUI.grid2D.
// Inputs  -> fragment (DocumentFragment): Fragment to append created cells to.
//         -> rowIdx (Number): 0-based index of the row being rendered.
//         -> rowData (Array): Array of values for the current row (gUI.arr[rowIdx]).
//         -> rowFormat (Object): Formatting object for the current row.
//         -> numCols (Number): Total number of columns in the grid.
// Outputs -> None (Modifies the input fragment and gUI.grid2D).
function fAppendRowCells(fragment, rowIdx, rowData, rowFormat, numCols) {
    // Loop through each column in the row
    for (let c = 0; c < numCols; c++) {
        const value = rowData?.[c]; // Get value for the current cell
        // Create and format the cell element
        const cell = fCreateAndFormatCell(rowIdx, c, value, rowFormat);
        // Store reference in the 2D grid array
        gUI.grid2D[rowIdx][c] = cell;
        // Append the created cell to the document fragment
        fragment.appendChild(cell);
    }
} // END fAppendRowCells




// fRenderChunkFactory /////////////////////////////////////////////////////////////
// Purpose -> Creates and returns a closure function (`renderChunk`) responsible for
//            rendering the grid rows in manageable chunks using requestAnimationFrame.
// Inputs  -> grid (HTMLElement): The grid container element.
//         -> gameArr (Array[][]): The 2D array of grid data.
//         -> format (Object): The main grid format object.
//         -> chunkSize (Number): The number of rows to render per chunk.
//         -> callback (Function): Function to call after all chunks are rendered.
// Outputs -> (Function): The `renderChunk` closure function.
function fRenderChunkFactory(grid, gameArr, format, chunkSize, callback) {
    let r = 0; // Current starting row index for the next chunk
    const numRows = gameArr.length;
    const numCols = gameArr[0].length;

    // The closure function that renders one chunk
    return function renderChunk() {
        const fragment = document.createDocumentFragment(); // Use fragment for efficiency
        const endRow = Math.min(r + chunkSize, numRows); // Calculate end row for this chunk

        // Render cells for the current chunk
        for (let rowIdx = r; rowIdx < endRow; rowIdx++) {
            const rowData = gameArr[rowIdx];
            const rowFormat = fBuildRowFormat(format, rowIdx);
            fAppendRowCells(fragment, rowIdx, rowData, rowFormat, numCols);
        }

        // Append the chunk's fragment to the grid
        grid.appendChild(fragment);
        r = endRow; // Update the starting row for the next chunk

        // Schedule the next chunk or finish up
        if (r < numRows) {
            requestAnimationFrame(renderChunk); // Schedule the next chunk
        } else {
            // All rows rendered, call the final callback
            fMyConsoleLog(`✅ Grid Rendered (${numRows} rows)`);
            if (typeof callback === 'function') {
                fMyConsoleLog("🚀 Applying Post-Render Formatting...");
                // Use setTimeout to allow browser to paint before running heavy post-render tasks
                setTimeout(callback, 0);
            }
        }
    }; // END renderChunk (inner function)
} // END fRenderChunkFactory





////////////////////////////////////////////////////////////////////////////////////////////////////////// END fRenderFullGrid and helpers




// ==========================================================================
// === Grid Formatting & Visibility  (End of Core Rendering & Grid Tag Setup) ===
// ==========================================================================




// fSetHeader ////////////////////////////////////////////////////////////////////
// Purpose -> Hides the top utility rows (0, 1) and applies sticky positioning
//            and styling to the header rows (2, 3, 4). Also adds a visual
//            indicator style to the row immediately below the sticky header (row 5).
// Inputs  -> None (Uses gUI.grid2D, gUI.ROW_HEIGHT_PX, gUI.format.bg).
// Outputs -> None (Modifies DOM cell styles and classes).
function fSetHeader() {
    fMyConsoleLog("🔒 Applying Sticky Header...");
    const numRows = gUI.grid2D.length;

    // === Validation ===
    if (numRows < 5) { // Need rows 0, 1, 2, 3, 4 for this to work
        fMyConsoleLog("⚠️ Not enough rows for sticky header.");
        return;
    }
    const numCols = gUI.grid2D[0]?.length || 0;
    if (numCols === 0) {
        fMyConsoleLog("⚠️ No columns found for sticky header.");
        return;
    }

    // === Hide Top Rows (0 and 1) ===
    for (let r = 0; r <= 1; r++) {
        for (let c = 0; c < numCols; c++) {
            const cell = gUI.grid2D?.[r]?.[c];
            if (cell) cell.style.display = 'none';
        }
    }

    // === Apply Sticky Styling to Header Rows (2, 3, 4) ===
    for (let r = 2; r <= 4; r++) {
        const offset = (r - 2) * gUI.ROW_HEIGHT_PX; // Calculate offset based on row index (0px for row 2)

        for (let c = 0; c < numCols; c++) {
            const cell = gUI.grid2D?.[r]?.[c];
            if (!cell || cell.style.display === 'none') continue; // Skip non-existent or hidden cells

            // Add class for base sticky styles
            cell.classList.add('sticky-header');
            // Apply dynamic top offset based on row index
            cell.style.top = `${offset}px`;

            // Re-apply original background color to prevent override by sticky-header class
            const bgColor = gUI.format?.bg?.[r]?.[c];
            cell.style.backgroundColor = bgColor || '#ffffff'; // Fallback to white
        }
    }

    // === Apply Styling to Row Below Sticky Section (Row 5) ===
    if (numRows > 5) { // Check if row 5 exists
        const belowRowIndex = 5;
        for (let c = 0; c < numCols; c++) {
            const cell = gUI.grid2D?.[belowRowIndex]?.[c];
            // Apply class only to visible cells in this row
            if (cell && cell.style.display !== 'none') {
                cell.classList.add('below-sticky');
            }
        }
    }

    fMyConsoleLog("✅ Sticky Header Applied");
} // END fSetHeader




// fUpdateGridColumnTemplate ///////////////////////////////////////////////////////
// Purpose -> Recalculates and applies the 'grid-template-columns' CSS style to the
//            grid container based on the current state of gUI.hiddenColumns.
//            Sets width to '0px' for hidden columns, uses original width otherwise.
// Inputs  -> None (Uses gUI.hiddenColumns, gUI.format.colWidths, gUI.arr).
// Outputs -> None (Modifies the grid element's style).
function fUpdateGridColumnTemplate() {
    const grid = document.getElementById("grid");

    // Validate prerequisites
    if (!grid || !gUI.format.colWidths || !gUI.arr || gUI.arr.length === 0) {
        console.error("fUpdateGridColumnTemplate: Missing prerequisites (grid element, colWidths, or arr data).");
        return;
    }

    const numCols = gUI.arr[0].length;
    const colWidths = gUI.format.colWidths || [];
    let templateCols = [];

    // Build the array of column width strings
    for (let c = 0; c < numCols; c++) {
        if (gUI.hiddenColumns.has(c)) { // Check if column index is in the hidden set
            templateCols.push("0px"); // Use 0px for hidden columns
        } else {
            const width = colWidths[c] || 60; // Use stored width or default to 60px
            templateCols.push(`${width}px`);
        }
    }

    // Join the array into the final CSS string
    const newTemplateString = templateCols.join(' ');

    // Apply the new style to the grid
    grid.style.gridTemplateColumns = newTemplateString;

} // END fUpdateGridColumnTemplate




// fSetColumnVisibility ////////////////////////////////////////////////////////////
// Purpose -> Hides or shows a single column by updating the `visibility: collapse`
//            style of its cells and optionally updating the grid template.
//            Manages the column index in the gUI.hiddenColumns Set.
// Inputs  -> colIndex (Number): 0-based index of the column to modify.
//         -> isVisible (Boolean): True to show the column, false to hide it.
//         -> updateTemplate (Boolean): If true (default), calls fUpdateGridColumnTemplate
//                                       after modifying cell visibility.
// Outputs -> None (Modifies cell styles, gUI.hiddenColumns, potentially grid style).
function fSetColumnVisibility(colIndex, isVisible, updateTemplate = true) {
    // === Validate Input ===
    if (isNaN(colIndex) || colIndex < 0 || !gUI.grid2D[0] || colIndex >= gUI.grid2D[0].length) {
        console.warn(`fSetColumnVisibility: Invalid column index ${colIndex}`);
        return;
    }

    // === Determine Action and Check Current State ===
    const numRows = gUI.grid2D.length;
    const currentlyHidden = gUI.hiddenColumns.has(colIndex);
    const action = isVisible ? 'Showing' : 'Hiding';
    const needsChange = (isVisible && currentlyHidden) || (!isVisible && !currentlyHidden);

    if (needsChange) {
        // === Update Hidden State Set ===
        if (isVisible) {
            gUI.hiddenColumns.delete(colIndex);
        } else {
            gUI.hiddenColumns.add(colIndex);
        }

        // === Update Cell Visibility ===
        for (let r = 0; r < numRows; r++) {
            const cell = gUI.grid2D[r]?.[colIndex];
            if (cell) {
                // Use visibility: collapse for hiding (maintains layout spacing)
                cell.style.visibility = isVisible ? '' : 'collapse';
            }
        }

        // === Update Grid Template (Optional) ===
        // Regenerate the grid template only if requested (e.g., batch updates skip this)
        if (updateTemplate) {
             fUpdateGridColumnTemplate();
        }
    }
    // else: Column is already in the desired state, no action needed.
} // END fSetColumnVisibility




// fSetRowVisibility ///////////////////////////////////////////////////////////////
// Purpose -> Hides or shows a single row by setting the 'display' style of its cells
//            and managing the row index in the gUI.hiddenRows Set.
//            Also handles resetting sticky styles if hiding a potentially sticky row.
// Inputs  -> rowIndex (Number): 0-based index of the row to modify.
//         -> isVisible (Boolean): True to show the row, false to hide it.
// Outputs -> None (Modifies cell styles, gUI.hiddenRows, potentially calls fSetHeader).
function fSetRowVisibility(rowIndex, isVisible) {
    // === Validate Input ===
     if (isNaN(rowIndex) || rowIndex < 0 || rowIndex >= gUI.grid2D.length) {
        console.warn(`fSetRowVisibility: Invalid row index ${rowIndex}.`);
        return;
    }

    // === Update Hidden State Set ===
    if (isVisible) {
        gUI.hiddenRows.delete(rowIndex); // Remove from Set when showing
    } else {
        gUI.hiddenRows.add(rowIndex); // Add to Set when hiding
    }

    // === Apply Visibility to Cells ===
    const numCols = gUI.grid2D[0]?.length || 0;
    for (let c = 0; c < numCols; c++) {
        const cell = gUI.grid2D[rowIndex]?.[c];
        if (cell) {
             cell.style.display = isVisible ? '' : 'none'; // Toggle display
             // If hiding, ensure any potential sticky styles are removed
             if (!isVisible) {
                 cell.classList.remove('sticky-header', 'below-sticky');
                 cell.style.position = '';
                 cell.style.top = '';
                 cell.style.zIndex = '';
             }
         } else {
             // Optional: Log if cell element is unexpectedly missing, especially in early columns
             // if (c < 5) console.warn(`fSetRowVisibility: Cell gUI.grid2D[${rowIndex}][${c}] not found!`);
         }
    }

    // === Handle Sticky Rows ===
    // If showing a row that could be part of the sticky header (rows 2-5), re-apply header formatting
    // to ensure correct offsets and styles are applied. Rows 0/1 are handled by fSetHeader initial run.
    if (isVisible && rowIndex >= 2 && rowIndex <= 5) {
         fSetHeader(); // Re-run fSetHeader to ensure stickiness is correct
    }

} // END fSetRowVisibility




// fApplyDynamicMerges /////////////////////////////////////////////////////////////
// Purpose -> Applies cell merging based on the `gUI.format.merges` array.
//            Sets grid-column/row span on the anchor cell and hides covered cells.
// Inputs  -> None (Uses gUI.format.merges, gUI.grid2D).
// Outputs -> None (Modifies DOM cell styles).
function fApplyDynamicMerges() {
    fMyConsoleLog("🧩 Applying Merges...");
    const merges = gUI.format?.merges || []; // Get merge definitions or empty array

    // === Iterate Through Each Merge Definition ===
    for (const mergeInfo of merges) {
        const r = mergeInfo.row;
        const c = mergeInfo.col;
        const rs = mergeInfo.rowspan;
        const cs = mergeInfo.colspan;

        // Get the top-left anchor cell of the merge area
        const anchor = gUI.grid2D?.[r]?.[c];

        // Validate anchor cell exists
        if (!anchor) {
             console.warn(`⚠️ Merge anchor cell not found at [${r},${c}]`);
             continue; // Skip this merge if anchor is missing
        }

        // === Apply CSS Grid Span to Anchor Cell ===
        if (cs > 1) anchor.style.gridColumn = `span ${cs}`;
        if (rs > 1) anchor.style.gridRow = `span ${rs}`;

        // === Hide Cells Covered by the Merge ===
        // Iterate through all cells within the merge bounds
        for (let rSub = r; rSub < r + rs; rSub++) {
            for (let cSub = c; cSub < c + cs; cSub++) {
                // Skip the anchor cell itself
                if (rSub === r && cSub === c) continue;

                // Find and hide the covered cell
                const cellToHide = gUI.grid2D?.[rSub]?.[cSub];
                if (cellToHide) {
                    cellToHide.style.display = 'none';
                }
            }
        }
    } // End loop through merge definitions

     fMyConsoleLog("✅ Merges Applied");
} // END fApplyDynamicMerges




// fApplyManualBorders /////////////////////////////////////////////////////////////
// Purpose -> Applies CSS border styles to cells within sections defined in
//            gUI.manualBorderSections. Applies top/left borders to all cells
//            in a section and right/bottom borders based on the 'edges' property.
// Inputs  -> None (Uses gUI.manualBorderSections, gUI.grid2D).
// Outputs -> None (Modifies DOM cell styles).
function fApplyManualBorders() {
    fMyConsoleLog("🖌️ Applying Manual Borders...");
    let appliedCount = 0;

    // === Iterate Through Each Defined Border Section ===
    gUI.manualBorderSections.forEach(section => {
        // Resolve section boundaries and get style/edge info
        const rowStart = resolveRow(section.r1);
        const colStart = resolveCol(section.c1);
        const rowEnd = resolveRow(section.r2);
        const colEnd = resolveCol(section.c2);
        const borderStyle = section.style || '1px solid #000'; // Default to black thin solid
        const edges = section.edges || ''; // Edge flags ('t', 'b', 'l', 'r')

        // Validate resolved indices
        if ([rowStart, colStart, rowEnd, colEnd].some(v => isNaN(v))) {
            console.warn("Skipping manual border section due to invalid tags:", section);
            return; // Skip this section if tags don't resolve
        }

        // === Apply Borders to Cells Within the Section ===
        for (let r = rowStart; r <= rowEnd; r++) {
             for (let c = colStart; c <= colEnd; c++) {
                const cell = gUI.grid2D?.[r]?.[c];

                // Skip non-existent cells or those hidden by merging
                if (!cell || cell.style.display === 'none') continue;

                let appliedThisCell = false;

                // Apply Top and Left to ALL cells in the rectangle (standard behavior)
                cell.style.borderTop = borderStyle;
                cell.style.borderLeft = borderStyle;
                appliedThisCell = true; // Count this application

                // Apply Right border only if it's the last column AND edges flag allows 'r'
                if (edges.includes('r') && c === colEnd) {
                    cell.style.borderRight = borderStyle;
                }

                // Apply Bottom border only if it's the last row AND edges flag allows 'b'
                if (edges.includes('b') && r === rowEnd) {
                    cell.style.borderBottom = borderStyle;
                }

                if (appliedThisCell) appliedCount++;
            }
        }
    }); // End forEach section

    fMyConsoleLog(`✅ Manual Borders Applied (${appliedCount} styles set)`);
} // END fApplyManualBorders




// fApplyManualColoring ////////////////////////////////////////////////////////////
// Purpose -> Applies specific font colors to predefined ranges based on the
//            gUI.fontColorRange configuration array. Automatically applies a
//            contrasting color (black/white) if the intended font color matches
//            the cell's background color.
// Inputs  -> None (Uses gUI.fontColorRange, gUI.grid2D, gUI.format.bg).
// Outputs -> None (Modifies DOM cell styles).
function fApplyManualColoring() {
    fMyConsoleLog("🎨 Applying Manual Font Colors...");
    const colorConfigArray = gUI.fontColorRange;

    // === Validation ===
    // Check if the config is a valid, non-empty array
    if (!Array.isArray(colorConfigArray)) {
        fMyConsoleLog("ℹ️ Manual font color configuration (gUI.fontColorRange) is not an array or is missing.");
        return;
    }
    if (colorConfigArray.length === 0) {
        fMyConsoleLog("ℹ️ Manual font color configuration is empty.");
        return;
    }

    // === Initialization ===
    let colorsAppliedCount = 0;
    let contrastAppliedCount = 0;

    // === Iterate Through Each Color Definition ===
    colorConfigArray.forEach((colorDef, index) => {
        // Validate the structure of the current color definition object
        if (!colorDef || typeof colorDef.color !== 'string' || !Array.isArray(colorDef.ranges)) {
             console.warn(`Skipping invalid color definition at index ${index}:`, colorDef);
             return; // Skip to the next definition
         }

        const cssColor = colorDef.color;   // Hex color string for this definition
        const ranges = colorDef.ranges;     // Array of range objects for this color

        // === Iterate Through Each Range for the Current Color ===
        ranges.forEach(range => {
            // Validate range object structure
            if (!fIsValidRangeObject(range)) {
                 console.warn(`Skipping invalid range object for color '${cssColor}':`, range);
                 return; // Skip this range
            }

            // Resolve range tags/indices
            const resolved = fResolveRangeIndices(range);
            if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
                 console.warn(`Could not resolve tags for range in color '${cssColor}':`, range);
                 return; // Skip range if tags invalid
            }

            // Determine bounds
            const rMin = Math.min(resolved.r1, resolved.r2);
            const rMax = Math.max(resolved.r1, resolved.r2);
            const cMin = Math.min(resolved.c1, resolved.c2);
            const cMax = Math.max(resolved.c1, resolved.c2);

            // === Apply Color to Cells Within the Range ===
            for (let r = rMin; r <= rMax; r++) {
                for (let c = cMin; c <= cMax; c++) {
                    const cell = gUI.grid2D?.[r]?.[c];
                    // Skip non-existent or hidden cells
                    if (!cell || cell.style.display === 'none') continue;

                    // --- Determine Background Color (handling computed vs explicit) ---
                    let cellBgColor = window.getComputedStyle(cell).backgroundColor;
                    if (cellBgColor && cellBgColor.startsWith('rgb')) {
                        // Convert computed rgb() to hex if possible
                        try {
                            const rgb = cellBgColor.match(/\d+/g).map(Number);
                            cellBgColor = '#' + rgb.map(x => { const hex = x.toString(16); return hex.length === 1 ? '0' + hex : hex; }).join('');
                        } catch (e) {
                             // Fallback if conversion fails
                             cellBgColor = cell.style.backgroundColor || gUI.format?.bg?.[r]?.[c] || '#ffffff';
                         }
                     } else {
                         // Use explicit style or format data, default white
                         cellBgColor = cell.style.backgroundColor || gUI.format?.bg?.[r]?.[c] || '#ffffff';
                     }
                    const cleanBgColor = cellBgColor.toLowerCase();
                    // --- End Background Color Determination ---

                    const intendedFontColor = cssColor.toLowerCase();

                    // --- Apply Color with Contrast Check ---
                    if (intendedFontColor === cleanBgColor) {
                        // If font matches background, apply contrast color
                        cell.style.color = fGetContrastColor(cleanBgColor);
                        contrastAppliedCount++;
                    } else {
                        // Otherwise, apply the intended font color
                        cell.style.color = intendedFontColor;
                        colorsAppliedCount++;
                    }
                } // end col loop
            } // end row loop
        }); // end forEach range
    }); // end forEach colorDef

    fMyConsoleLog(`✅ Manual Colors Applied (${colorsAppliedCount} direct, ${contrastAppliedCount} contrast).`);
} // END fApplyManualColoring



////////////////////////////////////////////////////////////////////////////////////////////////////////// START fAddHeaderButtons and helpers




// fAddHeaderButtons ///////////////////////////////////////////////////////////////
// Purpose -> Finds specific cells designated by tags in headerButtonConfigs, clears
//            their content, and inserts configured image buttons.
// Inputs  -> None (Uses gUI.grid2D, calls helper functions).
// Outputs -> None (Modifies DOM by inserting images into cells).
function fAddHeaderButtons() {
    fMyConsoleLog("⚙️ Adding Header Buttons...");
    let buttonsAdded = 0;

    // === Button Configurations ===
    // Define where each button image should go and what action it performs.
    const headerButtonConfigs = [
        {
            rowTag: 'Button_R',         // Row tag of the target cell
            colTag: 'DieButtonC',       // Column tag of the target cell
            action: 'action-rollDice',  // data-button-action attribute value
            imageUrl: 'https://raw.githubusercontent.com/bmobley333/TurboApp/main/Pics/Buttons/Button_d20.png', // Image source URL
            altText: 'Roll Dice',       // Image alt text
            titleText: 'Roll Dice'      // Image title text (tooltip)
        },
        {
            rowTag: 'Button_R',
            colTag: 'RefreshButtonC',
            action: 'action-refreshData',
            imageUrl: 'https://raw.githubusercontent.com/bmobley333/TurboApp/main/Pics/Buttons/Button_Refresh.png',
            altText: 'Refresh Data',
            titleText: 'Refresh Data'
        },
        {
            rowTag: 'Button_R',
            colTag: 'UpArrowButtonC',
            action: 'action-jumpTop',
            imageUrl: 'https://raw.githubusercontent.com/bmobley333/TurboApp/main/Pics/Buttons/Button_UpArrow.png',
            altText: 'Jump to Top',
            titleText: 'Jump to Top'
        },
        {
            rowTag: 'Button_R',
            colTag: 'DownArrowButtonC',
            action: 'action-jumpBottom',
            imageUrl: 'https://raw.githubusercontent.com/bmobley333/TurboApp/main/Pics/Buttons/Button_DownArrow.png',
            altText: 'Jump to Bottom',
            titleText: 'Jump to Bottom'
        },
        {
            rowTag: 'Button_R',
            colTag: 'MonsterButtonC',
            action: 'action-showMonsters',
            imageUrl: 'https://raw.githubusercontent.com/bmobley333/TurboApp/main/Pics/Buttons/Button_Monster.png',
            altText: 'Show Monsters',
            titleText: 'Show Monsters'
        }
        // Add more button configurations here
    ];

    // === Apply Buttons ===
    // Iterate through configurations and add buttons to grid
    headerButtonConfigs.forEach(config => {
        // Find the target cell using tags
        const cell = fGetResolvedCell(config.rowTag, config.colTag);
        if (!cell) return; // Skip if cell not found or tags invalid

        // Create the image element
        const img = fCreateHeaderButtonImage(config);
        // Clear cell and insert the image
        fApplyHeaderButtonToCell(cell, img);
        buttonsAdded++;
    });

    // Log summary
    fMyConsoleLog(buttonsAdded > 0
        ? `✅ Added ${buttonsAdded} Header Button(s).`
        : `ℹ️ No valid Header Buttons found or added.`);

} // END fAddHeaderButtons



// fGetResolvedCell ////////////////////////////////////////////////////////////////
// Purpose -> Resolves row and column tags to indices and retrieves the corresponding
//            cell DOM element from gUI.grid2D. Logs warnings if resolution or
//            element retrieval fails. Used primarily for finding header button cells.
// Inputs  -> rowTag (String): The row tag to resolve.
//         -> colTag (String): The column tag to resolve.
// Outputs -> (HTMLElement | null): The cell element if found, otherwise null.
function fGetResolvedCell(rowTag, colTag) {
    // Resolve tags to indices
    const r = resolveRow(rowTag);
    const c = resolveCol(colTag);

    // Validate resolved indices
    if (isNaN(r) || isNaN(c)) {
        console.warn(`fGetResolvedCell: Could not resolve tags [${rowTag}, ${colTag}]`);
        return null;
    }

    // Retrieve cell element from the grid cache
    const cell = gUI.grid2D?.[r]?.[c];

    // Validate cell element exists
    if (!cell) {
        console.warn(`fGetResolvedCell: Cell element not found at resolved [${r}, ${c}] for tags [${rowTag}, ${colTag}]`);
        return null;
    }

    return cell;
} // END fGetResolvedCell




// fCreateHeaderButtonImage //////////////////////////////////////////////////////
// Purpose -> Creates and returns a styled <img> element for a header button based
//            on the provided configuration object.
// Inputs  -> config (Object): Button configuration containing imageUrl, altText,
//                             titleText, and action (for data-button-action).
// Outputs -> (HTMLImageElement): The configured <img> element.
function fCreateHeaderButtonImage(config) {
    const img = document.createElement('img');

    // Set image attributes from config
    img.src = config.imageUrl;
    img.alt = config.altText;
    img.title = config.titleText; // Tooltip
    img.dataset.buttonAction = config.action; // Store action for click handler

    // Add CSS class for styling
    img.classList.add('header-button-img');

    return img;
} // END fCreateHeaderButtonImage




// fApplyHeaderButtonToCell //////////////////////////////////////////////////////
// Purpose -> Clears the target cell's content, inserts the provided image element,
//            and applies centering styles suitable for image buttons.
// Inputs  -> cell (HTMLElement): The target cell div element.
//         -> img (HTMLImageElement): The configured <img> element to insert.
// Outputs -> None (Modifies the input cell element's content and style).
function fApplyHeaderButtonToCell(cell, img) {
    // Clear existing content and append the image
    cell.innerHTML = '';
    cell.appendChild(img);

    // Apply centering styles to the cell
    cell.style.justifyContent = 'center';
    cell.style.alignItems = 'center';
    cell.style.padding = '0'; // Remove padding for better image fit
} // END fApplyHeaderButtonToCell










////////////////////////////////////////////////////////////////////////////////////////////////////////// END fAddHeaderButtons and helpers


// fMarkOverflowingCells ///////////////////////////////////////////////////////////
// Purpose -> Adds the 'overflow-left' CSS class to grid cells where the content's
//            scrollWidth exceeds the cell's clientWidth, indicating text overflow.
//            Optimized by separating DOM reads (dimensions) from writes (classList).
// Inputs  -> None (Queries DOM for cells).
// Outputs -> None (Modifies cell classLists).
function fMarkOverflowingCells() {
    fMyConsoleLog("↔️ Checking Cell Overflow (Optimized)...");
    const cells = document.querySelectorAll('#grid .cell:not([style*="display: none"])'); // Get visible cells
    let cellsToModify = []; // Store cells needing class modification

    // === Phase 1: Read Dimensions ===
    // Iterate through cells and store which ones need the class, without modifying DOM yet.
    cells.forEach(cell => {
        const clientW = cell.clientWidth;
        const scrollW = cell.scrollWidth;
        // Check for overflow (with a 1px tolerance)
        const shouldOverflow = scrollW > clientW + 1;
        // Store the cell and whether it should have the overflow class
        cellsToModify.push({ cellElement: cell, shouldOverflow: shouldOverflow });
    });

    // === Phase 2: Write Class Changes ===
    // Iterate through the collected data and apply class changes in a batch.
    let count = 0; // Count how many cells were newly marked
    cellsToModify.forEach(item => {
        const cell = item.cellElement;
        const currentlyHasClass = cell.classList.contains('overflow-left');

        if (item.shouldOverflow && !currentlyHasClass) {
            // Add class if needed and not present
            cell.classList.add('overflow-left');
            count++;
        } else if (!item.shouldOverflow && currentlyHasClass) {
            // Remove class if not needed and present
            cell.classList.remove('overflow-left');
            // Increment count here if you want to count removals as changes
        }
        // Otherwise, no change needed for this cell
    });

    fMyConsoleLog(`✅ Overflow Checked (Optimized - ${count} cells newly marked)`);
} // END fMarkOverflowingCells




// fHideColumnRange ////////////////////////////////////////////////////////////////
// Purpose -> Hides one or more ranges of columns defined in an array of range objects.
//            Calls fSetColumnVisibility for each affected column without updating the
//            grid template individually, then updates the template once at the end.
// Inputs  -> rangeArray (Array<Object>): An array of range definition objects,
//                                         each with c1 and c2 properties (tags/indices).
// Outputs -> None (Modifies cell styles, gUI.hiddenColumns, grid style).
function fHideColumnRange(rangeArray) {
    fMyConsoleLog(`👁️ Hiding Column Ranges...`);

    // === Validate Input ===
    if (!Array.isArray(rangeArray)) {
        console.error("fHideColumnRange: Invalid input - requires an array.", rangeArray);
        return;
    }

    let anyColumnsChanged = false; // Track if any action was taken

    // === Process Each Range ===
    for (const range of rangeArray) {
        // Validate range object structure
        if (!range || typeof range.c1 === 'undefined' || typeof range.c2 === 'undefined') {
             console.warn("fHideColumnRange: Skipping invalid range object:", range);
             continue;
        }

        // Resolve column tags/indices
        const startCol = resolveCol(range.c1);
        const endCol = resolveCol(range.c2);

        // Validate resolved indices
        if (isNaN(startCol) || isNaN(endCol)) {
            console.warn(`fHideColumnRange: Skipping range due to invalid tags/indices: ${range.c1}, ${range.c2}`);
            continue;
        }

        // Determine bounds
        const cMin = Math.min(startCol, endCol);
        const cMax = Math.max(startCol, endCol);

        // === Hide Columns Within Range ===
        for (let c = cMin; c <= cMax; c++) {
            // Check if the column is not already hidden
            if (!gUI.hiddenColumns.has(c)) {
                // Hide the column, but defer template update
                fSetColumnVisibility(c, false, false);
                anyColumnsChanged = true; // Mark that a change occurred
            }
            // else: Column already hidden, do nothing for this column index
        }
    } // End loop through rangeArray

    // === Update Grid Template (if needed) ===
    // Update the grid template ONCE after processing all ranges, only if changes were made.
    if (anyColumnsChanged) {
        fUpdateGridColumnTemplate();
        fMyConsoleLog(`✅ Column Ranges Hidden.`);
    } else {
        fMyConsoleLog(`ℹ️ All Specified Column Ranges Already Hidden (or no valid ranges found).`);
    }
} // END fHideColumnRange




// fShowColumnRange ////////////////////////////////////////////////////////////////
// Purpose -> Shows one or more ranges of columns defined in an array of range objects.
//            Calls fSetColumnVisibility for each affected column without updating the
//            grid template individually, then updates the template once at the end.
// Inputs  -> rangeArray (Array<Object>): An array of range definition objects,
//                                         each with c1 and c2 properties (tags/indices).
// Outputs -> None (Modifies cell styles, gUI.hiddenColumns, grid style).
function fShowColumnRange(rangeArray) {
    fMyConsoleLog(`👁️ Showing Column Ranges...`);

    // === Validate Input ===
    if (!Array.isArray(rangeArray)) {
        console.error("fShowColumnRange: Invalid input - requires an array.", rangeArray);
        return;
    }

    let anyColumnsChanged = false; // Track if any action was taken

    // === Process Each Range ===
    for (const range of rangeArray) {
        // Validate range object structure
        if (!range || typeof range.c1 === 'undefined' || typeof range.c2 === 'undefined') {
             console.warn("fShowColumnRange: Skipping invalid range object:", range);
             continue;
        }

        // Resolve column tags/indices
        const startCol = resolveCol(range.c1);
        const endCol = resolveCol(range.c2);

        // Validate resolved indices
        if (isNaN(startCol) || isNaN(endCol)) {
            console.warn(`fShowColumnRange: Skipping range due to invalid tags/indices: ${range.c1}, ${range.c2}`);
            continue;
        }

        // Determine bounds
        const cMin = Math.min(startCol, endCol);
        const cMax = Math.max(startCol, endCol);

        // === Show Columns Within Range ===
        for (let c = cMin; c <= cMax; c++) {
             // Check if the column IS currently hidden
             if (gUI.hiddenColumns.has(c)) {
                 // Show the column, but defer template update
                 fSetColumnVisibility(c, true, false);
                 anyColumnsChanged = true; // Mark that a change occurred
             }
             // else: Column already visible, do nothing for this column index
        }
    } // End loop through rangeArray

    // === Update Grid Template (if needed) ===
    // Update the grid template ONCE after processing all ranges, only if changes were made.
    if (anyColumnsChanged) {
        fUpdateGridColumnTemplate();
        fMyConsoleLog(`✅ Column Ranges Shown.`);
    } else {
         fMyConsoleLog(`ℹ️ All Specified Column Ranges Already Visible (or no valid ranges found).`);
    }
} // END fShowColumnRange




// fApplyInitialVisibility ///////////////////////////////////////////////////////
// Purpose -> Applies the initial hidden state for columns and rows based on the
//            gUI.initialHiddenCols and gUI.initialHiddenRows configuration arrays.
//            Calls fHideColumnRange for columns and fSetRowVisibility for rows.
// Inputs  -> None (Uses gUI.initialHiddenCols, gUI.initialHiddenRows).
// Outputs -> None (Calls other functions that modify DOM/state).
function fApplyInitialVisibility() {
    fMyConsoleLog("👁️ Applying Initial Visibility...");

    // === Hide Initial Columns ===
    if (gUI.initialHiddenCols && gUI.initialHiddenCols.length > 0) {
        // Use the dedicated range function for columns
        fHideColumnRange(gUI.initialHiddenCols);
    } else {
         fMyConsoleLog("   -> ℹ️ No initial columns defined to hide.");
    }

    // === Hide Initial Rows ===
    if (gUI.initialHiddenRows && gUI.initialHiddenRows.length > 0) {
        fMyConsoleLog("   -> 👁️ Hiding Initial Rows...");
        // Iterate through each defined row range
        gUI.initialHiddenRows.forEach(range => {
             // Resolve row tags/indices
             const r1 = resolveRow(range.r1);
             const r2 = resolveRow(range.r2);
             // Validate resolved indices
             if (isNaN(r1) || isNaN(r2)) {
                 console.warn("fApplyInitialVisibility: Skipping invalid row range due to tags:", range);
                 return; // Skip this range
             }
             // Determine bounds and hide each row individually
             const startRow = Math.min(r1, r2);
             const endRow = Math.max(r1, r2);
             for (let r = startRow; r <= endRow; r++) {
                 fSetRowVisibility(r, false); // Hide the row
             }
         });
         fMyConsoleLog("   -> ✅ Initial Rows Hidden.");
    } else {
        fMyConsoleLog("   -> ℹ️ No initial rows defined to hide.");
    }

} // END fApplyInitialVisibility




// ==========================================================================
// === Grid Hover                 (End of Grid Formatting & Visibility) ===
// ==========================================================================




// fPositionTooltip ////////////////////////////////////////////////////////////////
// Purpose -> Calculates and sets the top/left style properties for the tooltip
//            element, ensuring it stays within the browser viewport boundaries.
// Inputs  -> tooltip (HTMLElement): The tooltip element (#cell-tooltip).
//         -> event (MouseEvent): The mouse event that triggered the hover.
// Outputs -> None (Modifies the tooltip element's style).
function fPositionTooltip(tooltip, event) {
    if (!tooltip || !event) return; // Basic validation

    // === Get Dimensions and Positions ===
    const cursorX = event.pageX; // Cursor position relative to document
    const cursorY = event.pageY;

    const tooltipRect = tooltip.getBoundingClientRect(); // Tooltip dimensions
    const tooltipWidth = tooltipRect.width;
    const tooltipHeight = tooltipRect.height;

    const viewportWidth = window.innerWidth; // Viewport dimensions
    const viewportHeight = window.innerHeight;
    const scrollX = window.scrollX; // Current scroll offset
    const scrollY = window.scrollY;

    // === Calculate Initial Position ===
    // Start below and to the right of the cursor
    let newTop = cursorY + gUI.TOOLTIP_OFFSET_Y;
    let newLeft = cursorX + gUI.TOOLTIP_OFFSET_X;

    // === Adjust Position to Stay Within Viewport ===
    // Adjust left if off right edge
    if (newLeft + tooltipWidth > viewportWidth + scrollX) {
        newLeft = cursorX - tooltipWidth - gUI.TOOLTIP_OFFSET_X; // Move left of cursor
        // If moving left pushes it off the left edge, stick it near the edge
        if (newLeft < scrollX) {
             newLeft = scrollX + 5;
        }
    }

    // Adjust top if off bottom edge
    if (newTop + tooltipHeight > viewportHeight + scrollY) {
        newTop = cursorY - tooltipHeight - gUI.TOOLTIP_OFFSET_Y; // Move above cursor
        // If moving top pushes it off the top edge, stick it near the edge
        if (newTop < scrollY) {
            newTop = scrollY + 5;
        }
    }

    // === Apply Final Position ===
    tooltip.style.top = `${newTop}px`;
    tooltip.style.left = `${newLeft}px`;

} // END fPositionTooltip



////////////////////////////////////////////////////////////////////////////////////////////////////////// START fHandleCellHover and helpers




// fHandleCellHover ////////////////////////////////////////////////////////////////
// Purpose -> Delegated mouseenter/mouseover handler for grid cells. Starts a timer
//            to show the tooltip (via fStartTooltipTimer) if applicable.
// Inputs  -> event (MouseEvent): The mouse event.
// Outputs -> None.
function fHandleCellHover(event) {
    // Exit if tooltip element isn't cached/found
    if (!gUI.tooltipElement) return;

    // Get the target cell element
    const cell = fGetValidTargetCell(event);
    if (!cell) {
        // If not hovering over a valid cell, ensure tooltip is hidden
        fHideTooltip();
        return;
    }

    // Start the timer to potentially show the tooltip
    // This also clears any previous hide timer
    fStartTooltipTimer(cell, event);
} // END fHandleCellHover


// fGetValidTargetCell /////////////////////////////////////////////////////////////
// Purpose -> Finds the closest ancestor element with the class 'cell' from the
//            event target. Helper for delegated event listeners.
// Inputs  -> event (Event): The event object.
// Outputs -> (HTMLElement | null): The cell element or null if not found.
function fGetValidTargetCell(event) {
    return event.target.closest('.cell');
} // END fGetValidTargetCell


// fHideTooltip ////////////////////////////////////////////////////////////////////
// Purpose -> Clears any pending tooltip display timeout and hides the tooltip element.
// Inputs  -> None (Uses gUI.tooltipTimeoutId, gUI.tooltipElement).
// Outputs -> None (Modifies timeout, tooltip style).
function fHideTooltip() {
    // Clear any timer waiting to show the tooltip
    clearTimeout(gUI.tooltipTimeoutId);
    gUI.tooltipTimeoutId = null; // Reset the stored ID

    // Hide the tooltip element if it exists
    if (gUI.tooltipElement) {
        gUI.tooltipElement.style.display = 'none';
    }
} // END fHideTooltip


// fShouldShowTooltip //////////////////////////////////////////////////////////////
// Purpose -> Determines if a tooltip should be shown for a given cell based on
//            whether its content overflows or if it has an associated note.
// Inputs  -> r (Number): 0-based row index.
//         -> c (Number): 0-based column index.
//         -> cell (HTMLElement): The cell element.
// Outputs -> (Boolean): True if tooltip should be shown, false otherwise.
function fShouldShowTooltip(r, c, cell) {
    // Check for horizontal overflow (scrollWidth > clientWidth)
    const isOverflowing = cell.scrollWidth > cell.clientWidth + 1; // +1 for tolerance

    // Check if a note exists for this cell
    const noteText = gUI.notes?.[r]?.[c]?.trim();

    // Return true if either condition is met
    return isOverflowing || !!noteText; // Use !! to cast noteText presence to boolean
} // END fShouldShowTooltip


// fBuildTooltipContent ////////////////////////////////////////////////////////////
// Purpose -> Constructs the HTML content for the tooltip, combining overflow text
//            and/or cell notes as needed.
// Inputs  -> r (Number): 0-based row index.
//         -> c (Number): 0-based column index.
//         -> cell (HTMLElement): The cell element.
// Outputs -> (String): HTML string content for the tooltip.
function fBuildTooltipContent(r, c, cell) {
    const isOverflowing = cell.scrollWidth > cell.clientWidth + 1;
    const noteText = gUI.notes?.[r]?.[c]?.trim();
    let tooltipContent = '';

    // Add cell's text content if it's overflowing
    if (isOverflowing) {
        tooltipContent = cell.textContent;
    }

    // Add note text if it exists
    if (noteText) {
        // Add a separator if overflow text was already added
        if (tooltipContent) {
            tooltipContent += "\n---\n";
        }
        tooltipContent += `Note: ${noteText}`;
    }

    // Convert newlines to HTML line breaks for display
    return tooltipContent.replace(/\n/g, '<br>');
} // END fBuildTooltipContent


// fStartTooltipTimer //////////////////////////////////////////////////////////////
// Purpose -> Sets a timeout (`gUI.HOVER_DELAY_MS`) before attempting to show the
//            tooltip for a hovered cell. Clears any previous timeout.
// Inputs  -> cell (HTMLElement): The cell element being hovered over.
//         -> event (MouseEvent): The mouse event (used for positioning).
// Outputs -> None (Sets a timeout, potentially modifies tooltip content/style later).
function fStartTooltipTimer(cell, event) {
    // Clear any existing timeout before starting a new one
    clearTimeout(gUI.tooltipTimeoutId);

    // Set a new timeout
    gUI.tooltipTimeoutId = setTimeout(() => {
        // Get cell coordinates from data attributes
        const r = parseInt(cell.dataset.r, 10);
        const c = parseInt(cell.dataset.c, 10);

        // Validate coordinates
        if (isNaN(r) || isNaN(c)) {
            console.warn("Tooltip hover: Invalid r/c data attributes.", cell.dataset);
            fHideTooltip(); // Hide tooltip if coords invalid
            return;
        }

        // Check if tooltip should be shown for this cell
        if (fShouldShowTooltip(r, c, cell)) {
            // Build content, display tooltip, and position it
            gUI.tooltipElement.innerHTML = fBuildTooltipContent(r, c, cell);
            gUI.tooltipElement.style.display = 'block';
            fPositionTooltip(gUI.tooltipElement, event); // Position relative to mouse event
        } else {
            // Hide tooltip if conditions (overflow/note) are no longer met
            fHideTooltip();
        }

    }, gUI.HOVER_DELAY_MS); // Use configured delay
} // END fStartTooltipTimer



////////////////////////////////////////////////////////////////////////////////////////////////////////// END fHandleCellHover and helpers




// fHandleCellMouseOut /////////////////////////////////////////////////////////////
// Purpose -> Handles mouseout/mouseleave events delegated from the grid container.
//            Clears any pending tooltip display timeout and hides the tooltip.
// Inputs  -> event (MouseEvent): The mouse event object.
// Outputs -> None (Modifies timeout, tooltip style).
function fHandleCellMouseOut(event) {
    // Clear the pending timeout immediately if the mouse leaves before the delay finishes
    clearTimeout(gUI.tooltipTimeoutId);
    // Reset the stored timeout ID
    gUI.tooltipTimeoutId = null;

    // Hide the tooltip if it's currently visible and the element exists
    if (gUI.tooltipElement) {
        gUI.tooltipElement.style.display = 'none';
    }
} // END fHandleCellMouseOut




// ==========================================================================
// === Dropdown Boxes           (End of Grid Hover or appropriate section) ===
// ==========================================================================




// fCreateDropdownElement //////////////////////////////////////////////////////////
// Purpose -> Creates an HTML select element (<select>) for use within a grid cell dropdown.
//            Populates it with options and pre-selects the current value.
// Inputs  -> r (Number): 0-based row index (for data attributes).
//         -> c (Number): 0-based column index (for data attributes).
//         -> choices (Array): Array of option values for the dropdown.
//         -> currentValue (Any): The current value from gUI.arr to pre-select.
// Outputs -> (HTMLSelectElement): The configured <select> element.
function fCreateDropdownElement(r, c, choices, currentValue) {
    const select = document.createElement('select');

    // Add styling class and data attributes
    select.classList.add('grid-dropdown');
    select.dataset.r = r;
    select.dataset.c = c;

    // Ensure currentValue is a string for comparison, default to empty string
    const currentValStr = String(currentValue ?? '');

    // Create and append option elements
    choices.forEach(choice => {
        const option = document.createElement('option');
        option.value = choice; // Value attribute for the option
        option.textContent = choice; // Visible text for the option

        // Pre-select the option matching the current value
        if (String(choice) === currentValStr) {
            option.selected = true;
        }
        select.appendChild(option);
    });

    return select;
} // END fCreateDropdownElement




// fHandleDropdownChange ///////////////////////////////////////////////////////////
// Purpose -> Handles the 'change' event delegated from grid dropdowns (<select>).
//            Updates the corresponding value in gUI.arr, attempting to preserve
//            the original data type (Number or String) if possible.
// Inputs  -> event (Event): The change event object from the select element.
// Outputs -> None (Modifies gUI.arr).
function fHandleDropdownChange(event) {
    // === Get Data from Event ===
    const select = event.target;
    const r = parseInt(select.dataset.r, 10);
    const c = parseInt(select.dataset.c, 10);
    const newValue = select.value; // Value from <select> is always a string

    // === Validate Indices ===
    if (isNaN(r) || isNaN(c) || !gUI.arr?.[r]) {
         console.warn(`fHandleDropdownChange: Invalid coordinates [${r}, ${c}] from dataset.`);
         return;
    }

    // === Determine Final Value Type ===
    // Attempt to find the original choice in the config to infer data type.
    // This helps store numbers as numbers, not strings, if they were numbers originally.
    const originalChoice = gUI.dropDownBox
        .find(config => config.ranges.some(range => {
            // Find the config that applies to this cell's range
            const resolved = fResolveRangeIndices(range);
            return !isNaN(resolved.r1) && !isNaN(resolved.c1) && !isNaN(resolved.r2) && !isNaN(resolved.c2) &&
                   r >= Math.min(resolved.r1, resolved.r2) && r <= Math.max(resolved.r1, resolved.r2) &&
                   c >= Math.min(resolved.c1, resolved.c2) && c <= Math.max(resolved.c1, resolved.c2);
        })) // Get the relevant config object (if found)
        ?.choices // Access its choices array
        .find(choice => String(choice) === newValue); // Find the original choice matching the string value

    // If the original choice was a number, convert the newValue back to a number
    const finalValue = (typeof originalChoice === 'number') ? Number(newValue) : newValue;

    // === Update Data Model ===
    // Update gUI.arr only if the value has actually changed
    if (gUI.arr[r][c] !== finalValue) {
        gUI.arr[r][c] = finalValue;
        fMyConsoleLog(`Dropdown [${r}, ${c}] changed to: "${finalValue}" (Type: ${typeof finalValue})`);
        // Note: The <select> element in the DOM is already updated visually by the browser.
        // Add calls here if other actions need to be triggered by this change.
    }

} // END fHandleDropdownChange




// fApplyDropdownsToGrid ///////////////////////////////////////////////////////////
// Purpose -> Iterates through gUI.dropDownBox configurations and replaces the
//            content of applicable grid cells with dropdown (<select>) elements.
// Inputs  -> None (Uses gUI.dropDownBox, gUI.arr, gUI.grid2D).
// Outputs -> None (Modifies DOM by replacing cell content).
function fApplyDropdownsToGrid() {
    fMyConsoleLog("🧬 Applying Dropdowns to Grid...");
    let dropdownsApplied = 0;

    // === Validate Configuration ===
    if (!gUI.dropDownBox || !Array.isArray(gUI.dropDownBox)) {
        fMyConsoleLog("ℹ️ No dropdown configurations found in gUI.dropDownBox.");
        return;
    }

    // === Iterate Through Each Dropdown Configuration ===
    gUI.dropDownBox.forEach(config => {
        // Validate current config structure
        if (!config.choices || !config.ranges || !Array.isArray(config.choices) || !Array.isArray(config.ranges)) {
            console.warn("fApplyDropdownsToGrid: Skipping invalid dropdown config:", config);
            return; // Skip to next config
        }

        // === Iterate Through Ranges for This Config ===
        config.ranges.forEach(range => {
            // Validate range object structure
            if (!fIsValidRangeObject(range)) {
                 console.warn("fApplyDropdownsToGrid: Skipping invalid range object within dropdown config:", range);
                 return; // Skip this range
            }

            // Resolve range tags/indices
            const resolved = fResolveRangeIndices(range);
            if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
                 console.warn("fApplyDropdownsToGrid: Skipping dropdown range due to unresolved indices:", range);
                 return; // Skip range if tags invalid
            }

            // Determine bounds
            const rMin = Math.min(resolved.r1, resolved.r2);
            const rMax = Math.max(resolved.r1, resolved.r2);
            const cMin = Math.min(resolved.c1, resolved.c2);
            const cMax = Math.max(resolved.c1, resolved.c2);

            // === Apply Dropdown to Cells Within Range ===
            for (let r = rMin; r <= rMax; r++) {
                for (let c = cMin; c <= cMax; c++) {
                    const cell = gUI.grid2D?.[r]?.[c];

                    // Check if cell is suitable for a dropdown
                    // (Must exist, be visible, not already have a checkbox or dropdown)
                    if (cell && cell.style.display !== 'none' && !cell.querySelector('input[type="checkbox"]') && !cell.querySelector('select.grid-dropdown')) {
                         const currentValue = gUI.arr?.[r]?.[c];
                         // Create the dropdown element
                         const dropdown = fCreateDropdownElement(r, c, config.choices, currentValue);

                         // Replace cell content with the dropdown
                         cell.innerHTML = ''; // Clear existing content
                         cell.appendChild(dropdown);

                         // Adjust cell style for dropdown
                         cell.style.padding = '0'; // Remove padding to allow dropdown full space
                         cell.style.overflow = 'visible'; // Allow dropdown arrow to be visible

                         dropdownsApplied++;
                    }
                } // End col loop
            } // End row loop
        }); // End ranges.forEach
    }); // End dropDownBox.forEach

    fMyConsoleLog(`✅ Applied ${dropdownsApplied} Dropdowns.`);

} // END fApplyDropdownsToGrid



// ==========================================================================
// === Grid Interaction Logic          (End of Dropdown Boxes ) ===
// ==========================================================================




////////////////////////////////////////////////////////////////////////////////////////////////////////// START fHandleGridCheckboxClick and helpers




// fHandleGridCheckboxClick ////////////////////////////////////////////////////////
// Purpose -> Handles delegated click events specifically for checkboxes within the grid.
//            Updates the data model (gUI.arr) and handles radio-button logic for
//            Sk1/Sk2 checkboxes via fHandleSkGroupCheckboxClick.
// Inputs  -> event (MouseEvent): The click event object.
// Outputs -> None (Modifies gUI.arr, gUI.currentSkRadioChecked, and DOM checkbox state).
function fHandleGridCheckboxClick(event) {
    const checkbox = event.target;

    // Validate if the clicked element is a valid grid checkbox
    if (!fIsValidGridCheckbox(checkbox)) return;

    // Get coordinates from checkbox data attributes
    const r = parseInt(checkbox.dataset.r, 10);
    const c = parseInt(checkbox.dataset.c, 10);

    // Validate coordinates
    if (!fIsValidGridCoords(r, c)) {
        console.warn("Checkbox click handler: Invalid row/column index or missing grid element.", checkbox.dataset);
        return;
    }

    // Determine checked state and if it's part of the Sk radio group
    const isChecked = checkbox.checked;
    const isSkGroupMember = checkbox.dataset.skGroup === 'true';

    // Route to appropriate handler
    if (isSkGroupMember) {
        // Handle radio-button logic for Sk1/Sk2 group
        fHandleSkGroupCheckboxClick(r, c, isChecked);
    } else {
        // Handle standard checkbox: update data model directly
        gUI.arr[r][c] = isChecked;
        fMyConsoleLog(`Checkbox [${r}, ${c}] toggled to: ${isChecked}`);
    }
} // END fHandleGridCheckboxClick


// fIsValidGridCheckbox ////////////////////////////////////////////////////////////
// Purpose -> Checks if a given HTML element is a valid, enabled checkbox
//            located within a grid cell (.cell).
// Inputs  -> checkbox (HTMLElement): The element to check.
// Outputs -> (Boolean): True if the element is a valid grid checkbox, false otherwise.
function fIsValidGridCheckbox(checkbox) {
    return checkbox &&
           checkbox.tagName === 'INPUT' &&
           checkbox.type === 'checkbox' &&
           checkbox.closest('.cell') && // Ensure it's within a grid cell
           !checkbox.disabled;          // Ensure it's not disabled
} // END fIsValidGridCheckbox


// fIsValidGridCoords //////////////////////////////////////////////////////////////
// Purpose -> Validates if given row and column indices are valid numbers and
//            correspond to existing rows in gUI.arr and gUI.grid2D.
// Inputs  -> r (Number): 0-based row index.
//         -> c (Number): 0-based column index.
// Outputs -> (Boolean): True if coordinates are valid, false otherwise.
function fIsValidGridCoords(r, c) {
    return !isNaN(r) && !isNaN(c) && // Are they numbers?
           r >= 0 && c >= 0 &&        // Are they non-negative?
           gUI.arr[r] && gUI.grid2D[r]; // Do the rows exist in our data/DOM arrays?
} // END fIsValidGridCoords


// fHandleSkGroupCheckboxClick /////////////////////////////////////////////////////
// Purpose -> Handles the specific logic for Sk1/Sk2 checkboxes, ensuring only one
//            in the defined group (gUI.range.sk1sk2CheckBoxes) can be checked at a time.
// Inputs  -> r (Number): Row index of the clicked checkbox.
//         -> c (Number): Column index of the clicked checkbox.
//         -> isChecked (Boolean): The new checked state of the clicked checkbox.
// Outputs -> None (Modifies gUI.arr, gUI.currentSkRadioChecked, and potentially other DOM checkboxes).
function fHandleSkGroupCheckboxClick(r, c, isChecked) {
    const oldR = gUI.currentSkRadioChecked.r;
    const oldC = gUI.currentSkRadioChecked.c;

    if (isChecked) {
        // If checking a new box, uncheck the previously checked one (if different)
        if (oldR !== null && oldC !== null && (oldR !== r || oldC !== c)) {
            fUncheckOldSkGroupBox(oldR, oldC);
        }
        // Update tracker and data model for the newly checked box
        gUI.currentSkRadioChecked = { r, c };
        gUI.arr[r][c] = true;
        fMyConsoleLog(`Radio group: Checked box [${r}, ${c}]`);
    } else {
        // If unchecking the currently tracked box, clear the tracker
        if (oldR === r && oldC === c) {
            gUI.currentSkRadioChecked = { r: null, c: null };
        }
        // Update data model for the unchecked box
        gUI.arr[r][c] = false;
        fMyConsoleLog(`Radio group: Unchecked box [${r}, ${c}]`);
    }
} // END fHandleSkGroupCheckboxClick


// fUncheckOldSkGroupBox ///////////////////////////////////////////////////////////
// Purpose -> Finds and unchecks the previously checked Sk1/Sk2 radio group checkbox
//            in both the DOM and the data model (gUI.arr).
// Inputs  -> oldR (Number): Row index of the previously checked box.
//         -> oldC (Number): Column index of the previously checked box.
// Outputs -> None (Modifies DOM checkbox state and gUI.arr).
function fUncheckOldSkGroupBox(oldR, oldC) {
    // Find the DOM element for the old cell and its checkbox
    const oldCellDiv = gUI.grid2D[oldR]?.[oldC];
    const oldCheckbox = oldCellDiv?.querySelector('input[data-sk-group="true"]');

    if (oldCheckbox) {
        oldCheckbox.checked = false; // Uncheck DOM element
        gUI.arr[oldR][oldC] = false; // Update data model
        fMyConsoleLog(`Radio group: Unchecked previous box [${oldR}, ${oldC}]`);
    } else {
        // This might happen if the grid structure changed unexpectedly
        console.warn(`Radio group: Could not find previous checkbox element at [${oldR}, ${oldC}] to uncheck.`);
    }
} // END fUncheckOldSkGroupBox



////////////////////////////////////////////////////////////////////////////////////////////////////////// END fHandleGridCheckboxClick and helpers




////////////////////////////////////////////////////////////////////////////////////////////////////////// START fHandleGridClick and helpers




// fHandleGridClick ////////////////////////////////////////////////////////////////
// Purpose -> Delegated click handler for the main grid container (#grid). Routes clicks
//            based on the target element (header button, checkbox, URL link, editable cell).
//            Updates gUI.cellClickInfo with details of the last clicked cell.
// Inputs  -> event (MouseEvent): The click event object.
// Outputs -> None (Calls specific handlers based on target).
async function fHandleGridClick(event) { // Keep async for potential future needs
    const target = event.target;

    // === Handle Header Button Clicks ===
    // Check if the click was on an image inside a header button cell
    const buttonImg = target.closest('.header-button-img[data-button-action]');
    if (buttonImg) {
        fHandleHeaderButtonClick(event, buttonImg);
        // Note: cellClickInfo is NOT updated for header button clicks.
        return; // Stop further processing
    }

    // === Get Clicked Cell Element ===
    const cellDiv = target.closest('.cell');
    if (!cellDiv) return; // Exit if click wasn't inside a grid cell

    // === Update Last Clicked Cell Info ===
    try {
        const r_str = cellDiv.dataset.r;
        const c_str = cellDiv.dataset.c;
        const r = parseInt(r_str, 10);
        const c = parseInt(c_str, 10);
        const text = cellDiv.textContent?.trim() ?? ''; // Get visible text

        if (!isNaN(r) && !isNaN(c)) {
            // Store valid coordinates and text
            gUI.cellClickInfo = { r, c, text, focusText: null }; // Reset focusText
            fMyConsoleLog(`🖱️ Cell Click: [${r}, ${c}]`);
        } else {
            // Log warning and clear info if coordinates are invalid
            console.warn(`fHandleGridClick: Invalid row/col data attributes found: r='${r_str}', c='${c_str}'`);
            gUI.cellClickInfo = { r: null, c: null, text: null, focusText: null };
        }
    } catch (e) {
        console.error("Error updating gUI.cellClickInfo:", e);
        gUI.cellClickInfo = { r: null, c: null, text: null, focusText: null }; // Clear on error
    }

    // === Route Click Based on Target Type ===
    // Checkbox Click
    if (fIsCheckboxClick(target)) {
        fHandleGridCheckboxClick(event);
        return;
    }

    // Click inside an already focused editable cell (do nothing special)
    if (fIsEditableCell(cellDiv) && document.activeElement === cellDiv) {
        return;
    }

    // Click to focus an editable cell (allow default focus behavior)
    if (fIsEditableCell(cellDiv)) {
        return;
    }

    // URL Link Click
    if (fIsUrlLinkCell(cellDiv)) {
        fHandleUrlClick(cellDiv);
        return;
    }

    // Fallback for general clicks on non-interactive cells (optional logging)
    // fMyConsoleLog(`General click on non-interactive cell [${gUI.cellClickInfo.r}, ${gUI.cellClickInfo.c}]`);

} // END fHandleGridClick


// fIsCheckboxClick ////////////////////////////////////////////////////////////////
// Purpose -> Helper to check if the event target is a checkbox input element.
// Inputs  -> target (HTMLElement): The event target element.
// Outputs -> (Boolean): True if target is an <input type="checkbox">.
function fIsCheckboxClick(target) {
    return target.tagName === 'INPUT' && target.type === 'checkbox';
} // END fIsCheckboxClick


// fIsEditableCell /////////////////////////////////////////////////////////////////
// Purpose -> Helper to check if a cell element is contentEditable.
// Inputs  -> cellDiv (HTMLElement): The cell div element.
// Outputs -> (Boolean): True if the cell has the contentEditable attribute set to true.
function fIsEditableCell(cellDiv) {
    // Use optional chaining in case cellDiv is null/undefined
    return cellDiv?.isContentEditable;
} // END fIsEditableCell


// fIsUrlLinkCell //////////////////////////////////////////////////////////////////
// Purpose -> Helper to check if a cell element has the 'url-link' class.
// Inputs  -> cellDiv (HTMLElement): The cell div element.
// Outputs -> (Boolean): True if the cell has the 'url-link' class.
function fIsUrlLinkCell(cellDiv) {
    // Use optional chaining
    return cellDiv?.classList.contains('url-link');
} // END fIsUrlLinkCell


// fHandleDriveLink ////////////////////////////////////////////////////////////////
// Purpose -> Opens Google Drive file links in a new browser tab.
// Inputs  -> url (String): The Google Drive URL.
// Outputs -> None (Opens a new tab).
function fHandleDriveLink(url) {
    fMyConsoleLog(`🖱️ Opening Drive Link in new tab: ${url.substring(0, 100)}...`);
    window.open(url, '_blank');
} // END fHandleDriveLink


// fHandleImageModal ///////////////////////////////////////////////////////////////
// Purpose -> Handles clicks on standard image links (not Drive links) by showing
//            the image in the modal using fShowImageTab.
// Inputs  -> imageUrl (String): The direct URL of the image.
// Outputs -> None (Calls fShowImageTab).
function fHandleImageModal(imageUrl) {
    fMyConsoleLog(`🖱️ Clicked Standard Image Link: ${imageUrl.substring(0, 100)}...`);
    fShowImageTab(imageUrl);
} // END fHandleImageModal


// fShowImageTab ///////////////////////////////////////////////////////////////////
// Purpose -> Displays the image modal with the specified image URL.
// Inputs  -> imageUrl (String): The direct URL of the image to display.
// Outputs -> None (Modifies modal DOM elements).
function fShowImageTab(imageUrl) {
    // console.log("--- fShowImageTab Start ---");
    // console.log(" Image URL:", imageUrl);

    // Validate modal elements are cached
    if (!gUI.modalElement || !gUI.modalImageElement) {
        console.error("Cannot show modal: Modal elements not found in globals.");
        return;
    }
    // console.log("Modal elements found.");
    fMyConsoleLog(`🖼️ Showing image: ${imageUrl.substring(0, 100)}...`);

    // Set the image source
    // console.log("Setting image src...");
    gUI.modalImageElement.src = imageUrl;

    // Display the modal
    // console.log("Setting modal display to flex...");
    gUI.modalElement.style.display = 'flex';
    // console.log("--- fShowImageTab End ---");

} // END fShowImageTab


// fHandleWebLink //////////////////////////////////////////////////////////////////
// Purpose -> Opens non-image, non-Drive web links in a new browser tab.
// Inputs  -> url (String): The web URL.
// Outputs -> None (Opens a new tab).
function fHandleWebLink(url) {
    fMyConsoleLog(`🖱️ Clicked Web Link: ${url.substring(0, 100)}...`);
    window.open(url, '_blank');
} // END fHandleWebLink


// fHandleUrlClick /////////////////////////////////////////////////////////////////
// Purpose -> Determines the type of URL link clicked (Drive, Image, other Web)
//            and routes to the appropriate handler function.
// Inputs  -> cellDiv (HTMLElement): The cell div element that was clicked.
// Outputs -> None (Calls specific URL handler).
function fHandleUrlClick(cellDiv) {
    const originalUrl = cellDiv.dataset.url; // Get URL from data attribute

    // Validate URL exists
    if (!originalUrl) {
        console.warn("Clicked URL link cell, but data-url attribute was missing.", cellDiv);
        return;
    }

    // Determine URL type
    const isDrive = originalUrl.includes('drive.google.com/file/d/');
    const isImage = cellDiv.classList.contains('image-link') && !isDrive;
    const imageUrl = cellDiv.dataset.imageSrc; // Get potential image source

    // Route to handler
    if (isDrive) {
        fHandleDriveLink(originalUrl);
    } else if (isImage && imageUrl) {
        fHandleImageModal(imageUrl);
    } else {
        fHandleWebLink(originalUrl); // Fallback for other web links
    }
} // END fHandleUrlClick




////////////////////////////////////////////////////////////////////////////////////////////////////////// END fHandleGridClick and helpers




// fHandleGridCellEdit /////////////////////////////////////////////////////////////
// Purpose -> Handles the 'blur' event delegated from the grid for contenteditable cells.
//            Updates the underlying data model (gUI.arr) if the cell's text content
//            has changed since it gained focus.
// Inputs  -> event (FocusEvent): The blur event object.
// Outputs -> None (Modifies gUI.arr).
function fHandleGridCellEdit(event) {
    const cellDiv = event.target;

    // === Validate Target Element ===
    // Ensure the event target is a contentEditable cell div
    if (!cellDiv || !cellDiv.classList.contains('cell') || cellDiv.contentEditable !== 'true') {
        return; // Exit if not an editable cell div
    }

    // === Get Coordinates and Values ===
    const r = parseInt(cellDiv.dataset.r, 10);
    const c = parseInt(cellDiv.dataset.c, 10);

    // Validate indices
    if (isNaN(r) || isNaN(c) || r < 0 || c < 0 || !gUI.arr[r]) {
         console.warn("fHandleGridCellEdit: Invalid row/column index from data attributes.", cellDiv.dataset);
         return;
    }

    // Get the new value (current text) and old value (from data model)
    const newValue = cellDiv.textContent;
    const oldValue = String(gUI.arr[r][c] ?? ''); // Coerce old value to string for comparison

    // === Update Data Model (if changed) ===
    if (newValue !== oldValue) {
        gUI.arr[r][c] = newValue; // Update the data model
        fMyConsoleLog(`Cell [${r}, ${c}] changed to: "${newValue}"`);
        // Optional: Add visual feedback or trigger server update later
    }
    // else: Content unchanged, do nothing

} // END fHandleGridCellEdit




////////////////////////////////////////////////////////////////////////////////////////////////////////// START fClearCheckboxesInGridRange and helpers




// fIsValidRangeObject /////////////////////////////////////////////////////////////
// Purpose -> Checks if a given object has the required properties (r1, c1, r2, c2)
//            to be considered a valid range definition object.
// Inputs  -> range (Object): The object to check.
// Outputs -> (Boolean): True if the object is a valid range definition, false otherwise.
function fIsValidRangeObject(range) {
    return range &&
        typeof range.r1 !== 'undefined' &&
        typeof range.c1 !== 'undefined' &&
        typeof range.r2 !== 'undefined' &&
        typeof range.c2 !== 'undefined';
} // END fIsValidRangeObject


// fResolveRangeIndices ////////////////////////////////////////////////////////////
// Purpose -> Converts tag strings or numeric indices within a range definition
//            object into resolved 0-based numeric indices using resolveRow/resolveCol.
// Inputs  -> range (Object): The range definition object {r1, c1, r2, c2}.
// Outputs -> (Object): An object {r1, c1, r2, c2} with resolved numeric indices (or NaN).
function fResolveRangeIndices(range) {
    const r1 = resolveRow(range.r1);
    const c1 = resolveCol(range.c1);
    const r2 = resolveRow(range.r2);
    const c2 = resolveCol(range.c2);
    return { r1, c1, r2, c2 };
} // END fResolveRangeIndices



////////////////////////////////////////////////////////////////////////////////////////////////////////// END fClearCheckboxesInGridRange and helpers




// fCloseAllDropdowns //////////////////////////////////////////////////////////////
// Purpose -> Finds all open menu dropdown panels (elements with class
//            'dropdown-content' and 'show') and removes the 'show' class to hide them.
//            Also resets overflow style on parent main dropdowns.
// Inputs  -> None (Queries DOM).
// Outputs -> None (Modifies DOM element classLists and styles).
function fCloseAllDropdowns() {
  const dropdowns = document.getElementsByClassName("dropdown-content");

  for (let i = 0; i < dropdowns.length; i++) {
    const panel = dropdowns[i];
    // Remove 'show' class to hide the panel
    panel.classList.remove('show');

    // Reset parent's overflow style if it's a main dropdown being closed
    // This prevents submenus from being permanently clipped if closed via window click
    if (!panel.classList.contains('sub-menu') && panel.style.overflowY === 'visible') {
        panel.style.overflowY = 'auto';
    }
  }
} // END fCloseAllDropdowns



// ==========================================================================
// === Tags & Read Write Cells & Range                        (End of Grid Hover) ===
// ==========================================================================


// fSetGridTagsFromHeaders /////////////////////////////////////////////////////////
// Purpose -> Populates gUI.rowTag and gUI.colTag map objects by reading tag strings
//            from column 0 (for rows) and row 0 (for columns) of gUI.arr.
//            Handles comma-separated tags within a single cell.
// Inputs  -> None (Uses gUI.arr).
// Outputs -> None (Modifies gUI.rowTag, gUI.colTag).
function fSetGridTagsFromHeaders() {
    fMyConsoleLog("⚙️ Parsing Grid Tags...");
    gUI.rowTag = {}; // Initialize/clear row tag map
    gUI.colTag = {}; // Initialize/clear column tag map

    const gameArr = gUI.arr;

    // === Validate Data ===
    if (!gameArr || gameArr.length === 0 || !gameArr[0]) {
        console.warn("fSetGridTagsFromHeaders: Cannot parse tags, gUI.arr is empty or malformed.");
        fMyConsoleLog("⚠️ Grid Tags: Data empty.");
        return;
    }

    const rows = gameArr.length;
    const cols = gameArr[0].length;

    // === Process Row Tags (Column 0) ===
    for (let r = 0; r < rows; r++) {
        // Check if value in column 0 is a non-empty string
        const rowCell = gameArr[r]?.[0]; // Use optional chaining for safety
        if (typeof rowCell === 'string' && rowCell) {
            // Split potentially comma-separated tags
            rowCell.split(',').forEach(tag => {
                const trimmedTag = tag.trim();
                // Map the trimmed tag to the current row index (r)
                if (trimmedTag) gUI.rowTag[trimmedTag] = r;
            });
        }
    }

    // === Process Column Tags (Row 0) ===
    const colHeaderRow = gameArr[0]; // Already validated that gameArr[0] exists
    if (colHeaderRow) {
        for (let c = 0; c < cols; c++) {
            // Check if value in row 0 is a non-empty string
            const colCell = colHeaderRow[c];
            if (typeof colCell === 'string' && colCell) {
                // Split potentially comma-separated tags
                colCell.split(',').forEach(tag => {
                    const trimmedTag = tag.trim();
                    // Map the trimmed tag to the current column index (c)
                    if (trimmedTag) gUI.colTag[trimmedTag] = c;
                });
            }
        }
    }

    fMyConsoleLog("✅ Grid Tags Parsed");
} // END fSetGridTagsFromHeaders




// fGetGridValue ///////////////////////////////////////////////////////////////////
// Purpose -> Retrieves a value from gUI.arr using tags or indices. Optionally
//            attempts to convert the retrieved value to a number.
// Inputs  -> rowRef (String|Number): Row tag or 0-based index.
//         -> colRef (String|Number): Column tag or 0-based index.
//         -> asNumber (Boolean): If true, attempt to parse value as a Number (default: false).
// Outputs -> (Any|Number|undefined|NaN): The value from the grid, potentially coerced
//            to a Number, or undefined/NaN if resolution or coercion fails.
function fGetGridValue(rowRef, colRef, asNumber = false) {
    // === Resolve Coordinates ===
    const r = resolveRow(rowRef);
    const c = resolveCol(colRef);

    // Validate resolved indices
    if (isNaN(r) || isNaN(c)) {
        console.warn(`fGetGridValue: Could not resolve (${rowRef}, ${colRef}) to valid indices.`);
        return NaN; // Return NaN for unresolved references
    }

    // === Retrieve Value ===
    const value = gUI.arr?.[r]?.[c];

    // === Handle Empty/Null/Undefined ===
    // Treat empty/null/undefined as 0 if number requested, otherwise undefined
    if (value === undefined || value === null || value === '') {
        return asNumber ? 0 : undefined;
    }

    // === Handle Numeric Conversion (if requested) ===
    if (asNumber) {
        const numValue = Number(value);
        // Check if conversion resulted in NaN
        if (isNaN(numValue)) {
            console.warn(`fGetGridValue: Value at (${rowRef}, ${colRef}) -> [${r}, ${c}] ("${value}") is not a valid number.`);
            return NaN; // Return NaN if conversion failed
        }
        // Return the successfully converted number
        return numValue;
    }

    // === Return Original Value ===
    // If no numeric conversion requested, return the value as is
    return value;
} // END fGetGridValue




// fSetGridValue ///////////////////////////////////////////////////////////////////
// Purpose -> Updates a value in the data model (gUI.arr) and the corresponding
//            cell display in the DOM (gUI.grid2D). Handles special formatting for
//            Meta/Channel Meta cells, and dynamically applies/removes URL styling
//            and attributes based on the new value.
// Inputs  -> rowRef (String|Number): Row tag or 0-based index.
//         -> colRef (String|Number): Column tag or 0-based index.
//         -> newValue (Any): The new value to set.
// Outputs -> (Boolean): True if the update was successful (data and optionally DOM),
//                       false if resolution failed or row/cell doesn't exist.
function fSetGridValue(rowRef, colRef, newValue) {
    // === 1. Resolve Coordinates ===
    const r = resolveRow(rowRef);
    const c = resolveCol(colRef);
    let valueToSet = newValue; // Use a temporary variable

    // Validate resolved indices
    if (isNaN(r) || isNaN(c)) {
        console.warn(`fSetGridValue: Could not resolve (${rowRef}, ${colRef}) to valid indices [${r}, ${c}].`);
        return false;
    }

    // === 2. Validate Row Existence in Data Model ===
    if (!gUI.arr?.[r]) {
        console.warn(`fSetGridValue: Row ${r} does not exist in gUI.arr.`);
        return false;
    }

    // === 3. Handle Special Meta Cell Formatting ===
    const metaRowTags = ['meta', 'chnl'];
    const metaColTags = gUI.list?.metaColor || ['R', 'O', 'Y', 'G', 'B'];
    const isMetaCell = metaRowTags.includes(rowRef) && metaColTags.includes(colRef);
    if (isMetaCell) {
        const numericValue = Number(valueToSet);
        if (valueToSet === null || typeof valueToSet === 'undefined' || (!isNaN(numericValue) && numericValue < 1)) {
            valueToSet = '';
        }
    }

    // === 4. Update Data Model ===
    // Store the potentially modified value (e.g., '' for meta < 1)
    gUI.arr[r][c] = valueToSet;

    // === 5. Update DOM ===
    const cell = gUI.grid2D?.[r]?.[c];
    if (!cell) {
        // Log warning if DOM element wasn't found
        console.warn(`fSetGridValue: Cell element not found in gUI.grid2D at [${r}, ${c}]. Data model updated, DOM not.`);
        // Depending on requirements, you might return false here if DOM update is critical
        return true; // For now, return true as data model was updated
    }

    // === 6. Handle Dynamic URL Styling & Attributes ===
    const valueStr = String(valueToSet ?? '').trim(); // Use string version for checks
    const isUrl = valueStr.startsWith('http://') || valueStr.startsWith('https://');

    if (isUrl) {
        cell.classList.add('url-link');
        cell.dataset.url = valueStr;

        // Check for specific URL types (Drive image or standard image extension)
        const driveMatch = valueStr.match(/drive\.google\.com\/file\/d\/([-\w]+)/);
        const imgExts = /\.(png|jpg|jpeg|gif|webp|svg)$/i;

        if (driveMatch && driveMatch[1]) {
            // Handle Google Drive image link
            const fileId = driveMatch[1];
            const imageUrl = 'https://drive.google.com/uc?export=view&id=' + fileId;
            cell.classList.add('image-link');
            cell.dataset.imageSrc = imageUrl;
        } else if (imgExts.test(valueStr)) {
            // Handle standard image link (by extension)
            cell.classList.add('image-link');
            cell.dataset.imageSrc = valueStr;
        } else {
            // It's a URL, but not identified as an image link - remove image attributes
            cell.classList.remove('image-link');
            delete cell.dataset.imageSrc; // Use delete operator for dataset properties
        }
    } else {
        // Not a URL - remove all link-related classes and attributes
        cell.classList.remove('url-link', 'image-link');
        delete cell.dataset.url;
        delete cell.dataset.imageSrc;
    }

    // === 7. Update Cell Visual Content ===
    const checkbox = cell.querySelector('input[type="checkbox"]');
    const dropdown = cell.querySelector('select.grid-dropdown');

    if (checkbox) {
        // Update checkbox state
        const valUpper = String(valueToSet).toUpperCase();
        checkbox.checked = valueToSet === true || valUpper === "TRUE";
    } else if (dropdown) {
        // Update dropdown selection
        dropdown.value = String(valueToSet ?? '');
    } else {
        // Update text content (stripping ID if present)
        // Ensure the correct value (valueToSet) is used here
        const idPattern = /\s{2,}_\w{6}$/;
        const text = (typeof valueToSet === 'string' && idPattern.test(valueToSet))
                     ? valueToSet.replace(idPattern, '')
                     : valueToSet;
        cell.textContent = text ?? ''; // Use empty string for null/undefined
    }

    // Optional log: fMyConsoleLog(`Grid updated [${r}, ${c}] = ${valueToSet}`);
    return true; // Indicate success (data and DOM updated)

} // END fSetGridValue




// fSetRangeValues /////////////////////////////////////////////////////////////////
// Purpose -> Updates values in a specified grid range (both gUI.arr and DOM) using
//            either a single value (fill) or a 1D/2D array matching the range dimensions.
// Inputs  -> r1Ref (String|Number): Starting row tag or 0-based index.
//         -> c1Ref (String|Number): Starting column tag or 0-based index.
//         -> r2Ref (String|Number): Ending row tag or 0-based index.
//         -> c2Ref (String|Number): Ending column tag or 0-based index.
//         -> valueOrArray (Array|Any): 1D/2D array matching range dimensions, OR a single value.
// Outputs -> (Boolean): True if all updates were successful, false otherwise.
function fSetRangeValues(r1Ref, c1Ref, r2Ref, c2Ref, valueOrArray) {
    fMyConsoleLog(`⚙️ Setting range values: ${r1Ref},${c1Ref} to ${r2Ref},${c2Ref}...`);

    // === 1. Resolve Indices & Validate ===
    const r1 = resolveRow(r1Ref);
    const c1 = resolveCol(c1Ref);
    const r2 = resolveRow(r2Ref);
    const c2 = resolveCol(c2Ref);

    if ([r1, c1, r2, c2].some(isNaN)) {
        console.warn(`fSetRangeValues: Could not resolve one or more references: (${r1Ref}, ${c1Ref}, ${r2Ref}, ${c2Ref}) -> (${r1}, ${c1}, ${r2}, ${c2}).`);
        fMyConsoleLog(`❌ fSetRangeValues failed: Invalid range references.`);
        return false;
    }

    // === 2. Determine Mode (Fill vs Array) ===
    const isSingleValueFill = !Array.isArray(valueOrArray);
    const singleFillValue = isSingleValueFill ? valueOrArray : null;
    const newValArr = isSingleValueFill ? null : valueOrArray;

    if (isSingleValueFill) {
        fMyConsoleLog(`   -> Mode: Single value fill ('${singleFillValue}')`);
    } else {
        fMyConsoleLog(`   -> Mode: Array mapping`);
    }

    // === 3. Determine Range Dimensions ===
    const rMin = Math.min(r1, r2);
    const rMax = Math.max(r1, r2);
    const cMin = Math.min(c1, c2);
    const cMax = Math.max(c1, c2);
    const rangeRows = rMax - rMin + 1;
    const rangeCols = cMax - cMin + 1;

    // === 4. Validate Input Array Dimensions (if not filling) ===
    if (!isSingleValueFill) {
        let arrRows = 0;
        let arrCols = 0;

        if (newValArr.length > 0) {
            const isInputArray2D = Array.isArray(newValArr[0]);
            if (isInputArray2D) {
                // Handle 2D array input
                arrRows = newValArr.length;
                arrCols = newValArr[0]?.length || 0; // Handle empty inner array edge case
                // Check for consistent column lengths in 2D array
                if (!newValArr.every(row => Array.isArray(row) && row.length === arrCols)) {
                    console.warn(`fSetRangeValues: Input 2D array has inconsistent column lengths.`);
                    fMyConsoleLog(`❌ fSetRangeValues failed: Input 2D array malformed.`);
                    return false;
                }
            } else {
                // Handle 1D array input (assume it matches either row or column count)
                if (rangeRows === 1) { // Target is a single row
                    arrRows = 1;
                    arrCols = newValArr.length;
                } else if (rangeCols === 1) { // Target is a single column
                    arrRows = newValArr.length;
                    arrCols = 1;
                } else {
                    // Ambiguous: Target is multi-row/col but input is 1D
                    // Defaulting to matching columns if range is wider than tall, else rows
                    if(rangeCols >= rangeRows) {
                        arrRows = 1;
                        arrCols = newValArr.length;
                    } else {
                         arrRows = newValArr.length;
                         arrCols = 1;
                    }
                    console.warn(`fSetRangeValues: Ambiguous 1D array input for multi-dimensional range (${rangeRows}x${rangeCols}). Assuming ${arrRows}x${arrCols}.`);
                }
            }
        }
        // Else: newValArr is empty array, dimensions remain 0

        // Check if calculated array dimensions match range dimensions
        if (rangeRows !== arrRows || rangeCols !== arrCols) {
            console.warn(`fSetRangeValues: Dimension mismatch. Range: ${rangeRows}x${rangeCols}, Array: ${arrRows}x${arrCols}.`);
            fMyConsoleLog(`❌ fSetRangeValues failed: Dimension mismatch.`);
            return false;
        }
    } // End array dimension validation

    // === 5. Update Data and DOM ===
    let updateCount = 0;
    let updateErrors = 0;
    for (let r = rMin; r <= rMax; r++) {
        // Skip if row doesn't exist in data model or DOM cache
        if (!gUI.arr[r] || !gUI.grid2D[r]) {
            console.warn(`fSetRangeValues: Row ${r} does not exist in gUI.arr or gUI.grid2D. Skipping row.`);
            updateErrors += rangeCols; // Count all columns in this row as errors
            continue;
        }

        for (let c = cMin; c <= cMax; c++) {
            let newValue;
            // Determine the value to set based on mode
            if (isSingleValueFill) {
                newValue = singleFillValue;
            } else {
                // Calculate corresponding index in newValArr based on dimensions
                const arrRowIdx = (rangeRows === 1) ? 0 : r - rMin;
                const arrColIdx = (rangeCols === 1) ? 0 : c - cMin;
                newValue = Array.isArray(newValArr[0])
                         ? newValArr[arrRowIdx]?.[arrColIdx] // 2D access
                         : (rangeCols === 1 ? newValArr[arrRowIdx] : newValArr[arrColIdx]); // 1D access (column or row)
            }

            // Update data model and DOM using fSetGridValue (handles DOM types)
            if (!fSetGridValue(r, c, newValue)) {
                // fSetGridValue logs specific errors
                updateErrors++;
            } else {
                updateCount++;
            }
        } // End col loop
    } // End row loop

    fMyConsoleLog(`✅ fSetRangeValues: ${isSingleValueFill ? 'Filled' : 'Updated'} ${updateCount} cells. ${updateErrors > 0 ? `(${updateErrors} errors)` : ''}`);
    return updateErrors === 0; // Return true only if no errors occurred

} // END fSetRangeValues



// ==========================================================================
// === Sidebar                       (End of Read Write Cell & Range) ===
// ==========================================================================




// fPrependToSidebar ///////////////////////////////////////////////////////////////
// Purpose -> Prepends a message (HTML) as a new paragraph (<p>) to the sidebar
//            content area (#sidebar-content). Also adds a plain text version to
//            gUI.plainTextLogEntries for GMScreen updates.
// Inputs  -> htmlMessage (String): The HTML content to prepend to the sidebar display.
//         -> plainTextMessage (String): The plain text version to add to the log array.
// Outputs -> None (Modifies DOM and gUI.plainTextLogEntries).
function fPrependToSidebar(htmlMessage, plainTextMessage = null) {
    const sidebarContent = document.getElementById('sidebar-content');
    // Validate sidebar element
    if (!sidebarContent) {
        console.error("fPrependToSidebar: Cannot find sidebar content element (#sidebar-content).");
        return;
    }

    // --- Handle DOM Update ---
    // Remove initial placeholder paragraph if it exists
    const placeholder = sidebarContent.querySelector('p');
    if (placeholder && placeholder.textContent === 'Roll log entries will appear here...') {
        placeholder.remove();
    }

    // Create and prepend the new HTML entry
    const newEntry = document.createElement('p');
    newEntry.innerHTML = htmlMessage; // Use innerHTML to render HTML tags
    sidebarContent.prepend(newEntry);
    // Scroll the sidebar content area to the top to show the latest entry
    sidebarContent.scrollTop = 0;

    // --- Handle Plain Text Log Array Update ---
    // If plainTextMessage wasn't provided, attempt to derive it from htmlMessage
    // This is a basic fallback - ideally plain text should always be generated alongside HTML
    const textToLog = (plainTextMessage !== null)
                      ? plainTextMessage
                      : htmlMessage.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '').trim(); // Basic strip tags and convert <br>

    // Push the plain text version to the log array
    gUI.plainTextLogEntries.push(textToLog);

    // Save Turbo text to Firestore
    fHandleAutoSaveTextData();

    // --- Optional: Immediate GMScreen Update (Consider using throttle/debounce if called too often) ---
    // fSendLogToGMScreenNPS(); // Direct call - we'll add calls at end-of-action instead

} // END fPrependToSidebar




// fRollLogMsg /////////////////////////////////////////////////////////////////////
// Purpose -> Logs a warning message to the console and prepends it to the sidebar,
//            ensuring the sidebar is visible. Used for roll-related warnings/errors.
// Inputs  -> msg (String): Message to display.
// Outputs -> None (Logs to console, calls fPrependToSidebar, fShowSidebar).
function fRollLogMsg(msg) {
    // Only proceed if a message is provided
    if (msg) {
        console.warn(msg); // Log as warning
        fPrependToSidebar(msg); // Add message to sidebar
        fShowSidebar(); // Ensure sidebar is visible
    }
} // END fRollLogMsg




// fShowSidebar ////////////////////////////////////////////////////////////////////
// Purpose -> Makes the Roll Log sidebar visible by adding the 'show' class.
// Inputs  -> None.
// Outputs -> None (Modifies sidebar element's classList).
function fShowSidebar() {
    const sidebar = document.getElementById('roll-log-sidebar');

    // Add 'show' class only if the sidebar exists and isn't already shown
    if (sidebar && !sidebar.classList.contains('show')) {
        sidebar.classList.add('show');
        fMyConsoleLog("▶️ Sidebar Shown");
    } else if (!sidebar) {
        console.error("fShowSidebar: Cannot find sidebar element (#roll-log-sidebar).");
    }
    // else: Sidebar exists and is already shown, do nothing.
} // END fShowSidebar




// fHideSidebar ////////////////////////////////////////////////////////////////////
// Purpose -> Hides the Roll Log sidebar by removing the 'show' class.
// Inputs  -> None.
// Outputs -> None (Modifies sidebar element's classList).
function fHideSidebar() {
    const sidebar = document.getElementById('roll-log-sidebar');

    // Remove 'show' class only if the sidebar exists and is currently shown
    if (sidebar && sidebar.classList.contains('show')) {
        sidebar.classList.remove('show');
        fMyConsoleLog("◀️ Sidebar Hidden");
    } else if (!sidebar) {
        console.error("fHideSidebar: Cannot find sidebar element (#roll-log-sidebar).");
    }
    // else: Sidebar exists and is already hidden, or doesn't exist, do nothing.
} // END fHideSidebar




// fHandleApplyWoundsClick ///////////////////////////////////////////////////////
// Purpose -> Handles clicks on the dynamically added "Apply" wounds button in the
//            sidebar. Reads the wound amount from the button's data attribute,
//            adds it to the current 1st Degree Wounds cell ('VitTbl', 'vit1st'),
//            updates the grid, recalculates Vit Now/Percent, and disables the button.
// Inputs  -> event (MouseEvent): The click event object.
// Outputs -> None (Modifies grid data/DOM via helpers, updates button state).
async function fHandleApplyWoundsClick(event) {
    const button = event.target; // The element that was actually clicked

    // === Validate Button and State ===
    if (!button || !button.classList.contains('apply-wounds-btn')) {
        return; // Click was not on an apply button
    }
    fMyConsoleLog(`🖱️ Sidebar 'Apply Wounds' Button Clicked...`);

    // Prevent double-clicks
    if (button.disabled) {
        fMyConsoleLog("   -> Button already disabled. Ignoring click.");
        return;
    }
    button.disabled = true; // Disable immediately
    button.textContent = 'Applied'; // Change button text

    // === Get Wound Amount ===
    const woundAmountStr = button.dataset.woundAmount;
    const woundAmount = Number(woundAmountStr); // Get amount from data attribute
    if (isNaN(woundAmount) || woundAmount < 0) { // Validate amount
        console.error(`Invalid wound amount stored on button: ${woundAmountStr}`);
        fMyConsoleLog(`❌ Error applying wounds: Invalid amount '${woundAmountStr}'.`);
        await fShowMessage("Error: Could not read a valid wound amount from the button.");
        // Keep button disabled on error? Or re-enable? Currently keeps disabled.
        return;
    }
    fMyConsoleLog(`   -> Wound Amount to Apply: ${woundAmount}`);

    // === Get Current Wounds ===
    const targetRow = 'VitTbl';
    const targetCol = 'vit1st';
    let currentVit1st = fGetGridValue(targetRow, targetCol, true); // Get as number
    if (isNaN(currentVit1st)) {
        fMyConsoleLog(`   -> Warning: Current value in ('${targetRow}', '${targetCol}') is not a number. Treating as 0.`);
        currentVit1st = 0; // Default to 0 if current value is invalid/empty
    }
    fMyConsoleLog(`   -> Current 1st Degree Wounds: ${currentVit1st}`);

    // === Calculate and Update Grid ===
    const newWoundValue = Math.round(currentVit1st + woundAmount); // Apply wounds
    fMyConsoleLog(`   -> Calculated New 1st Degree Wounds: ${newWoundValue}`);

    if (!fSetGridValue(targetRow, targetCol, newWoundValue)) {
        fMyConsoleLog(`❌ Error applying wounds: fSetGridValue failed for ('${targetRow}', '${targetCol}').`);
        await fShowMessage("Error: Failed to update the 1st Degree Wounds cell.");
        // Button remains disabled here as well.
        return;
    }

    // === Update Dependent Cells ===
    fMyConsoleLog("   -> Recalculating Vit Now & Percent...");
    await fVitNowNPercent_Calc(); // Update Vit Now and Vit Now Percent cells

    // Post text to Firestore
    fHandleAutoSaveTextData();

    fMyConsoleLog("✅ Wounds Applied Successfully.");
} // END fHandleApplyWoundsClick




// fSetupSidebarActionListeners //////////////////////////////////////////////////
// Purpose -> Sets up a delegated event listener on the sidebar content area
//            (#sidebar-content) to handle clicks on interactive elements within it,
//            such as 'Apply Wounds', 'Prep AR', and 'Prep Dmg' buttons.
// Inputs  -> None.
// Outputs -> None (Attaches event listener).
function fSetupSidebarActionListeners() {
    fMyConsoleLog("🖱️ Setting up Sidebar Action Listeners...");
    const sidebarContent = document.getElementById('sidebar-content');

    // Validate sidebar content element exists
    if (!sidebarContent) {
        console.error("fSetupSidebarActionListeners: Cannot setup listeners - #sidebar-content element not found.");
        fMyConsoleLog("⚠️ Sidebar Action Listeners NOT Attached (content area missing).");
        return;
    }

    // Add single delegated listener to the content area
    sidebarContent.addEventListener('click', (event) => {
        const target = event.target; // The actual element clicked

        // Route click based on button class
        if (target.classList.contains('apply-wounds-btn')) {
            fHandleApplyWoundsClick(event); // Handle 'Apply Wounds'
        } else if (target.classList.contains('prep-ar-btn')) {
            fHandlePrepARClick(event);      // Handle 'Prep AR'
        } else if (target.classList.contains('prep-dmg-btn')) {
            fHandlePrepDmgClick(event);     // Handle 'Prep Dmg'
        }
        // Add other 'else if' blocks here for future interactive sidebar elements
    });

    fMyConsoleLog("✅ Sidebar Action Listeners Attached.");
} // END fSetupSidebarActionListeners




// fHandleUpdateHeaderInfo ///////////////////////////////////////////////////////
// Purpose -> Handles the "Update (Level, Slot, Names)" menu action. Fetches fresh
//            header data, validates it (especially slotNum), updates gUI.characterInfo,
//            and triggers a log refresh if successful.
// Inputs  -> None.
// Outputs -> (Promise<void>): Resolves after completing actions or handling errors.
async function fHandleUpdateHeaderInfo() {
    fMyConsoleLog("⚙️ Menu Action: Update Header Info Triggered...");

    // Add visual feedback maybe? (e.g., temporary button text change?)

    fMyConsoleLog("   -> Requesting fresh Character Header Data...");
    google.script.run
        .withSuccessHandler((headerData) => {
            fMyConsoleLog("   -> Received fresh Character Header Data.");

            // Validate the response structure
            if (!headerData || typeof headerData !== 'object' || headerData.error) {
                const errMsg = headerData?.message || "Invalid header data structure received during update.";
                console.error("fHandleUpdateHeaderInfo Error:", errMsg, headerData);
                fMyConsoleLog(`   -> ❌ Update failed: ${errMsg}`);
                fShowMessage(`Error updating header data: ${errMsg}`).catch(e => console.error("Error showing message:", e));
                return; // Stop processing on invalid data structure
            }

            // Validate Slot Number specifically
            const receivedSlotNum = headerData.slotNum ?? null;
            if (!receivedSlotNum || typeof receivedSlotNum !== 'string' || !receivedSlotNum.startsWith('Slot')) {
                 const slotErrorMsg = "Error: Invalid or missing Slot # found on RaceClass tab. Cannot save log updates.";
                 fMyConsoleLog(`   -> ❌ Update failed: ${slotErrorMsg}`);
                 fShowMessage(slotErrorMsg).catch(e => console.error("Error showing message:", e));
                 return; // Stop processing if Slot Number is invalid
            }

            // --- Update Successful & Valid ---
            // Update the global character info object
            gUI.characterInfo = {
                slotNum: receivedSlotNum, // Store validated slot number
                raceClass: headerData.raceClass ?? '',
                level: headerData.level ?? '',
                playerName: headerData.playerName ?? '',
                charName: headerData.charName ?? ''
            };
            fMyConsoleLog(`   -> gUI.characterInfo updated: ${JSON.stringify(gUI.characterInfo)}`);

            // Find and click the sidebar refresh button
            const refreshButton = document.getElementById('sidebar-refresh-log-btn');
            if (refreshButton) {
                fMyConsoleLog("   -> Simulating click on sidebar refresh button...");
                refreshButton.click(); // Trigger the log send with updated info
            } else {
                 fMyConsoleLog("   -> ⚠️ Could not find sidebar refresh button (#sidebar-refresh-log-btn) to click.");
                 // Optionally show a message that refresh couldn't be triggered automatically
            }

            // Show success message to the user
            fShowMessage("✅ Header Info Updated.").catch(e => console.error("Error showing message:", e));

        })
        .withFailureHandler((error) => {
            // Handle transport errors
            const errorMsg = `Failed to call server for header update: ${error.message}`;
            console.error(errorMsg, error);
            fMyConsoleLog(`   -> ❌ ${errorMsg}`);
            fShowMessage(`Error updating header data: ${error.message}`).catch(e => console.error("Error showing message:", e));
        })
        .fGetCharacterHeaderData(gIndexCSID); // Call the existing server function

} // END fHandleUpdateHeaderInfo


// ==========================================================================
// === Menu Bar Setup                 (End of Sidebar) ===
// ==========================================================================



// fSetupMenuButtonListeners ///////////////////////////////////////////////////////
// Purpose -> Adds click event listeners to the main menu bar buttons (Nish, Roll,
//            Free, Luck, Game, Gear). Defines the logic for each button click,
//            including complex precedence for the 'Roll' button (Chaos -> Ad-Hoc -> Ability).
// Inputs  -> btnNish, btnRoll, btnFree, btnLuck, btnGame, dropdownGame, btnGear, dropdownGear (HTMLElements)
// Outputs -> None (Attaches event listeners).
function fSetupMenuButtonListeners(btnNish, btnRoll, btnFree, btnLuck, btnGame, dropdownGame, btnGear, dropdownGear) {

    // === Nish Button Listener ===
    btnNish.addEventListener('click', fHandleNishButtonClick);

    // === Roll Button Listener ===
    btnRoll.addEventListener('click', async (event) => {
        event.stopPropagation(); // Prevent event from bubbling up
        fCloseAllDropdowns();    // Ensure menus are closed
        fSetButtonOrMenuState('Roll'); // Set initial state for this action chain

        const { r: lastClickR, c: lastClickC } = gUI.cellClickInfo; // Coords of last grid cell click
        const { r: checked_r, c: checked_c } = gUI.currentSkRadioChecked; // Coords of currently checked Sk radio
        let handled = false; // Flag to track if an action was taken
        let currentCellTextForAdHoc = null; // Store cell text if needed for ad-hoc

        // --- Action Precedence ---
        // 1. Check for Chaos Gem click first
        if (lastClickR !== null && lastClickC !== null) {
            fMyConsoleLog(`   -> <Roll> Click: Checking Chaos Gem for last clicked cell [${lastClickR}, ${lastClickC}]...`);
            handled = await fHandleChaosGemClick(lastClickR, lastClickC);
            if (handled) {
                fMyConsoleLog("   -> <Roll> Click: Chaos Gem action completed.");
            }
        } else {
            fMyConsoleLog("   -> <Roll> Click: No previous cell click info for Chaos Gem check.");
        }

        // 2. If not Chaos, check for Ad-Hoc roll (if click was outside restricted areas)
        if (!handled && lastClickR !== null && lastClickC !== null) {
            fMyConsoleLog("   -> <Roll> Click: No Chaos Gem used. Checking for Ad-Hoc roll eligibility...");
            const chaosRangeArray = gUI.range?.chaosGems ? [gUI.range.chaosGems] : [];
            const abilityRangeArray = gUI.range?.entireAbiliyNGearTables || [];
            const isChaosCell = fIsCellInRangeArray(lastClickR, lastClickC, chaosRangeArray);
            const isAbilityCell = fIsCellInRangeArray(lastClickR, lastClickC, abilityRangeArray);

            // Only attempt ad-hoc if click was NOT in Chaos or Ability/Gear tables
            if (!isChaosCell && !isAbilityCell) {
                fMyConsoleLog(`   -> Click [${lastClickR}, ${lastClickC}] is outside Chaos/Ability tables. Attempting ad-hoc parse...`);
                // Read current text directly from DOM cell
                const cellElement = gUI.grid2D?.[lastClickR]?.[lastClickC];
                if (cellElement) {
                    currentCellTextForAdHoc = cellElement.textContent?.trim() ?? '';
                    gUI.cellClickInfo.focusText = currentCellTextForAdHoc; // Store for potential error message
                    fMyConsoleLog(`      -> Read current text: "${currentCellTextForAdHoc}", stored in focusText.`);
                    handled = await fHandleAdHocRoll(currentCellTextForAdHoc); // Attempt the roll
                } else {
                    fMyConsoleLog(`      -> Could not find cell element [${lastClickR}, ${lastClickC}] to read current text.`);
                    gUI.cellClickInfo.focusText = null; // Clear if element not found
                }

                if (handled) {
                    fMyConsoleLog("    -> <Roll> Click: Ad-Hoc roll completed.");
                } else {
                    fMyConsoleLog("   -> <Roll> Click: Ad-Hoc roll pattern not found in cell text.");
                }
            } else {
                fMyConsoleLog(`   -> Click [${lastClickR}, ${lastClickC}] is inside restricted Chaos/Ability table. Skipping ad-hoc roll.`);
                gUI.cellClickInfo.focusText = null; // Clear if not applicable
            }
        } else if (!handled) {
            // Log if ad-hoc wasn't checked due to missing click info
            fMyConsoleLog("   -> <Roll> Click: No last cell click info for ad-hoc roll check.");
            gUI.cellClickInfo.focusText = null;
        } else {
            // Clear focusText if Chaos Gem handled the click
            gUI.cellClickInfo.focusText = null;
        }

        // 3. If not Chaos or Ad-Hoc, check for standard Ability roll (Sk checkbox checked)
        if (!handled && checked_r !== null) {
            fMyConsoleLog(`   -> <Roll> Click: No Chaos/Ad-Hoc handled. Active Sk checkbox [${checked_r}, ${checked_c}] found. Triggering standard roll action...`);
            await fHandleRollDiceAction(); // Call the main ability roll handler
            handled = true; // Mark as handled
        } else if (!handled && checked_r === null) {
            fMyConsoleLog("   -> <Roll> Click: No Chaos/Ad-Hoc handled and no Ability checkbox checked.");
        }

        // 4. Show Message if Nothing Was Handled
        if (!handled) {
            fMyConsoleLog("   -> <Roll> Click: No Chaos Gem, Ad-Hoc Roll, or Ability Checkbox action taken.");
            let adHocAttemptedButFailed = (gUI.cellClickInfo.focusText !== null); // Ad-hoc was attempted if focusText was set

            if (adHocAttemptedButFailed) {
                await fShowMessage(`Nothing rollable found in cell "${gUI.cellClickInfo.focusText || ''}"`);
            } else {
                await fShowMessage("Click an Ability checkbox, a usable Chaos Crystal, or a cell with dice notation (e.g., d6, sk20) first!");
            }
            fSetButtonOrMenuState(null); // Reset button state if nothing handled
        } else {
            // If handled by Chaos or Ad-Hoc, reset state immediately.
            // If handled by Ability roll, state reset happens within fHandleRollDiceAction.
            const wasAbilityRoll = (checked_r !== null);
            if (!wasAbilityRoll) {
                fSetButtonOrMenuState(null);
            }
        }
    }); // END Roll Button Listener

    // === Free Button Listener ===
    btnFree.addEventListener('click', (event) => {
        event.stopPropagation();
        fCloseAllDropdowns();
        fSetButtonOrMenuState('Free'); // Set state
        fHandleRollDiceAction();       // Trigger main roll handler
    });

    // === Luck Button Listener ===
    btnLuck.addEventListener('click', (event) => {
        event.stopPropagation();
        fCloseAllDropdowns();
        fSetButtonOrMenuState('Luck'); // Set state
        fHandleRollDiceAction();       // Trigger main roll handler
    });

    // === Game Menu Button Listener ===
    btnGame.addEventListener('click', (event) => {
        event.stopPropagation(); // Prevent window click listener from closing immediately
        const currentlyShown = dropdownGame.classList.contains('show');
        fCloseAllDropdowns(); // Close any other open menus
        // Toggle the Game dropdown
        if (!currentlyShown) {
            dropdownGame.classList.add('show');
        }
    });

    // === Gear Menu Button Listener ===
    btnGear.addEventListener('click', (event) => {
        event.stopPropagation(); // Prevent window click listener from closing immediately
        const currentlyShown = dropdownGear.classList.contains('show');
        fCloseAllDropdowns(); // Close any other open menus
        // Toggle the Gear dropdown
        if (!currentlyShown) {
            dropdownGear.classList.add('show');
        }
    });

} // END fSetupMenuButtonListeners




// fSetButtonOrMenuState ///////////////////////////////////////////////////////////
// Purpose -> Sets the state flags within gUI.buttonOrMenu (isNish, isRoll, etc.)
//            to indicate which button/menu item initiated the current roll action.
//            Resets all flags to false before setting the specified one.
// Inputs  -> buttonType (String | null): Type name ('Nish', 'Roll', 'Free', 'Luck')
//                                         or null to reset all flags.
// Outputs -> None (Modifies gUI.buttonOrMenu).
function fSetButtonOrMenuState(buttonType) {
    // Map input type string to the corresponding property name in gUI.buttonOrMenu
    const validTypes = {
        'Nish': 'isNish',
        'Roll': 'isRoll',
        'Free': 'isFree',
        'Luck': 'isLuck'
        // Add other mappings here if needed later
    };

    // Reset all flags to false initially
    for (const key in gUI.buttonOrMenu) {
        if (Object.hasOwnProperty.call(gUI.buttonOrMenu, key)) {
            gUI.buttonOrMenu[key] = false;
        }
    }

    // Set the specific flag to true if a valid type is provided
    if (buttonType && validTypes[buttonType]) {
        const flagToSet = validTypes[buttonType];
        gUI.buttonOrMenu[flagToSet] = true;
        fMyConsoleLog(`🚦 Button/Menu State Set: ${flagToSet} = true`);
    } else if (buttonType === null) {
        // If buttonType is null, reset is intended (already done)
        fMyConsoleLog("🚦 Button/Menu State Reset (all flags false).");
    } else {
        // Log warning if an invalid type string was passed
        console.warn(`fSetButtonOrMenuState: Invalid buttonType provided: ${buttonType}`);
        fMyConsoleLog(`🚦 Button/Menu State: Invalid type '${buttonType}', all flags remain false.`);
    }

} // END fSetButtonOrMenuState


// fSetupWindowClickListener ///////////////////////////////////////////////////////
// Purpose -> Adds a global click listener to the window. If a click occurs outside
//            of the main menu bar buttons or dropdown menu items, it closes all
//            currently open dropdown menus by calling fCloseAllDropdowns.
// Inputs  -> None.
// Outputs -> None (Attaches event listener).
function fSetupWindowClickListener() {
    window.addEventListener('click', (event) => {
        // Check if the click target is outside the menu bar buttons and dropdown items
        if (event.target && !event.target.closest('.menu-item') && !event.target.closest('#menu-bar > button')) {
            // If click is outside, close all dropdowns
            fCloseAllDropdowns();
        }
    });
} // END fSetupWindowClickListener




////////////////////////////////////////////////////////////////////////////////////////////////////////// START fSetupSubMenuHover and helpers




// fSetupSubMenuHover //////////////////////////////////////////////////////////////
// Purpose -> Sets up hover event listeners for all submenu items within a given
//            menu bar to handle showing/hiding nested dropdown menus with delays.
// Inputs  -> menuBar (HTMLElement): The main menu bar container element.
// Outputs -> None (Attaches event listeners via fSetupSingleSubMenuItem).
function fSetupSubMenuHover(menuBar) {
    if (!menuBar) return;

    // Find all elements that represent items containing submenus
    const subMenuItems = menuBar.querySelectorAll('.sub-menu-item');

    // Attach hover logic to each submenu item found
    subMenuItems.forEach((item, index) => {
        fSetupSingleSubMenuItem(item, index);
    });
} // END fSetupSubMenuHover



// fClearHideTimeout ///////////////////////////////////////////////////////////////
// Purpose -> Clears any active 'hide' timeout associated with a submenu panel.
//            Reads the timeout ID from the panel's dataset.
// Inputs  -> panel (HTMLElement): The submenu panel element.
// Outputs -> None (Clears timeout, modifies panel's dataset).
function fClearHideTimeout(panel) {
    // Get timeout ID stored on the element, default to 0 if not found/invalid
    const timeoutId = parseInt(panel.dataset.hideTimeoutId || '0');

    // If a valid timeout ID exists, clear it and remove from dataset
    if (timeoutId) {
        clearTimeout(timeoutId);
        panel.dataset.hideTimeoutId = ''; // Reset dataset property
    }
} // END fClearHideTimeout



// fIsAnySiblingSubmenuOpen ////////////////////////////////////////////////////////
// Purpose -> Checks if any sibling submenu items (relative to the provided item)
//            currently have their submenu panels open (i.e., contain the 'show' class).
// Inputs  -> item (HTMLElement): The reference submenu item element.
// Outputs -> (Boolean): True if any sibling submenu is open, false otherwise.
function fIsAnySiblingSubmenuOpen(item) {
    const parent = item.parentElement; // Get the container of the submenus
    if (!parent) return false; // Cannot check siblings if no parent

    // Get all sibling elements that are also submenu items
    const siblings = Array.from(parent.children).filter(el =>
        el !== item && el.classList.contains('sub-menu-item')
    );

    // Check if any sibling has a submenu panel with the 'show' class
    return siblings.some(sibling => {
        const siblingPanel = sibling.querySelector('.dropdown-content.sub-menu');
        return siblingPanel && siblingPanel.classList.contains('show');
    });
} // END fIsAnySiblingSubmenuOpen




// fStartHideTimeout ///////////////////////////////////////////////////////////////
// Purpose -> Sets a timeout (default 250ms) to hide a submenu panel. Before hiding,
//            checks if the parent dropdown's overflow style needs to be restored
//            (only if no other sibling submenus are currently open).
// Inputs  -> item (HTMLElement): The submenu item element.
//         -> panel (HTMLElement): The submenu panel element to hide.
//         -> mainDropdown (HTMLElement | null): The parent dropdown panel element.
//         -> delayMs (Number): Delay in milliseconds before hiding (default 250).
// Outputs -> None (Sets timeout, potentially modifies mainDropdown style, modifies panel classList).
function fStartHideTimeout(item, panel, mainDropdown, delayMs = 250) {
    // Clear any previously set hide timeout for this panel
    fClearHideTimeout(panel);

    // Set a new timeout to hide the panel
    const timeoutId = setTimeout(() => {
        // Before hiding, check if parent overflow needs resetting
        // (Avoids clipping if mouse moves quickly between sibling submenus)
        if (mainDropdown && !fIsAnySiblingSubmenuOpen(item)) {
            mainDropdown.style.overflowY = 'auto'; // Restore default overflow
        }
        // Hide the panel by removing the 'show' class
        panel.classList.remove('show');
    }, delayMs); // Use the specified delay

    // Store the timeout ID on the panel element's dataset
    panel.dataset.hideTimeoutId = timeoutId;
} // END fStartHideTimeout




// fSetupSingleSubMenuItem /////////////////////////////////////////////////////////
// Purpose -> Attaches mouseenter/mouseleave event listeners to a single submenu item
//            and its corresponding submenu panel to manage showing/hiding with delays.
// Inputs  -> item (HTMLElement): The submenu item element (.sub-menu-item).
//         -> index (Number): Index (for logging/debugging purposes).
// Outputs -> None (Attaches event listeners).
function fSetupSingleSubMenuItem(item, index) {
    // === Get Element References ===
    const triggerLink = item.querySelector('a'); // Link that triggers the submenu
    const subMenuPanel = item.querySelector('.dropdown-content.sub-menu'); // The submenu panel itself
    const mainDropdown = item.closest('.dropdown-content:not(.sub-menu)'); // The parent dropdown panel

    // Exit if no submenu panel exists for this item
    if (!subMenuPanel) return;

    // Warn if the parent dropdown wasn't found (indicates potential structure issue)
    if (!mainDropdown && triggerLink) {
        console.warn(`fSetupSingleSubMenuItem Item ${index} (${triggerLink?.textContent}): Could not find parent main dropdown!`);
    }

    // === Attach Event Listeners ===

    // --- Mouse Enter Item ---
    // Show submenu immediately, clear hide timer, ensure parent allows overflow
    item.addEventListener('mouseenter', () => {
        fClearHideTimeout(subMenuPanel);
        if (mainDropdown) mainDropdown.style.overflowY = 'visible'; // Allow overflow
        subMenuPanel.classList.add('show');
    });

    // --- Mouse Leave Item ---
    // Start timer to hide the submenu
    item.addEventListener('mouseleave', () => {
        fStartHideTimeout(item, subMenuPanel, mainDropdown);
    });

    // --- Mouse Enter Submenu Panel ---
    // If mouse moves directly onto the submenu panel, keep it open (clear hide timer)
    subMenuPanel.addEventListener('mouseenter', () => {
        fClearHideTimeout(subMenuPanel);
    });

    // --- Mouse Leave Submenu Panel ---
    // If mouse leaves the submenu panel itself, start timer to hide it
    subMenuPanel.addEventListener('mouseleave', () => {
        fStartHideTimeout(item, subMenuPanel, mainDropdown);
    });
} // END fSetupSingleSubMenuItem




////////////////////////////////////////////////////////////////////////////////////////////////////////// End fSetupSubMenuHover and helpers




// fSendLogToGMScreenNPS ////////////////////////////////////////////////////////////
// Purpose -> Sends bundled log and header data (dynamic + static) sequentially to
//            the GMScreen sheet ('db') and the PartyLog sheet ('ps') via the
//            server-side fSetLogAndHeaderData function. Uses a lock.
// Inputs  -> None (Uses gUI state: plainTextLogEntries, arr, characterInfo, isSendingLog).
// Outputs -> None (Calls google.script.run if not already sending and slotNum is valid).
function fSendLogToGMScreenNPS() {
    // === 1. Check Lock ===
    if (gUI.isSendingLog) {
        fMyConsoleLog("📤 Log & Header send already in progress, skipping.");
        return;
    }

    // === 1a. Validate Slot Number === <<< NEW SECTION
    const slotNum = gUI.characterInfo?.slotNum;
    if (!slotNum || typeof slotNum !== 'string' || !slotNum.startsWith('Slot')) {
        // Only log this warning once perhaps, or make it less prominent?
        // For now, we log it every time the send is blocked.
        fMyConsoleLog(`📤 Cannot send Log & Headers: Invalid or missing slotNum ('${slotNum}').`);
        // Do not set the lock, just return.
        // Optionally show a message the first time?
        // fShowMessage("Cannot send log updates: Invalid player Slot #.").catch(e=>console.error(e));
        return;
    }
    // === END NEW SECTION ===

    // === 2. Set Lock ===
    gUI.isSendingLog = true;
    fMyConsoleLog(`📤 Preparing to send Log & Header data for ${slotNum} (Lock Acquired)...`);

    // === 3. Prepare Log Content ===
    const logEntriesSnapshot = [...gUI.plainTextLogEntries];
    const reversedLogEntries = logEntriesSnapshot.reverse();
    const combinedLog = reversedLogEntries.join('\n\n\n');
    const truncatedLog = combinedLog.substring(0, gUI.GMSCREEN_LOG_MAX_CHARS);
    fMyConsoleLog(`   -> Log Content Prepared (Entries: ${logEntriesSnapshot.length}, Length: ${truncatedLog.length})`);

    // === 4. Prepare Header Data ===
    // --- Dynamic Data (from gUI.arr) ---
    const vitMax = fGetGridValue('VitTbl', 'vitMax') ?? '?';
    const vitNow = fGetGridValue('VitTbl', 'vitNow') ?? '?';
    const vitPercent = fGetGridValue('VitTbl', 'VitNowPercent') ?? '?%';
    const vitString = `${vitNow} of ${vitMax} (${vitPercent})`;
    const nishValue = fGetGridValue('Nish', 'Nish') ?? '';
    fMyConsoleLog(`   -> Dynamic Header Data: Vit='${vitString}', Nish='${nishValue}'`);

    // --- Static/Constructed Data (from gUI.characterInfo / gIndexCSID) ---
    const { raceClass, level, playerName, charName } = gUI.characterInfo || {};
    const playerCharString = `${playerName || '?'} (${charName || '?'})`;
    const characterUrl = "https://docs.google.com/spreadsheets/d/" + gIndexCSID + "/";
    fMyConsoleLog(`   -> Static Header Data: URL='${characterUrl}', RaceClass='${raceClass}', Level='${level}', PlayerChar='${playerCharString}', Slot='${slotNum}'`); // Added Slot here

    // === 5. Create Data Bundle ===
    const dataBundle = {
        log: truncatedLog,
        vit: vitString,
        nish: nishValue,
        url: characterUrl,
        raceClass: raceClass || '',
        level: level || '',
        playerChar: playerCharString,
        slotNum: slotNum 
    };

    // === 6. Call Server Function ===
    fMyConsoleLog(`   -> Calling fSetLogAndHeaderData with bundled data...`);
    google.script.run
        .withSuccessHandler((success) => {
            if (success) {
                fMyConsoleLog("   -> ✅ Log & Headers updated successfully on server targets.");
            } else {
                fMyConsoleLog("   -> ⚠️ Log & Headers update partially failed on server. Check server logs.");
                fShowMessage("Warning: Update failed for one or more target sheets.").catch(e => console.error("Error showing message:", e));
            }
            gUI.isSendingLog = false; // Release Lock
            fMyConsoleLog("   -> Lock Released.");
        })
        .withFailureHandler((error) => {
            const errorMsg = error?.message || "Unknown server error";
            console.error(`fSendLogToGMScreenNPS Failure: ${errorMsg}`, error);
            fMyConsoleLog(`   -> ❌ Error sending Log & Headers: ${errorMsg}`);
            gUI.isSendingLog = false; // Release Lock
            fMyConsoleLog("   -> Lock Released due to error.");
            fShowMessage(`Error: Could not send updates: ${errorMsg}`).catch(e => console.error("Error showing message:", e));
        })
        .fSetLogAndHeaderData(dataBundle);

} // END fSendLogToGMScreenNPS



// ==========================================================================
// === Menu Bar Click     (End of Menu Bar Setup)) ===
// ==========================================================================




// fSetupDelegatedMenuActionClick //////////////////////////////////////////////
// Purpose -> Sets up a single event listener on the menu bar to handle clicks
//            on menu items using event delegation and data attributes.
// Inputs  -> None. Relies on DOM structure.
// Outputs -> None. Attaches event listener.
function fSetupDelegatedMenuActionClick() {
    const menuBar = document.getElementById('menu-bar');
    if (!menuBar) {
        console.error("Setup failed: Menu bar (#menu-bar) not found.");
        return; // Stop if the menu bar isn't there
    }

    menuBar.addEventListener('click', (event) => {
        const target = event.target.closest('a[data-action]'); // Find the clicked link with a data-action
        if (!target) return; // Exit if the click wasn't on an action link

        event.preventDefault(); // Prevent default link behavior (like navigating)
        const action = target.dataset.action;
        fMyConsoleLog(`🎬 Menu Action Clicked: ${action}`);


        // Close any open dropdowns first
        document.querySelectorAll('.dropdown-content.show').forEach(dropdown => {
            dropdown.classList.remove('show');
        });
        // Close any open sub-menus
         document.querySelectorAll('.dropdown-content.sub-menu.show-sub').forEach(subMenu => {
             subMenu.classList.remove('show-sub');
         });


        // --- Handle actions based on the data-action attribute ---
        switch (action) {
            // Game Menu Actions
            case 'game-nishStartEnd':       fHandleNishStartOrEnd(); break;
            case 'game-toggleSidebar':      fToggleSidebar(); break;
            case 'game-updateHeaderInfo':   fHandleUpdateHeaderInfo(); break; // Corrected name
            case 'game-gmAward':            /* fHandleGMAwardAction(); */ fShowMessage(`Action "${action}" is not yet implemented.`); break; // Placeholder
            case 'game-metaFlood':          fMetaFlood(); break; // Correct function call
            case 'game-healingNatural':     fCalc_NaturalHealing(); break; // Correct function call
            case 'game-healingAll':         fHealAllWounds(); break; // Added case
            case 'game-restTimeRest':       fHandleRestTimeRest(); break; // Added case
            case 'game-restTimeSleep':      fHandleRestTimeSleep(); break; // Added case
            case 'game-restTimeNewSession': fHandleRestTimeNewSession(); break; // Added case
            case 'game-clearChanneled':     fClearChanneledMeta(); break; // Added case
            case 'game-clearCheckboxes':    fClearSk1Sk2Checkboxes(); break; // Added case
            case 'game-clearMonsters':      fClearMonsters(); break; // Added case
            case 'game-clearMorphs':        fClearMorphs(); break; // Added case
            case 'game-clearNish':          fClearCurrentNish(); break; // Added case
            case 'game-clearRollLog':       fClearRollLog(); break; // Added case
            case 'game-setMaxLuck':         fLuck_SetToMax(); break; // Added case
            case 'game-setMaxMeta':         fMeta_SetToMax(); break; // Added case
            case 'game-setMaxVit':          fCalc_VitMaxNowPerc(); break; // Added case
            case 'game-setMaxAll':          fHandleResetAllToMax(); break; // Added case

            // Gear Menu Actions
            case 'gear-toggleGear':         fToggleGearColumns(); break; // Added case
            case 'gear-loot':               /* fHandleLootAction('Add'); */ fShowMessage(`Action "${action}" is not yet implemented.`); break; // Placeholder
            case 'gear-lootArtifact':       /* fHandleLootAction('Artifact'); */ fShowMessage(`Action "${action}" is not yet implemented.`); break; // Placeholder
            case 'gear-lootChaosCrystal':   /* fHandleLootAction('ChaosCrystal'); */ fShowMessage(`Action "${action}" is not yet implemented.`); break; // Placeholder
            case 'gear-lootGear':           /* fHandleLootAction('Gear'); */ fShowMessage(`Action "${action}" is not yet implemented.`); break; // Placeholder
            case 'gear-lootGem':            /* fHandleLootAction('Gem'); */ fShowMessage(`Action "${action}" is not yet implemented.`); break; // Placeholder
            case 'gear-lootSocketed':       /* fHandleLootAction('Socketed'); */ fShowMessage(`Action "${action}" is not yet implemented.`); break; // Placeholder
            case 'gear-lootValuables':      /* fHandleLootAction('Valuables'); */ fShowMessage(`Action "${action}" is not yet implemented.`); break; // Placeholder

            // Data Menu Actions
            case 'data-saveNow':            fHandleAutoSaveTextData(); break;
            case 'data-designerOnly':       fHandleDesignerOnlyClick(); break; // Keep reference

            // Placeholder/Legacy Actions (can be removed if not needed)
            // case 'view-toggleTester': fToggleTesterVisibility(); break;

            // Default case for unhandled actions
            default:
                fMyConsoleLog(`   -> WARNING: No handler defined for action: ${action}`);
                fShowMessage(`Action "${action}" is not yet implemented.`);
        }
    });

    fMyConsoleLog("✅ Delegated Menu Action Click Listener Attached.");
} // END fSetupDelegatedMenuActionClick



// fHandleNishStartOrEnd ///////////////////////////////////////////////////////////
// Purpose -> Handles <Game><Nish Start or End> menu action. Runs Meta Flood,
//            clears channeled meta/durations, sets max AP, logs action, and sends update.
// Inputs  -> None.
// Outputs -> (Promise<void>): Resolves after completing actions.
async function fHandleNishStartOrEnd() {
    fMyConsoleLog("⚙️ Menu Action: Nish Start or End Triggered...");
    await fMetaFlood();          // Async - Logs own message
    fClearChanneledMeta();       // Sync
    await fAct_SetToMax();       // Async - No sidebar log
    fClearIsOnDurationRange();   // Sync

    // Log completion to sidebar (HTML and Plain Text)
    const sidebarMsgHtml = `🚩<span class="blue-bold">Nish Start or End</span>`;
    const sidebarMsgText = `🚩 Nish Start or End`;
    fPrependToSidebar(sidebarMsgHtml, sidebarMsgText);
    fShowSidebar();

    fMyConsoleLog("✅ Nish Start or End Action Completed.");

    // Send log update to GMScreen (with slight delay)
    setTimeout(() => fSendLogToGMScreenNPS(), 0); 

} // END fHandleNishStartOrEnd



// fClearIsOnDurationRange /////////////////////////////////////////////////////////
// Purpose -> Clears all cells within the 'Is On / Duration' ranges defined in
//            gUI.range.isONDur by setting their values to empty strings.
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM).
function fClearIsOnDurationRange() {
    fMyConsoleLog("⚙️ Clearing 'Is On/Duration' Range...");
    let allSucceeded = true;
    const rangesToClear = gUI.range?.isONDur; // Get the array of ranges

    // === Validate Configuration ===
    if (!Array.isArray(rangesToClear) || rangesToClear.length === 0) {
        console.warn("fClearIsOnDurationRange: No 'Is On/Duration' ranges defined in gUI.range.isONDur.");
        fMyConsoleLog("⚠️ Cannot clear 'Is On/Duration': Ranges not defined.");
        // Optional: fShowMessage("Error: 'Is On/Duration' ranges not defined.");
        return;
    }

    // === Clear Cells in Each Range ===
    rangesToClear.forEach(range => {
        // Validate the range object structure
        if (!fIsValidRangeObject(range)) {
            console.warn("fClearIsOnDurationRange: Skipping invalid range object within gUI.range.isONDur:", range);
            allSucceeded = false;
            return; // Skip this invalid range
        }

        // Resolve range tags/indices
        const r1 = resolveRow(range.r1);
        const c1 = resolveCol(range.c1);
        const r2 = resolveRow(range.r2);
        const c2 = resolveCol(range.c2);

        // Validate resolved indices
        if ([r1, c1, r2, c2].some(isNaN)) {
            console.warn(`fClearIsOnDurationRange: Skipping invalid range definition:`, range);
            allSucceeded = false; // Mark failure
            return; // Skip this range
        }

        // Call fSetRangeValues to set all cells in the range to empty string
        const success = fSetRangeValues(r1, c1, r2, c2, ''); // Set value to empty string
        if (!success) {
            allSucceeded = false; // Track if any update fails
        }
    });

    // === Log Result ===
    if (!allSucceeded) {
        fMyConsoleLog("⚠️ Failed to clear one or more 'Is On/Duration' ranges.");
        // Optional: fShowMessage("Error clearing some 'Is On/Duration' cells.");
    } else {
        fMyConsoleLog("✅ 'Is On/Duration' Ranges Cleared.");
    }

} // END fClearIsOnDurationRange


// fToggleSidebar //////////////////////////////////////////////////////////////////
// Purpose -> Toggles the visibility of the Roll Log sidebar by calling either
//            fShowSidebar or fHideSidebar based on its current state.
// Inputs  -> None.
// Outputs -> None (Calls show/hide function).
function fToggleSidebar() {
    const sidebar = document.getElementById('roll-log-sidebar');

    // Validate sidebar element exists
    if (!sidebar) {
        console.error("fToggleSidebar: Cannot find sidebar element (#roll-log-sidebar) to toggle.");
        return;
    }

    // Check current visibility state
    const isVisible = sidebar.classList.contains('show');

    // Call the appropriate function to toggle state
    if (isVisible) {
        fHideSidebar();
    } else {
        fShowSidebar();
    }
} // END fToggleSidebar




// fMetaFlood //////////////////////////////////////////////////////////////////////
// Purpose -> Handles <Game><Meta><Flood>. Selects Meta col, increases values, caps,
//            updates grid, logs action to sidebar, and triggers GMScreen update.
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM, calls fShowMessage, logs to sidebar/GMScreen).
async function fMetaFlood() {
    fMyConsoleLog("⚙️ Menu Action: Meta Flood...");
    const metaRangeDef = gUI.range?.meta; const metaCaps = gUI.list?.metaFull; const metaColorTags = gUI.list?.metaColor;
    let errorMsg = '';
    if (!metaRangeDef || !fIsValidRangeObject(metaRangeDef)) errorMsg = "Meta range definition missing or invalid.";
    else if (!Array.isArray(metaCaps) || metaCaps.length === 0) errorMsg = "Meta caps list (gUI.list.metaFull) missing or invalid.";
    // Allow missing metaColorTags for now
    if (errorMsg) { console.warn(`fMetaFlood: ${errorMsg}`); fMyConsoleLog(`⚠️ Meta Flood failed: ${errorMsg}`); await fShowMessage(`Error: ${errorMsg}`); return; }

    const metaRowTag = metaRangeDef.r1; const startCol = resolveCol(metaRangeDef.c1); const endCol = resolveCol(metaRangeDef.c2);
    if ([startCol, endCol].some(isNaN)) { errorMsg = `Could not resolve Meta column tags: ${metaRangeDef.c1}, ${metaRangeDef.c2}.`; console.warn(`fMetaFlood: ${errorMsg}`); fMyConsoleLog(`⚠️ Meta Flood failed: ${errorMsg}`); await fShowMessage(`Error: ${errorMsg}`); return; }
    const numMetaCols = Math.abs(endCol - startCol) + 1;
    if (metaCaps.length > 0 && numMetaCols !== metaCaps.length) { errorMsg = `Mismatch between number of Meta columns (${numMetaCols}) and Meta caps (${metaCaps.length}).`; console.warn(`fMetaFlood: ${errorMsg}`); fMyConsoleLog(`⚠️ Meta Flood failed: ${errorMsg}`); await fShowMessage(`Error: ${errorMsg}`); return; }

    const selectedIndex = Math.floor(Math.random() * numMetaCols); const selectedColIndex = startCol + selectedIndex; const selectedColTag = metaColorTags?.[selectedIndex] ?? `Index ${selectedIndex}`;
    fMyConsoleLog(`   -> Selected Meta Index: ${selectedIndex} (Column ${selectedColIndex} - Tag: ${selectedColTag})`);

    const finalValues = []; let amountToAdd = 1;
    for (let i = selectedIndex; i >= 0; i--) {
        const currentColIndex = startCol + i; const currentColTag = metaColorTags?.[i] ?? `Index ${i}`;
        const currentVal = fGetGridValue(metaRowTag, currentColIndex, true) || 0;
        const newValRaw = currentVal + amountToAdd;
        const cap = (metaCaps && metaCaps[i] !== undefined) ? metaCaps[i] : Infinity;
        const finalVal = Math.min(newValRaw, cap);
        fMyConsoleLog(`      -> Index ${i} (${currentColTag}): Current=${currentVal}, Add=${amountToAdd}, Raw=${newValRaw}, Cap=${cap === Infinity ? 'N/A' : cap} => Final=${finalVal}`);
        finalValues.unshift(finalVal);
        amountToAdd++;
    }

    fMyConsoleLog(`   -> Updating Meta columns ${startCol} to ${selectedColIndex} with final values: [${finalValues.join(', ')}]`);
    const success = fSetRangeValues(metaRowTag, startCol, metaRowTag, selectedColIndex, finalValues);

    if (!success) {
        errorMsg = `fSetRangeValues failed to update Meta grid.`;
        fMyConsoleLog(`   -> ⚠️ Meta Flood Error: ${errorMsg}`); await fShowMessage(`Error: ${errorMsg}`);
    } else {
        fMyConsoleLog("✅ Meta Flood Update Complete.");
        const sidebarMsgHtml = `<span class="blue-bold">ℹ️ Meta Flood (Rolled ${selectedColTag}):</span>`;
        const sidebarMsgText = `ℹ️ Meta Flood (Rolled ${selectedColTag}):`;
        fPrependToSidebar(sidebarMsgHtml, sidebarMsgText);
        fShowSidebar();

        // Send log update to GMScreen (with slight delay) <<< ADDED CALL >>>
        setTimeout(() => fSendLogToGMScreenNPS(), 0);
    }
} // END fMetaFlood



// fMetaChannel ////////////////////////////////////////////////////////////////////
// Purpose -> Handles Meta Channeling calculation. Selects Meta Channel column,
//            increments value, updates grid, logs to sidebar. (No GMScreen call needed here,
//            as called by fHandleNishStartOrEnd which sends the final log state).
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM, calls fShowMessage, logs to sidebar).
async function fMetaChannel() {
    fMyConsoleLog("⚙️ Calculating Meta Channel...");
    const channelRangeDef = gUI.range?.metaChannel; const metaColorTags = gUI.list?.metaColor;
    let errorMsg = '';
    if (!channelRangeDef || !fIsValidRangeObject(channelRangeDef)) errorMsg = "Meta Channel range definition missing or invalid.";
    // Allow missing metaColorTags
    if (errorMsg) { console.warn(`fMetaChannel: ${errorMsg}`); fMyConsoleLog(`⚠️ Meta Channel failed: ${errorMsg}`); await fShowMessage(`Error: ${errorMsg}`); return; }

    const channelRowTag = channelRangeDef.r1; const startCol = resolveCol(channelRangeDef.c1); const endCol = resolveCol(channelRangeDef.c2);
    if ([startCol, endCol].some(isNaN)) { errorMsg = `Could not resolve Meta Channel column tags: ${channelRangeDef.c1}, ${channelRangeDef.c2}.`; console.warn(`fMetaChannel: ${errorMsg}`); fMyConsoleLog(`⚠️ Meta Channel failed: ${errorMsg}`); await fShowMessage(`Error: ${errorMsg}`); return; }

    const numMetaCols = Math.abs(endCol - startCol) + 1;
    const roll1 = Math.floor(Math.random() * numMetaCols); const roll2 = Math.floor(Math.random() * numMetaCols);
    const lowestSelectedIndex = Math.min(roll1, roll2); const finalColIndex = startCol + lowestSelectedIndex;
    const selectedColTag = metaColorTags?.[lowestSelectedIndex] ?? `Index ${lowestSelectedIndex}`;
    fMyConsoleLog(`   -> Meta Channel Rolls: ${roll1}, ${roll2}. Lowest Index: ${lowestSelectedIndex} (Column ${finalColIndex} - Tag: ${selectedColTag})`);

    const currentVal = fGetGridValue(channelRowTag, finalColIndex, true) || 0; const newValue = currentVal + 1;
    fMyConsoleLog(`      -> Index ${lowestSelectedIndex} (${selectedColTag}): Current=${currentVal}, Add=1 => New=${newValue}`);

    const success = fSetGridValue(channelRowTag, finalColIndex, newValue);
    if (!success) {
        errorMsg = `fSetGridValue failed to update Meta Channel grid cell [${channelRowTag}, ${finalColIndex}].`;
        fMyConsoleLog(`   -> ⚠️ Meta Channel Error: ${errorMsg}`); await fShowMessage(`Error: ${errorMsg}`);
    } else {
        fMyConsoleLog("✅ Meta Channel Update Complete.");
        // Build and Display Sidebar Message (HTML and Plain Text)
        const sidebarMsgHtml = `<span class="blue-bold">ℹ️ Meta Channeled (${selectedColTag}):</span> ${currentVal} &rarr; ${newValue}`;
        const sidebarMsgText = `ℹ️ Meta Channeled (${selectedColTag}): ${currentVal} -> ${newValue}`;
        fPrependToSidebar(sidebarMsgHtml, sidebarMsgText); // Update sidebar and plain text log
        // No GMScreen update here - handled by calling function
    }
} // END fMetaChannel



// fIsOn_NewNishSet ////////////////////////////////////////////////////////////////
// Purpose -> Processes the 'Is On' / 'Duration' columns at the start of a Nish turn.
//            Decrements positive integer durations by 1. Changes 0, 'i', 'p', 'n'
//            (case-insensitive) to empty strings. Updates grid data and DOM.
// Inputs  -> None (uses gUI.range.isONDur).
// Outputs -> None (modifies gUI.arr and gUI.grid2D via fSetGridValue).
async function fIsOn_NewNishSet() {
    fMyConsoleLog("⚙️ Processing 'Is On/Duration' cells for Nish turn...");

    const rangeDefs = gUI.range?.isONDur; // Get the array of relevant range definitions

    // === Validate Configuration ===
    if (!Array.isArray(rangeDefs) || rangeDefs.length === 0) {
        fMyConsoleLog("⚠️ Cannot process 'Is On': Range definitions missing or empty in gUI.range.isONDur.");
        // Optional: await fShowMessage("Error: 'Is On/Duration' range definitions not found.");
        return;
    }

    // === Initialize Counters ===
    let cellsProcessed = 0;
    let cellsChanged = 0;
    let errorsEncountered = false;

    // === Iterate Through Each Defined Range ===
    for (const range of rangeDefs) {
        // Validate range object structure
        if (!fIsValidRangeObject(range)) {
             console.warn("fIsOn_NewNishSet: Skipping invalid range object", range);
             errorsEncountered = true;
             continue;
        }

        // Resolve range tags/indices
        const resolved = fResolveRangeIndices(range);
        if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
             console.warn("fIsOn_NewNishSet: Skipping range due to unresolved indices", range);
             errorsEncountered = true;
             continue;
        }

        // Determine bounds
        const rMin = Math.min(resolved.r1, resolved.r2);
        const rMax = Math.max(resolved.r1, resolved.r2);
        const cMin = Math.min(resolved.c1, resolved.c2);
        const cMax = Math.max(resolved.c1, resolved.c2);

        // === Process Cells Within Range ===
        for (let r = rMin; r <= rMax; r++) {
            for (let c = cMin; c <= cMax; c++) {
                cellsProcessed++;
                const currentValue = fGetGridValue(r, c); // Get current value
                let newValue = currentValue; // Assume no change initially

                // --- Apply Duration Logic ---
                if (currentValue === null || typeof currentValue === 'undefined') {
                    // Treat truly empty cells as empty string
                    newValue = '';
                } else {
                    const currentValueStrLower = String(currentValue).toLowerCase();
                    // Check for specific non-numeric states to clear
                    if (currentValueStrLower === 'i' || currentValueStrLower === 'p' || currentValueStrLower === 'n') {
                        newValue = ''; // Clear 'i', 'p', 'n'
                    } else {
                        // Try converting to number
                        const numericValue = Number(currentValue);
                        if (!isNaN(numericValue)) {
                            // It's a number
                            if (numericValue > 0) {
                                newValue = numericValue - 1; // Decrement positive duration
                                if (newValue === 0) {
                                     newValue = ''; // Convert resulting 0 to empty string
                                }
                            } else if (numericValue === 0) {
                                newValue = ''; // Convert existing 0 to empty string
                            }
                            // Negative numbers remain unchanged
                        }
                        // Else: Not 'i'/'p'/'n' or a number, keep original value
                    }
                }
                // --- End Duration Logic ---

                // Update grid only if value actually changed
                if (newValue !== currentValue) {
                    if (fSetGridValue(r, c, newValue)) {
                         cellsChanged++;
                         // Optional log: fMyConsoleLog(`   -> Changed cell [${r}, ${c}] from '${currentValue}' to '${newValue}'`);
                    } else {
                        // fSetGridValue logs its own errors
                        errorsEncountered = true;
                    }
                }
            } // end column loop
        } // end row loop
    } // end loop through range definitions

    fMyConsoleLog(`✅ 'Is On/Duration' Processing Complete. Processed: ${cellsProcessed}, Changed: ${cellsChanged}${errorsEncountered ? ' (with errors)' : ''}.`);

} // END fIsOn_NewNishSet



// fCalc_NaturalHealing ////////////////////////////////////////////////////////////
// Purpose -> Handles <Game><Healing><Natural Healing>. Calculates healing, updates
//            wound cells, recalculates Vit Now/Percent, logs results, and sends update.
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM, calls sidebar/GMScreen functions).
async function fCalc_NaturalHealing() {
    fMyConsoleLog("⚙️ Menu Action: Natural Healing...");
    // === 1. Get Vit Max ===
    const vitMaxRange = gUI.range?.vitMax; let errorMsg = '';
    if (!vitMaxRange || !vitMaxRange.r1 || !vitMaxRange.c1) errorMsg = "Vit Max range definition missing.";
    if (errorMsg) { console.warn(`fCalc_NaturalHealing: ${errorMsg}`); fMyConsoleLog(`⚠️ Natural Healing failed: ${errorMsg}`); await fShowMessage(`Error: ${errorMsg}`); return; }
    const vitMax = fGetGridValue(vitMaxRange.r1, vitMaxRange.c1, true);
    if (isNaN(vitMax) || vitMax < 1) { errorMsg = `Vit Max value ('${vitMax}') is invalid or zero. Cannot calculate healing.`; console.warn(`fCalc_NaturalHealing: ${errorMsg}`); fMyConsoleLog(`⚠️ Natural Healing failed: ${errorMsg}`); await fShowMessage(`Error: ${errorMsg}`); return; }
    fMyConsoleLog(`   -> Vit Max for healing calc: ${vitMax}`);

    // === 2. Process Healing for Each Wound Type ===
    let errorsOccurred = false;
    const healingResults = {};
    healingResults['1st'] = await fProcessWoundHealing('vit1stWnds', vitMax, 4, '1st'); if (healingResults['1st'] === null) errorsOccurred = true;
    healingResults['2nd'] = await fProcessWoundHealing('vit2ndWnds', vitMax, 8, '2nd'); if (healingResults['2nd'] === null) errorsOccurred = true;
    healingResults['3rd'] = await fProcessWoundHealing('vit3rdWnds', vitMax, 16, '3rd'); if (healingResults['3rd'] === null) errorsOccurred = true;

    // === 3. Update Vit Now & Percent ===
    if (!errorsOccurred) { await fVitNowNPercent_Calc(); }
    else { fMyConsoleLog("   -> Skipping Vit Now/Percent update due to healing errors."); }

    // === 4. Log Results to Sidebar ===
    let sidebarMsgHtml = `<span class="blue-bold">ℹ️ Natural Healing:</span>`;
    let sidebarMsgText = `ℹ️ Natural Healing:`;
    if (healingResults['1st'] !== null) { sidebarMsgHtml += `<br>${healingResults['1st']} -> 1st Deg Wnds`; sidebarMsgText += `\n${healingResults['1st']} -> 1st Deg Wnds`; }
    if (healingResults['2nd'] !== null) { sidebarMsgHtml += `<br>${healingResults['2nd']} -> 2nd Deg Wnds`; sidebarMsgText += `\n${healingResults['2nd']} -> 2nd Deg Wnds`; }
    if (healingResults['3rd'] !== null) { sidebarMsgHtml += `<br>${healingResults['3rd']} -> 3rd Deg Wnds`; sidebarMsgText += `\n${healingResults['3rd']} -> 3rd Deg Wnds`; }

    fPrependToSidebar(sidebarMsgHtml, sidebarMsgText);
    fShowSidebar();
    fMyConsoleLog(`✅ Natural Healing Process Complete ${errorsOccurred ? '(with errors)' : ''}.`);

    // === 5. Send Log Update (with slight delay) ===
    setTimeout(() => fSendLogToGMScreenNPS(), 0); 

} // END fCalc_NaturalHealing



// fProcessWoundHealing ////////////////////////////////////////////////////////////
// Purpose -> Helper for natural healing. Gets current wounds for a specific degree,
//            rolls appropriate healing die (based on Vit Max / divisor), calculates
//            new wound total (min 0), updates the grid, and returns the amount healed.
// Inputs  -> woundRangeTag (String): Tag for the specific wound cell (e.g., 'vit1stWnds').
//         -> vitMax (Number): Character's maximum vitality.
//         -> divisor (Number): Divisor for Vit Max to determine healing die size (4, 8, 16).
//         -> degreeLabel (String): Label for logging ('1st', '2nd', '3rd').
// Outputs -> (Promise<Number | null>): The actual amount healed (>= 0), or null if an error occurred.
async function fProcessWoundHealing(woundRangeTag, vitMax, divisor, degreeLabel) {
    fMyConsoleLog(`      -> Processing ${degreeLabel} Degree wounds...`);

    // === Get Range Definition ===
    const woundRange = gUI.range?.[woundRangeTag];
    if (!woundRange || !woundRange.r1 || !woundRange.c1) {
        const msg = `Wound range definition missing for tag: ${woundRangeTag}.`;
        console.warn(`fProcessWoundHealing: ${msg}`);
        fMyConsoleLog(`         -> ⚠️ Error: ${msg}`);
        await fShowMessage(`Error processing ${degreeLabel} wounds: ${msg}`);
        return null; // Indicate error
    }

    // === Get Current Wounds ===
    // Default to 0 if invalid/missing, ensure non-negative
    let currentWounds = Math.max(0, fGetGridValue(woundRange.r1, woundRange.c1, true) || 0);
    if (isNaN(currentWounds)) { // Should be caught by || 0, but extra check
        fMyConsoleLog(`         -> Warning: Invalid current wound value for ${degreeLabel}. Assuming 0.`);
        currentWounds = 0;
    }

    // === Calculate Healing ===
    const healingDieSize = Math.max(1, Math.round(vitMax / divisor)); // Die size is at least 1
    const healingRoll = fCSd(healingDieSize); // Roll the healing die
    fMyConsoleLog(`         -> Healing roll (${degreeLabel}): d${healingDieSize} = ${healingRoll}`);

    // === Calculate New Wounds and Amount Healed ===
    const newWounds = Math.max(0, currentWounds - healingRoll); // Cannot go below 0 wounds
    const actualHealed = currentWounds - newWounds; // Calculate the positive amount healed
    fMyConsoleLog(`         -> Wounds: ${currentWounds} -> ${newWounds} (Healed: ${actualHealed})`);

    // === Update Grid ===
    // Set the new wound value
    if (!fSetGridValue(woundRange.r1, woundRange.c1, newWounds)) {
        const msg = `Failed to update grid for ${degreeLabel} wounds.`;
        console.warn(`fProcessWoundHealing: ${msg}`);
        fMyConsoleLog(`         -> ⚠️ Error: ${msg}`);
        await fShowMessage(`Error updating ${degreeLabel} wounds: ${msg}`);
        return null; // Indicate failure
    }

    // Return the actual amount healed (positive number or zero)
    return actualHealed;

} // END fProcessWoundHealing




// fHealAllWounds //////////////////////////////////////////////////////////////////
// Purpose -> Handles <Game><Healing><All wounds>. Sets wound cells to 0, updates
//            Vit Now/Percent, logs action, and sends update.
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM, calls sidebar/GMScreen functions).
async function fHealAllWounds() {
    fMyConsoleLog("⚙️ Menu Action: Clearing All Wounds...");
    const woundTags = ['vit1stWnds', 'vit2ndWnds', 'vit3rdWnds'];
    let errorsOccurred = false;

    // === Clear Each Wound Type ===
    for (const tag of woundTags) {
        const woundRange = gUI.range?.[tag];
        if (!woundRange || !woundRange.r1 || !woundRange.c1) {
            const msg = `Wound range definition missing for tag: ${tag}.`;
            console.warn(`fHealAllWounds: ${msg}`); fMyConsoleLog(`   -> ⚠️ Error: ${msg}`);
            await fShowMessage(`Error clearing wounds: ${msg}`); errorsOccurred = true; continue;
        }
        if (!fSetGridValue(woundRange.r1, woundRange.c1, 0)) {
            const msg = `Failed to update grid for tag: ${tag}.`;
            fMyConsoleLog(`   -> ⚠️ Error: ${msg}`); await fShowMessage(`Error clearing wounds: ${msg}`);
            errorsOccurred = true;
        } else { fMyConsoleLog(`   -> Cleared wounds for tag: ${tag}`); }
    }

    // === Update Dependent Cells ===
    if (!errorsOccurred) { await fVitNowNPercent_Calc(); }
    else { fMyConsoleLog("   -> Skipping Vit Now/Percent update due to errors clearing wounds."); }

    // === Log to Sidebar ===
    const sidebarMsgHtml = `<span class="blue-bold">ℹ️ All Wounds Healed</span>`;
    const sidebarMsgText = `ℹ️ All Wounds Healed`;
    fPrependToSidebar(sidebarMsgHtml, sidebarMsgText);
    fShowSidebar();

    fMyConsoleLog(`✅ Clear All Wounds Process Complete ${errorsOccurred ? '(with errors)' : ''}.`);

    // Send log update to GMScreen (with slight delay) <<< MODIFIED >>>
    setTimeout(() => fSendLogToGMScreenNPS(), 0);

} // END fHealAllWounds



// fHandleRestTimeRest /////////////////////////////////////////////////////////////
// Purpose -> Handles <Game><Rest or Time><Rest>. Runs Meta Flood, logs action,
//            and sends update.
// Inputs  -> None.
// Outputs -> (Promise<void>): Resolves after completing actions.
async function fHandleRestTimeRest() {
    fMyConsoleLog("⚙️ Menu Action: Rest Triggered...");
    await fMetaFlood(); // This logs its own message to sidebar

    // Log action to sidebar (HTML and Plain Text)
    const sidebarMsgHtml = `🕒 <span class="blue-bold">Character Rested</span>`;
    const sidebarMsgText = `🕒 Character Rested`;
    fPrependToSidebar(sidebarMsgHtml, sidebarMsgText);
    fShowSidebar();
    fMyConsoleLog("✅ Rest Action Completed.");

    // Send log update to GMScreen (with slight delay) <<< MODIFIED >>>
    setTimeout(() => fSendLogToGMScreenNPS(), 0);

} // END fHandleRestTimeRest




// fHandleRestTimeNewSession ///////////////////////////////////////////////////////
// Purpose -> Handles <Game><Rest or Time><New Game Session>. Sets Luck to Max,
//            logs action, and sends update.
// Inputs  -> None.
// Outputs -> (Promise<void>): Resolves after completing actions.
async function fHandleRestTimeNewSession() {
    fMyConsoleLog("⚙️ Menu Action: New Game Session Triggered...");
    await fLuck_SetToMax(); // This logs its own message and triggers its own send now

    // Log action to sidebar (HTML and Plain Text)
    const sidebarMsgHtml = `⚡ <span class="blue-bold">New Game Session</span>`;
    const sidebarMsgText = `⚡ New Game Session`;
    fPrependToSidebar(sidebarMsgHtml, sidebarMsgText);
    fShowSidebar();

    fMyConsoleLog("✅ New Game Session Action Completed.");

    // Send log update to GMScreen (with slight delay) <<< MODIFIED >>>
    // This ensures this *final* message is also included if fLuck_SetToMax finished quickly
    setTimeout(() => fSendLogToGMScreenNPS(), 0);

} // END fHandleRestTimeNewSession



// fHandleRestTimeSleep ////////////////////////////////////////////////////////////
// Purpose -> Handles <Game><Rest or Time><Sleep>. Sets Meta to Max, runs Natural
//            Healing, logs action, and sends update.
// Inputs  -> None.
// Outputs -> (Promise<void>): Resolves after completing actions.
async function fHandleRestTimeSleep() {
    fMyConsoleLog("⚙️ Menu Action: Sleep Triggered...");
    fMeta_SetToMax();           // Sync - Logs its own message and triggers send
    await fCalc_NaturalHealing(); // Async - Logs its own message and triggers send

    // Log action to sidebar (HTML and Plain Text)
    const sidebarMsgHtml = `🕒 <span class="blue-bold">Character Slept</span>`;
    const sidebarMsgText = `🕒 Character Slept`;
    fPrependToSidebar(sidebarMsgHtml, sidebarMsgText);
    fShowSidebar();

    fMyConsoleLog("✅ Sleep Action Completed.");

    // Send log update to GMScreen (with slight delay) <<< MODIFIED >>>
    // This ensures this *final* message is included if helpers finished quickly
    setTimeout(() => fSendLogToGMScreenNPS(), 0);

} // END fHandleRestTimeSleep





// fMeta_SetToMax //////////////////////////////////////////////////////////////////
// Purpose -> Handles <Game><Set to Max><Meta>. Sets 'meta' row to max values,
//            logs action, and sends update.
// Inputs  -> None.
// Outputs -> None (Calls fSetRangeValues, potentially fShowMessage, logs to sidebar/GMScreen).
function fMeta_SetToMax() {
    fMyConsoleLog("⚙️ Menu Action: Setting Meta to Max...");
    const metaRange = gUI.range?.meta; const maxMetaValues = gUI.list?.metaFull;
    let errorMsg = '';
    if (!metaRange || !fIsValidRangeObject(metaRange)) errorMsg = "Meta range definition is missing or invalid.";
    else if (!Array.isArray(maxMetaValues) || maxMetaValues.length === 0) errorMsg = "Max Meta values list (gUI.list.metaFull) is missing or empty.";
    if (errorMsg) { console.warn(`fMeta_SetToMax: ${errorMsg}`); fMyConsoleLog(`⚠️ Cannot set Meta to max: ${errorMsg}`); fShowMessage(`Error: ${errorMsg}`); return; }

    const success = fSetRangeValues(metaRange.r1, metaRange.c1, metaRange.r2, metaRange.c2, maxMetaValues);
    if (!success) {
        fMyConsoleLog(`⚠️ Failed to set Meta to max using fSetRangeValues.`);
    } else {
        fMyConsoleLog("✅ Meta Set to Max.");
        const sidebarMsgHtml = `<span class="blue-bold">ℹ️ Meta Set to Max</span>`;
        const sidebarMsgText = `ℹ️ Meta Set to Max`;
        fPrependToSidebar(sidebarMsgHtml, sidebarMsgText);
        fShowSidebar();

        // Send log update to GMScreen (with slight delay) <<< MODIFIED >>>
        setTimeout(() => fSendLogToGMScreenNPS(), 0);
    }
} // END fMeta_SetToMax




// fLuck_SetToMax //////////////////////////////////////////////////////////////////
// Purpose -> Handles <Game><Set to Max><Luck>. Calculates max luck, updates cell,
//            logs action, and sends update.
// Inputs  -> None.
// Outputs -> None (Calls helpers, potentially fShowMessage, logs to sidebar/GMScreen).
async function fLuck_SetToMax() {
    fMyConsoleLog("⚙️ Menu Action: Setting Luck to Max...");
    const baseLuck = gUI.list?.luckBoxMax; const luckBoxRange = gUI.range?.luckBox; const luckBoxPlusRange = gUI.range?.luckBoxPlus;
    let errorMsg = '';
    if (typeof baseLuck !== 'number' || isNaN(baseLuck)) errorMsg = "Base Luck value (gUI.list.luckBoxMax) missing or invalid.";
    else if (!luckBoxRange || !luckBoxRange.r1 || !luckBoxRange.c1) errorMsg = "LuckBox range definition missing or incomplete.";
    else if (!luckBoxPlusRange || !luckBoxPlusRange.r1 || !luckBoxPlusRange.c1) errorMsg = "LuckBoxPlus range definition missing or incomplete.";
    if (errorMsg) { console.warn(`fLuck_SetToMax: ${errorMsg}`); fMyConsoleLog(`⚠️ Cannot set Luck to max: ${errorMsg}`); await fShowMessage(`Error: ${errorMsg}`); return; }

    const luckPlusValueRaw = fGetGridValue(luckBoxPlusRange.r1, luckBoxPlusRange.c1); let luckPlusBonus = 0;
    if (luckPlusValueRaw !== null && luckPlusValueRaw !== '' && !isNaN(Number(luckPlusValueRaw))) { luckPlusBonus = Math.round(Number(luckPlusValueRaw)); fMyConsoleLog(`   -> Luck Plus Bonus found: ${luckPlusValueRaw} -> Rounded: ${luckPlusBonus}`); }
    else { fMyConsoleLog(`   -> No valid Luck Plus Bonus found. Using 0.`); }

    const newLuckValue = baseLuck + luckPlusBonus;
    fMyConsoleLog(`   -> Calculated Max Luck: ${baseLuck} (Base) + ${luckPlusBonus} (Bonus) = ${newLuckValue}`);
    const success = fSetGridValue(luckBoxRange.r1, luckBoxRange.c1, newLuckValue);

    if (!success) {
        fMyConsoleLog(`⚠️ Failed to set Luck to max value (${newLuckValue}).`); await fShowMessage(`Error: Failed to update the Luck value in the grid.`);
    } else {
        fMyConsoleLog(`✅ Luck Set to Max (${newLuckValue}).`);
        const sidebarMsgHtml = `<span class="blue-bold">ℹ️ Luck Set to Max</span>`;
        const sidebarMsgText = `ℹ️ Luck Set to Max`;
        fPrependToSidebar(sidebarMsgHtml, sidebarMsgText);
        fShowSidebar();

        // Send log update to GMScreen (with slight delay) <<< MODIFIED >>>
        setTimeout(() => fSendLogToGMScreenNPS(), 0);
    }
} // END fLuck_SetToMax



// fAct_SetToMax ///////////////////////////////////////////////////////////////////
// Purpose -> Sets the current Action Points value (in cell defined by gUI.range.actTotal)
//            to its maximum, calculated as gUI.list.actMax + the integer value of the
//            cell defined by gUI.range.actPlus. Typically called during Nish sequence.
// Inputs  -> None.
// Outputs -> None (Calls fGetGridValue, fSetGridValue, potentially fShowMessage).
async function fAct_SetToMax() {
    fMyConsoleLog("⚙️ Setting Action Points to Max...");

    // === 1. Get Config Data & Ranges ===
    const baseActMax = gUI.list?.actMax;
    const actTotalRange = gUI.range?.actTotal;
    const actPlusRange = gUI.range?.actPlus;

    // === 2. Validate Config Data & Ranges ===
    let errorMsg = '';
    if (typeof baseActMax !== 'number' || isNaN(baseActMax)) errorMsg = "Base Action Points Max value (gUI.list.actMax) missing or invalid.";
    else if (!actTotalRange || !actTotalRange.r1 || !actTotalRange.c1) errorMsg = "Action Points Total range definition missing or incomplete.";
    else if (!actPlusRange || !actPlusRange.r1 || !actPlusRange.c1) errorMsg = "Action Points Plus range definition missing or incomplete.";

    if (errorMsg) {
        console.warn(`fAct_SetToMax: ${errorMsg}`);
        fMyConsoleLog(`⚠️ Cannot set Act to max: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }

    // === 3. Get Act Plus Bonus ===
    const actPlusValueRaw = fGetGridValue(actPlusRange.r1, actPlusRange.c1);
    let actPlusBonus = 0; // Default bonus to 0

    // Convert bonus to integer if it's a valid number
    if (actPlusValueRaw !== null && actPlusValueRaw !== '' && !isNaN(Number(actPlusValueRaw))) {
        actPlusBonus = Math.round(Number(actPlusValueRaw));
        fMyConsoleLog(`   -> Act Plus Bonus found: ${actPlusValueRaw} -> Rounded: ${actPlusBonus}`);
    } else {
        fMyConsoleLog(`   -> No valid Act Plus Bonus found in cell (${actPlusRange.r1}, ${actPlusRange.c1}). Using 0.`);
        // Optional Warning:
        // if (actPlusValueRaw !== null && actPlusValueRaw !== '') {
        //    await fShowMessage(`Warning: Value "${actPlusValueRaw}" in Act Plus cell is not valid number. Using 0 bonus.`);
        // }
    }

    // === 4. Calculate and Set New Act Value ===
    const newActValue = baseActMax + actPlusBonus;
    fMyConsoleLog(`   -> Calculated Max Act: ${baseActMax} (Base) + ${actPlusBonus} (Bonus) = ${newActValue}`);

    const success = fSetGridValue(actTotalRange.r1, actTotalRange.c1, newActValue);

    // === 5. Log Result ===
    if (!success) {
        // fSetGridValue logs specific errors
        fMyConsoleLog(`⚠️ Failed to set Act to max value (${newActValue}) in cell (${actTotalRange.r1}, ${actTotalRange.c1}).`);
        await fShowMessage(`Error: Failed to update the Action Points value in the grid.`);
    } else {
        fMyConsoleLog(`✅ Action Points Set to Max (${newActValue}).`);
        // Note: No sidebar message here as it's usually part of Nish sequence
    }

} // END fAct_SetToMax




// fCalc_VitMaxNowPerc /////////////////////////////////////////////////////////////
// Purpose -> Handles the <Game><Set to Max><Vit Max> menu action. Calculates the
//            character's maximum vitality (Vit Max = Fortitude Sk1 + Vit Bonus),
//            updates the Vit Max cell, then calls fVitNowNPercent_Calc to update
//            the derived Vit Now and Vit Now Percent cells.
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM via helpers, potentially calls fShowMessage).
async function fCalc_VitMaxNowPerc() {
    fMyConsoleLog("⚙️ Menu Action: Setting Vit to Max...");

    // === 1. Get Range Definitions ===
    const fortitudeRange = gUI.range?.fortitudeSk1;
    const vitMaxRange = gUI.range?.vitMax;
    const vitMaxPlusRange = gUI.range?.vitMaxPlus;

    // === 2. Validate Ranges ===
    let errorMsg = '';
    if (!fortitudeRange || !fortitudeRange.r1 || !fortitudeRange.c1) errorMsg = "Fortitude range definition missing.";
    else if (!vitMaxRange || !vitMaxRange.r1 || !vitMaxRange.c1) errorMsg = "Vit Max range definition missing.";
    else if (!vitMaxPlusRange || !vitMaxPlusRange.r1 || !vitMaxPlusRange.c1) errorMsg = "Vit Max Plus range definition missing.";

    if (errorMsg) {
        console.warn(`fCalc_VitMaxNowPerc: ${errorMsg}`);
        fMyConsoleLog(`⚠️ Cannot set Vit to max: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }

    // === 3. Get Fortitude Value ===
    const fortitudeValueRaw = fGetGridValue(fortitudeRange.r1, fortitudeRange.c1);
    const fortitudeValue = Number(fortitudeValueRaw); // Convert to number

    if (isNaN(fortitudeValue)) { // Validate Fortitude value
        errorMsg = `Fortitude Sk1 value ('${fortitudeValueRaw}') is not a valid number.`;
        console.warn(`fCalc_VitMaxNowPerc: ${errorMsg}`);
        fMyConsoleLog(`⚠️ Cannot set Vit to max: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }
    fMyConsoleLog(`   -> Fortitude Sk1 value: ${fortitudeValue}`);

    // === 4. Get Vit Max Plus Bonus ===
    const vitMaxPlusValueRaw = fGetGridValue(vitMaxPlusRange.r1, vitMaxPlusRange.c1);
    let vitMaxPlusBonus = 0; // Default bonus to 0

    // Convert bonus to integer if it's a valid number
    if (vitMaxPlusValueRaw !== null && vitMaxPlusValueRaw !== '' && !isNaN(Number(vitMaxPlusValueRaw))) {
        vitMaxPlusBonus = Math.round(Number(vitMaxPlusValueRaw));
        fMyConsoleLog(`   -> Vit Max Plus Bonus found: ${vitMaxPlusValueRaw} -> Rounded: ${vitMaxPlusBonus}`);
    } else {
        fMyConsoleLog(`   -> No valid Vit Max Plus Bonus found. Using 0.`);
    }

    // === 5. Calculate and Set New Vit Max ===
    const newVitMax = Math.round(fortitudeValue + vitMaxPlusBonus); // Ensure integer
    fMyConsoleLog(`   -> Calculated New Vit Max: ${fortitudeValue} (For) + ${vitMaxPlusBonus} (Bonus) = ${newVitMax}`);

    // Update the Vit Max cell in the grid
    const setMaxSuccess = fSetGridValue(vitMaxRange.r1, vitMaxRange.c1, newVitMax);

    if (!setMaxSuccess) {
        fMyConsoleLog(`⚠️ Failed to set Vit Max value (${newVitMax}) in cell (${vitMaxRange.r1}, ${vitMaxRange.c1}). Aborting further updates.`);
        await fShowMessage(`Error: Failed to update the Vit Max value in the grid.`);
        return; // Stop if essential Vit Max update failed
    }
    fMyConsoleLog(`   -> Successfully set Vit Max to ${newVitMax}.`);

    // === 6. Update Derived Vit Values ===
    // Call helper to update Vit Now and Vit Now Percent based on the new Vit Max
    await fVitNowNPercent_Calc();

    fMyConsoleLog("✅ Vit Set to Max sequence complete.");

} // END fCalc_VitMaxNowPerc




// fVitNowNPercent_Calc ////////////////////////////////////////////////////////////
// Purpose -> Helper function to calculate 'Vit Now' (Vit Max - Total Wounds) and
//            'Vit Now Percent'. Updates the corresponding grid cells. Typically called
//            after Vit Max or Wounds change.
// Inputs  -> None (Reads Vit Max and Wound values from grid).
// Outputs -> None (Modifies Vit Now and Vit Now Percent cells in grid data/DOM).
async function fVitNowNPercent_Calc() {
    fMyConsoleLog("   -> Calculating Vit Now & Percent...");

    // === 1. Get Range Definitions ===
    const vitMaxRange = gUI.range?.vitMax;
    const vit1stRange = gUI.range?.vit1stWnds;
    const vit2ndRange = gUI.range?.vit2ndWnds;
    const vit3rdRange = gUI.range?.vit3rdWnds;
    const vitNowRange = gUI.range?.vitNow;
    const vitNowPercentRange = gUI.range?.vitNowPercent;

    // === 2. Validate Ranges ===
    let errorMsg = '';
    if (!vitMaxRange || !vitMaxRange.r1 || !vitMaxRange.c1) errorMsg = "Vit Max range definition missing.";
    else if (!vit1stRange || !vit1stRange.r1 || !vit1stRange.c1) errorMsg = "Vit 1st Wounds range definition missing.";
    else if (!vit2ndRange || !vit2ndRange.r1 || !vit2ndRange.c1) errorMsg = "Vit 2nd Wounds range definition missing.";
    else if (!vit3rdRange || !vit3rdRange.r1 || !vit3rdRange.c1) errorMsg = "Vit 3rd Wounds range definition missing.";
    else if (!vitNowRange || !vitNowRange.r1 || !vitNowRange.c1) errorMsg = "Vit Now range definition missing.";
    else if (!vitNowPercentRange || !vitNowPercentRange.r1 || !vitNowPercentRange.c1) errorMsg = "Vit Now Percent range definition missing.";

    if (errorMsg) {
        console.warn(`fVitNowNPercent_Calc: ${errorMsg}`);
        fMyConsoleLog(`   -> ⚠️ Calculation aborted: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }

    // === 3. Get Current Vit Max ===
    const currentVitMaxRaw = fGetGridValue(vitMaxRange.r1, vitMaxRange.c1);
    const currentVitMax = Number(currentVitMaxRaw); // Convert to number
    if (isNaN(currentVitMax)) { // Validate Vit Max is usable number
        errorMsg = `Vit Max value ('${currentVitMaxRaw}') needed for calculation is not a number.`;
        console.warn(`fVitNowNPercent_Calc: ${errorMsg}`);
        fMyConsoleLog(`   -> ⚠️ Calculation aborted: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }

    // === 4. Get and Sum Wound Values ===
    // Helper to get wound value, defaulting invalid/empty to 0
    const getWoundVal = (range) => {
        const raw = fGetGridValue(range.r1, range.c1);
        return (raw !== null && raw !== '' && !isNaN(Number(raw))) ? Math.round(Number(raw)) : 0;
    };
    const wounds1st = getWoundVal(vit1stRange);
    const wounds2nd = getWoundVal(vit2ndRange);
    const wounds3rd = getWoundVal(vit3rdRange);
    const totalWounds = wounds1st + wounds2nd + wounds3rd;
    fMyConsoleLog(`      -> Wounds: ${wounds1st}(1st) + ${wounds2nd}(2nd) + ${wounds3rd}(3rd) = ${totalWounds}`);

    // === 5. Calculate and Set Vit Now ===
    const newVitNow = Math.round(currentVitMax - totalWounds); // Ensure integer
    fMyConsoleLog(`      -> Calculated Vit Now: ${currentVitMax} (Max) - ${totalWounds} (Wounds) = ${newVitNow}`);
    const setNowSuccess = fSetGridValue(vitNowRange.r1, vitNowRange.c1, newVitNow);

    if (!setNowSuccess) {
        fMyConsoleLog(`   -> ⚠️ Failed to set Vit Now value (${newVitNow}).`);
        await fShowMessage(`Error: Failed to update the Vit Now value.`);
        // Continue to attempt percentage calculation even if Vit Now fails? Currently yes.
    }

    // === 6. Calculate and Set Vit Now Percentage ===
    // Calculate percentage, handle division by zero if Vit Max is 0
    const percent = (currentVitMax === 0) ? 0 : Math.round((newVitNow / currentVitMax) * 100);
    const percentString = percent + '%'; // Format as string with '%'
    fMyConsoleLog(`      -> Calculated Vit Now Percent: ${percentString}`);

    const setPercentSuccess = fSetGridValue(vitNowPercentRange.r1, vitNowPercentRange.c1, percentString);
    if (!setPercentSuccess) {
        fMyConsoleLog(`   -> ⚠️ Failed to set Vit Now Percent value (${percentString}).`);
        await fShowMessage(`Error: Failed to update the Vit Now Percent value.`);
    }

    fMyConsoleLog("   -> Vit Now & Percent Calculation complete.");

} // END fVitNowNPercent_Calc




// fHandleResetAllToMax ////////////////////////////////////////////////////////////
// Purpose -> Handles <Game><Set to Max><Reset All to Max>. Prompts user, runs reset
//            functions, logs completion, and sends ONE final update.
// Inputs  -> None.
// Outputs -> (Promise<void>): Resolves after completing actions or if cancelled.
async function fHandleResetAllToMax() {
    fMyConsoleLog("⚙️ Menu Action: Reset All to Max Triggered...");
    const promptMessage = `<b>Reset All to Max?</b><br><br>This will:<br>-- Clear Roll Log<br>-- Clear current Nish roll<br>-- Flood Meta<br>-- Clear Channeled Meta<br>-- Set Luck to Max<br>-- Set Action Points to Max<br>-- Heal All Wounds<br>-- Clear Morphs<br>-- Clear 'Is On' Column<br>-- Clear Monsters<b><br>Are you sure?</b>`;
    fMyConsoleLog("   -> Displaying confirmation prompt...");
    const userConfirmed = await fShowPrompt(promptMessage);

    if (userConfirmed) {
        fMyConsoleLog("   -> User confirmed Reset All. Executing actions...");

        // --- Clear Logs Locally (Before other actions add new logs) ---
        const sidebarContent = document.getElementById('sidebar-content');
        if (sidebarContent) sidebarContent.innerHTML = ''; // Clear HTML display
        gUI.plainTextLogEntries = []; // Clear the plain text array directly
        fMyConsoleLog("   -> Cleared local logs (HTML & array).");

        // --- Execute Reset Sequence ---
        // NOTE: These functions log AND call fSendLogToGMScreenNPS (delayed)
        fClearCurrentNish();         // Sync
        fMeta_SetToMax();          // Async (Logs only)
        fClearChanneledMeta();       // Sync
        await fLuck_SetToMax();      // Async (Logs + Delayed Send)
        await fAct_SetToMax();       // Async (No sidebar log)
        await fHealAllWounds();      // Async (Logs + Delayed Send)
        fClearMorphs();              // Sync
        fClearIsOnDurationRange();   // Sync
        fClearMonsters();            // Sync
        // ----------------------

        // Log final completion message to sidebar (HTML and Plain Text)
        const sidebarMsgHtml = `⚡ <span class="red-bold">RESET ALL TO MAX!</span> ⚡`;
        const sidebarMsgText = `⚡ RESET ALL TO MAX! ⚡`;
        fPrependToSidebar(sidebarMsgHtml, sidebarMsgText); // Add final message
        fShowSidebar();

        fMyConsoleLog("✅ Reset All to Max Action Completed.");

        // Send final log state AFTER all actions AND the final message are logged (with slight delay)
        setTimeout(() => fSendLogToGMScreenNPS(), 0); 

    } else {
        fMyConsoleLog("   -> User cancelled Reset All action.");
    }
} // END fHandleResetAllToMax




// fClearChanneledMeta /////////////////////////////////////////////////////////////
// Purpose -> Handles the <Game><Clear><Channeled Meta> menu action. Clears the
//            values in the Channeled Meta range (defined by gUI.range.metaChannel)
//            by setting them to empty strings using fSetRangeValues.
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM).
function fClearChanneledMeta() {
    fMyConsoleLog("⚙️ Menu Action: Clearing Channeled Meta...");

    // === 1. Get Range Definition ===
    const metaChannelRange = gUI.range?.metaChannel;

    // === 2. Validate Range Object ===
    if (!metaChannelRange || !fIsValidRangeObject(metaChannelRange)) {
        console.warn("fClearChanneledMeta: Channeled Meta range definition is missing or incomplete in gUI.range.metaChannel.");
        fMyConsoleLog("⚠️ Cannot clear Channeled Meta: Range definition missing or incomplete.");
        fShowMessage("Error: Channeled Meta range definition is missing.");
        return;
    }

    // === 3. Clear Range Values ===
    // Call fSetRangeValues to set all cells in the range to empty string
    const success = fSetRangeValues(
        metaChannelRange.r1,
        metaChannelRange.c1,
        metaChannelRange.r2,
        metaChannelRange.c2,
        '' // Set value to empty string
    );

    // === 4. Log Result ===
    if (!success) {
        // fSetRangeValues logs specific errors
        fMyConsoleLog(`⚠️ Failed to clear Channeled Meta range (${metaChannelRange.r1},${metaChannelRange.c1} to ${metaChannelRange.r2},${metaChannelRange.c2}).`);
        // Optional: fShowMessage("Error clearing the channeled meta range.");
    } else {
        fMyConsoleLog("✅ Channeled Meta Range Cleared.");
    }

} // END fClearChanneledMeta



// fClearSk1Sk2Checkboxes ////////////////////////////////////////////////////////
// Purpose -> Handles the <Game><Clear><All Check Boxes...> menu action. Clears
//            (sets to false) all checkboxes within the ranges defined in
//            gUI.range.sk1sk2CheckBoxes using fSetRangeValues. Also clears the tracker.
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM, clears gUI.currentSkRadioChecked).
function fClearSk1Sk2Checkboxes() {
    fMyConsoleLog("⚙️ Menu Action: Clearing Sk1/Sk2 Checkboxes...");
    let allSucceeded = true;
    const rangesToClear = gUI.range.sk1sk2CheckBoxes; // Get the array of ranges

    // === Validate Configuration ===
    if (!Array.isArray(rangesToClear) || rangesToClear.length === 0) {
        fMyConsoleLog("ℹ️ No Sk1/Sk2 checkbox ranges defined in gUI.range.sk1sk2CheckBoxes.");
        return;
    }

    // === Clear Checkboxes in Each Range ===
    rangesToClear.forEach(range => {
        // Resolve each range definition
        const r1 = resolveRow(range.r1);
        const c1 = resolveCol(range.c1);
        const r2 = resolveRow(range.r2);
        const c2 = resolveCol(range.c2);

        // Validate resolved indices
        if ([r1, c1, r2, c2].some(isNaN)) {
             console.warn(`fClearSk1Sk2Checkboxes: Skipping invalid range definition:`, range);
             allSucceeded = false; // Mark failure
             return; // Skip this range
        }

        // Call fSetRangeValues to set all checkboxes in the range to false
        const success = fSetRangeValues(r1, c1, r2, c2, false);
        if (!success) {
             allSucceeded = false; // Track if any update fails
        }
    });

    // === Clear Tracker ===
    gUI.currentSkRadioChecked = { r: null, c: null }; // Reset the tracker

    // === Log Result ===
    if (!allSucceeded) {
         fMyConsoleLog("⚠️ Failed to clear one or more Sk1/Sk2 Checkbox ranges.");
         // Optional: fShowMessage("Error clearing some checkboxes.");
    } else {
        fMyConsoleLog("✅ Sk1/Sk2 Checkboxes Cleared.");
    }

} // END fClearSk1Sk2Checkboxes




// fClearMonsters ////////////////////////////////////////////////////////////////
// Purpose -> Handles the <Game><Clear><Monsters> menu action. Clears the monster
//            data range (defined by gUI.range.monsters) by setting cell values
//            to a space character (' ') using fSetRangeValues.
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM).
function fClearMonsters() {
    fMyConsoleLog("⚙️ Menu Action: Clearing Monsters...");
    const monsterRange = gUI.range?.monsters; // Get the range definition

    // === Validate Range Definition ===
    if (!monsterRange || !fIsValidRangeObject(monsterRange)) {
        console.warn("fClearMonsters: Monster range definition is missing or incomplete in gUI.range.monsters.");
        fMyConsoleLog("⚠️ Cannot clear monsters: Range definition missing or incomplete.");
        // Optional: fShowMessage("Error: Monster range definition missing.");
        return;
    }

    // === Clear Range Values ===
    const clearValue = ' '; // Use a space character to clear cells
    const success = fSetRangeValues(
        monsterRange.r1,
        monsterRange.c1,
        monsterRange.r2,
        monsterRange.c2,
        clearValue
    );

    // === Log Result ===
    if (!success) {
         // fSetRangeValues logs specific errors
         fMyConsoleLog(`⚠️ Failed to clear Monsters range (${monsterRange.r1},${monsterRange.c1} to ${monsterRange.r2},${monsterRange.c2}).`);
         // Optional: fShowMessage("Error clearing the monster data range.");
    } else {
        fMyConsoleLog("✅ Monsters Range Cleared.");
    }
} // END fClearMonsters





// fClearMorphs //////////////////////////////////////////////////////////////////
// Purpose -> Handles the <Game><Clear><Morphs> menu action. Clears the Morph1
//            and Morph2 columns within the Ability and Gear tables (ranges defined
//            in gUI.range.morphs) by setting cell values to a space (' ').
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM).
function fClearMorphs() {
    fMyConsoleLog("⚙️ Menu Action: Clearing Morphs...");
    let allSucceeded = true;
    const morphRanges = gUI.range?.morphs; // Get array of Morph1/Morph2 ranges

    // === Validate Configuration ===
    if (!Array.isArray(morphRanges) || morphRanges.length === 0) {
        console.warn("fClearMorphs: No morph ranges defined in gUI.range.morphs.");
        fMyConsoleLog("⚠️ Cannot clear morphs: Ranges not defined.");
        // Optional: fShowMessage("Error: Morph ranges not defined.");
        return;
    }

    // === Clear Each Morph Range ===
    morphRanges.forEach(range => {
        // Validate the range object structure
        if (!fIsValidRangeObject(range)) {
            console.warn("fClearMorphs: Skipping invalid range object within gUI.range.morphs:", range);
            allSucceeded = false;
            return; // Skip this invalid range
         }

        // Call fSetRangeValues to clear the range with spaces
        const success = fSetRangeValues(range.r1, range.c1, range.r2, range.c2, ' ');
        if (!success) {
             allSucceeded = false; // Track if any update fails
        }
    });

    // === Log Result ===
    if (!allSucceeded) {
         fMyConsoleLog("⚠️ Failed to clear one or more Morph ranges.");
         // Optional: fShowMessage("Error clearing some morph ranges.");
     } else {
        fMyConsoleLog("✅ Morph Ranges Cleared.");
    }
} // END fClearMorphs




// fClearCurrentNish /////////////////////////////////////////////////////////////
// Purpose -> Handles the <Game><Clear><Nish> menu action. Clears the current Nish
//            value cell (defined by gUI.range.currentNish) by setting its value
//            to a space (' ').
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM).
function fClearCurrentNish() {
    fMyConsoleLog("⚙️ Menu Action: Clearing Current Nish...");
    const nishRange = gUI.range?.currentNish; // Get the range definition

    // === Validate Range Definition ===
    if (!nishRange || !fIsValidRangeObject(nishRange)) {
        console.warn("fClearCurrentNish: Nish range definition is missing or incomplete in gUI.range.currentNish.");
        fMyConsoleLog("⚠️ Cannot clear Nish: Range definition missing or incomplete.");
        // Optional: fShowMessage("Error: Nish range definition missing.");
        return;
    }

    // === Clear Cell Value ===
    const clearValue = ' '; // Use a space character to clear the cell
    const success = fSetRangeValues(
        nishRange.r1,
        nishRange.c1,
        nishRange.r2, // Usually same as r1 for single cell
        nishRange.c2, // Usually same as c1 for single cell
        clearValue
    );

    // === Log Result ===
    if (!success) {
         // fSetRangeValues logs specific errors
         fMyConsoleLog(`⚠️ Failed to clear Nish range (${nishRange.r1},${nishRange.c1}).`);
         // Optional: fShowMessage("Error clearing the Nish data cell.");
    } else {
        fMyConsoleLog("✅ Current Nish Range Cleared.");
    }
} // END fClearCurrentNish




// fClearRollLog /////////////////////////////////////////////////////////////////
// Purpose -> Handles the <Game><Clear><Roll Log> menu action. Clears the sidebar,
//            plain text log array, displays confirmation, shows sidebar, and sends update.
// Inputs  -> None.
// Outputs -> None (Modifies sidebar DOM, gUI.plainTextLogEntries, calls fShowSidebar, fSendLogToGMScreenNPS).
function fClearRollLog() {
    fMyConsoleLog("⚙️ Menu Action: Clearing Roll Log...");
    const sidebarContent = document.getElementById('sidebar-content');
    if (!sidebarContent) {
        console.error("fClearRollLog: Could not find sidebar content element (#sidebar-content).");
        fMyConsoleLog("⚠️ Cannot clear Roll Log: Sidebar content element not found.");
        return;
    }

    // Clear the HTML display and add confirmation message
    const clearedMsgHtml = '<p><span class="blue-bold">Roll Log Cleared</span></p>';
    sidebarContent.innerHTML = clearedMsgHtml;

    // Clear the plain text log array and add the cleared message
    const clearedMsgText = 'Roll Log Cleared';
    gUI.plainTextLogEntries = [clearedMsgText];
    fMyConsoleLog("✅ Roll Log Cleared (HTML and plain text array).");

    // Ensure sidebar is visible after clearing <<< ADDED >>>
    fShowSidebar();

    // Send the cleared state (with the confirmation message) to the GMScreen (with slight delay)
    setTimeout(() => fSendLogToGMScreenNPS(), 0);

} // END fClearRollLog




// fToggleGearColumns //////////////////////////////////////////////////////////////
// Purpose -> Handles the <Gear><Gear (Show/Hide)> menu action. Checks if any column
//            within the gear ranges (defined in gUI.gearTblCols) is currently visible.
//            Calls fHideColumnRange or fShowColumnRange accordingly to toggle visibility.
// Inputs  -> None.
// Outputs -> None (Calls show/hide range functions).
function fToggleGearColumns() {
    const gearRanges = gUI.gearTblCols; // Get the array of gear column ranges

    // === Validate Configuration ===
    if (!Array.isArray(gearRanges) || gearRanges.length === 0) {
        console.error("fToggleGearColumns: gUI.gearTblCols is not a valid array or is empty.");
        fMyConsoleLog("❌ Error: Gear column definition missing or invalid.");
        // Optional: fShowMessage("Error: Gear column range definitions missing.");
        return;
    }

    // === Check Current Visibility ===
    // Determine if *any* column within the defined gear ranges is currently visible
    let isCurrentlyVisible = false;
    for (const range of gearRanges) {
        // Validate range object
        if (!range || typeof range.c1 === 'undefined' || typeof range.c2 === 'undefined') {
            console.warn("fToggleGearColumns: Skipping invalid range object:", range);
            continue;
        }
        // Resolve tags/indices
        const startCol = resolveCol(range.c1);
        const endCol = resolveCol(range.c2);
        if (isNaN(startCol) || isNaN(endCol)) {
            console.warn(`fToggleGearColumns: Skipping gear range due to invalid tags/indices: ${range.c1}, ${range.c2}`);
            continue;
        }

        // Check columns within this range
        const cMin = Math.min(startCol, endCol);
        const cMax = Math.max(startCol, endCol);
        for (let c = cMin; c <= cMax; c++) {
            // If one visible column is found, set flag and exit loops
            if (!gUI.hiddenColumns.has(c)) {
                isCurrentlyVisible = true;
                break;
            }
        }
        if (isCurrentlyVisible) break; // Exit outer loop if visibility confirmed
    }

    // === Toggle Visibility ===
    // Call the appropriate show/hide function based on current state
    if (isCurrentlyVisible) {
        fMyConsoleLog("⚙️ Toggling Gear: Currently Visible -> Hiding...");
        fHideColumnRange(gearRanges); // Hide all defined gear ranges
    } else {
        fMyConsoleLog("⚙️ Toggling Gear: Currently Hidden -> Showing...");
        fShowColumnRange(gearRanges); // Show all defined gear ranges
    }
} // END fToggleGearColumns










// fHandleDesignerOnlyClick ////////////////////////////////////////////////////
// Purpose -> Handles clicks on the "Data" -> "Designer Only" menu item.
//            Initiates the password prompt flow.
// Inputs  -> None.
// Outputs -> None (Calls fPromptForDesignerPassword).
function fHandleDesignerOnlyClick() {
    fMyConsoleLog("⚙️ Menu Action: Designer Only Clicked...");
    fPromptForDesignerPassword(); // Start the password process
} // END fHandleDesignerOnlyClick




// fPromptForDesignerPassword //////////////////////////////////////////////////
// Purpose -> Prompts the user for the Designer Password using window.prompt
//            and calls the server-side validation function if a password is entered.
// Inputs  -> None.
// Outputs -> None (Calls google.script.run or shows messages).
async function fPromptForDesignerPassword() {
    fMyConsoleLog("🔑 Prompting for Designer Password...");

    // Use the browser's native prompt for password input
    const enteredPassword = window.prompt("Enter Designer Password:");

    // Check if the user entered a password (prompt returns null if Cancel is clicked)
    if (enteredPassword !== null) {
        fMyConsoleLog("   -> Password entered. Calling server for validation...");
        // Show a temporary message while verifying
        const verifyingMsg = fShowMessage("🔐 Verifying Password..."); // Don't await

        google.script.run
            .withSuccessHandler((isValid) => {
                // Success handler for the server call
                fHandleDesignerPasswordResult(isValid); // Handle the boolean result
            })
            .withFailureHandler((error) => {
                // Failure handler for the server call (transport error)
                fHideMessage(); // Ensure verifying message is hidden
                const errorMsg = `Error communicating with server for password validation: ${error.message}`;
                console.error("fPromptForDesignerPassword Failure:", error);
                fMyConsoleLog(`   -> ❌ ${errorMsg}`);
                fShowMessage(`❌ ${errorMsg}`); // Show error to user
                // Ensure designer mode is off if communication fails
                gUI.isDesignerMode = false;
                const designerButton = document.getElementById('btn-designer-menu');
                if(designerButton) designerButton.style.display = 'none';
            })
            .fValidateDesignerPassword(enteredPassword); // Call the server function

    } else {
        // User clicked Cancel on the prompt
        fMyConsoleLog("   -> User cancelled password prompt.");
        // Optionally show a message indicating cancellation
        // await fShowMessage("Designer password entry cancelled.");
    }
} // END fPromptForDesignerPassword



// fHandleDesignerPasswordResult ///////////////////////////////////////////////
// Purpose -> Handles the boolean result from the server-side password validation.
//            Shows/hides the Designer button and updates state accordingly.
// Inputs  -> isValid (Boolean): The result from fValidateDesignerPassword.
// Outputs -> None (Modifies DOM, gUI state, shows messages).
function fHandleDesignerPasswordResult(isValid) {
    fMyConsoleLog(`🔑 Handling Password Validation Result: ${isValid}`);
    fHideMessage(); // Hide any "Verifying..." message

    const designerButton = document.getElementById('btn-designer-menu');
    if (!designerButton) {
        console.error("fHandleDesignerPasswordResult: Could not find Designer button (#btn-designer-menu).");
        fShowMessage("Error: Could not find the Designer menu button element.");
        gUI.isDesignerMode = false; // Ensure mode is off
        return;
    }

    if (isValid) {
        fMyConsoleLog("   -> Password CORRECT. Enabling Designer Mode.");
        designerButton.style.display = 'inline-flex'; // Make button visible (use inline-flex like others)
        gUI.isDesignerMode = true; // Set flag
        fShowMessage("✅ Designer Mode Enabled!"); // Show success feedback
    } else {
        fMyConsoleLog("   -> Password INCORRECT.");
        designerButton.style.display = 'none'; // Ensure button is hidden
        gUI.isDesignerMode = false; // Ensure flag is false
        fShowMessage("❌ Incorrect Password."); // Show failure feedback
    }
} // END fHandleDesignerPasswordResult




// ==========================================================================
// === MENU BAR "LIKE"     (End of Menu Bar Click) ===
// ==========================================================================



// fCalculateMovementAndEncumbrance ///////////////////////////////////////////////////
// Purpose -> Calculates Movement Rate (MR) tiers and Carry Capacity tiers based on Agility,
//            Strength, and bonuses. Determines the character's current MR by comparing
//            current encumbrance to carry capacity tiers. Updates the MR/Carry table,
//            checkboxes, and the main MR display cell.
// Inputs  -> None (Reads values directly from gUI.arr using tags).
// Outputs -> (Promise<void>): Resolves when calculations and updates are complete. May show
//                              an alert message if over-encumbered.
async function fCalculateMovementAndEncumbrance() {
    fMyConsoleLog("⚙️ Calculating Movement Rate and Encumbrance...");

    // === 1. Define Constants ===
    const movementMultipliers = [1, 0.9, 0.8, 0.65, 0.5, 0.25];
    const carryMultipliers = [1, 2, 4, 8, 12, 16];
    const mrColumnTags = ['GearMRCol1', 'GearMRCol2', 'GearMRCol3', 'GearMRCol4', 'GearMRCol5', 'GearMRCol6'];
    const MR_TABLE_ROW = 'GearMRTbl';
    const CARRY_TABLE_ROW = 'GearCarryTbl';
    const CHECKBOX_ROW = 'GearMRCheckBox_R';

    // === 2. Get Input Values ===
    let errorMsg = '';
    const agilityValue = fGetGridValue('Agi', 'Sk1', true);
    const strengthValue = fGetGridValue('Str', 'Sk1', true);
    const plusMRValue = fGetGridValue('GearPlusMR', 'GearPlusMR', true) || 0; // Default 0 if NaN/empty
    const plusCarryValue = fGetGridValue('GearPlusCarry', 'GearPlusCarry', true) || 0; // Default 0 if NaN/empty
    const currentEncumbrance = fGetGridValue('PossEncTot', 'PossEncTot', true) || 0; // Default 0 if NaN/empty

    // Validate essential inputs
    if (isNaN(agilityValue)) errorMsg += "Agility ('Agi', 'Sk1') is not a valid number. ";
    if (isNaN(strengthValue)) errorMsg += "Strength ('Str', 'Sk1') is not a valid number. ";
    if (isNaN(currentEncumbrance)) errorMsg += "Current Encumbrance ('PossEncTot', 'PossEncTot') is not a valid number.";

    if (errorMsg) {
        console.error(`fCalculateMovementAndEncumbrance: Input validation failed: ${errorMsg}`);
        fMyConsoleLog(`❌ MR/Enc Calc Failed: ${errorMsg}`);
        await fShowMessage(`Error calculating MR/Enc: ${errorMsg}`);
        return;
    }

    fMyConsoleLog(`   -> Inputs: Agi=${agilityValue}, Str=${strengthValue}, +MR=${plusMRValue}, +Carry=${plusCarryValue}, CurrentEnc=${currentEncumbrance}`);

    // === 3. Update Gear Table Overview ===
    let updateSuccess = true;
    updateSuccess &&= fSetGridValue('GearSpe', 'GearSpeAndStr', agilityValue);
    updateSuccess &&= fSetGridValue('GearStr', 'GearSpeAndStr', strengthValue);

    if (!updateSuccess) {
        fMyConsoleLog("   -> ⚠️ Warning: Failed to update GearSpe/GearStr overview cells.");
        // Continue calculation even if these fail? For now, yes.
    }

    // === 4. Calculate and Update MR & Carry Tables & Checkboxes ===
    let foundActiveMRLevel = false;
    let finalMovementRate = 0;
    let calculationErrors = false;

    for (let i = 0; i < mrColumnTags.length; i++) {
        const colTag = mrColumnTags[i];

        // Calculate MR and Carry for this column
        const movementRate = Math.round((6 + agilityValue / 5 + plusMRValue) * movementMultipliers[i]);
        const carryCapacity = Math.round((50 + strengthValue + plusCarryValue) * carryMultipliers[i]);

        // Update Grid Cells for this column
        let mrSet = fSetGridValue(MR_TABLE_ROW, colTag, movementRate);
        let carrySet = fSetGridValue(CARRY_TABLE_ROW, colTag, carryCapacity);
        let cbSetInitial = fSetGridValue(CHECKBOX_ROW, colTag, false); // Set to false initially

        if (!mrSet || !carrySet || !cbSetInitial) {
            fMyConsoleLog(`   -> ⚠️ Error setting MR/Carry/Checkbox values for column ${colTag}.`);
            calculationErrors = true;
            // Continue processing other columns despite error? For now, yes.
        } else {
            // fMyConsoleLog(`   -> Col '${colTag}': MR=${movementRate}, Carry=${carryCapacity}`);
        }

        // Check if this is the active MR level
        if (!foundActiveMRLevel && currentEncumbrance <= carryCapacity) {
            fMyConsoleLog(`   -> Active MR Level Found: Col '${colTag}' (Enc ${currentEncumbrance} <= Carry ${carryCapacity})`);
            if (!fSetGridValue(CHECKBOX_ROW, colTag, true)) { // Try to check the box
                fMyConsoleLog(`   -> ⚠️ Error setting Checkbox to TRUE for column ${colTag}.`);
                calculationErrors = true;
            } else {
                foundActiveMRLevel = true;
                finalMovementRate = movementRate;
                fMyConsoleLog(`   -> Final MR set to: ${finalMovementRate}`);
            }
        }
    } // End loop

    // === 5. Update Final MR Cell ===
    if (!fSetGridValue('MR', 'MR', finalMovementRate)) {
        fMyConsoleLog("   -> ⚠️ Error setting final MR value in ('MR', 'MR').");
        calculationErrors = true;
    }

    // === 6. Show Over-Encumbered Alert ===
    if (!foundActiveMRLevel || finalMovementRate === 0) { // Check if no level was found OR MR ended up 0
        fMyConsoleLog("   -> 🚨 Character is over-encumbered!");
        await fShowMessage("You are over encumbered, MR is 0.");
    }

    // === 7. Log Completion Status ===
    if (calculationErrors) {
        fMyConsoleLog("❌ MR/Enc Calc Completed with errors.");
    } else {
        fMyConsoleLog("✅ MR/Enc Calc Completed successfully.");
    }

} // END fCalculateMovementAndEncumbrance



// ==========================================================================
// === Header Button Click     (End of MENU BAR "LIKE") ===
// ==========================================================================



// fHandleHeaderButtonClick //////////////////////////////////////////////////////
// Purpose -> Handles clicks delegated from the grid specifically for header button images.
//            Routes the click to the appropriate action handler based on the
//            image's 'data-button-action' attribute. Simulates a click on the
//            main '#btn-roll' for the 'action-rollDice' button.
// Inputs  -> event (MouseEvent): The original click event object.
//         -> buttonImg (HTMLImageElement): The header button image element that was clicked.
// Outputs -> None (Calls other action functions).
function fHandleHeaderButtonClick(event, buttonImg) {
    const action = buttonImg.dataset.buttonAction;
    fMyConsoleLog(`🖱️ Header Button Clicked: ${action}`);

    event.preventDefault();  // Prevent any default image link behavior
    event.stopPropagation(); // Stop click from propagating further

    const grid = document.getElementById('grid'); // Needed for scrolling actions

    // === Dispatch Action ===
    switch (action) {
        case 'action-rollDice':
            // Simulate a click on the main Roll button in the menu bar
            const rollButton = document.getElementById('btn-roll');
            if (rollButton) {
                fMyConsoleLog("   -> Simulating click on #btn-roll...");
                rollButton.click(); // Trigger the main roll button's logic
            } else {
                console.error("fHandleHeaderButtonClick: Could not find #btn-roll element to simulate click!");
                fMyConsoleLog("   -> ❌ Error: Could not find #btn-roll.");
                // Optional: fShowMessage("Error: Could not find the main Roll button.");
            }
            break;

        case 'action-refreshData':
            // Placeholder for future refresh logic
            console.log("ACTION: Refresh Data button clicked (logic pending)");
             fMyConsoleLog("   -> Refresh Data action (pending implementation).");
           // await fFetchFullData(); // Example future call
            break;

        case 'action-jumpTop':
            fScrollGridToTop(grid); // Scroll grid viewport to top
            break;

        case 'action-jumpBottom':
            fScrollGridToBottom(grid); // Scroll grid viewport to bottom (Gear section)
            break;

        case 'action-showMonsters':
            fRefreshMonsterData(); // Refresh monster data from sheet
            break;

        default:
            console.warn(`Unhandled header button action: ${action}`);
    }
} // END fHandleHeaderButtonClick


// fScrollGridToTop ////////////////////////////////////////////////////////////////
// Purpose -> Scrolls the grid container smoothly to the top (0px scroll).
// Inputs  -> grid (HTMLElement): The grid container element (#grid).
// Outputs -> None (Performs scroll animation).
function fScrollGridToTop(grid) {
    if (grid) {
        // Use smooth scrolling behavior
        grid.scrollTo({ top: 0, behavior: 'smooth' });
    } else {
        // Log warning if grid element wasn't found
        console.warn("fScrollGridToTop: Could not find #grid element to scroll.");
    }
} // END fScrollGridToTop




// fScrollGridToBottom /////////////////////////////////////////////////////////////
// Purpose -> Scrolls the grid container smoothly to center the view vertically
//            on the start of the Gear Table section ('GearTblHeaderStartR').
// Inputs  -> grid (HTMLElement): The grid container element (#grid).
// Outputs -> None (Performs scroll animation).
function fScrollGridToBottom(grid) {
    // Validate grid element
    if (!grid) {
        console.warn("fScrollGridToBottom: Could not find #grid element to scroll.");
        return;
    }

    // Resolve target row index
    const targetRowTag = 'GearTblHeaderStartR';
    const targetRowIndex = resolveRow(targetRowTag);
    if (isNaN(targetRowIndex)) {
        console.warn(`fScrollGridToBottom: Could not resolve row tag '${targetRowTag}' for scrolling.`);
        return;
    }

    // Get the target cell element (using column 0)
    const targetCell = gUI.grid2D?.[targetRowIndex]?.[0];
    if (!targetCell) {
        console.warn(`fScrollGridToBottom: Could not find cell element for row ${targetRowIndex} (Tag: ${targetRowTag})`);
        return;
    }

    // Calculate the scroll position to center the target row
    // (offsetTop of cell - half viewport height + half cell height)
    const scrollTop = targetCell.offsetTop - (grid.clientHeight / 2) + (targetCell.offsetHeight / 2);

    // Perform smooth scroll
    grid.scrollTo({ top: scrollTop, behavior: 'smooth' });
    fMyConsoleLog(`Scrolling grid to center row ${targetRowIndex} (Tag: ${targetRowTag})`);

} // END fScrollGridToBottom



// fRefreshMonsterData /////////////////////////////////////////////////////////////
// Purpose -> Handles the 'Show Monsters' header button action. Clears the Turbo
//            monster table locally, fetches fresh monster data from the GM Screen DB
//            via the server, and then populates the Turbo table using the returned data.
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM, calls server function).
async function fRefreshMonsterData() {
    fMyConsoleLog("⚙️ Refreshing Monster Data from GM Screen DB...");

    // === 1. Get and Validate Turbo Monster Range Definition ===
    // This is the range on the *client-side* Turbo grid we will populate
    const turboMonsterRangeDef = gUI.range?.monsters;
    if (!turboMonsterRangeDef || !fIsValidRangeObject(turboMonsterRangeDef)) {
        const msg = "Turbo Monster range definition (gUI.range.monsters) is missing or invalid.";
        console.error(`fRefreshMonsterData: ${msg}`);
        fMyConsoleLog(`❌ Monster Refresh Failed: ${msg}`);
        await fShowMessage(`Error: ${msg}`);
        return;
    }
    // We don't resolve indices here, fUpdateTurboMonsterTable will handle it.

    // === 2. Get GM Screen DB Range Definition ===
    // This is the range we request from the server's 'GMScreen' sheet in the 'db' file
    const gmMonsterRangeDef = gUI.rangeDB?.monstersDB;
     if (!gmMonsterRangeDef || !fIsValidRangeObject(gmMonsterRangeDef)) {
        const msg = "GM Screen DB Monster range definition (gUI.rangeDB.monstersDB) is missing or invalid.";
        console.error(`fRefreshMonsterData: ${msg}`);
        fMyConsoleLog(`❌ Monster Refresh Failed: ${msg}`);
        await fShowMessage(`Error: ${msg}`);
        return;
    }


    // === 3. Clear Local Turbo Monster Table ===
    fMyConsoleLog(`   -> Clearing local Turbo monster table...`);
    fClearMonsters(); // Clears based on gUI.range.monsters definition

    // === 4. Call Server Function ===
    fMyConsoleLog(`   -> Fetching GM monster data using key 'db', sheet 'GMScreen', range: ${JSON.stringify(gmMonsterRangeDef)}`);
    // Consider adding a visual loading indicator here

    google.script.run
        // --- Success Handler ---
        .withSuccessHandler((response) => {
            // Remove loading indicator here
            fMyConsoleLog(`   -> Received response from server.`);

            // === Validate Response Structure ===
            if (!response || typeof response !== 'object' || response.error ||
                !response.hasOwnProperty('data') || !response.hasOwnProperty('colTags') || !response.hasOwnProperty('rowTags') ) {
                const errMsg = "Received invalid data structure from server for monsters.";
                console.error(`fRefreshMonsterData Success Handler: ${errMsg}`, response);
                fMyConsoleLog(`   -> ❌ Error: ${errMsg}`);
                fShowMessage(`Error: ${errMsg}`);
                return;
            }

            const { data: gmDataArray, colTags: gmColTags, rowTags: gmRowTags } = response;
            fMyConsoleLog(`   -> Server returned Data (${Array.isArray(gmDataArray) ? gmDataArray.length : 'N/A'}), ColTags (${Object.keys(gmColTags).length}), RowTags (${Object.keys(gmRowTags).length}).`);

            // === Process Received Data ===
            // Call the new helper function to populate the Turbo grid
            fUpdateTurboMonsterTable(gmDataArray, gmColTags, gmRowTags);

        })
        // --- Failure Handler ---
        .withFailureHandler((error) => {
            // Remove loading indicator here
            const errorMsgFromServer = error.message || "Unknown server error";
            const finalErrorMsg = `Failed to fetch monster data from server: ${errorMsgFromServer}`;
            console.error(`fRefreshMonsterData Failure Handler:`, error);
            fMyConsoleLog(`❌ Monster Refresh Failed: ${finalErrorMsg}`);
            fShowMessage(`Error: ${finalErrorMsg}`);
        })
        // === Server Function Call ===
        // Pass the DB key, Sheet Name, and the GM Screen Range Object
        .fGetServerSheetData('db', 'GMScreen', gmMonsterRangeDef);

} // END fRefreshMonsterData



// ==========================================================================
// === Firestore Text Read/Write     (End of Header Button Click) ===
// ==========================================================================



// fCaptureTextState ///////////////////////////////////////////////////////////
// Purpose -> Iterates through grid data (gUI.arr) and notes (gUI.notes),
//            building an object containing only non-empty text/note values,
//            keyed by 'r,c' strings.
// Inputs  -> None (Uses gUI.arr, gUI.notes).
// Outputs -> (Object): { 'r,c': 'text', 'r2,c2': 'note text', ... } or empty object.
function fCaptureTextState() {
    fMyConsoleLog("💾 Capturing Grid Text State...");
    const textData = {};
    const numRows = gUI.arr?.length || 0;
    const numCols = numRows > 0 ? gUI.arr[0].length : 0;
    let cellsWithText = 0;

    // Iterate through main data array (gUI.arr)
    for (let r = 0; r < numRows; r++) {
        for (let c = 0; c < numCols; c++) {
            const value = gUI.arr[r]?.[c];
            // Only add if value is a non-empty string (trimmed)
            if (typeof value === 'string' && value.trim() !== '') {
                const key = `${r},${c}`;
                textData[key] = value; // Store original value
                cellsWithText++;
            }
        }
    }

    // Iterate through notes array (gUI.notes)
    const noteRows = gUI.notes?.length || 0;
    if (noteRows > 0) {
        const noteCols = gUI.notes[0]?.length || 0;
        for (let r = 0; r < noteRows; r++) {
            for (let c = 0; c < noteCols; c++) {
                const noteText = gUI.notes[r]?.[c]?.trim();
                // Only add if note text is non-empty
                if (noteText) {
                    const key = `${r},${c}_note`; // Use distinct key for notes
                    // Avoid overwriting if cell text and note exist for same r,c
                    // Although keys are now distinct, this check prevents adding if note is blank
                    if (!textData[key]) {
                         textData[key] = noteText; // Store trimmed note text
                         cellsWithText++; // Count notes with text as well
                    }
                }
            }
        }
    }

    fMyConsoleLog(`   -> Captured text/notes from ${cellsWithText} cells.`);
    return textData;
} // END fCaptureTextState




// fHandleAutoSaveTextData /////////////////////////////////////////////////////
// Purpose -> Orchestrates the background auto-saving of the entire gUI.arr to Firestore.
//            Checks if data exists and initiates server call.
// Inputs  -> None.
// Outputs -> None (Initiates async server call).
function fHandleAutoSaveTextData() {
    fMyConsoleLog("💾 Handling Auto-Save Data (Full Array)...");

    // === 1. Check if gUI.arr exists and has data ===
    if (!gUI.arr || !Array.isArray(gUI.arr) || gUI.arr.length === 0) {
        fMyConsoleLog("   -> No grid data (gUI.arr) found to save. Skipping server call.");
        return; // Nothing to save
    }

    // === 2. Validate character info needed for metadata ===
    if (!gUI.characterInfo || !gIndexCSID) {
         console.error("fHandleAutoSaveTextData: Missing gIndexCSID or gUI.characterInfo needed for saving.");
         fMyConsoleLog("   -> ❌ Auto-save aborted: Missing CS ID or character info.");
         // Optionally show a non-disruptive warning? Maybe only after repeated fails?
         return;
    }

    // === 3. Call Server Function ===
    fMyConsoleLog("   -> Calling server function fSaveTextDataToFirestore with full gUI.arr...");
    // Pass gUI.arr directly instead of textData
    google.script.run
        .withSuccessHandler(fHandleAutoSaveSuccess)
        .withFailureHandler(fHandleAutoSaveFailure)
        .fSaveTextDataToFirestore(gIndexCSID, gUI.arr, gUI.characterInfo); // Pass gUI.arr

} // END fHandleAutoSaveTextData




// fHandleAutoSaveSuccess //////////////////////////////////////////////////////
// Purpose -> Success callback for the fSaveTextDataToFirestore server call.
//            Logs success and provides minimal UI feedback.
// Inputs  -> result (Object): The object returned from the server (expected: { success: true }).
// Outputs -> None.
function fHandleAutoSaveSuccess(result) {
    // Basic check if server explicitly indicated success (optional)
    if (result && result.success) {
        fMyConsoleLog("   -> ✅ Auto-save successful (Server confirmed).");
    } else {
        // Log even if server didn't return explicit success, as long as failure handler wasn't called
        fMyConsoleLog("   -> ✅ Auto-save call completed (Server response did not explicitly indicate failure).");
        // If server returns {success: false, message: '...'}, failure handler should catch it.
    }

    // --- REMOVED Subtle UI Feedback (Flash icon) ---

} // END fHandleAutoSaveSuccess



// fHandleAutoSaveFailure //////////////////////////////////////////////////////
// Purpose -> Failure callback for the fSaveTextDataToFirestore server call.
//            Logs the error comprehensively to the console. Avoids disruptive user messages.
// Inputs  -> error (Error Object): The error object from the failed server call.
// Outputs -> None.
function fHandleAutoSaveFailure(error) {
    const errorMsg = `Auto-save to Firestore failed: ${error?.message || 'Unknown error'}`;
    console.error("❌ fHandleAutoSaveFailure:", errorMsg, error); // Log detailed error object
    fMyConsoleLog(`   -> ❌ ${errorMsg}`); // Log simplified message via fMyConsoleLog

    // --- Avoid Disruptive Messages ---
    // Generally, do NOT show fShowMessage here for background saves unless absolutely
    // critical or after repeated failures, as it interrupts the user experience.
    // If needed, implement a counter or flag for repeated failures.
    // Example (Conditional Message):
    // gUI.autoSaveFailureCount = (gUI.autoSaveFailureCount || 0) + 1;
    // if (gUI.autoSaveFailureCount > 3) {
    //     fShowMessage("Warning: Repeatedly failed to auto-save grid text.").catch(e => {});
    //     gUI.autoSaveFailureCount = 0; // Reset counter
    // }

} // END fHandleAutoSaveFailure




// fUnpackFirestoreArray ///////////////////////////////////////////////////////
// Purpose -> Converts the Firestore array-of-row-objects format back into a
//            standard 2D JavaScript array.
// Inputs  -> firestoreArr (Array): The array from Firestore, e.g.,
//            [ {"row0":[...]}, {"row1":[...]}, ... ]
// Outputs -> (Array[][]): A standard 2D JavaScript array.
function fUnpackFirestoreArray(firestoreArr) {
    const new2DArray = [];
    let maxRow = -1;

    // First pass to populate based on keys and find max row index encountered
    for (const rowObject of firestoreArr) {
        // Assuming only one key like "rowX" per object
        const key = Object.keys(rowObject)[0];
        if (!key || !key.startsWith('row')) continue; // Skip invalid objects

        const rowNum = parseInt(key.substring(3), 10);
        if (isNaN(rowNum)) continue; // Skip if key is not like "rowX"

        new2DArray[rowNum] = rowObject[key] || []; // Assign the inner array, default to empty
        if (rowNum > maxRow) {
            maxRow = rowNum;
        }
    }

    // Second pass to fill potential sparse gaps with empty arrays up to maxRow
    // This ensures gUI.arr doesn't have 'undefined' holes if Firestore data was sparse
    for (let r = 0; r <= maxRow; r++) {
         if (typeof new2DArray[r] === 'undefined') {
             new2DArray[r] = []; // Initialize empty row for sparse gaps
         }
    }

     // Optional Third Pass: Ensure all rows have the same length (based on the longest row found)
     // This might be necessary depending on how other code interacts with gUI.arr.
     // If not strictly needed, this step can be skipped for efficiency.
     /*
     let maxCols = 0;
     for(let r = 0; r < new2DArray.length; r++) {
         if (new2DArray[r].length > maxCols) {
             maxCols = new2DArray[r].length;
         }
     }
     for(let r = 0; r < new2DArray.length; r++) {
         while (new2DArray[r].length < maxCols) {
             new2DArray[r].push(''); // Pad with empty strings or appropriate default
         }
     }
     */

    return new2DArray;
} // END fUnpackFirestoreArray


// ==========================================================================
// === Initialization & Setup Functions     (End of Firestore Text Read/Write) ===
// ==========================================================================




// fSetupGridClickListeners ////////////////////////////////////////////////////////
// Purpose -> Attaches delegated 'click' and 'change' event listeners to the main
//            grid container (#grid) to handle user interactions like cell clicks,
//            checkbox toggles, URL clicks, and dropdown changes.
// Inputs  -> gridElement (HTMLElement): The grid container element.
// Outputs -> None (Attaches event listeners).
function fSetupGridClickListeners(gridElement) {
    // Validate input
    if (!gridElement) {
        console.error("fSetupGridClickListeners: Cannot setup listeners - Grid element not provided.");
        return;
    }

    fMyConsoleLog("🖱️ Setting up Grid Click & Change Listeners...");

    // Delegated 'click' listener (handles cell clicks, checkboxes, URLs, etc.)
    gridElement.addEventListener('click', fHandleGridClick);

    // Delegated 'change' listener (specifically for dropdowns within grid cells)
    gridElement.addEventListener('change', (event) => {
        // Check if the changed element is one of our grid dropdowns
        if (event.target.tagName === 'SELECT' && event.target.classList.contains('grid-dropdown')) {
            fHandleDropdownChange(event); // Call the dropdown change handler
        }
    });

    fMyConsoleLog("✅ Grid Click & Change Listeners Attached.");

} // END fSetupGridClickListeners




// fSetupGridHoverListeners ////////////////////////////////////////////////////////
// Purpose -> Attaches delegated 'mouseover' and 'mouseout' event listeners to the
//            grid container (#grid) to handle showing and hiding cell tooltips.
// Inputs  -> gridElement (HTMLElement): The grid container element.
// Outputs -> None (Attaches event listeners).
function fSetupGridHoverListeners(gridElement) {
    // Validate input
    if (!gridElement) {
        console.error("fSetupGridHoverListeners: Cannot setup hover listeners - Grid element not provided.");
        return;
    }

    fMyConsoleLog("🖱️ Setting up Grid Hover Listeners for Tooltips...");

    // Use mouseover/mouseout for better event delegation with cell children
    gridElement.addEventListener('mouseover', fHandleCellHover); // Handle entering a cell area
    gridElement.addEventListener('mouseout', fHandleCellMouseOut); // Handle leaving a cell area

    fMyConsoleLog("✅ Grid Hover Listeners Attached.");

} // END fSetupGridHoverListeners




// fHideImageModal /////////////////////////////////////////////////////////////////
// Purpose -> Hides the image modal element and clears its image source.
// Inputs  -> None (Uses gUI.modalElement, gUI.modalImageElement).
// Outputs -> None (Modifies modal DOM element styles and attributes).
function fHideImageModal() {
    // Check if modal elements are cached/exist
    if (!gUI.modalElement || !gUI.modalImageElement) return;

    // Hide the main modal container
    gUI.modalElement.style.display = 'none';
    // Clear the image source to prevent showing old image briefly on next open
    gUI.modalImageElement.src = '';
} // END fHideImageModal




// fSetupModalListeners ////////////////////////////////////////////////////////////
// Purpose -> Adds click event listeners to the image modal's close button
//            (#modal-close-btn) and backdrop (#modal-backdrop) to hide the modal.
// Inputs  -> None (Uses gUI.modalCloseBtn, gUI.modalBackdrop).
// Outputs -> None (Attaches event listeners).
function fSetupModalListeners() {
    // Check if modal elements required for listeners are cached/exist
    if (!gUI.modalCloseBtn || !gUI.modalBackdrop) {
         fMyConsoleLog("⚠️ Cannot setup modal listeners: Modal close button or backdrop not found.");
         console.warn("Modal listeners not set up.");
         return;
    }

    fMyConsoleLog("🖱️ Setting up Modal Listeners...");

    // Add listener to close button
    gUI.modalCloseBtn.addEventListener('click', fHideImageModal);

    // Add listener to backdrop (closes modal if background is clicked)
    gUI.modalBackdrop.addEventListener('click', fHideImageModal);

    fMyConsoleLog("✅ Modal Listeners Attached.");

} // END fSetupModalListeners




// fSetupMenuInteractivity /////////////////////////////////////////////////////////
// Purpose -> Orchestrates the setup of all menu bar and sidebar interactivity,
//            including button clicks, dropdown toggles, submenu hover behavior,
//            delegated menu action clicks, and sidebar header/close buttons.
// Inputs  -> None (Gets elements by ID).
// Outputs -> None (Attaches various event listeners).
function fSetupMenuInteractivity() {
    fMyConsoleLog("⚙️ Setting up Menu & Sidebar Interactivity...");
    // === Get Element References ===
    const menuBar = document.getElementById('menu-bar');
    const btnNish = document.getElementById('btn-nish');
    const btnRoll = document.getElementById('btn-roll'); // Keep reference for sidebar button
    const btnFree = document.getElementById('btn-free');
    const btnLuck = document.getElementById('btn-luck');
    const btnGame = document.getElementById('btn-game-menu');
    const dropdownGame = document.getElementById('dropdown-game');
    const btnGear = document.getElementById('btn-gear-menu');
    const dropdownGear = document.getElementById('dropdown-gear');
    const btnData = document.getElementById('btn-data-menu');
    const dropdownData = document.getElementById('dropdown-data');
    const btnDesigner = document.getElementById('btn-designer-menu');     
    const dropdownDesigner = document.getElementById('dropdown-designer'); 
    const sidebarCloseBtn = document.getElementById('sidebar-close-btn');
    const sidebarRollBtn = document.getElementById('sidebar-roll-btn');
    const sidebarRefreshLogBtn = document.getElementById('sidebar-refresh-log-btn');

    // === Validate Elements ===
    if (!menuBar || !btnNish || !btnRoll || !btnFree || !btnLuck ||
        !btnGame || !dropdownGame || !btnGear || !dropdownGear ||
        !btnData || !dropdownData ||
        !btnDesigner || !dropdownDesigner ||
        !sidebarCloseBtn || !sidebarRollBtn || !sidebarRefreshLogBtn)
    {
        console.error("❌ Could not find all required menu/sidebar elements for interactivity setup.");
        // Log specific missing elements for easier debugging
        if(!menuBar) console.error("     -> Missing: #menu-bar");
        if(!btnNish) console.error("     -> Missing: #btn-nish");
        if(!btnRoll) console.error("     -> Missing: #btn-roll");
        if(!btnFree) console.error("     -> Missing: #btn-free");
        if(!btnLuck) console.error("     -> Missing: #btn-luck");
        if(!btnGame) console.error("     -> Missing: #btn-game-menu");
        if(!dropdownGame) console.error("     -> Missing: #dropdown-game");
        if(!btnGear) console.error("     -> Missing: #btn-gear-menu");
        if(!dropdownGear) console.error("     -> Missing: #dropdown-gear");
        if(!btnData) console.error("     -> Missing: #btn-data-menu");
        if(!dropdownData) console.error("     -> Missing: #dropdown-data");
        if(!btnDesigner) console.error("     -> Missing: #btn-designer-menu");
        if(!dropdownDesigner) console.error("     -> Missing: #dropdown-designer");
        if(!sidebarCloseBtn) console.error("     -> Missing: #sidebar-close-btn");
        if(!sidebarRollBtn) console.error("     -> Missing: #sidebar-roll-btn");
        if(!sidebarRefreshLogBtn) console.error("     -> Missing: #sidebar-refresh-log-btn");
        return; // Stop setup if essential elements are missing
    }

    // === Attach Listeners ===
    // Main menu bar button click handlers (Nish, Roll, Free, Luck, Game, Gear)
    fSetupMenuButtonListeners(btnNish, btnRoll, btnFree, btnLuck, btnGame, dropdownGame, btnGear, dropdownGear);

    // --- Specific Listener for Data Menu Button ---
    if (btnData && dropdownData) {
        btnData.addEventListener('click', (event) => {
            event.stopPropagation(); // Prevent window listener from closing it immediately
            const currentlyShown = dropdownData.classList.contains('show');
            fCloseAllDropdowns(); // Close any other open menus
            // Toggle the Data dropdown
            if (!currentlyShown) {
                dropdownData.classList.add('show');
            }
        });
    }

    // --- Specific Listener for Designer Menu Button --- <<< MODIFIED BLOCK >>>
    if (btnDesigner && dropdownDesigner) {
        btnDesigner.addEventListener('click', (event) => {
            event.stopPropagation();
            fMyConsoleLog("🖱️ Designer Menu Button Clicked...");

            // Only show the dropdown if designer mode is already enabled.
            // No need to re-prompt here. Re-prompting will happen per-action later.
            if (gUI.isDesignerMode) {
                const currentlyShown = dropdownDesigner.classList.contains('show');
                fCloseAllDropdowns(); // Close others
                if (!currentlyShown) {
                    dropdownDesigner.classList.add('show');
                    fMyConsoleLog("   -> Showing Designer dropdown.");
                }
            } else {
                // This case shouldn't happen if the button is only visible when mode is true,
                // but as a fallback, ensure the dropdown remains closed.
                fMyConsoleLog("   -> Designer mode is not active. Button click ignored.");
                fCloseAllDropdowns();
            }
        });
    }
    // --- END MODIFIED BLOCK ---

    // Window listener to close dropdowns on outside click
    fSetupWindowClickListener();
    // Delegated listener for actions within dropdown menus
    fSetupDelegatedMenuActionClick(menuBar);
    // Listeners for submenu hover behavior
    fSetupSubMenuHover(menuBar);
    // Listener for the sidebar close button
    sidebarCloseBtn.addEventListener('click', fHideSidebar);

    // --- Sidebar Header Button Listeners ---
    // Sidebar Roll Button (simulates click on main Roll button)
    sidebarRollBtn.addEventListener('click', () => {
        fMyConsoleLog("🖱️ Sidebar Roll Button Clicked -> Simulating Main Roll Button Click...");
        btnRoll.click(); // Trigger the click handler of the main #btn-roll
    });
    // Sidebar Refresh Log Button (calls function to resend log)
    sidebarRefreshLogBtn.addEventListener('click', () => {
        fMyConsoleLog("🖱️ Sidebar Refresh Log Button Clicked -> Calling fSendLogToGMScreenNPS...");
        fSendLogToGMScreenNPS(); // Call the function to resend logs
    });
    // --- End Sidebar Listeners ---

    fMyConsoleLog("✅ Menu & Sidebar Interactivity Setup Done");
} // END fSetupMenuInteractivity




// ==========================================================================
// === Initial Data Load      (End of Initialization & Setup Functions) ===
// ==========================================================================




////////////////////////////////////////////////////////////////////////////////////////////////////////// START fOnDataLoaded and helpers




// fOnDataLoaded ///////////////////////////////////////////////////////////////////
// Purpose -> Callback function executed upon successful data retrieval from the
//            server (fCSGetGameSheet5). Validates data, stores it in gUI, checks
//            Firestore for overriding data, fetches static header data, and
//            initiates grid rendering using the final data source.
// Inputs  -> data (Object): The structured data object from the server { arr, format, notesArr }.
// Outputs -> None (Initiates UI rendering and setup).
function fOnDataLoaded(data) {
    fMyConsoleLog("✅ Initial Sheet Data received from server");

    // === 1. Validate and Store Initial Sheet Data ===
    const isSheetDataValid = fStoreAndValidateData(data);
    if (!isSheetDataValid) {
        fMyConsoleLog("❌ Initial sheet data invalid or empty. Halting load process.");
        // fStoreAndValidateData shows messages/logs errors
        return;
    }
    fMyConsoleLog("   -> Stored initial data from Sheet into gUI.");

    // === 2. Check Firestore for Overriding Data ===
    fMyConsoleLog("⚙️ Checking Firestore for saved data...");
    google.script.run
        .withSuccessHandler((firestoreResponse) => {
            let useFirestoreData = false;
            if (firestoreResponse && firestoreResponse.success === true) {
                // Firestore data exists and was retrieved successfully
                if (firestoreResponse.firestoreArr && Array.isArray(firestoreResponse.firestoreArr)) {
                    fMyConsoleLog("   -> ✅ Firestore data found. Overwriting gUI.arr.");
                    gUI.arr = firestoreResponse.firestoreArr; // Use unpacked 2D array from server
                    // gUI.notes remains untouched, preserving Sheet notes
                    useFirestoreData = true;
                } else {
                    fMyConsoleLog("   -> ⚠️ Firestore check successful, but returned invalid 'firestoreArr'. Using Sheet data.");
                    // Optional: Show a warning message?
                }
            } else {
                // Firestore data not found or error during check
                const reason = firestoreResponse?.message || "Reason unknown.";
                fMyConsoleLog(`   -> ℹ️ Firestore check returned false (${reason}). Using Sheet data.`);
                // No changes needed, gUI.arr/gUI.notes retain Sheet data
            }

            // === 3. Proceed with Header Fetch & Grid Render (using final data) ===
            // This section now runs *after* the Firestore check completes.
            fSetupTooltipAndModal(); // Cache tooltip/modal elements (can be done earlier if needed)
            fFetchCharacterHeaderAndRenderGrid(); // New function to group next steps

        })
        .withFailureHandler((error) => {
            // Handle transport errors calling fCheckAndLoadFirestoreData
            const errorMsg = `Error checking Firestore: ${error.message}`;
            console.error(errorMsg, error);
            fMyConsoleLog(`   -> ❌ ${errorMsg}. Using Sheet data as fallback.`);
            // Proceed using Sheet data despite the check failure
            fSetupTooltipAndModal();
            fFetchCharacterHeaderAndRenderGrid(); // Proceed with rendering
        })
        .fCheckAndLoadFirestoreData(gIndexCSID); // Call the new server function

} // END fOnDataLoaded



// fFetchCharacterHeaderAndRenderGrid //////////////////////////////////////////
// Purpose -> Fetches static character header data (Race/Class, Level, Names, Slot)
//            and then initiates the main grid rendering process. Called after
//            initial data load and Firestore check.
// Inputs  -> None.
// Outputs -> None (Initiates server call, then rendering).
function fFetchCharacterHeaderAndRenderGrid() {
    fMyConsoleLog("⚙️ Requesting Static Character Header Data...");
    google.script.run
        .withSuccessHandler((headerData) => {
            fMyConsoleLog("✅ Static Character Header Data received.");
            let proceedWithRender = true; // Flag to control rendering

            if (headerData && typeof headerData === 'object' && !headerData.error) {
                // Store the received data
                gUI.characterInfo = {
                    slotNum: headerData.slotNum ?? null, // Use null coalesce for safety
                    raceClass: headerData.raceClass ?? '',
                    level: headerData.level ?? '',
                    playerName: headerData.playerName ?? '',
                    charName: headerData.charName ?? ''
                };
                fMyConsoleLog(`   -> Stored Header Data: ${JSON.stringify(gUI.characterInfo)}`);

                // Validate Slot Number - Prevent rendering if invalid? (Currently just warns)
                if (!gUI.characterInfo.slotNum) {
                    const slotErrorMsg = "Error: Invalid or missing Slot # found on RaceClass tab. Log updates might fail.";
                    fMyConsoleLog(`   -> ⚠️ ${slotErrorMsg}`);
                    // Show message, but still allow rendering to proceed for now
                    fShowMessage(slotErrorMsg).catch(e => console.error("Error showing message:", e));
                    // If a valid slot is absolutely required, set proceedWithRender = false;
                }

            } else {
                // Handle error case from server function
                const errMsg = headerData?.message || "Invalid header data structure received.";
                console.error("Error fetching header data:", errMsg, headerData);
                fMyConsoleLog(`❌ Failed to fetch/store header data: ${errMsg}`);
                fShowMessage(`Error fetching character header data: ${errMsg}`).catch(e => console.error("Error showing message:", e));
                // Proceed with blank header info
                gUI.characterInfo = { slotNum: null, raceClass: '', level: '', playerName: '', charName: '' }; // Reset
            }

            // === Render Grid & Apply Post-Processing ===
            if (proceedWithRender) {
                fRenderFullGrid(() => {
                    fRunPostRenderFormatting(); // Apply merges, borders, listeners, etc.
                });
            } else {
                fMyConsoleLog("❌ Halting grid rendering due to critical error (e.g., invalid Slot #).");
                const gridDiv = document.getElementById('grid');
                if(gridDiv) gridDiv.innerHTML = '<p style="color:red;">Critical error loading character data. Please check configuration.</p>';
            }
        })
        .withFailureHandler((error) => {
            // Handle transport errors fetching header data
            const errorMsg = `Failed to call server for header data: ${error.message}`;
            console.error(errorMsg, error);
            fMyConsoleLog(`❌ ${errorMsg}`);
            fShowMessage(`Error fetching character header data: ${error.message}`).catch(e => console.error("Error showing message:", e));
            // Proceed with grid rendering without header data
            gUI.characterInfo = { slotNum: null, raceClass: '', level: '', playerName: '', charName: '' }; // Reset
            fRenderFullGrid(() => {
                fRunPostRenderFormatting();
            });
        })
        .fGetCharacterHeaderData(gIndexCSID);

} // END fFetchCharacterHeaderAndRenderGrid




// fStoreAndValidateData ///////////////////////////////////////////////////////////
// Purpose -> Validates the structure and content of the data object received from
//            the server. Stores valid data arrays (arr, format, notesArr) in the
//            gUI object. Checks for essential elements (#grid). Clears the grid container.
// Inputs  -> data (Object): The data object received from the server.
// Outputs -> (Boolean): True if data and required elements are valid, false otherwise.
function fStoreAndValidateData(data) {
    // === Validate Data Structure ===
    if (!data || typeof data !== 'object' || !data.arr || !data.format || !data.notesArr || data.error || data instanceof Error) {
        console.error("Error or invalid data structure received:", data);
        fMyConsoleLog("❌ Error or invalid data structure received.");
        // Consider showing a user message here
        // fShowMessage("Error: Received invalid data from server.");
        return false;
    }

    // === Store Data in gUI ===
    gUI.arr = data.arr;
    gUI.format = data.format;
    gUI.notes = data.notesArr || []; // Use notes or default to empty array

    // === Validate Data Content ===
    // Check if the main data array is empty or malformed
    if (gUI.arr.length === 0 || !gUI.arr[0] || gUI.arr[0].length === 0) {
        fMyConsoleLog("⚠️ Data array received is empty.");
        gUI.notes = []; // Ensure notes are also empty if data is empty
        // Consider showing a user message?
        // fShowMessage("Warning: Received empty data sheet.");
        return false; // Treat empty data as invalid for rendering
    }

    // === Validate Grid Container ===
    const container = document.getElementById('grid');
    if (!container) {
        console.error("❌ Grid container #grid not found!");
        fMyConsoleLog("❌ Grid container #grid not found!");
        // fShowMessage("Error: Grid container element is missing.");
        return false;
    }

    // === Clear Grid Container ===
    // Prepare grid for new rendering
    container.innerHTML = '';

    return true; // Data is valid and stored
} // END fStoreAndValidateData




// fSetupTooltipAndModal ///////////////////////////////////////////////////////////
// Purpose -> Gets references to the tooltip and image modal DOM elements by ID
//            and caches them in the gUI object for later use. Logs warnings if
//            elements are not found.
// Inputs  -> None.
// Outputs -> None (Modifies gUI object properties).
function fSetupTooltipAndModal() {
    // === Cache Tooltip Element ===
    gUI.tooltipElement = document.getElementById('cell-tooltip');
    if (!gUI.tooltipElement) {
        fMyConsoleLog("⚠️ Tooltip element (#cell-tooltip) missing...");
        console.warn("Tooltip element not found. Hover tooltips will not function.");
    }

    // === Cache Modal Elements ===
    gUI.modalElement = document.getElementById('image-modal');
    gUI.modalImageElement = document.getElementById('modal-image');
    gUI.modalCloseBtn = document.getElementById('modal-close-btn');
    gUI.modalBackdrop = document.getElementById('modal-backdrop');

    // Check if all essential modal elements were found
    if (!fModalElementsAvailable()) { // Use helper to check cached refs
        console.error("❌ One or more modal elements not found in DOM!");
        fMyConsoleLog("⚠️ Modal elements missing, image preview disabled.");
        // Log specific missing elements if needed for debugging
        if (!gUI.modalElement) console.error(" -> Missing: #image-modal");
        if (!gUI.modalImageElement) console.error(" -> Missing: #modal-image");
        if (!gUI.modalCloseBtn) console.error(" -> Missing: #modal-close-btn");
        if (!gUI.modalBackdrop) console.error(" -> Missing: #modal-backdrop");
    }
} // END fSetupTooltipAndModal



// fModalElementsAvailable /////////////////////////////////////////////////////////
// Purpose -> Helper function to check if all required image modal DOM element
//            references have been successfully cached in the gUI object.
// Inputs  -> None (Checks gUI properties).
// Outputs -> (Boolean): True if all required modal elements are present in gUI, false otherwise.
function fModalElementsAvailable() {
    // Check if all expected properties hold truthy values (i.e., the elements were found)
    return gUI.modalElement && gUI.modalImageElement && gUI.modalCloseBtn && gUI.modalBackdrop;
} // END fModalElementsAvailable




// fAttachGridListeners ////////////////////////////////////////////////////////////
// Purpose -> Attaches various delegated event listeners (click, change, blur, hover)
//            to the main grid container element.
// Inputs  -> gridElement (HTMLElement): The grid container element (#grid).
// Outputs -> None (Attaches event listeners).
function fAttachGridListeners(gridElement) {
    // Validate grid element exists
    if (!gridElement) {
        console.error("fAttachGridListeners: Could not find grid element to attach listeners.");
        fMyConsoleLog("❌ Failed to attach grid event listeners.");
        return;
    }

    // Attach click/change listeners (delegated)
    fSetupGridClickListeners(gridElement);

    // Attach blur listener for handling edits in contentEditable cells (using capture phase)
    gridElement.addEventListener('blur', fHandleGridCellEdit, true);

    // Attach hover listeners for tooltips, only if tooltip element exists
    if (gUI.tooltipElement) {
        fSetupGridHoverListeners(gridElement);
    }
} // END fAttachGridListeners




// fRunPostRenderFormatting ////////////////////////////////////////////////////////
// Purpose -> Executes a sequence of functions to apply formatting and attach
//            listeners after the main grid structure has been rendered. This includes
//            merging cells, adding buttons, applying borders/colors, setting visibility,
//            handling sticky headers, applying dropdowns, checking for overflow,
//            and setting up final event listeners.
// Inputs  -> None.
// Outputs -> None (Calls various formatting and setup functions).
function fRunPostRenderFormatting() {
    fMyConsoleLog("🚀 Applying Post-Render Formatting...");

    // === Apply Structural Formatting ===
    fApplyDynamicMerges();     // Handle merged cells first
    fAddHeaderButtons();       // Add image buttons to header cells
    fApplyManualBorders();     // Apply borders defined in gUI.manualBorderSections
    fApplyInitialVisibility(); // Hide initially hidden rows/columns
    fApplyManualColoring();    // Apply font colors defined in gUI.fontColorRange
    fSetHeader();              // Apply sticky header styling

    // === Apply Interactive Elements ===
    // Apply dropdowns AFTER merges/visibility might have hidden target cells
    fApplyDropdownsToGrid();

    // === Final Adjustments & Listeners ===
    fMarkOverflowingCells();    // Add class to cells with overflow after layout changes
    fClearSk1Sk2Checkboxes();   // Ensure radio button group starts clean (optional, depending on desired state)

    // Attach main grid event listeners
    const gridElement = document.getElementById('grid');
    fAttachGridListeners(gridElement);

    // Setup image modal listeners if elements are available
    if (fModalElementsAvailable()) {
        fSetupModalListeners();
    }

    fMyConsoleLog("✅ All Post-Render Formatting Done!");
} // END fRunPostRenderFormatting




////////////////////////////////////////////////////////////////////////////////////////////////////////// END fOnDataLoaded and helpers



// fLoadGameSheet //////////////////////////////////////////////////////////////////
// Purpose -> Initiates the process of loading and displaying the game sheet data.
//            Sets up timing, validates gIndexCSID, and calls the server-side
//            function (fCSGetGameSheet5) to retrieve data, handling success and failure cases.
// Inputs  -> None (Uses global gIndexCSID).
// Outputs -> None (Initiates server call).
function fLoadGameSheet() {
    // === Initialize Timers ===
    gUI.startTime = performance.now(); // Record start time for performance logging
    gUI.lastLogTime = gUI.startTime;   // Initialize last log time
    fMyConsoleLog("🚀 Requesting GSheet Data...");
    console.log("Sheet ID:", gIndexCSID); // Log the sheet ID being used

    // === Validate Sheet ID ===
    if (!gIndexCSID) {
        const errorMsg = "❌ No Sheet ID found. Cannot load data.";
        console.error(errorMsg);
        fMyConsoleLog(errorMsg);
        // Display error message in the grid container if ID is missing
        const gridDiv = document.getElementById('grid');
        if (gridDiv) gridDiv.innerHTML = `<p style="color:red;">${errorMsg} Check URL parameter.</p>`;
        return;
    }

    // === Call Server Function ===
    // Use google.script.run to call the Apps Script function
    google.script.run
        .withSuccessHandler(fOnDataLoaded) // Callback for successful data retrieval or server-side errors
        .withFailureHandler(error => {     // Callback for transport errors or unhandled exceptions
            const errorMsg = `❌ Failed to call server: ${error.message}`;
            console.error(errorMsg, error);
            fMyConsoleLog(errorMsg);
            // Display error message in the grid container on failure
            const gridDiv = document.getElementById('grid');
            if(gridDiv) gridDiv.innerHTML = `<p style="color:red;">${errorMsg}</p>`;
        })
        .fCSGetGameSheet5(gIndexCSID); // The server-side function to call in Turbo.gs

} // END fLoadGameSheet




// ==========================================================================
// === Entry Point                 (End of Initial Data Load) ===
// ==========================================================================




// DOMContentLoaded Hook ///////////////////////////////////////////////////////////
// Purpose -> Main entry point for client-side script execution. Attaches a listener
//            that waits for the HTML DOM to be fully loaded and parsed, then calls
//            initial setup functions to load data and attach event listeners.
window.addEventListener("DOMContentLoaded", () => {
    // Initiate data loading from the Google Sheet
    fLoadGameSheet();

    // Setup interactivity for UI elements
    fSetupMenuInteractivity();       // Menu bar buttons, dropdowns, actions
    fSetupMessageModalListeners();   // Message box (OK button, Escape key)
    fSetupPromptModalListeners();    // Prompt box (Yes/No buttons)
    fSetupSidebarActionListeners();  // Buttons within the Roll Log sidebar
});




</script>