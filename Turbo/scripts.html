<script>
// scripts.html //



// ==========================================================================
// === Core Cell Creation Helpers       (End of Low-Level Utilities) ===
// ==========================================================================




// fIsSkRadioGroupMember ////////////////////////////////////////////////////////////
// Purpose -> Checks if a cell (r, c) is part of the Sk1/Sk2 checkbox 'radio group'.
// Inputs  -> r (Number): 0-based row index.
//         -> c (Number): 0-based column index.
// Outputs -> (Boolean): True if the cell is within any range defined in
//                       gUI.range.sk1sk2CheckBoxes, false otherwise.
function fIsSkRadioGroupMember(r, c) {
    const ranges = gUI.range.sk1sk2CheckBoxes;

    // Validate the range definition array
    if (!Array.isArray(ranges)) {
        console.warn("fIsSkRadioGroupMember: gUI.range.sk1sk2CheckBoxes is not a valid array.");
        return false;
    }

    // Validate input coordinates
    if (typeof r !== 'number' || typeof c !== 'number' || isNaN(r) || isNaN(c)) {
         console.warn(`fIsSkRadioGroupMember: Invalid input coordinates (${r}, ${c})`);
         return false;
    }

    // Loop through each defined range for the Sk1/Sk2 checkboxes
    for (const range of ranges) {
        // Validate the range object structure
        if (!fDoesObjectHaveR1C1R2C2Properties(range)) { // Use existing helper function
             console.warn("fIsSkRadioGroupMember: Skipping invalid range object", range);
             continue;
        }

        // Resolve the tags/indices for the current range
        const resolved = fConvertsR1C1R2C2TagOrNumToIndices(range); // Use existing helper function
        if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
             console.warn("fIsSkRadioGroupMember: Skipping range due to unresolved indices", range);
             continue;
        }

        // Determine min/max row and column
        const rMin = Math.min(resolved.r1, resolved.r2);
        const rMax = Math.max(resolved.r1, resolved.r2);
        const cMin = Math.min(resolved.c1, resolved.c2);
        const cMax = Math.max(resolved.c1, resolved.c2);

        // Check if the input r, c falls within this range
        if (r >= rMin && r <= rMax && c >= cMin && c <= cMax) {
            return true; // Found a match
        }
    }

    // No range matched after checking all of them
    return false;
} // END fIsSkRadioGroupMember



// fMakeCorrectCheckBoxType ///////////////////////////////////////////////////////////////////
// Purpose -> Returns a checkbox input element reflecting boolean value in gUI.arr[r][c].
//            Disables checkbox if background color is not white/default.
//            Adds 'data-sk-group' attribute if part of the Sk1/Sk2 radio group.
// Inputs  -> r (Number): 0-based row index.
//         -> c (Number): 0-based column index.
// Outputs -> (HTMLInputElement): The configured checkbox element.
function fMakeCorrectCheckBoxType(r, c) {
    const value = gUI.arr[r]?.[c];
    const checkbox = document.createElement("input");

    // Set basic properties and data attributes
    checkbox.type = "checkbox";
    checkbox.dataset.r = r;
    checkbox.dataset.c = c;

    // Check background color to set disabled state
    const bgColor = gUI.format?.bg?.[r]?.[c];
    const isNonWhite = bgColor && bgColor.toLowerCase() !== '#ffffff' && bgColor.toLowerCase() !== '#fff';
    checkbox.disabled = isNonWhite;

    // Set checked state based on boolean or string "TRUE" (case-insensitive)
    const valStr = String(value).toUpperCase();
    checkbox.checked = value === true || valStr === "TRUE";

    // Add data attribute if this checkbox is part of the Sk radio group
    if (fIsSkRadioGroupMember(r, c)) {
        checkbox.dataset.skGroup = 'true';
    }

    return checkbox;
} // END fMakeCorrectCheckBoxType




// ==========================================================================
// === Core Rendering & Grid Tag Setup  (End of Core Cell Creation Helpers) ===
// ==========================================================================




// fCreateAndFormatCell //////////////////////////////////////////////////////////////
// Purpose -> Creates and formats a single grid cell div element. Handles content
//            (text, checkbox, dropdown), URL/image/note tags, editability, and styling.
// Inputs  -> r (Number): 0-based row index.
//         -> c (Number): 0-based column index.
//         -> value (Any): The raw value for the cell from gUI.arr.
//         -> rowFormat (Object): Formatting object for this specific row.
// Outputs -> (HTMLElement): The configured cell div element.
function fCreateAndFormatCell(r, c, value, rowFormat) {
    // === Initialization ===
    const cell = document.createElement("div");
    cell.className = "cell";

    const originalValue = value ?? "";
    const valStr = String(originalValue).toUpperCase();
    const isCheckbox = value === true || value === false || valStr === "TRUE" || valStr === "FALSE";

    // === Set Base Attributes & Check Editability/Note ===
    const bgColor = rowFormat.bg?.[c];
    const isEditable = fCheckIfEditable(bgColor, isCheckbox);
    fSetCellAttributes(cell, r, c, isEditable);
    fCheckAndTagNote(cell, r, c);

    // === Determine Content Type (Dropdown or Standard) ===
    const dropConfig = fFindDropdownMatch(r, c);
    if (dropConfig) {
        // Create and append dropdown
        const select = fMakeDropdown(r, c, dropConfig, value);
        cell.appendChild(select);
    } else {
        // Handle standard content (URL/Image/Checkbox/Text)
        const { displayValue, isUrl } = fCheckAndTagUrl(cell, originalValue);
        fPopulateCellContent(cell, r, c, displayValue, isCheckbox);
    }

    // === Apply Final Formatting ===
    fApplyCellFormatting(cell, c, bgColor, rowFormat);

    return cell;
} // END fCreateAndFormatCell




// fFindDropdownMatch //////////////////////////////////////////////////////////////
// Purpose -> Checks if coordinates (r,c) fall within any dropdown range defined in
//            gUI.dropDownBox and returns the matching configuration object.
// Inputs  -> r (Number): 0-based row index.
//         -> c (Number): 0-based column index.
// Outputs -> (Object | null): The dropdown config object if found, otherwise null.
function fFindDropdownMatch(r, c) {
    // Iterate through each dropdown configuration
    for (const config of gUI.dropDownBox) {
        // Iterate through the ranges defined for this configuration
        for (const range of config.ranges) {
            // Resolve range tags/indices
            const r1 = fResolveRow(range.r1), r2 = fResolveRow(range.r2);
            const c1 = fResolveCol(range.c1), c2 = fResolveCol(range.c2);

            // Check if resolved indices are valid and if (r, c) is within the range
            if (
                !isNaN(r1) && !isNaN(r2) && !isNaN(c1) && !isNaN(c2) &&
                r >= Math.min(r1, r2) && r <= Math.max(r1, r2) &&
                c >= Math.min(c1, c2) && c <= Math.max(c1, c2)
            ) {
                return config; // Found a match, return the config
            }
        }
    }

    // No match found after checking all configurations
    return null;
} // END fFindDropdownMatch




// fMakeDropdown ///////////////////////////////////////////////////////////////////
// Purpose -> Builds a <select> element populated with choices for a grid dropdown.
// Inputs  -> r (Number): 0-based row index for data attributes.
//         -> c (Number): 0-based column index for data attributes.
//         -> config (Object): Dropdown configuration object from gUI.dropDownBox.
//         -> currentVal (Any): The current value in gUI.arr[r][c] to pre-select.
// Outputs -> (HTMLSelectElement): The configured <select> element.
function fMakeDropdown(r, c, config, currentVal) {
    const select = document.createElement("select");
    select.dataset.r = r;
    select.dataset.c = c;

    // Populate options
    for (const choice of config.choices) {
        const option = document.createElement("option");
        option.value = String(choice);
        option.textContent = String(choice);
        // Select the current value
        if (String(choice) === String(currentVal)) {
            option.selected = true;
        }
        select.appendChild(option);
    }

    // Add styling class
    select.classList.add("dropdown-cell");

    return select;
} // END fMakeDropdown





// fCheckIfEditable //////////////////////////////////////////////////////////////
// Purpose -> Determines if a cell should be contentEditable based on background
//            color (must be white/default) and type (must not be a checkbox).
// Inputs  -> bgColor (String | null): Background color hex string or null.
//         -> isCheckbox (Boolean): True if the cell contains a checkbox.
// Outputs -> (Boolean): True if the cell should be editable, false otherwise.
function fCheckIfEditable(bgColor, isCheckbox) {
    const isWhiteBg = (!bgColor || bgColor.toLowerCase() === '#ffffff' || bgColor === 'white');

    return isWhiteBg && !isCheckbox;
} // END fCheckIfEditable




// fSetCellAttributes //////////////////////////////////////////////////////////////
// Purpose -> Sets the data-r and data-c attributes on a cell element. Also sets
//            contentEditable and related styles if the cell is designated as editable.
// Inputs  -> cell (HTMLElement): The cell div element.
//         -> r (Number): 0-based row index.
//         -> c (Number): 0-based column index.
//         -> isEditable (Boolean): True if the cell should be contentEditable.
// Outputs -> None (Modifies the input cell element).
function fSetCellAttributes(cell, r, c, isEditable) {
    cell.dataset.r = r;
    cell.dataset.c = c;

    if (isEditable) {
        cell.contentEditable = true;
        cell.style.justifyContent = 'flex-start'; // Align text left for editing
        cell.style.textAlign = 'left';
    }
} // END fSetCellAttributes




// fCheckAndTagNote ////////////////////////////////////////////////////////////////
// Purpose -> Adds the 'has-note' CSS class to a cell element if a corresponding
//            note exists in gUI.notes.
// Inputs  -> cell (HTMLElement): The cell div element.
//         -> r (Number): 0-based row index.
//         -> c (Number): 0-based column index.
// Outputs -> None (Modifies the input cell element's classList).
function fCheckAndTagNote(cell, r, c) {
    const noteText = gUI.notes?.[r]?.[c]?.trim();

    // Add class only if there's trimmed note text
    if (noteText) {
        cell.classList.add('has-note');
    }
} // END fCheckAndTagNote



// fCheckAndTagUrl /////////////////////////////////////////////////////////////////
// Purpose -> Checks if a cell's value is a URL. If so, adds 'url-link' class and
//            data-url attribute. Further checks for Drive image links or standard
//            image extensions, adding 'image-link' class and data-image-src if found.
// Inputs  -> cell (HTMLElement): The cell div element.
//         -> value (Any): The raw value for the cell from gUI.arr.
// Outputs -> (Object): { displayValue: Any, isUrl: Boolean }
function fCheckAndTagUrl(cell, value) {
    const trimmed = typeof value === 'string' ? value.trim() : '';
    const isUrl = trimmed.startsWith('http://') || trimmed.startsWith('https://');
    let displayValue = value; // Return original value by default

    if (!isUrl) {
        return { displayValue, isUrl }; // Not a URL, exit early
    }

    // It is a URL, add base class and data attribute
    cell.classList.add('url-link');
    cell.dataset.url = trimmed;

    // Check for specific URL types (Drive image or standard image extension)
    const driveMatch = trimmed.match(/drive\.google\.com\/file\/d\/([-\w]+)/);
    const imgExts = /\.(png|jpg|jpeg|gif|webp|svg)$/i;

    if (driveMatch && driveMatch[1]) {
        // Handle Google Drive image link
        const fileId = driveMatch[1];
        const imageUrl = 'https://drive.google.com/uc?export=view&id=' + fileId;
        cell.classList.add('image-link');
        cell.dataset.imageSrc = imageUrl;
    } else if (imgExts.test(trimmed)) {
        // Handle standard image link (by extension)
        cell.classList.add('image-link');
        cell.dataset.imageSrc = trimmed;
    }

    return { displayValue, isUrl };
} // END fCheckAndTagUrl



// fPopulateCellContent ////////////////////////////////////////////////////////////
// Purpose -> Populates a cell element with either a checkbox (using fMakeCorrectCheckBoxType)
//            or text content. Strips trailing ID patterns from text content.
// Inputs  -> cell (HTMLElement): The cell div element.
//         -> r (Number): 0-based row index (passed to fMakeCorrectCheckBoxType).
//         -> c (Number): 0-based column index (passed to fMakeCorrectCheckBoxType).
//         -> displayValue (Any): The value to display (used for text content).
//         -> isCheckbox (Boolean): True if the cell should contain a checkbox.
// Outputs -> None (Modifies the input cell element's content).
function fPopulateCellContent(cell, r, c, displayValue, isCheckbox) {
    if (isCheckbox) {
        // Append a checkbox if required
        cell.appendChild(fMakeCorrectCheckBoxType(r, c));
    } else {
        // Otherwise, set text content, stripping any trailing ID
        const idPattern = /\s{2,}_\w{6}$/; // Matches '  _XXXXXX' at end of string
        const text = (typeof displayValue === 'string' && idPattern.test(displayValue))
            ? displayValue.replace(idPattern, '') // Strip ID if found
            : displayValue; // Use original value otherwise
        cell.textContent = text;
    }
} // END fPopulateCellContent





// fApplyCellFormatting ////////////////////////////////////////////////////////////
// Purpose -> Applies styles (background, font weight/size/style/family, wrap)
//            to a cell element based on the provided row formatting data.
// Inputs  -> cell (HTMLElement): The cell div element to style.
//         -> c (Number): 0-based column index to lookup format specific to the column.
//         -> bgColor (String | null): Background color hex string.
//         -> rowFormat (Object): Object containing formatting arrays for the row
//                                (e.g., weight, fontSize, fontStyle, fontFamily, wrap).
//         -> isUrl (Boolean): (Currently unused) Indicates if the cell contains a URL.
// Outputs -> None (Modifies the input cell element's style and classList).
function fApplyCellFormatting(cell, c, bgColor, rowFormat, isUrl) {
    // Apply background color if provided
    if (bgColor) {
        cell.style.backgroundColor = bgColor;
    }

    // Apply font color (placeholder logic, currently does nothing)
    const finalFontColor = null;
    cell.style.color = finalFontColor || ''; // Default to browser default if null/empty

    // Destructure font/wrap properties from rowFormat for the specific column `c`
    const { weight, fontSize, fontStyle, fontFamily, wrap } = rowFormat;

    // Apply specific font styles if they exist for this column
    if (weight?.[c]) cell.style.fontWeight = weight[c];
    if (fontSize?.[c]) cell.style.fontSize = `${fontSize[c]}px`;
    if (fontStyle?.[c]) cell.style.fontStyle = fontStyle[c];
    if (fontFamily?.[c]) cell.style.fontFamily = fontFamily[c];

    // Apply wrap class if wrapping is enabled for this column
    if (wrap?.[c]) {
        cell.classList.add('wrap');
    }
} // END fApplyCellFormatting




// fRenderTurbosFullGrid /////////////////////////////////////////////////////////////////
// Purpose -> Main controller function to render the entire grid dynamically.
//            Initializes grid, sets up columns/tags, then renders cells in chunks
//            using requestAnimationFrame for better performance. Calls a callback
//            function after rendering is complete for post-processing.
// Inputs  -> callback (Function): Function to execute after the grid is fully rendered.
// Outputs -> None (Modifies DOM, populates gUI.grid2D).
function fRenderTurbosFullGrid(callback) {
    fMyConsoleLog("⚙️ Rendering Full Grid...");

    // === Get DOM Elements and Data ===
    const grid = document.getElementById("grid");
    const gameArr = gUI.arr;
    const format = gUI.format || {};

    // === Initial Grid Setup & Validation ===
    if (!fInitGridAndSettings(grid, gameArr)) {
        return; // Stop if grid container or data is invalid
    }

    // === Grid Configuration ===
    const numRows = gameArr.length;
    const numCols = gameArr[0].length;
    fSetGridColumnWidths(grid, format, numCols); // Apply column widths from format object
    fSetGridTagsFromHeaders(); // Populate gUI.rowTag and gUI.colTag

    // Initialize the 2D array to hold cell DOM element references
    gUI.grid2D = Array.from({ length: numRows }, () => Array(numCols).fill(null));

    // === Chunked Rendering ===
    fMyConsoleLog(`🏎️ Rendering ${numRows} rows in chunks of 50...`);
    const renderChunk = fRenderChunkFactory(grid, gameArr, format, 50, callback);
    requestAnimationFrame(renderChunk); // Start the chunked rendering process

} // END fRenderTurbosFullGrid





// fInitGridAndSettings ////////////////////////////////////////////////////////////
// Purpose -> Validates the grid container element and data array (gUI.arr) exist
//            and are correctly formatted. Clears existing grid content if valid.
// Inputs  -> grid (HTMLElement): The grid container element (#grid).
//         -> gameArr (Array[][]): The 2D array of grid data (gUI.arr).
// Outputs -> (Boolean): True if grid and data are valid, false otherwise.
function fInitGridAndSettings(grid, gameArr) {
    // Validate grid container element
    if (!grid) {
        console.error("❌ Grid container #grid not found!");
        return false;
    }

    // Validate data array structure
    if (!Array.isArray(gameArr) || gameArr.length === 0 || !Array.isArray(gameArr[0])) {
        console.error("❌ gUI.arr is empty or malformed. Cannot render grid.");
        grid.innerHTML = '<p style="color:red;">Error: Invalid data array for rendering.</p>';
        return false;
    }

    // Clear old grid content if validation passed
    grid.innerHTML = "";

    return true;
} // END fInitGridAndSettings




// fSetGridColumnWidths ////////////////////////////////////////////////////////////
// Purpose -> Applies the 'grid-template-columns' CSS style to the grid container
//            based on the column widths provided in the format object.
// Inputs  -> grid (HTMLElement): The grid container element (#grid).
//         -> format (Object): The formatting object containing 'colWidths' array.
//         -> numCols (Number): The total number of columns in the grid.
// Outputs -> None (Modifies the grid element's style).
function fSetGridColumnWidths(grid, format, numCols) {
    const colWidths = format.colWidths || []; // Use provided widths or empty array

    // Create the CSS string (e.g., "60px 100px 80px...") using provided widths or a default of 60px
    const gridTemplateColumns = colWidths.map(w => `${w || 60}px`).join(' ');

    // Apply the style to the grid container
    grid.style.gridTemplateColumns = gridTemplateColumns;

    fMyConsoleLog(`📐 Applied ${numCols} column widths`);
} // END fSetGridColumnWidths





// fBuildRowFormat /////////////////////////////////////////////////////////////////
// Purpose -> Extracts and returns a formatting object specific to a single row index
//            from the main format object.
// Inputs  -> format (Object): The main grid format object (gUI.format).
//         -> rowIdx (Number): The 0-based row index for which to extract formats.
// Outputs -> (Object): An object containing formatting arrays (bg, fontColorHex,
//                       weight, fontSize, fontStyle, fontFamily, wrap) for the specified row.
function fBuildRowFormat(format, rowIdx) {
    // Use optional chaining (?.) to safely access properties, returning undefined if format or sub-property is missing
    return {
        bg: format.bg?.[rowIdx],
        fontColorHex: format.fontColorHex?.[rowIdx],
        weight: format.weight?.[rowIdx],
        fontSize: format.fontSize?.[rowIdx],
        fontStyle: format.fontStyle?.[rowIdx],
        fontFamily: format.fontFamily?.[rowIdx],
        wrap: format.wrap?.[rowIdx]
    };
} // END fBuildRowFormat




// fAppendRowCells /////////////////////////////////////////////////////////////////
// Purpose -> Creates all cell elements for a single row using fCreateAndFormatCell,
//            appends them to a document fragment, and stores references in gUI.grid2D.
// Inputs  -> fragment (DocumentFragment): Fragment to append created cells to.
//         -> rowIdx (Number): 0-based index of the row being rendered.
//         -> rowData (Array): Array of values for the current row (gUI.arr[rowIdx]).
//         -> rowFormat (Object): Formatting object for the current row.
//         -> numCols (Number): Total number of columns in the grid.
// Outputs -> None (Modifies the input fragment and gUI.grid2D).
function fAppendRowCells(fragment, rowIdx, rowData, rowFormat, numCols) {
    // Loop through each column in the row
    for (let c = 0; c < numCols; c++) {
        const value = rowData?.[c]; // Get value for the current cell
        // Create and format the cell element
        const cell = fCreateAndFormatCell(rowIdx, c, value, rowFormat);
        // Store reference in the 2D grid array
        gUI.grid2D[rowIdx][c] = cell;
        // Append the created cell to the document fragment
        fragment.appendChild(cell);
    }
} // END fAppendRowCells




// fRenderChunkFactory /////////////////////////////////////////////////////////////
// Purpose -> Creates and returns a closure function (`renderChunk`) responsible for
//            rendering the grid rows in manageable chunks using requestAnimationFrame.
// Inputs  -> grid (HTMLElement): The grid container element.
//         -> gameArr (Array[][]): The 2D array of grid data.
//         -> format (Object): The main grid format object.
//         -> chunkSize (Number): The number of rows to render per chunk.
//         -> callback (Function): Function to call after all chunks are rendered.
// Outputs -> (Function): The `renderChunk` closure function.
function fRenderChunkFactory(grid, gameArr, format, chunkSize, callback) {
    let r = 0; // Current starting row index for the next chunk
    const numRows = gameArr.length;
    const numCols = gameArr[0].length;

    // The closure function that renders one chunk
    return function renderChunk() {
        const fragment = document.createDocumentFragment(); // Use fragment for efficiency
        const endRow = Math.min(r + chunkSize, numRows); // Calculate end row for this chunk

        // Render cells for the current chunk
        for (let rowIdx = r; rowIdx < endRow; rowIdx++) {
            const rowData = gameArr[rowIdx];
            const rowFormat = fBuildRowFormat(format, rowIdx);
            fAppendRowCells(fragment, rowIdx, rowData, rowFormat, numCols);
        }

        // Append the chunk's fragment to the grid
        grid.appendChild(fragment);
        r = endRow; // Update the starting row for the next chunk

        // Schedule the next chunk or finish up
        if (r < numRows) {
            requestAnimationFrame(renderChunk); // Schedule the next chunk
        } else {
            // All rows rendered, call the final callback
            fMyConsoleLog(`✅ Grid Rendered (${numRows} rows)`);
            if (typeof callback === 'function') {
                fMyConsoleLog("🚀 Applying Post-Render Formatting...");
                // Use setTimeout to allow browser to paint before running heavy post-render tasks
                setTimeout(callback, 0);
            }
        }
    }; // END renderChunk (inner function)
} // END fRenderChunkFactory




// ==========================================================================
// === Grid Formatting & Visibility  (End of Core Rendering & Grid Tag Setup) ===
// ==========================================================================




// fSetTurbosGridHeaderRows ////////////////////////////////////////////////////////////////////
// Purpose -> Hides the top utility rows (0, 1) and applies sticky positioning
//            and styling to the header rows (2, 3, 4). Also adds a visual
//            indicator style to the row immediately below the sticky header (row 5).
// Inputs  -> None (Uses gUI.grid2D, gUI.ROW_HEIGHT_PX, gUI.format.bg).
// Outputs -> None (Modifies DOM cell styles and classes).
function fSetTurbosGridHeaderRows() {
    fMyConsoleLog("🔒 Applying Sticky Header...");
    const numRows = gUI.grid2D.length;

    // === Validation ===
    if (numRows < 5) { // Need rows 0, 1, 2, 3, 4 for this to work
        fMyConsoleLog("⚠️ Not enough rows for sticky header.");
        return;
    }
    const numCols = gUI.grid2D[0]?.length || 0;
    if (numCols === 0) {
        fMyConsoleLog("⚠️ No columns found for sticky header.");
        return;
    }

    // === Hide Top Rows (0 and 1) ===
    for (let r = 0; r <= 1; r++) {
        for (let c = 0; c < numCols; c++) {
            const cell = gUI.grid2D?.[r]?.[c];
            if (cell) cell.style.display = 'none';
        }
    }

    // === Apply Sticky Styling to Header Rows (2, 3, 4) ===
    for (let r = 2; r <= 4; r++) {
        const offset = (r - 2) * gUI.ROW_HEIGHT_PX; // Calculate offset based on row index (0px for row 2)

        for (let c = 0; c < numCols; c++) {
            const cell = gUI.grid2D?.[r]?.[c];
            if (!cell || cell.style.display === 'none') continue; // Skip non-existent or hidden cells

            // Add class for base sticky styles
            cell.classList.add('sticky-header');
            // Apply dynamic top offset based on row index
            cell.style.top = `${offset}px`;

            // Re-apply original background color to prevent override by sticky-header class
            const bgColor = gUI.format?.bg?.[r]?.[c];
            cell.style.backgroundColor = bgColor || '#ffffff'; // Fallback to white
        }
    }

    // === Apply Styling to Row Below Sticky Section (Row 5) ===
    if (numRows > 5) { // Check if row 5 exists
        const belowRowIndex = 5;
        for (let c = 0; c < numCols; c++) {
            const cell = gUI.grid2D?.[belowRowIndex]?.[c];
            // Apply class only to visible cells in this row
            if (cell && cell.style.display !== 'none') {
                cell.classList.add('below-sticky');
            }
        }
    }

    fMyConsoleLog("✅ Sticky Header Applied");
} // END fSetTurbosGridHeaderRows




// fAppliesGridColumnOnOff ///////////////////////////////////////////////////////
// Purpose -> Recalculates and applies the 'grid-template-columns' CSS style to the
//            grid container based on the current state of gUI.hiddenColumns.
//            Sets width to '0px' for hidden columns, uses original width otherwise.
// Inputs  -> None (Uses gUI.hiddenColumns, gUI.format.colWidths, gUI.arr).
// Outputs -> None (Modifies the grid element's style).
function fAppliesGridColumnOnOff() {
    const grid = document.getElementById("grid");

    // Validate prerequisites
    if (!grid || !gUI.format.colWidths || !gUI.arr || gUI.arr.length === 0) {
        console.error("fAppliesGridColumnOnOff: Missing prerequisites (grid element, colWidths, or arr data).");
        return;
    }

    const numCols = gUI.arr[0].length;
    const colWidths = gUI.format.colWidths || [];
    let templateCols = [];

    // Build the array of column width strings
    for (let c = 0; c < numCols; c++) {
        if (gUI.hiddenColumns.has(c)) { // Check if column index is in the hidden set
            templateCols.push("0px"); // Use 0px for hidden columns
        } else {
            const width = colWidths[c] || 60; // Use stored width or default to 60px
            templateCols.push(`${width}px`);
        }
    }

    // Join the array into the final CSS string
    const newTemplateString = templateCols.join(' ');

    // Apply the new style to the grid
    grid.style.gridTemplateColumns = newTemplateString;

} // END fAppliesGridColumnOnOff




// fSetsGridColumnVisibility ////////////////////////////////////////////////////////////
// Purpose -> Hides or shows a single column by updating the `visibility: collapse`
//            style of its cells and optionally updating the grid template.
//            Manages the column index in the gUI.hiddenColumns Set.
// Inputs  -> colIndex (Number): 0-based index of the column to modify.
//         -> isVisible (Boolean): True to show the column, false to hide it.
//         -> updateTemplate (Boolean): If true (default), calls fAppliesGridColumnOnOff
//                                       after modifying cell visibility.
// Outputs -> None (Modifies cell styles, gUI.hiddenColumns, potentially grid style).
function fSetsGridColumnVisibility(colIndex, isVisible, updateTemplate = true) {
    // === Validate Input ===
    if (isNaN(colIndex) || colIndex < 0 || !gUI.grid2D[0] || colIndex >= gUI.grid2D[0].length) {
        console.warn(`fSetsGridColumnVisibility: Invalid column index ${colIndex}`);
        return;
    }

    // === Determine Action and Check Current State ===
    const numRows = gUI.grid2D.length;
    const currentlyHidden = gUI.hiddenColumns.has(colIndex);
    const action = isVisible ? 'Showing' : 'Hiding';
    const needsChange = (isVisible && currentlyHidden) || (!isVisible && !currentlyHidden);

    if (needsChange) {
        // === Update Hidden State Set ===
        if (isVisible) {
            gUI.hiddenColumns.delete(colIndex);
        } else {
            gUI.hiddenColumns.add(colIndex);
        }

        // === Update Cell Visibility ===
        for (let r = 0; r < numRows; r++) {
            const cell = gUI.grid2D[r]?.[colIndex];
            if (cell) {
                // Use visibility: collapse for hiding (maintains layout spacing)
                cell.style.visibility = isVisible ? '' : 'collapse';
            }
        }

        // === Update Grid Template (Optional) ===
        // Regenerate the grid template only if requested (e.g., batch updates skip this)
        if (updateTemplate) {
             fAppliesGridColumnOnOff();
        }
    }
    // else: Column is already in the desired state, no action needed.
} // END fSetsGridColumnVisibility




// fSetGridRowVisibility ///////////////////////////////////////////////////////////////
// Purpose -> Hides or shows a single row by setting the 'display' style of its cells
//            and managing the row index in the gUI.hiddenRows Set.
//            Also handles resetting sticky styles if hiding a potentially sticky row.
// Inputs  -> rowIndex (Number): 0-based index of the row to modify.
//         -> isVisible (Boolean): True to show the row, false to hide it.
// Outputs -> None (Modifies cell styles, gUI.hiddenRows, potentially calls fSetTurbosGridHeaderRows).
function fSetGridRowVisibility(rowIndex, isVisible) {
    // === Validate Input ===
     if (isNaN(rowIndex) || rowIndex < 0 || rowIndex >= gUI.grid2D.length) {
        console.warn(`fSetGridRowVisibility: Invalid row index ${rowIndex}.`);
        return;
    }

    // === Update Hidden State Set ===
    if (isVisible) {
        gUI.hiddenRows.delete(rowIndex); // Remove from Set when showing
    } else {
        gUI.hiddenRows.add(rowIndex); // Add to Set when hiding
    }

    // === Apply Visibility to Cells ===
    const numCols = gUI.grid2D[0]?.length || 0;
    for (let c = 0; c < numCols; c++) {
        const cell = gUI.grid2D[rowIndex]?.[c];
        if (cell) {
             cell.style.display = isVisible ? '' : 'none'; // Toggle display
             // If hiding, ensure any potential sticky styles are removed
             if (!isVisible) {
                 cell.classList.remove('sticky-header', 'below-sticky');
                 cell.style.position = '';
                 cell.style.top = '';
                 cell.style.zIndex = '';
             }
         } else {
             // Optional: Log if cell element is unexpectedly missing, especially in early columns
             // if (c < 5) console.warn(`fSetGridRowVisibility: Cell gUI.grid2D[${rowIndex}][${c}] not found!`);
         }
    }

    // === Handle Sticky Rows ===
    // If showing a row that could be part of the sticky header (rows 2-5), re-apply header formatting
    // to ensure correct offsets and styles are applied. Rows 0/1 are handled by fSetTurbosGridHeaderRows initial run.
    if (isVisible && rowIndex >= 2 && rowIndex <= 5) {
         fSetTurbosGridHeaderRows(); // Re-run fSetTurbosGridHeaderRows to ensure stickiness is correct
    }

} // END fSetGridRowVisibility




// fApplyGridDynamicMerges /////////////////////////////////////////////////////////////
// Purpose -> Applies cell merging based on the `gUI.format.merges` array.
//            Sets grid-column/row span on the anchor cell and hides covered cells.
// Inputs  -> None (Uses gUI.format.merges, gUI.grid2D).
// Outputs -> None (Modifies DOM cell styles).
function fApplyGridDynamicMerges() {
    fMyConsoleLog("🧩 Applying Merges...");
    const merges = gUI.format?.merges || []; // Get merge definitions or empty array

    // === Iterate Through Each Merge Definition ===
    for (const mergeInfo of merges) {
        const r = mergeInfo.row;
        const c = mergeInfo.col;
        const rs = mergeInfo.rowspan;
        const cs = mergeInfo.colspan;

        // Get the top-left anchor cell of the merge area
        const anchor = gUI.grid2D?.[r]?.[c];

        // Validate anchor cell exists
        if (!anchor) {
             console.warn(`⚠️ Merge anchor cell not found at [${r},${c}]`);
             continue; // Skip this merge if anchor is missing
        }

        // === Apply CSS Grid Span to Anchor Cell ===
        if (cs > 1) anchor.style.gridColumn = `span ${cs}`;
        if (rs > 1) anchor.style.gridRow = `span ${rs}`;

        // === Hide Cells Covered by the Merge ===
        // Iterate through all cells within the merge bounds
        for (let rSub = r; rSub < r + rs; rSub++) {
            for (let cSub = c; cSub < c + cs; cSub++) {
                // Skip the anchor cell itself
                if (rSub === r && cSub === c) continue;

                // Find and hide the covered cell
                const cellToHide = gUI.grid2D?.[rSub]?.[cSub];
                if (cellToHide) {
                    cellToHide.style.display = 'none';
                }
            }
        }
    } // End loop through merge definitions

     fMyConsoleLog("✅ Merges Applied");
} // END fApplyGridDynamicMerges




// fApplyGridManualBorders /////////////////////////////////////////////////////////////
// Purpose -> Applies CSS border styles to cells within sections defined in
//            gUI.manualBorderSections. Applies top/left borders to all cells
//            in a section and right/bottom borders based on the 'edges' property.
// Inputs  -> None (Uses gUI.manualBorderSections, gUI.grid2D).
// Outputs -> None (Modifies DOM cell styles).
function fApplyGridManualBorders() {
    fMyConsoleLog("🖌️ Applying Manual Borders...");
    let appliedCount = 0;

    // === Iterate Through Each Defined Border Section ===
    gUI.manualBorderSections.forEach(section => {
        // Resolve section boundaries and get style/edge info
        const rowStart = fResolveRow(section.r1);
        const colStart = fResolveCol(section.c1);
        const rowEnd = fResolveRow(section.r2);
        const colEnd = fResolveCol(section.c2);
        const borderStyle = section.style || '1px solid #000'; // Default to black thin solid
        const edges = section.edges || ''; // Edge flags ('t', 'b', 'l', 'r')

        // Validate resolved indices
        if ([rowStart, colStart, rowEnd, colEnd].some(v => isNaN(v))) {
            console.warn("Skipping manual border section due to invalid tags:", section);
            return; // Skip this section if tags don't resolve
        }

        // === Apply Borders to Cells Within the Section ===
        for (let r = rowStart; r <= rowEnd; r++) {
             for (let c = colStart; c <= colEnd; c++) {
                const cell = gUI.grid2D?.[r]?.[c];

                // Skip non-existent cells or those hidden by merging
                if (!cell || cell.style.display === 'none') continue;

                let appliedThisCell = false;

                // Apply Top and Left to ALL cells in the rectangle (standard behavior)
                cell.style.borderTop = borderStyle;
                cell.style.borderLeft = borderStyle;
                appliedThisCell = true; // Count this application

                // Apply Right border only if it's the last column AND edges flag allows 'r'
                if (edges.includes('r') && c === colEnd) {
                    cell.style.borderRight = borderStyle;
                }

                // Apply Bottom border only if it's the last row AND edges flag allows 'b'
                if (edges.includes('b') && r === rowEnd) {
                    cell.style.borderBottom = borderStyle;
                }

                if (appliedThisCell) appliedCount++;
            }
        }
    }); // End forEach section

    fMyConsoleLog(`✅ Manual Borders Applied (${appliedCount} styles set)`);
} // END fApplyGridManualBorders




// fApplyGridManualColoring ////////////////////////////////////////////////////////////
// Purpose -> Applies specific font colors to predefined ranges based on the
//            gUI.fontColorRange configuration array. Automatically applies a
//            contrasting color (black/white) if the intended font color matches
//            the cell's background color.
// Inputs  -> None (Uses gUI.fontColorRange, gUI.grid2D, gUI.format.bg).
// Outputs -> None (Modifies DOM cell styles).
function fApplyGridManualColoring() {
    fMyConsoleLog("🎨 Applying Manual Font Colors...");
    const colorConfigArray = gUI.fontColorRange;

    // === Validation ===
    // Check if the config is a valid, non-empty array
    if (!Array.isArray(colorConfigArray)) {
        fMyConsoleLog("ℹ️ Manual font color configuration (gUI.fontColorRange) is not an array or is missing.");
        return;
    }
    if (colorConfigArray.length === 0) {
        fMyConsoleLog("ℹ️ Manual font color configuration is empty.");
        return;
    }

    // === Initialization ===
    let colorsAppliedCount = 0;
    let contrastAppliedCount = 0;

    // === Iterate Through Each Color Definition ===
    colorConfigArray.forEach((colorDef, index) => {
        // Validate the structure of the current color definition object
        if (!colorDef || typeof colorDef.color !== 'string' || !Array.isArray(colorDef.ranges)) {
             console.warn(`Skipping invalid color definition at index ${index}:`, colorDef);
             return; // Skip to the next definition
         }

        const cssColor = colorDef.color;   // Hex color string for this definition
        const ranges = colorDef.ranges;     // Array of range objects for this color

        // === Iterate Through Each Range for the Current Color ===
        ranges.forEach(range => {
            // Validate range object structure
            if (!fDoesObjectHaveR1C1R2C2Properties(range)) {
                 console.warn(`Skipping invalid range object for color '${cssColor}':`, range);
                 return; // Skip this range
            }

            // Resolve range tags/indices
            const resolved = fConvertsR1C1R2C2TagOrNumToIndices(range);
            if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
                 console.warn(`Could not resolve tags for range in color '${cssColor}':`, range);
                 return; // Skip range if tags invalid
            }

            // Determine bounds
            const rMin = Math.min(resolved.r1, resolved.r2);
            const rMax = Math.max(resolved.r1, resolved.r2);
            const cMin = Math.min(resolved.c1, resolved.c2);
            const cMax = Math.max(resolved.c1, resolved.c2);

            // === Apply Color to Cells Within the Range ===
            for (let r = rMin; r <= rMax; r++) {
                for (let c = cMin; c <= cMax; c++) {
                    const cell = gUI.grid2D?.[r]?.[c];
                    // Skip non-existent or hidden cells
                    if (!cell || cell.style.display === 'none') continue;

                    // --- Determine Background Color (handling computed vs explicit) ---
                    let cellBgColor = window.getComputedStyle(cell).backgroundColor;
                    if (cellBgColor && cellBgColor.startsWith('rgb')) {
                        // Convert computed rgb() to hex if possible
                        try {
                            const rgb = cellBgColor.match(/\d+/g).map(Number);
                            cellBgColor = '#' + rgb.map(x => { const hex = x.toString(16); return hex.length === 1 ? '0' + hex : hex; }).join('');
                        } catch (e) {
                             // Fallback if conversion fails
                             cellBgColor = cell.style.backgroundColor || gUI.format?.bg?.[r]?.[c] || '#ffffff';
                         }
                     } else {
                         // Use explicit style or format data, default white
                         cellBgColor = cell.style.backgroundColor || gUI.format?.bg?.[r]?.[c] || '#ffffff';
                     }
                    const cleanBgColor = cellBgColor.toLowerCase();
                    // --- End Background Color Determination ---

                    const intendedFontColor = cssColor.toLowerCase();

                    // --- Apply Color with Contrast Check ---
                    if (intendedFontColor === cleanBgColor) {
                        // If font matches background, apply contrast color
                        cell.style.color = fGetContrastColor(cleanBgColor);
                        contrastAppliedCount++;
                    } else {
                        // Otherwise, apply the intended font color
                        cell.style.color = intendedFontColor;
                        colorsAppliedCount++;
                    }
                } // end col loop
            } // end row loop
        }); // end forEach range
    }); // end forEach colorDef

    fMyConsoleLog(`✅ Manual Colors Applied (${colorsAppliedCount} direct, ${contrastAppliedCount} contrast).`);
} // END fApplyGridManualColoring




// fAddGridsHeaderRowButtons ///////////////////////////////////////////////////////////////
// Purpose -> Finds specific cells designated by tags in headerButtonConfigs, clears
//            their content, and inserts configured image buttons.
// Inputs  -> None (Uses gUI.grid2D, calls helper functions).
// Outputs -> None (Modifies DOM by inserting images into cells).
function fAddGridsHeaderRowButtons() {
    fMyConsoleLog("⚙️ Adding Header Buttons...");
    let buttonsAdded = 0;

    // === Button Configurations ===
    // Define where each button image should go and what action it performs.
    const headerButtonConfigs = [
        {
            rowTag: 'Button_R',         // Row tag of the target cell
            colTag: 'DieButtonC',       // Column tag of the target cell
            action: 'action-rollDice',  // data-button-action attribute value
            imageUrl: 'https://raw.githubusercontent.com/bmobley333/TurboApp/main/Pics/Buttons/Button_d20.png', // Image source URL
            altText: 'Roll Dice',       // Image alt text
            titleText: 'Roll Dice'      // Image title text (tooltip)
        },
        {
            rowTag: 'Button_R',
            colTag: 'RefreshButtonC',
            action: 'action-refreshData',
            imageUrl: 'https://raw.githubusercontent.com/bmobley333/TurboApp/main/Pics/Buttons/Button_Refresh.png',
            altText: 'Refresh Data',
            titleText: 'Refresh Data'
        },
        {
            rowTag: 'Button_R',
            colTag: 'UpArrowButtonC',
            action: 'action-jumpTop',
            imageUrl: 'https://raw.githubusercontent.com/bmobley333/TurboApp/main/Pics/Buttons/Button_UpArrow.png',
            altText: 'Jump to Top',
            titleText: 'Jump to Top'
        },
        {
            rowTag: 'Button_R',
            colTag: 'DownArrowButtonC',
            action: 'action-jumpBottom',
            imageUrl: 'https://raw.githubusercontent.com/bmobley333/TurboApp/main/Pics/Buttons/Button_DownArrow.png',
            altText: 'Jump to Bottom',
            titleText: 'Jump to Bottom'
        },
        {
            rowTag: 'Button_R',
            colTag: 'MonsterButtonC',
            action: 'action-showMonsters',
            imageUrl: 'https://raw.githubusercontent.com/bmobley333/TurboApp/main/Pics/Buttons/Button_Monster.png',
            altText: 'Show Monsters',
            titleText: 'Show Monsters'
        }
        // Add more button configurations here
    ];

    // === Apply Buttons ===
    // Iterate through configurations and add buttons to grid
    headerButtonConfigs.forEach(config => {
        // Find the target cell using tags
        const cell = fGetGridCellFromRTagCTag(config.rowTag, config.colTag);
        if (!cell) return; // Skip if cell not found or tags invalid

        // Create the image element
        const img = fCreateGridHeaderRowButtonImage(config);
        // Clear cell and insert the image
        fApplyGridButtonToCell(cell, img);
        buttonsAdded++;
    });

    // Log summary
    fMyConsoleLog(buttonsAdded > 0
        ? `✅ Added ${buttonsAdded} Header Button(s).`
        : `ℹ️ No valid Header Buttons found or added.`);

} // END fAddGridsHeaderRowButtons



// fGetGridCellFromRTagCTag ////////////////////////////////////////////////////////////////
// Purpose -> Resolves row and column tags to indices and retrieves the corresponding
//            cell DOM element from gUI.grid2D. Logs warnings if resolution or
//            element retrieval fails. Used primarily for finding header button cells.
// Inputs  -> rowTag (String): The row tag to resolve.
//         -> colTag (String): The column tag to resolve.
// Outputs -> (HTMLElement | null): The cell element if found, otherwise null.
function fGetGridCellFromRTagCTag(rowTag, colTag) {
    // Resolve tags to indices
    const r = fResolveRow(rowTag);
    const c = fResolveCol(colTag);

    // Validate resolved indices
    if (isNaN(r) || isNaN(c)) {
        console.warn(`fGetGridCellFromRTagCTag: Could not resolve tags [${rowTag}, ${colTag}]`);
        return null;
    }

    // Retrieve cell element from the grid cache
    const cell = gUI.grid2D?.[r]?.[c];

    // Validate cell element exists
    if (!cell) {
        console.warn(`fGetGridCellFromRTagCTag: Cell element not found at resolved [${r}, ${c}] for tags [${rowTag}, ${colTag}]`);
        return null;
    }

    return cell;
} // END fGetGridCellFromRTagCTag




// fCreateGridHeaderRowButtonImage //////////////////////////////////////////////////////
// Purpose -> Creates and returns a styled <img> element for a header button based
//            on the provided configuration object.
// Inputs  -> config (Object): Button configuration containing imageUrl, altText,
//                             titleText, and action (for data-button-action).
// Outputs -> (HTMLImageElement): The configured <img> element.
function fCreateGridHeaderRowButtonImage(config) {
    const img = document.createElement('img');

    // Set image attributes from config
    img.src = config.imageUrl;
    img.alt = config.altText;
    img.title = config.titleText; // Tooltip
    img.dataset.buttonAction = config.action; // Store action for click handler

    // Add CSS class for styling
    img.classList.add('header-button-img');

    return img;
} // END fCreateGridHeaderRowButtonImage




// fApplyGridButtonToCell //////////////////////////////////////////////////////
// Purpose -> Clears the target cell's content, inserts the provided image element,
//            and applies centering styles suitable for image buttons.
// Inputs  -> cell (HTMLElement): The target cell div element.
//         -> img (HTMLImageElement): The configured <img> element to insert.
// Outputs -> None (Modifies the input cell element's content and style).
function fApplyGridButtonToCell(cell, img) {
    // Clear existing content and append the image
    cell.innerHTML = '';
    cell.appendChild(img);

    // Apply centering styles to the cell
    cell.style.justifyContent = 'center';
    cell.style.alignItems = 'center';
    cell.style.padding = '0'; // Remove padding for better image fit
} // END fApplyGridButtonToCell




// fMarkGridOverflowingCells ///////////////////////////////////////////////////////////
// Purpose -> Adds the 'overflow-left' CSS class to grid cells where the content's
//            scrollWidth exceeds the cell's clientWidth, indicating text overflow.
//            Optimized by separating DOM reads (dimensions) from writes (classList).
// Inputs  -> None (Queries DOM for cells).
// Outputs -> None (Modifies cell classLists).
function fMarkGridOverflowingCells() {
    fMyConsoleLog("↔️ Checking Cell Overflow (Optimized)...");
    const cells = document.querySelectorAll('#grid .cell:not([style*="display: none"])'); // Get visible cells
    let cellsToModify = []; // Store cells needing class modification

    // === Phase 1: Read Dimensions ===
    // Iterate through cells and store which ones need the class, without modifying DOM yet.
    cells.forEach(cell => {
        const clientW = cell.clientWidth;
        const scrollW = cell.scrollWidth;
        // Check for overflow (with a 1px tolerance)
        const shouldOverflow = scrollW > clientW + 1;
        // Store the cell and whether it should have the overflow class
        cellsToModify.push({ cellElement: cell, shouldOverflow: shouldOverflow });
    });

    // === Phase 2: Write Class Changes ===
    // Iterate through the collected data and apply class changes in a batch.
    let count = 0; // Count how many cells were newly marked
    cellsToModify.forEach(item => {
        const cell = item.cellElement;
        const currentlyHasClass = cell.classList.contains('overflow-left');

        if (item.shouldOverflow && !currentlyHasClass) {
            // Add class if needed and not present
            cell.classList.add('overflow-left');
            count++;
        } else if (!item.shouldOverflow && currentlyHasClass) {
            // Remove class if not needed and present
            cell.classList.remove('overflow-left');
            // Increment count here if you want to count removals as changes
        }
        // Otherwise, no change needed for this cell
    });

    fMyConsoleLog(`✅ Overflow Checked (Optimized - ${count} cells newly marked)`);
} // END fMarkGridOverflowingCells




// fHideGridsColumnRange ////////////////////////////////////////////////////////////////
// Purpose -> Hides one or more ranges of columns defined in an array of range objects.
//            Calls fSetsGridColumnVisibility for each affected column without updating the
//            grid template individually, then updates the template once at the end.
// Inputs  -> rangeArray (Array<Object>): An array of range definition objects,
//                                         each with c1 and c2 properties (tags/indices).
// Outputs -> None (Modifies cell styles, gUI.hiddenColumns, grid style).
function fHideGridsColumnRange(rangeArray) {
    fMyConsoleLog(`👁️ Hiding Column Ranges...`);

    // === Validate Input ===
    if (!Array.isArray(rangeArray)) {
        console.error("fHideGridsColumnRange: Invalid input - requires an array.", rangeArray);
        return;
    }

    let anyColumnsChanged = false; // Track if any action was taken

    // === Process Each Range ===
    for (const range of rangeArray) {
        // Validate range object structure
        if (!range || typeof range.c1 === 'undefined' || typeof range.c2 === 'undefined') {
             console.warn("fHideGridsColumnRange: Skipping invalid range object:", range);
             continue;
        }

        // Resolve column tags/indices
        const startCol = fResolveCol(range.c1);
        const endCol = fResolveCol(range.c2);

        // Validate resolved indices
        if (isNaN(startCol) || isNaN(endCol)) {
            console.warn(`fHideGridsColumnRange: Skipping range due to invalid tags/indices: ${range.c1}, ${range.c2}`);
            continue;
        }

        // Determine bounds
        const cMin = Math.min(startCol, endCol);
        const cMax = Math.max(startCol, endCol);

        // === Hide Columns Within Range ===
        for (let c = cMin; c <= cMax; c++) {
            // Check if the column is not already hidden
            if (!gUI.hiddenColumns.has(c)) {
                // Hide the column, but defer template update
                fSetsGridColumnVisibility(c, false, false);
                anyColumnsChanged = true; // Mark that a change occurred
            }
            // else: Column already hidden, do nothing for this column index
        }
    } // End loop through rangeArray

    // === Update Grid Template (if needed) ===
    // Update the grid template ONCE after processing all ranges, only if changes were made.
    if (anyColumnsChanged) {
        fAppliesGridColumnOnOff();
        fMyConsoleLog(`✅ Column Ranges Hidden.`);
    } else {
        fMyConsoleLog(`ℹ️ All Specified Column Ranges Already Hidden (or no valid ranges found).`);
    }
} // END fHideGridsColumnRange




// fShowGridsColumnRange ////////////////////////////////////////////////////////////////
// Purpose -> Shows one or more ranges of columns defined in an array of range objects.
//            Calls fSetsGridColumnVisibility for each affected column without updating the
//            grid template individually, then updates the template once at the end.
// Inputs  -> rangeArray (Array<Object>): An array of range definition objects,
//                                         each with c1 and c2 properties (tags/indices).
// Outputs -> None (Modifies cell styles, gUI.hiddenColumns, grid style).
function fShowGridsColumnRange(rangeArray) {
    fMyConsoleLog(`👁️ Showing Column Ranges...`);

    // === Validate Input ===
    if (!Array.isArray(rangeArray)) {
        console.error("fShowGridsColumnRange: Invalid input - requires an array.", rangeArray);
        return;
    }

    let anyColumnsChanged = false; // Track if any action was taken

    // === Process Each Range ===
    for (const range of rangeArray) {
        // Validate range object structure
        if (!range || typeof range.c1 === 'undefined' || typeof range.c2 === 'undefined') {
             console.warn("fShowGridsColumnRange: Skipping invalid range object:", range);
             continue;
        }

        // Resolve column tags/indices
        const startCol = fResolveCol(range.c1);
        const endCol = fResolveCol(range.c2);

        // Validate resolved indices
        if (isNaN(startCol) || isNaN(endCol)) {
            console.warn(`fShowGridsColumnRange: Skipping range due to invalid tags/indices: ${range.c1}, ${range.c2}`);
            continue;
        }

        // Determine bounds
        const cMin = Math.min(startCol, endCol);
        const cMax = Math.max(startCol, endCol);

        // === Show Columns Within Range ===
        for (let c = cMin; c <= cMax; c++) {
             // Check if the column IS currently hidden
             if (gUI.hiddenColumns.has(c)) {
                 // Show the column, but defer template update
                 fSetsGridColumnVisibility(c, true, false);
                 anyColumnsChanged = true; // Mark that a change occurred
             }
             // else: Column already visible, do nothing for this column index
        }
    } // End loop through rangeArray

    // === Update Grid Template (if needed) ===
    // Update the grid template ONCE after processing all ranges, only if changes were made.
    if (anyColumnsChanged) {
        fAppliesGridColumnOnOff();
        fMyConsoleLog(`✅ Column Ranges Shown.`);
    } else {
         fMyConsoleLog(`ℹ️ All Specified Column Ranges Already Visible (or no valid ranges found).`);
    }
} // END fShowGridsColumnRange




// fApplyGridColAndRowInitialVisibility ///////////////////////////////////////////////////////
// Purpose -> Applies the initial hidden state for columns and rows based on the
//            gUI.initialHiddenCols and gUI.initialHiddenRows configuration arrays.
//            Calls fHideGridsColumnRange for columns and fSetGridRowVisibility for rows.
// Inputs  -> None (Uses gUI.initialHiddenCols, gUI.initialHiddenRows).
// Outputs -> None (Calls other functions that modify DOM/state).
function fApplyGridColAndRowInitialVisibility() {
    fMyConsoleLog("👁️ Applying Initial Visibility...");

    // === Hide Initial Columns ===
    if (gUI.initialHiddenCols && gUI.initialHiddenCols.length > 0) {
        // Use the dedicated range function for columns
        fHideGridsColumnRange(gUI.initialHiddenCols);
    } else {
         fMyConsoleLog("   -> ℹ️ No initial columns defined to hide.");
    }

    // === Hide Initial Rows ===
    if (gUI.initialHiddenRows && gUI.initialHiddenRows.length > 0) {
        fMyConsoleLog("   -> 👁️ Hiding Initial Rows...");
        // Iterate through each defined row range
        gUI.initialHiddenRows.forEach(range => {
             // Resolve row tags/indices
             const r1 = fResolveRow(range.r1);
             const r2 = fResolveRow(range.r2);
             // Validate resolved indices
             if (isNaN(r1) || isNaN(r2)) {
                 console.warn("fApplyGridColAndRowInitialVisibility: Skipping invalid row range due to tags:", range);
                 return; // Skip this range
             }
             // Determine bounds and hide each row individually
             const startRow = Math.min(r1, r2);
             const endRow = Math.max(r1, r2);
             for (let r = startRow; r <= endRow; r++) {
                 fSetGridRowVisibility(r, false); // Hide the row
             }
         });
         fMyConsoleLog("   -> ✅ Initial Rows Hidden.");
    } else {
        fMyConsoleLog("   -> ℹ️ No initial rows defined to hide.");
    }

} // END fApplyGridColAndRowInitialVisibility




// ==========================================================================
// === Grid Hover                 (End of Grid Formatting & Visibility) ===
// ==========================================================================




// fConfineNotesTooltipBox ////////////////////////////////////////////////////////////////
// Purpose -> Calculates and sets the top/left style properties for the tooltip
//            element, ensuring it stays within the browser viewport boundaries.
// Inputs  -> tooltip (HTMLElement): The tooltip element (#cell-tooltip).
//         -> event (MouseEvent): The mouse event that triggered the hover.
// Outputs -> None (Modifies the tooltip element's style).
function fConfineNotesTooltipBox(tooltip, event) {
    if (!tooltip || !event) return; // Basic validation

    // === Get Dimensions and Positions ===
    const cursorX = event.pageX; // Cursor position relative to document
    const cursorY = event.pageY;

    const tooltipRect = tooltip.getBoundingClientRect(); // Tooltip dimensions
    const tooltipWidth = tooltipRect.width;
    const tooltipHeight = tooltipRect.height;

    const viewportWidth = window.innerWidth; // Viewport dimensions
    const viewportHeight = window.innerHeight;
    const scrollX = window.scrollX; // Current scroll offset
    const scrollY = window.scrollY;

    // === Calculate Initial Position ===
    // Start below and to the right of the cursor
    let newTop = cursorY + gUI.TOOLTIP_OFFSET_Y;
    let newLeft = cursorX + gUI.TOOLTIP_OFFSET_X;

    // === Adjust Position to Stay Within Viewport ===
    // Adjust left if off right edge
    if (newLeft + tooltipWidth > viewportWidth + scrollX) {
        newLeft = cursorX - tooltipWidth - gUI.TOOLTIP_OFFSET_X; // Move left of cursor
        // If moving left pushes it off the left edge, stick it near the edge
        if (newLeft < scrollX) {
             newLeft = scrollX + 5;
        }
    }

    // Adjust top if off bottom edge
    if (newTop + tooltipHeight > viewportHeight + scrollY) {
        newTop = cursorY - tooltipHeight - gUI.TOOLTIP_OFFSET_Y; // Move above cursor
        // If moving top pushes it off the top edge, stick it near the edge
        if (newTop < scrollY) {
            newTop = scrollY + 5;
        }
    }

    // === Apply Final Position ===
    tooltip.style.top = `${newTop}px`;
    tooltip.style.left = `${newLeft}px`;

} // END fConfineNotesTooltipBox




// fHandleCellHover ////////////////////////////////////////////////////////////////
// Purpose -> Delegated mouseenter/mouseover handler for grid cells. Starts a timer
//            to show the tooltip (via fStartTooltipBoxDelayTimer) if applicable.
// Inputs  -> event (MouseEvent): The mouse event.
// Outputs -> None.
function fHandleCellHover(event) {
    // Exit if tooltip element isn't cached/found
    if (!gUI.tooltipElement) return;

    // Get the target cell element
    const cell = fGetValidTargetCell(event);
    if (!cell) {
        // If not hovering over a valid cell, ensure tooltip is hidden
        fHideTooltip();
        return;
    }

    // Start the timer to potentially show the tooltip
    // This also clears any previous hide timer
    fStartTooltipBoxDelayTimer(cell, event);
} // END fHandleCellHover




// fGetValidTargetCell /////////////////////////////////////////////////////////////
// Purpose -> Finds the closest ancestor element with the class 'cell' from the
//            event target. Helper for delegated event listeners.
// Inputs  -> event (Event): The event object.
// Outputs -> (HTMLElement | null): The cell element or null if not found.
function fGetValidTargetCell(event) {
    return event.target.closest('.cell');
} // END fGetValidTargetCell




// fHideTooltip ////////////////////////////////////////////////////////////////////
// Purpose -> Clears any pending tooltip display timeout and hides the tooltip element.
// Inputs  -> None (Uses gUI.tooltipTimeoutId, gUI.tooltipElement).
// Outputs -> None (Modifies timeout, tooltip style).
function fHideTooltip() {
    // Clear any timer waiting to show the tooltip
    clearTimeout(gUI.tooltipTimeoutId);
    gUI.tooltipTimeoutId = null; // Reset the stored ID

    // Hide the tooltip element if it exists
    if (gUI.tooltipElement) {
        gUI.tooltipElement.style.display = 'none';
    }
} // END fHideTooltip




// fIsTooltipBoxNeeded //////////////////////////////////////////////////////////////
// Purpose -> Determines if a tooltip should be shown for a given cell based on
//            whether its content overflows or if it has an associated note.
// Inputs  -> r (Number): 0-based row index.
//         -> c (Number): 0-based column index.
//         -> cell (HTMLElement): The cell element.
// Outputs -> (Boolean): True if tooltip should be shown, false otherwise.
function fIsTooltipBoxNeeded(r, c, cell) {
    // Check for horizontal overflow (scrollWidth > clientWidth)
    const isOverflowing = cell.scrollWidth > cell.clientWidth + 1; // +1 for tolerance

    // Check if a note exists for this cell
    const noteText = gUI.notes?.[r]?.[c]?.trim();

    // Return true if either condition is met
    return isOverflowing || !!noteText; // Use !! to cast noteText presence to boolean
} // END fIsTooltipBoxNeeded




// fBuildsTooltipBoxesContent ////////////////////////////////////////////////////////////
// Purpose -> Constructs the HTML content for the tooltip, combining overflow text
//            and/or cell notes as needed.
// Inputs  -> r (Number): 0-based row index.
//         -> c (Number): 0-based column index.
//         -> cell (HTMLElement): The cell element.
// Outputs -> (String): HTML string content for the tooltip.
function fBuildsTooltipBoxesContent(r, c, cell) {
    const isOverflowing = cell.scrollWidth > cell.clientWidth + 1;
    const noteText = gUI.notes?.[r]?.[c]?.trim();
    let tooltipContent = '';

    // Add cell's text content if it's overflowing
    if (isOverflowing) {
        tooltipContent = cell.textContent;
    }

    // Add note text if it exists
    if (noteText) {
        // Add a separator if overflow text was already added
        if (tooltipContent) {
            tooltipContent += "\n---\n";
        }
        tooltipContent += `Note: ${noteText}`;
    }

    // Convert newlines to HTML line breaks for display
    return tooltipContent.replace(/\n/g, '<br>');
} // END fBuildsTooltipBoxesContent




// fStartTooltipBoxDelayTimer //////////////////////////////////////////////////////////////
// Purpose -> Sets a timeout (`gUI.HOVER_DELAY_MS`) before attempting to show the
//            tooltip for a hovered cell. Clears any previous timeout.
// Inputs  -> cell (HTMLElement): The cell element being hovered over.
//         -> event (MouseEvent): The mouse event (used for positioning).
// Outputs -> None (Sets a timeout, potentially modifies tooltip content/style later).
function fStartTooltipBoxDelayTimer(cell, event) {
    // Clear any existing timeout before starting a new one
    clearTimeout(gUI.tooltipTimeoutId);

    // Set a new timeout
    gUI.tooltipTimeoutId = setTimeout(() => {
        // Get cell coordinates from data attributes
        const r = parseInt(cell.dataset.r, 10);
        const c = parseInt(cell.dataset.c, 10);

        // Validate coordinates
        if (isNaN(r) || isNaN(c)) {
            console.warn("Tooltip hover: Invalid r/c data attributes.", cell.dataset);
            fHideTooltip(); // Hide tooltip if coords invalid
            return;
        }

        // Check if tooltip should be shown for this cell
        if (fIsTooltipBoxNeeded(r, c, cell)) {
            // Build content, display tooltip, and position it
            gUI.tooltipElement.innerHTML = fBuildsTooltipBoxesContent(r, c, cell);
            gUI.tooltipElement.style.display = 'block';
            fConfineNotesTooltipBox(gUI.tooltipElement, event); // Position relative to mouse event
        } else {
            // Hide tooltip if conditions (overflow/note) are no longer met
            fHideTooltip();
        }

    }, gUI.HOVER_DELAY_MS); // Use configured delay
} // END fStartTooltipBoxDelayTimer




// fHandleCellMouseOut /////////////////////////////////////////////////////////////
// Purpose -> Handles mouseout/mouseleave events delegated from the grid container.
//            Clears any pending tooltip display timeout and hides the tooltip.
// Inputs  -> event (MouseEvent): The mouse event object.
// Outputs -> None (Modifies timeout, tooltip style).
function fHandleCellMouseOut(event) {
    // Clear the pending timeout immediately if the mouse leaves before the delay finishes
    clearTimeout(gUI.tooltipTimeoutId);
    // Reset the stored timeout ID
    gUI.tooltipTimeoutId = null;

    // Hide the tooltip if it's currently visible and the element exists
    if (gUI.tooltipElement) {
        gUI.tooltipElement.style.display = 'none';
    }
} // END fHandleCellMouseOut




// ==========================================================================
// === Dropdown Boxes           (End of Grid Hover or appropriate section) ===
// ==========================================================================




// fCreateDropdownElement //////////////////////////////////////////////////////////
// Purpose -> Creates an HTML select element (<select>) for use within a grid cell dropdown.
//            Populates it with options and pre-selects the current value.
// Inputs  -> r (Number): 0-based row index (for data attributes).
//         -> c (Number): 0-based column index (for data attributes).
//         -> choices (Array): Array of option values for the dropdown.
//         -> currentValue (Any): The current value from gUI.arr to pre-select.
// Outputs -> (HTMLSelectElement): The configured <select> element.
function fCreateDropdownElement(r, c, choices, currentValue) {
    const select = document.createElement('select');

    // Add styling class and data attributes
    select.classList.add('grid-dropdown');
    select.dataset.r = r;
    select.dataset.c = c;

    // Ensure currentValue is a string for comparison, default to empty string
    const currentValStr = String(currentValue ?? '');

    // Create and append option elements
    choices.forEach(choice => {
        const option = document.createElement('option');
        option.value = choice; // Value attribute for the option
        option.textContent = choice; // Visible text for the option

        // Pre-select the option matching the current value
        if (String(choice) === currentValStr) {
            option.selected = true;
        }
        select.appendChild(option);
    });

    return select;
} // END fCreateDropdownElement




// fHandleDropdownChange ///////////////////////////////////////////////////////////
// Purpose -> Handles the 'change' event delegated from grid dropdowns (<select>).
//            Updates the corresponding value in gUI.arr, attempting to preserve
//            the original data type (Number or String) if possible.
//            If the change occurs in an Ability Name cell, triggers fProcessAbilityChange.
// Inputs  -> event (Event): The change event object from the select element.
// Outputs -> None (Modifies gUI.arr, potentially triggers ability processing).
function fHandleDropdownChange(event) {
    // === Get Data from Event ===
    const select = event.target;
    const r = parseInt(select.dataset.r, 10);
    const c = parseInt(select.dataset.c, 10);
    const newValue = select.value; // Value from <select> is always a string

    // === Validate Indices ===
    if (isNaN(r) || isNaN(c) || !gUI.arr?.[r]) {
        console.warn(`fHandleDropdownChange: Invalid coordinates [${r}, ${c}] from dataset.`);
        return;
    }

    // Capture original value *before* determining final type and updating model
    const oldValue = gUI.arr[r][c]; // <<< Capture old value here

    // === Determine Final Value Type ===
    // Attempt to find the original choice in the config to infer data type.
    // This helps store numbers as numbers, not strings, if they were numbers originally.
    const originalChoice = gUI.dropDownBox
        .find(config => config.ranges.some(range => {
            // Find the config that applies to this cell's range
            const resolved = fConvertsR1C1R2C2TagOrNumToIndices(range);
            return !isNaN(resolved.r1) && !isNaN(resolved.c1) && !isNaN(resolved.r2) && !isNaN(resolved.c2) &&
                   r >= Math.min(resolved.r1, resolved.r2) && r <= Math.max(resolved.r1, resolved.r2) &&
                   c >= Math.min(resolved.c1, resolved.c2) && c <= Math.max(resolved.c1, resolved.c2);
        })) // Get the relevant config object (if found)
        ?.choices // Access its choices array
        .find(choice => String(choice) === newValue); // Find the original choice matching the string value

    // If the original choice was a number, convert the newValue back to a number
    const finalValue = (typeof originalChoice === 'number') ? Number(newValue) : newValue;

    // === Update Data Model (if changed) ===
    if (gUI.arr[r][c] !== finalValue) {
        // Check if it's an Ability Name Dropdown BEFORE updating gUI.arr
        const isAbilityNameCell = fIsCellInRangeArray(r, c, gUI.range.abilNameNoNish);

        // Update gUI.arr AFTER checking, but BEFORE calling fProcessAbilityChange
        gUI.arr[r][c] = finalValue;
        fMyConsoleLog(`Dropdown [${r}, ${c}] changed to: "${finalValue}" (Type: ${typeof finalValue})`);

        // If it was an ability name cell, call the processing function
        if (isAbilityNameCell) {
            fMyConsoleLog(`   -> Change detected in Ability Name cell [${r}, ${c}]. Triggering processing...`);
            // Pass the finalValue (correct type) and the captured oldValue
            fProcessAbilityChange(r, c, finalValue, oldValue);
        }
        // Add calls here if other actions need to be triggered by this change for other dropdown types.
        fHandleAutoSaveTextToFirestore(); // Save changes
    }
} // END fHandleDropdownChange




// fProcessAbilityChange ///////////////////////////////////////////////////////
// Purpose -> Handles the logic when an Ability dropdown value changes. Dispatches
//            to helper functions for clearing or processing the new selection,
//            using synchronous calls to fHandleNewAbilitySelection which reads from caches.
// Inputs  -> r (Number): Row index of the changed ability cell.
//         -> c (Number): Column index of the changed ability cell (likely 'Ability' col).
//         -> newValue (Any): The new value selected in the dropdown (expected format 'Name_id').
//         -> oldValue (Any): The previous value in the cell.
// Outputs -> None (Calls helper functions which modify grid).
function fProcessAbilityChange(r, c, newValue, oldValue) {
    const funcName = 'fProcessAbilityChange';
    fMyConsoleLog(`⚙️ ${funcName}: Processing change for Ability/Gear at row ${r}.`);

    // Ensure values are strings for comparison, trimming whitespace
    const newValueStr = String(newValue ?? '').trim();
    const oldValueStr = String(oldValue ?? '').trim();

    // Exit if the trimmed value hasn't actually changed
    if (newValueStr === oldValueStr) {
        fMyConsoleLog(`   -> No significant change detected ('${oldValueStr}' -> '${newValueStr}'). Exiting.`);
        return;
    }

    // --- Dispatch based on new value ---
    if (newValueStr === '') {
        // Scenario 1: New value is empty - call helper to clear row
        fHandleClearAbilityRow(r); // Uses default saveAbilityNameID = false
        // Recalculate Enc/MR AFTER clearing the row
        fCalculatesEnc_MR_AP();
    } else {
        // Scenario 2: New value is not empty - Process data from relevant sources using caches
        fHandleClearAbilityRow(r, true); // Clears fields BUT preserves 'Ability' name
        fMyConsoleLog(`   -> ${funcName}: New Ability/Gear selected: "${newValueStr}". Processing caches...`);
        // Set loading indicator (will be cleared by fSaveNewAbilityToAbilTbl)
        fSetGridValue(r, 'Sk1', '⏳');
        // Call handlers synchronously - they now read from cache
        const dbAbilityResult = fHandleNewAbilitySelection('DB', 'Abilities', r, newValueStr);
        const klMyAbilitiesResult = fHandleNewAbilitySelection('MyKL', 'MyAbilities', r, newValueStr);
        const dbGearResult = fHandleNewAbilitySelection('DB', 'Gear', r, newValueStr);
        // Check for critical errors during cache access/processing within handlers
        if (dbAbilityResult === null || klMyAbilitiesResult === null || dbGearResult === null) {
             fMyConsoleLog(`--> ❌ ${funcName}: Critical error occurred during cache processing for row ${r}. Halting.`);
             // Error message should have been shown by fHandleNewAbilitySelection
             // Ensure indicator is cleared if it wasn't already
             if(fGetGridValue(r, 'Sk1') === '⏳') fSetGridValue(r, 'Sk1', 'ERR');
             return; // Stop processing
        }

        // Log individual outcomes based on the 'found' flag
        fMyConsoleLog(`   -> ${funcName}: Cache Processing Results - DB Ability Found: ${dbAbilityResult.found}, KL MyAbil Found: ${klMyAbilitiesResult.found}, DB Gear Found: ${dbGearResult.found}`);
        // Check if we have *at least* Ability OR Gear dataRow to proceed
        const hasAbilityData = dbAbilityResult.found || klMyAbilitiesResult.found;
        const hasGearData = dbGearResult.found;

        if (!hasAbilityData && !hasGearData) {
            // If neither ability nor gear data was found in caches, report error
            fMyConsoleLog(`--> ❌ ${funcName}: Could not find ID "${newValueStr}" in DB Abilities, MyKL, or DB Gear caches for row ${r}.`);
            fSetGridValue(r, 'Sk1', 'NF'); // Indicate Not Found
            fShowMessage(`Error processing selection: Could not find data in Abilities, MyAbilities, or Gear definitions.`).catch(e => console.error("ShowMessage Error:", e));
            return; // Stop processing
        }

        // Proceed to apply data
        fMyConsoleLog(`--> ${funcName}: Cache processing complete for row ${r}. Applying data...`);
        fSaveNewAbilityToAbilTbl(r, dbAbilityResult, klMyAbilitiesResult, dbGearResult);

        // Recalculate Enc/MR AFTER saving the new data
        fCalculatesEnc_MR_AP();
    } // End else (newValueStr !== '')

} // END fProcessAbilityChange



// fHandleClearAbilityRow //////////////////////////////////////////////////////
// Purpose -> Helper function to clear relevant cells in a grid row when an
//            Ability selection is removed (set to empty) or when preparing for
//            a new selection (optionally preserving the Ability name).
// Inputs  -> r (Number): Row index to clear.
//         -> saveAbilityNameID (Boolean): Optional. If true, preserves the 'Ability'
//                                         cell value. Defaults to false (clears 'Ability').
// Outputs -> None (Modifies grid via fSetGridValue, calls auto-save).
function fHandleClearAbilityRow(r, saveAbilityNameID = false) {
    const funcName = 'fHandleClearAbilityRow';
    fMyConsoleLog(`   -> ${funcName}: Clearing row ${r}${saveAbilityNameID ? ' (preserving Ability Name)' : ''}...`);
    let clearSuccess = true; // Note: check based on fSetGridValue return is likely flawed

    // Clear cells needing empty string
    // Assumes gUI.list.clearAbilityColTags_EmptyString is defined and populated
    const colsToClearEmpty = gUI.list?.clearAbilityColTags_EmptyString || [];
    colsToClearEmpty.forEach(tag => {
        let shouldClear = true;
        // --- MODIFIED LOGIC ---
        if (tag === 'Ability' && saveAbilityNameID) {
             shouldClear = false; // Don't clear Ability name if flag is true
             fMyConsoleLog(`     -> Skipping clear for column '${tag}' due to saveAbilityNameID=true.`);
        }
        // --- END MODIFIED LOGIC ---

        if (shouldClear) {
            // Note: This check assumes fSetGridValue returns boolean, which it might not.
            if (!fSetGridValue(r, tag, '')) { // Set to empty string
                fMyConsoleLog(`     -> (Check Warning) Failed check for clearing column '${tag}' for row ${r}.`);
                // clearSuccess = false; // Commented out: Unreliable check
            }
        }
    });

    // Clear cells needing false
    // Assumes gUI.list.clearAbilityColTags_False is defined and populated
    const colsToClearFalse = gUI.list?.clearAbilityColTags_False || [];
    colsToClearFalse.forEach(tag => {
        // Note: This check assumes fSetGridValue returns boolean, which it might not.
        if (!fSetGridValue(r, tag, false)) { // Set to boolean false
            fMyConsoleLog(`     -> (Check Warning) Failed check for clearing column '${tag}' for row ${r}.`);
            // clearSuccess = false; // Commented out: Unreliable check
        }
    });

    // Original success check logic might be unreliable
    fMyConsoleLog(`   -> ${funcName}: Finished attempting to clear relevant cells for row ${r}.`);
    fHandleAutoSaveTextToFirestore(); // Save changes after clearing attempt

} // END fHandleClearAbilityRow




// fHandleNewAbilitySelection //////////////////////////////////////////////////
// Purpose -> Handles selection of a new ability/gear item synchronously using cached data.
//            Finds the data row for the selected item ID within the appropriate cached
//            FSData object (DB Abilities, MyKL Abilities, or DB Gear).
// Inputs  -> workbookAbr (String): The workbook abbreviation ('DB' or 'MyKL').
//         -> sheetName (String): The sheet name ('Abilities', 'MyAbilities', or 'Gear').
//         -> r (Number): Row index in the grid where the ability was selected (for logging).
//         -> newValueStr (String): The new ability value selected (e.g., 'Name_id').
// Outputs -> (Object | null): Returns { dataRow, headerRow, colTagsMap, found: boolean } on success,
//                              or null if critical errors occur (like cache not loaded).
//                              'found' is true if the ID was located in the respective cache.
function fHandleNewAbilitySelection(workbookAbr, sheetName, r, newValueStr) {
    const funcName = 'fHandleNewAbilitySelection';
    fMyConsoleLog(`   -> ${funcName}: Processing "${newValueStr}" for ${workbookAbr}/${sheetName} using CACHE...`);

    // --- 1. Determine Target Cache and Key ---
    let targetCache = null;
    let cacheKey = '';
    const lowerWorkbookAbr = workbookAbr.toLowerCase();
    const lowerSheetName = sheetName.toLowerCase();

    if (lowerWorkbookAbr === 'db' && lowerSheetName === 'abilities') {
        targetCache = gUI.dbAbilitiesFSData;
        cacheKey = 'gUI.dbAbilitiesFSData';
    } else if (lowerWorkbookAbr === 'mykl' && lowerSheetName === 'myabilities') {
        targetCache = gUI.myKlMyAbilitiesFSData;
        cacheKey = 'gUI.myKlMyAbilitiesFSData';
    } else if (lowerWorkbookAbr === 'db' && lowerSheetName === 'gear') {
        targetCache = gUI.dbGearFSData;
        cacheKey = 'gUI.dbGearFSData';
    } else {
        fMyConsoleLog(`      -> ❌ ${funcName} Error: Unsupported workbook/sheet combination: ${workbookAbr}/${sheetName}`);
        fSetGridValue(r, 'Sk1', 'ERR');
        return null;
    }

    // --- 2. Validate Cache Loaded ---
    if (!targetCache || !targetCache.text || !targetCache.rowTagsMap || !targetCache.colTagsMap) {
        fMyConsoleLog(`      -> ❌ ${funcName} Error: Required cache ${cacheKey} is not loaded or invalid.`);
        fShowMessage(`Error: Required definition data (${cacheKey}) not loaded. Please reload.`).catch(e => console.error("ShowMessage Error:", e));
        fSetGridValue(r, 'Sk1', 'ERR');
        return null;
    }

    // --- 3. Extract Ability ID using Helper Function ---
    const abilID = fGetIDFromNameID(newValueStr); // Use the helper function

    if (!abilID) { // Check if helper returned null (ID not found/invalid)
        fMyConsoleLog(`      -> ❌ ${funcName} Error: Could not extract valid ID from selected value "${newValueStr}".`);
        fSetGridValue(r, 'Sk1', 'ERR');
        return null;
    }
    fMyConsoleLog(`       -> Extracted ID: "${abilID}" for ${workbookAbr}/${sheetName}`);

    // --- 4. Find Row Index using FSData Resolver ---
    const rowIndex = fResolveFSDataRow(cacheKey.replace('gUI.', ''), abilID); // Use resolver, pass gUI key without 'gUI.'
    let dataRow = null;
    let found = false;

    if (isNaN(rowIndex)) {
        // ID not found or index out of bounds (fResolveFSDataRow handles this)
        const isOptionalNotFound = (lowerWorkbookAbr === 'mykl' && lowerSheetName === 'myabilities') ||
                                   (lowerWorkbookAbr === 'db' && lowerSheetName === 'gear');
        if (isOptionalNotFound) {
            // Log INFO for optional sources
            if (lowerWorkbookAbr === 'db' && lowerSheetName === 'gear') {
                 fMyConsoleLog(`       -> INFO: ID "${abilID}" not found in ${cacheKey}. Expected for non-gear.`);
            } else { // MyKL/MyAbilities case
                 fMyConsoleLog(`       -> ID "${abilID}" not found in ${cacheKey}. Expected/handled.`);
            }
        } else {
            // DB/Abilities case (Should ideally be found)
            fMyConsoleLog(`       -> ⚠️ ${funcName} Warning: ID "${abilID}" NOT found in ${cacheKey} or index invalid.`);
        }
        found = false;
        dataRow = null;
    } else {
        // Row index is valid and within bounds
        dataRow = targetCache.text[rowIndex];
        if (Array.isArray(dataRow)) {
             found = true;
             fMyConsoleLog(`       -> Successfully found row for ID "${abilID}" at index ${rowIndex} in ${cacheKey}.`);
        } else {
             fMyConsoleLog(`       -> ⚠️ ${funcName} Warning: Found index ${rowIndex} for ID "${abilID}", but data at index is not an array in ${cacheKey}.`);
             dataRow = null; // Treat non-array data as not found
             found = false;
        }
    }
    // --- END 4. Find Row Index ---


    // --- 5. Prepare Return Object ---
    const headerRow = targetCache.text?.[0] || [];
    const colTagsMap = targetCache.colTagsMap || {};

    return {
        dataRow: dataRow,
        headerRow: headerRow,
        colTagsMap: colTagsMap,
        found: found
    };
} // END fHandleNewAbilitySelection




// fSaveNewAbilityToAbilTbl ////////////////////////////////////////////////////
// Purpose -> Saves data fetched from DB Abilities, DB Gear, and KL MyAbilities sources
//            to the appropriate columns in a specific grid row using fSetGridValue.
//            Also sets default values and calculates derived gear properties.
// Inputs  -> r (Number): The target row index in the grid.
//         -> dbAbilityResult (Object | null): Result from DB Abilities fetch { dataRow, headerRow, colTagsMap } or null.
//         -> klMyAbilitiesResult (Object | null): Result from KL MyAbilities fetch { dataRow, headerRow, colTagsMap } or null.
//         -> dbGearResult (Object | null): Result from DB Gear fetch { dataRow, headerRow, colTagsMap } or null (or might lack dataRow if not found).
// Outputs -> None (Modifies grid via fSetGridValue, calls auto-save).
function fSaveNewAbilityToAbilTbl(r, dbAbilityResult, klMyAbilitiesResult, dbGearResult) {
    const funcName = 'fSaveNewAbilityToAbilTbl';
    fMyConsoleLog(`   -> ${funcName}: Applying fetched data to grid row ${r}...`);

    // --- Extract data and maps safely ---
    const dbAbilityRow = dbAbilityResult?.dataRow;
    const dbAbilityColTags = dbAbilityResult?.colTagsMap;
    const klMyAbilitiesRow = klMyAbilitiesResult?.dataRow;
    const klMyAbilitiesColTags = klMyAbilitiesResult?.colTagsMap;
    const dbGearRow = dbGearResult?.dataRow; // This might be undefined/null if not found or fetch failed
    const dbGearColTags = dbGearResult?.colTagsMap;

    // --- Helper to get value safely from a source row using source tags ---
    const getValueFromSource = (sourceRow, sourceColTags, sourceTag) => {
        if (!sourceRow || !sourceColTags) return undefined; // Source data missing
        const sourceIndex = sourceColTags[sourceTag];
        if (sourceIndex !== undefined && sourceIndex !== null && sourceIndex < sourceRow.length) {
            return sourceRow[sourceIndex];
        }
        // fMyConsoleLog(`     -> getValueFromSource: Tag '${sourceTag}' not found or index out of bounds.`); // Can be noisy
        return undefined; // Tag not found or index invalid
    };

    // --- Define the base mappings (Abilities & MyAbilities) ---
    const dataMappings = [
        // klMyAbilitiesRow source Data
        { gridTag: 'Sk1', sourceRow: klMyAbilitiesRow, sourceColTags: klMyAbilitiesColTags, sourceTag: 'TrainedSk1' },
        { gridTag: 'Sk2', sourceRow: klMyAbilitiesRow, sourceColTags: klMyAbilitiesColTags, sourceTag: 'TrainedSk2' },
        { gridTag: 'Ver', sourceRow: klMyAbilitiesRow, sourceColTags: klMyAbilitiesColTags, sourceTag: 'Ver' },
        { gridTag: 'Act', sourceRow: klMyAbilitiesRow, sourceColTags: klMyAbilitiesColTags, sourceTag: 'Act' },
        { gridTag: 'Dur', sourceRow: klMyAbilitiesRow, sourceColTags: klMyAbilitiesColTags, sourceTag: 'Dur' },
        { gridTag: 'Rng', sourceRow: klMyAbilitiesRow, sourceColTags: klMyAbilitiesColTags, sourceTag: 'Rng' },
        { gridTag: 'MetaCost', sourceRow: klMyAbilitiesRow, sourceColTags: klMyAbilitiesColTags, sourceTag: 'Meta' }, // Note gridTag vs sourceTag
        { gridTag: 'Uses', sourceRow: klMyAbilitiesRow, sourceColTags: klMyAbilitiesColTags, sourceTag: 'Uses' },
        { gridTag: 'Regain', sourceRow: klMyAbilitiesRow, sourceColTags: klMyAbilitiesColTags, sourceTag: 'Regain' },

        // dbAbilityRow Source Data
        { gridTag: 'Sk1Typ', sourceRow: dbAbilityRow, sourceColTags: dbAbilityColTags, sourceTag: 'SkTyp1' },
        { gridTag: 'Sk2Typ', sourceRow: dbAbilityRow, sourceColTags: dbAbilityColTags, sourceTag: 'SkTyp2' },
        { gridTag: 'Notes', sourceRow: dbAbilityRow, sourceColTags: dbAbilityColTags, sourceTag: 'Notes' },
        { gridTag: 'Pic', sourceRow: dbAbilityRow, sourceColTags: dbAbilityColTags, sourceTag: 'Pic' },
    ];

    // --- Apply mapped data (Abilities & MyAbilities) ---
    fMyConsoleLog(`     -> Applying Ability/MyAbilities mappings...`);
    dataMappings.forEach(map => {
        const value = getValueFromSource(map.sourceRow, map.sourceColTags, map.sourceTag);
        // Set grid value only if source value was found (undefined if not found)
        if (value !== undefined) {
            // fMyConsoleLog(`     -> Setting Grid '${map.gridTag}' from source '${map.sourceTag}', Value: ${value}`); // Verbose
            fSetGridValue(r, map.gridTag, value);
        } else {
            // If source value is undefined, explicitly clear the grid cell
            // Ensures fields are cleared if switching from an Ability WITH that field to one WITHOUT it.
            // fMyConsoleLog(`     -> Clearing Grid '${map.gridTag}' as source '${map.sourceTag}' not found.`); // Verbose
            fSetGridValue(r, map.gridTag, '');
        }
    });

    // --- Apply Gear-Specific Data and Calculations (if found) ---
    if (dbGearRow && dbGearColTags) {
        fMyConsoleLog(`     -> Applying Gear mappings and calculations...`);
        // Get values needed for calculations first
        // const isWornValRaw = fGetGridValue(r, 'PossWorn'); // REMOVED - Assume true
        const possNameVal = getValueFromSource(dbGearRow, dbGearColTags, 'Name_ID') ?? '';
        const isArtifactVal = getValueFromSource(dbGearRow, dbGearColTags, 'IsArtifact');
        const wornEncValRaw = getValueFromSource(dbGearRow, dbGearColTags, 'WornEnc');
        const itemEncValRaw = getValueFromSource(dbGearRow, dbGearColTags, 'ItemEnc');
        const crEachValRaw = getValueFromSource(dbGearRow, dbGearColTags, 'ItemCR');
        // const perOffValRaw = fGetGridValue(r, 'PossPerOff'); // REMOVED - Assume ''
        const apEachValRaw = getValueFromSource(dbGearRow, dbGearColTags, 'AP');

        // --- Process PossNum (Simplified) ---
        const possNumVal = 1; // Always assume 1 for calculations when applying gear
        fSetGridValue(r, 'PossNum', 1); // Always set the grid cell to 1
        fMyConsoleLog(`       -> Set possNumVal to: ${possNumVal}`);
        // --- End Process PossNum ---

        // Process PossWorn (Simplified - Always true for calc, grid cell not updated here)
        const isWornVal = true; // Assume true for calculations
        fSetGridValue(r, 'PossWorn', true); // Explicitly set checkbox to true
        fMyConsoleLog(`       -> Set isWornVal: ${isWornVal}`);

        // Calculate Encumbrance
        const wornEnc = Number(wornEncValRaw) || 0;
        const itemEnc = Number(itemEncValRaw) || 0;
        const encEachVal = (isWornVal && wornEncValRaw !== '') ? wornEnc : itemEnc; // isWornVal is true
        const encTotalVal = possNumVal * encEachVal; // possNumVal is 1
        fMyConsoleLog(`       -> Enc Calc: Worn=${isWornVal}, WornEnc=${wornEnc}, ItemEnc=${itemEnc} => EncEach=${encEachVal}, TotalEnc=${encTotalVal}`);

        // Calculate Credit Value
        const crEachVal = Number(crEachValRaw) || 0;
        const perOffVal = ''; // Assume empty for calculations
        // Removed parsing logic for perOffValRaw
        fSetGridValue(r, 'PossPerOff', ''); // Ensure grid cell is empty
        // Calculation simplifies because perOffVal is always ''
        const crTotalVal = possNumVal * crEachVal; // possNumVal is 1
        fMyConsoleLog(`       -> CR Calc: CREach=${crEachVal}, Num=${possNumVal}, PerOff=${perOffVal} => CRTotal=${crTotalVal}`);

        // Calculate AP Value
        const apEachVal = Number(apEachValRaw) || 0;
        const apTotalVal = possNumVal * apEachVal; // possNumVal is 1
        fMyConsoleLog(`       -> AP Calc: APEach=${apEachVal}, Num=${possNumVal} => APTotal=${apTotalVal}`);

        // --- Set Gear Grid Values ---
        fSetGridValue(r, 'PossName', possNameVal);
        // PossNum already handled/set above
        // PossWorn explicitly set above
        fSetGridValue(r, 'PossEnc', encTotalVal);
        fSetGridValue(r, 'PossCrEa', crEachVal);
        // PossPerOff explicitly set above
        fSetGridValue(r, 'PossCrTot', crTotalVal);
        fSetGridValue(r, 'PossIsArtifact', isArtifactVal); // Set boolean
        fSetGridValue(r, 'PossAPEa', apEachVal);
        fSetGridValue(r, 'PossAPTot', apTotalVal);

    } else {
        // --- Clear Gear-Specific Fields (if not gear) ---
        fMyConsoleLog(`     -> Clearing Gear-specific fields as item not found in DB Gear.`);
        const gearFieldsToClear = ['PossNum', 'PossName', 'PossWorn', 'PossEnc', 'PossCrEa', 'PossPerOff', 'PossCrTot', 'PossIsArtifact', 'PossAPEa', 'PossAPTot'];
        gearFieldsToClear.forEach(tag => fSetGridValue(r, tag, '')); // Clear with empty string
        // Set checkboxes to false explicitly
        fSetGridValue(r, 'PossWorn', false);
        fSetGridValue(r, 'PossIsArtifact', false);

    }

    fMyConsoleLog(`   -> ${funcName}: Finished applying data to grid row ${r}.`);
    // --- Save changes ---
    fHandleAutoSaveTextToFirestore();

} // END fSaveNewAbilityToAbilTbl



// fApplyDropdownsToGrid ///////////////////////////////////////////////////////////
// Purpose -> Iterates through gUI.dropDownBox configurations and replaces the
//            content of applicable grid cells with dropdown (<select>) elements.
//            Allows replacing existing dropdowns specifically for Ability Name lists.
// Inputs  -> None (Uses gUI.dropDownBox, gUI.arr, gUI.grid2D).
// Outputs -> None (Modifies DOM by replacing cell content).
function fApplyDropdownsToGrid() {
    fMyConsoleLog("🧬 Applying Dropdowns to Grid...");
    let dropdownsApplied = 0;
    const abilityListKey = 'myCsListFSData'; // Key identifying the ability dropdown config

    // === Validate Configuration ===
    if (!gUI.dropDownBox || !Array.isArray(gUI.dropDownBox)) {
        fMyConsoleLog("ℹ️ No dropdown configurations found in gUI.dropDownBox.");
        return;
    }

    // === Iterate Through Each Dropdown Configuration ===
    gUI.dropDownBox.forEach(config => {
        // Validate current config structure
        if (!config.choices || !config.ranges || !Array.isArray(config.choices) || !Array.isArray(config.ranges)) {
            console.warn("fApplyDropdownsToGrid: Skipping invalid dropdown config:", config);
            return; // Skip to next config
        }

        const isAbilityDropdownConfig = (config.gUIListKey === abilityListKey); // <<< ADDED: Check if this is the ability config

        // === Iterate Through Ranges for This Config ===
        config.ranges.forEach(range => {
            // Validate range object structure
            if (!fDoesObjectHaveR1C1R2C2Properties(range)) {
                 console.warn("fApplyDropdownsToGrid: Skipping invalid range object within dropdown config:", range);
                 return; // Skip this range
            }

            // Resolve range tags/indices
            const resolved = fConvertsR1C1R2C2TagOrNumToIndices(range);
            if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
                 console.warn("fApplyDropdownsToGrid: Skipping dropdown range due to unresolved indices:", range);
                 return; // Skip range if tags invalid
            }

            // Determine bounds
            const rMin = Math.min(resolved.r1, resolved.r2);
            const rMax = Math.max(resolved.r1, resolved.r2);
            const cMin = Math.min(resolved.c1, resolved.c2);
            const cMax = Math.max(resolved.c1, resolved.c2);

            // === Apply Dropdown to Cells Within Range ===
            for (let r = rMin; r <= rMax; r++) {
                for (let c = cMin; c <= cMax; c++) {
                    const cell = gUI.grid2D?.[r]?.[c];

                    // --- Check if cell is suitable for dropdown update ---
                    const existingDropdown = cell ? cell.querySelector('select.grid-dropdown') : null;
                    const hasCheckbox = cell ? cell.querySelector('input[type="checkbox"]') : true; // Assume true if cell missing

                    // <<< MODIFIED Check: >>>
                    // Allow update if:
                    // 1. Cell exists and is visible
                    // 2. Cell does NOT contain a checkbox
                    // 3. EITHER the cell does NOT currently have a dropdown OR this IS the ability dropdown config
                    const shouldApplyDropdown = cell &&
                                                cell.style.display !== 'none' &&
                                                !hasCheckbox &&
                                                (!existingDropdown || isAbilityDropdownConfig);

                    if (shouldApplyDropdown) {
                         const currentValue = gUI.arr?.[r]?.[c];
                         // Create the NEW dropdown element with updated choices
                         const dropdown = fCreateDropdownElement(r, c, config.choices, currentValue);

                         // Replace cell content with the dropdown
                         cell.innerHTML = ''; // Clear existing content (including old dropdown if present)
                         cell.appendChild(dropdown);

                         // Adjust cell style for dropdown
                         cell.style.padding = '0'; // Remove padding to allow dropdown full space
                         cell.style.overflow = 'visible'; // Allow dropdown arrow to be visible

                         dropdownsApplied++;
                    }
                    // --- End Check ---

                } // End col loop
            } // End row loop
        }); // End ranges.forEach
    }); // End dropDownBox.forEach

    fMyConsoleLog(`✅ Applied ${dropdownsApplied} Dropdowns.`);
} // END fApplyDropdownsToGrid




// fFetchAndApplyAbilityDropdowns //////////////////////////////////////////////
// Purpose -> Ensures the ability list ('MyCS'/'List') is processed from the cache
//            and applied to the grid dropdowns. Assumes the cache has already been loaded.
// Inputs  -> None.
// Outputs -> None (Calls fProcessCachedAbilityList).
function fFetchAndApplyAbilityDropdowns() {
    const funcName = "fFetchAndApplyAbilityDropdowns";
    fMyConsoleLog(`⚙️ ${funcName}: Triggering processing of cached Ability List...`);

    // --- Validate Prerequisite Cache ---
    // Check if the cache load mechanism should have already run and populated the cache
    if (!gUI.myCsListFSData) {
         const errorMsg = `Cannot process ability list: Required cache (gUI.myCsListFSData) was not loaded during initial setup.`;
         console.error(`${funcName}: ${errorMsg}`);
         fMyConsoleLog(`   -> ❌ ${funcName} Error: ${errorMsg}`);
         fShowMessage(`Error: ${errorMsg}`).catch(e => console.error("ShowMessage Error:", e));
         return; // Stop if the cache isn't ready
    }

    // --- Call Processing Function ---
    // The cache exists, now process it and apply dropdowns
    fProcessCachedAbilityList();

} // END fFetchAndApplyAbilityDropdowns




// fProcessCachedAbilityList ///////////////////////////////////////////////
// Purpose -> Processes the cached MyCS/List data, extracting only rows from
//            'TableFirstRow' down, sorts the relevant column ('AbilitiesNameID'),
//            adds an empty option, and applies it to the grid dropdowns.
// Inputs  -> None (Uses gUI.myCsListFSData).
// Outputs -> None (Modifies gUI.dropDownBox, calls fApplyDropdownsToGrid).
function fProcessCachedAbilityList() {
    const funcName = "fProcessCachedAbilityList";
    fMyConsoleLog(`   -> ${funcName}: Processing cached MyCS/List data...`);

    // --- 1. Access and Validate Cache & Required Tags ---
    const listCache = gUI.myCsListFSData;
    const cacheKey = 'myCsListFSData'; // Key for resolver functions
    const colTagForAbilities = 'AbilitiesNameID';
    const startRowTag = 'TableFirstRow';

    // Basic cache check
    if (!listCache) {
        const errMsg = `MyCS/List cache (gUI.${cacheKey}) is missing. Cannot populate Ability dropdowns.`;
        console.error(`${funcName}: ${errMsg}`);
        fMyConsoleLog(`      -> ❌ ${funcName} Error: ${errMsg}`);
        fShowMessage(`Error: ${errMsg}`).catch(e => console.error("ShowMessage Error:", e));
        return;
    }

    // Resolve indices using FSData resolvers
    const abilitiesColIndex = fResolveFSDataCol(cacheKey, colTagForAbilities);
    const startRowIndex = fResolveFSDataRow(cacheKey, startRowTag);

    // Validate resolved indices
    if (isNaN(abilitiesColIndex)) {
        const errMsg = `Column tag '${colTagForAbilities}' not found or invalid in ${cacheKey} maps.`;
        console.error(`${funcName}: ${errMsg}`);
        fMyConsoleLog(`      -> ❌ ${funcName} Error: ${errMsg}`);
        fShowMessage(`Error: ${errMsg}`).catch(e => console.error("ShowMessage Error:", e));
        return;
    }
    if (isNaN(startRowIndex)) {
        const errMsg = `Start row tag '${startRowTag}' not found or invalid in ${cacheKey} maps.`;
        console.error(`${funcName}: ${errMsg}`);
        fMyConsoleLog(`      -> ❌ ${funcName} Error: ${errMsg}`);
        fShowMessage(`Error: ${errMsg}`).catch(e => console.error("ShowMessage Error:", e));
        return;
    }
    // fResolveFSDataRow already checks bounds

    fMyConsoleLog(`      -> Processing list from absolute row index ${startRowIndex} ('${startRowTag}') downwards.`);
    fMyConsoleLog(`      -> Using data from column index ${abilitiesColIndex} ('${colTagForAbilities}').`);

    // --- 2. Extract Relevant Column Data Starting From Specific Row ---
    const abilityListRaw = [];
    const cachedText = listCache.text; // Full 2D array
    const numRows = cachedText.length;

    for (let r = startRowIndex; r < numRows; r++) {
        // Ensure the row and cell exist before accessing
        const cellValue = cachedText[r]?.[abilitiesColIndex];
        // Add to list if it exists (it will be filtered for emptiness later)
        if (cellValue !== undefined) {
            abilityListRaw.push(cellValue);
        }
    }

    fMyConsoleLog(`      -> Extracted ${abilityListRaw.length} potential ability names from row ${startRowIndex} onwards.`);

    // --- 3. Process List ---
    // Filter empty/null/undefined, sort, add empty option at start
    const abilityListFiltered = abilityListRaw
        .filter(name => name !== undefined && name !== null && String(name).trim() !== '')
        .map(name => String(name).trim());
    abilityListFiltered.sort((a, b) => a.localeCompare(b));
    abilityListFiltered.unshift('');

    fMyConsoleLog(`      -> Processed list size: ${abilityListFiltered.length} (after filter, sort, unshift).`);

    // --- 4. Update Dropdown Config ---
    let abilityConfig = gUI.dropDownBox.find(config => config.gUIListKey === cacheKey);

    if (!abilityConfig) {
         fMyConsoleLog(`      -> Creating new dropdown config for Abilities.`);
         abilityConfig = {
            gUIListKey: cacheKey, // Key to identify this config
            choices: abilityListFiltered,
            ranges: gUI.range.abilNameNoNish // Use existing range definition
         };
         gUI.dropDownBox.push(abilityConfig);
    } else {
        fMyConsoleLog(`      -> Updating existing dropdown config choices for Abilities.`);
        abilityConfig.choices = abilityListFiltered;
    }
    fMyConsoleLog("      -> Added/Updated Ability config in gUI.dropDownBox.");

    // --- 5. Apply Dropdowns to Grid ---
    fApplyDropdownsToGrid();

} // END fProcessCachedAbilityList




// ==========================================================================
// === Grid Interaction Logic          (End of Dropdown Boxes ) ===
// ==========================================================================




// fHandleGridCheckboxClick ////////////////////////////////////////////////////////
// Purpose -> Handles delegated click events specifically for checkboxes within the grid.
//            Updates the data model (gUI.arr), handles radio-button logic for
//            Sk1/Sk2 checkboxes, and triggers fCalcGearLine for PossWorn checkboxes.
// Inputs  -> event (MouseEvent): The click event object.
// Outputs -> None (Modifies gUI.arr, gUI.currentSkRadioChecked, DOM checkbox state, potentially triggers recalc/save).
async function fHandleGridCheckboxClick(event) { // <<< MADE ASYNC
    const checkbox = event.target;

    // Validate if the clicked element is a valid grid checkbox
    if (!fIsValidGridCheckbox(checkbox)) return;

    // Get coordinates from checkbox data attributes
    const r = parseInt(checkbox.dataset.r, 10);
    const c = parseInt(checkbox.dataset.c, 10);

    // Validate coordinates
    if (!fIsValidGridCoords(r, c)) {
        console.warn("Checkbox click handler: Invalid row/column index or missing grid element.", checkbox.dataset);
        return;
    }

    // Determine checked state and if it's part of the Sk radio group
    const isChecked = checkbox.checked;
    const isSkGroupMember = checkbox.dataset.skGroup === 'true';
    const possWornCol = fResolveCol('PossWorn'); // Get the index for PossWorn

    // Update data model *before* potentially calling fCalcGearLine
    const oldValue = gUI.arr[r][c]; // Capture old value before update
    gUI.arr[r][c] = isChecked;
    fMyConsoleLog(`Checkbox [${r}, ${c}] toggled to: ${isChecked}`);

    // Handle Sk1/Sk2 Radio Group Logic
    if (isSkGroupMember) {
        // Handle radio-button logic (doesn't need await)
        fHandleSkGroupCheckboxClickLogicOnly(r, c, isChecked, oldValue); // Use refactored logic-only function
    }

    // --- Trigger Gear Calculation if PossWorn was clicked ---
    if (c === possWornCol) {
        fMyConsoleLog(`   -> PossWorn checkbox clicked [${r}, ${c}]. Triggering fCalcGearLine...`);
        // Call fCalcGearLine, passing the OLD value (!isChecked) for potential revert
        const calcResult = await fCalcGearLine(r, c, isChecked, !isChecked);

        // fCalcGearLine now handles DOM revert on failure and returns null.
        // We already updated gUI.arr[r][c] optimistically.
        // If calcResult is null, fCalcGearLine failed validation/calculation and reverted the DOM.
        // We should technically revert gUI.arr[r][c] as well in that case, but fCalcGearLine
        // already showed an error. Leaving gUI.arr as is simplifies this handler.
        // We only trigger auto-save if the calculation succeeded (calcResult is not null).
        if (calcResult !== null) {
            fHandleAutoSaveTextToFirestore(); // Auto-save after successful calc
        } else {
             fMyConsoleLog(`   -> fCalcGearLine indicated failure for PossWorn click at [${r}, ${c}]. Auto-save skipped.`);
             // Optionally revert gUI.arr here if strict consistency is needed:
             // gUI.arr[r][c] = !isChecked;
        }
    } else if (!isSkGroupMember) {
         // If it wasn't PossWorn and wasn't an SkGroup member, just save the standard checkbox change
         fHandleAutoSaveTextToFirestore();
    }
     // Note: SkGroup changes don't trigger auto-save directly here; subsequent actions usually do.

} // END fHandleGridCheckboxClick




// fHandleSkGroupCheckboxClickLogicOnly ////////////////////////////////////////////
// Purpose -> Handles the synchronous data model and tracker updates for Sk1/Sk2
//            radio group checkboxes. Called by fHandleGridCheckboxClick.
// Inputs  -> r (Number): Row index of the clicked checkbox.
//         -> c (Number): Column index of the clicked checkbox.
//         -> isChecked (Boolean): The new checked state of the clicked checkbox.
//         -> oldValue (Any): The previous value (used to determine if unchecking).
// Outputs -> None (Modifies gUI.arr, gUI.currentSkRadioChecked, and potentially other DOM checkboxes).
function fHandleSkGroupCheckboxClickLogicOnly(r, c, isChecked, oldValue) {
    const oldR = gUI.currentSkRadioChecked.r;
    const oldC = gUI.currentSkRadioChecked.c;

    if (isChecked) {
        // If checking a new box, uncheck the previously checked one (if different)
        if (oldR !== null && oldC !== null && (oldR !== r || oldC !== c)) {
            fUncheckOldSkGroupBox(oldR, oldC);
        }
        // Update tracker
        gUI.currentSkRadioChecked = { r, c };
        // gUI.arr[r][c] is already set to true by the caller
        fMyConsoleLog(`Radio group: Checked box [${r}, ${c}]`);
    } else {
        // If unchecking the currently tracked box, clear the tracker
        if (oldR === r && oldC === c) {
            gUI.currentSkRadioChecked = { r: null, c: null };
        }
        // gUI.arr[r][c] is already set to false by the caller
        fMyConsoleLog(`Radio group: Unchecked box [${r}, ${c}]`);
    }
} // END fHandleSkGroupCheckboxClickLogicOnly



// fIsValidGridCheckbox ////////////////////////////////////////////////////////////
// Purpose -> Checks if a given HTML element is a valid, enabled checkbox
//            located within a grid cell (.cell).
// Inputs  -> checkbox (HTMLElement): The element to check.
// Outputs -> (Boolean): True if the element is a valid grid checkbox, false otherwise.
function fIsValidGridCheckbox(checkbox) {
    return checkbox &&
           checkbox.tagName === 'INPUT' &&
           checkbox.type === 'checkbox' &&
           checkbox.closest('.cell') && // Ensure it's within a grid cell
           !checkbox.disabled;          // Ensure it's not disabled
} // END fIsValidGridCheckbox




// fIsValidGridCoords //////////////////////////////////////////////////////////////
// Purpose -> Validates if given row and column indices are valid numbers and
//            correspond to existing rows in gUI.arr and gUI.grid2D.
// Inputs  -> r (Number): 0-based row index.
//         -> c (Number): 0-based column index.
// Outputs -> (Boolean): True if coordinates are valid, false otherwise.
function fIsValidGridCoords(r, c) {
    return !isNaN(r) && !isNaN(c) && // Are they numbers?
           r >= 0 && c >= 0 &&        // Are they non-negative?
           gUI.arr[r] && gUI.grid2D[r]; // Do the rows exist in our data/DOM arrays?
} // END fIsValidGridCoords




// fHandleSkGroupCheckboxClick /////////////////////////////////////////////////////
// Purpose -> Handles the specific logic for Sk1/Sk2 checkboxes, ensuring only one
//            in the defined group (gUI.range.sk1sk2CheckBoxes) can be checked at a time.
// Inputs  -> r (Number): Row index of the clicked checkbox.
//         -> c (Number): Column index of the clicked checkbox.
//         -> isChecked (Boolean): The new checked state of the clicked checkbox.
// Outputs -> None (Modifies gUI.arr, gUI.currentSkRadioChecked, and potentially other DOM checkboxes).
function fHandleSkGroupCheckboxClick(r, c, isChecked) {
    const oldR = gUI.currentSkRadioChecked.r;
    const oldC = gUI.currentSkRadioChecked.c;

    if (isChecked) {
        // If checking a new box, uncheck the previously checked one (if different)
        if (oldR !== null && oldC !== null && (oldR !== r || oldC !== c)) {
            fUncheckOldSkGroupBox(oldR, oldC);
        }
        // Update tracker and data model for the newly checked box
        gUI.currentSkRadioChecked = { r, c };
        gUI.arr[r][c] = true;
        fMyConsoleLog(`Radio group: Checked box [${r}, ${c}]`);
    } else {
        // If unchecking the currently tracked box, clear the tracker
        if (oldR === r && oldC === c) {
            gUI.currentSkRadioChecked = { r: null, c: null };
        }
        // Update data model for the unchecked box
        gUI.arr[r][c] = false;
        fMyConsoleLog(`Radio group: Unchecked box [${r}, ${c}]`);
    }
} // END fHandleSkGroupCheckboxClick




// fUncheckOldSkGroupBox ///////////////////////////////////////////////////////////
// Purpose -> Finds and unchecks the previously checked Sk1/Sk2 radio group checkbox
//            in both the DOM and the data model (gUI.arr).
// Inputs  -> oldR (Number): Row index of the previously checked box.
//         -> oldC (Number): Column index of the previously checked box.
// Outputs -> None (Modifies DOM checkbox state and gUI.arr).
function fUncheckOldSkGroupBox(oldR, oldC) {
    // Find the DOM element for the old cell and its checkbox
    const oldCellDiv = gUI.grid2D[oldR]?.[oldC];
    const oldCheckbox = oldCellDiv?.querySelector('input[data-sk-group="true"]');

    if (oldCheckbox) {
        oldCheckbox.checked = false; // Uncheck DOM element
        gUI.arr[oldR][oldC] = false; // Update data model
        fMyConsoleLog(`Radio group: Unchecked previous box [${oldR}, ${oldC}]`);
    } else {
        // This might happen if the grid structure changed unexpectedly
        console.warn(`Radio group: Could not find previous checkbox element at [${oldR}, ${oldC}] to uncheck.`);
    }
} // END fUncheckOldSkGroupBox




// fHandleGridClick ////////////////////////////////////////////////////////////////
// Purpose -> Delegated click handler for the main grid container (#grid). Routes clicks
//            based on the target element (header button, checkbox, URL link, editable cell).
//            Updates gUI.cellClickInfo with details of the last clicked cell.
// Inputs  -> event (MouseEvent): The click event object.
// Outputs -> None (Calls specific handlers based on target).
async function fHandleGridClick(event) { // Keep async for potential future needs
    const target = event.target;

    // === Handle Header Button Clicks ===
    // Check if the click was on an image inside a header button cell
    const buttonImg = target.closest('.header-button-img[data-button-action]');
    if (buttonImg) {
        fHandleGridButtonClick(event, buttonImg);
        // Note: cellClickInfo is NOT updated for header button clicks.
        return; // Stop further processing
    }

    // === Get Clicked Cell Element ===
    const cellDiv = target.closest('.cell');
    if (!cellDiv) return; // Exit if click wasn't inside a grid cell

    // === Update Last Clicked Cell Info ===
    try {
        const r_str = cellDiv.dataset.r;
        const c_str = cellDiv.dataset.c;
        const r = parseInt(r_str, 10);
        const c = parseInt(c_str, 10);
        const text = cellDiv.textContent?.trim() ?? ''; // Get visible text

        if (!isNaN(r) && !isNaN(c)) {
            // Store valid coordinates and text
            gUI.cellClickInfo = { r, c, text, focusText: null }; // Reset focusText
            fMyConsoleLog(`🖱️ Cell Click: [${r}, ${c}]`);
        } else {
            // Log warning and clear info if coordinates are invalid
            console.warn(`fHandleGridClick: Invalid row/col data attributes found: r='${r_str}', c='${c_str}'`);
            gUI.cellClickInfo = { r: null, c: null, text: null, focusText: null };
        }
    } catch (e) {
        console.error("Error updating gUI.cellClickInfo:", e);
        gUI.cellClickInfo = { r: null, c: null, text: null, focusText: null }; // Clear on error
    }

    // === Route Click Based on Target Type ===
    // Checkbox Click
    if (fIsCheckboxClick(target)) {
        fHandleGridCheckboxClick(event);
        return;
    }

    // Click inside an already focused editable cell (do nothing special)
    if (fIsEditableCell(cellDiv) && document.activeElement === cellDiv) {
        return;
    }

    // Click to focus an editable cell (allow default focus behavior)
    if (fIsEditableCell(cellDiv)) {
        return;
    }

    // URL Link Click
    if (fIsUrlLinkCell(cellDiv)) {
        fHandleUrlClick(cellDiv);
        return;
    }

    // Fallback for general clicks on non-interactive cells (optional logging)
    // fMyConsoleLog(`General click on non-interactive cell [${gUI.cellClickInfo.r}, ${gUI.cellClickInfo.c}]`);

} // END fHandleGridClick




// fIsCheckboxClick ////////////////////////////////////////////////////////////////
// Purpose -> Helper to check if the event target is a checkbox input element.
// Inputs  -> target (HTMLElement): The event target element.
// Outputs -> (Boolean): True if target is an <input type="checkbox">.
function fIsCheckboxClick(target) {
    return target.tagName === 'INPUT' && target.type === 'checkbox';
} // END fIsCheckboxClick




// fIsEditableCell /////////////////////////////////////////////////////////////////
// Purpose -> Helper to check if a cell element is contentEditable.
// Inputs  -> cellDiv (HTMLElement): The cell div element.
// Outputs -> (Boolean): True if the cell has the contentEditable attribute set to true.
function fIsEditableCell(cellDiv) {
    // Use optional chaining in case cellDiv is null/undefined
    return cellDiv?.isContentEditable;
} // END fIsEditableCell




// fIsUrlLinkCell //////////////////////////////////////////////////////////////////
// Purpose -> Helper to check if a cell element has the 'url-link' class.
// Inputs  -> cellDiv (HTMLElement): The cell div element.
// Outputs -> (Boolean): True if the cell has the 'url-link' class.
function fIsUrlLinkCell(cellDiv) {
    // Use optional chaining
    return cellDiv?.classList.contains('url-link');
} // END fIsUrlLinkCell




// fHandleDriveLink ////////////////////////////////////////////////////////////////
// Purpose -> Opens Google Drive file links in a new browser tab.
// Inputs  -> url (String): The Google Drive URL.
// Outputs -> None (Opens a new tab).
function fHandleDriveLink(url) {
    fMyConsoleLog(`🖱️ Opening Drive Link in new tab: ${url.substring(0, 100)}...`);
    window.open(url, '_blank');
} // END fHandleDriveLink




// fHandleImageModal ///////////////////////////////////////////////////////////////
// Purpose -> Handles clicks on standard image links (not Drive links) by showing
//            the image in the modal using fShowImageTab.
// Inputs  -> imageUrl (String): The direct URL of the image.
// Outputs -> None (Calls fShowImageTab).
function fHandleImageModal(imageUrl) {
    fMyConsoleLog(`🖱️ Clicked Standard Image Link: ${imageUrl.substring(0, 100)}...`);
    fShowImageTab(imageUrl);
} // END fHandleImageModal




// fShowImageTab ///////////////////////////////////////////////////////////////////
// Purpose -> Displays the image modal with the specified image URL.
// Inputs  -> imageUrl (String): The direct URL of the image to display.
// Outputs -> None (Modifies modal DOM elements).
function fShowImageTab(imageUrl) {
    // console.log("--- fShowImageTab Start ---");
    // console.log(" Image URL:", imageUrl);

    // Validate modal elements are cached
    if (!gUI.modalElement || !gUI.modalImageElement) {
        console.error("Cannot show modal: Modal elements not found in globals.");
        return;
    }
    // console.log("Modal elements found.");
    fMyConsoleLog(`🖼️ Showing image: ${imageUrl.substring(0, 100)}...`);

    // Set the image source
    // console.log("Setting image src...");
    gUI.modalImageElement.src = imageUrl;

    // Display the modal
    // console.log("Setting modal display to flex...");
    gUI.modalElement.style.display = 'flex';
    // console.log("--- fShowImageTab End ---");

} // END fShowImageTab




// fHandleWebLink //////////////////////////////////////////////////////////////////
// Purpose -> Opens non-image, non-Drive web links in a new browser tab.
// Inputs  -> url (String): The web URL.
// Outputs -> None (Opens a new tab).
function fHandleWebLink(url) {
    fMyConsoleLog(`🖱️ Clicked Web Link: ${url.substring(0, 100)}...`);
    window.open(url, '_blank');
} // END fHandleWebLink




// fHandleUrlClick /////////////////////////////////////////////////////////////////
// Purpose -> Determines the type of URL link clicked (Drive, Image, other Web)
//            and routes to the appropriate handler function.
// Inputs  -> cellDiv (HTMLElement): The cell div element that was clicked.
// Outputs -> None (Calls specific URL handler).
function fHandleUrlClick(cellDiv) {
    const originalUrl = cellDiv.dataset.url; // Get URL from data attribute

    // Validate URL exists
    if (!originalUrl) {
        console.warn("Clicked URL link cell, but data-url attribute was missing.", cellDiv);
        return;
    }

    // Determine URL type
    const isDrive = originalUrl.includes('drive.google.com/file/d/');
    const isImage = cellDiv.classList.contains('image-link') && !isDrive;
    const imageUrl = cellDiv.dataset.imageSrc; // Get potential image source

    // Route to handler
    if (isDrive) {
        fHandleDriveLink(originalUrl);
    } else if (isImage && imageUrl) {
        fHandleImageModal(imageUrl);
    } else {
        fHandleWebLink(originalUrl); // Fallback for other web links
    }
} // END fHandleUrlClick




// fHandleGridCellEdit /////////////////////////////////////////////////////////////
// Purpose -> Handles the 'blur' event delegated from the grid for contenteditable cells.
//            Updates the underlying data model (gUI.arr) if the cell's text content
//            has changed since it gained focus. Calls fCalcGearLine for specific gear columns.
// Inputs  -> event (FocusEvent): The blur event object.
// Outputs -> None (Modifies gUI.arr, potentially triggers calculations and auto-save).
async function fHandleGridCellEdit(event) { // <<< MADE ASYNC
    const cellDiv = event.target;

    // === 1. Validate Target Element ===
    if (!cellDiv || !cellDiv.classList.contains('cell') || cellDiv.contentEditable !== 'true') {
        return; // Exit if not an editable cell div
    }

    // === 2. Get Coordinates and Values ===
    const r = parseInt(cellDiv.dataset.r, 10);
    const c = parseInt(cellDiv.dataset.c, 10);

    if (isNaN(r) || isNaN(c) || r < 0 || c < 0 || !gUI.arr[r]) {
         console.warn("fHandleGridCellEdit: Invalid row/column index from data attributes.", cellDiv.dataset);
         return;
    }

    const newValue = cellDiv.textContent;
    const oldValue = String(gUI.arr[r][c] ?? ''); // Coerce old value to string for comparison

    // === 3. Check if Value Changed ===
    if (newValue === oldValue) {
        // fMyConsoleLog(`Cell [${r}, ${c}] content unchanged.`); // Can be noisy
        return; // Exit if content hasn't changed
    }

    // === 4. Identify Edited Column & Handle Gear Calculations ===
    const gearColumnsToCalculate = ['PossNum', 'PossWorn', 'PossPerOff'];
    const editedColTag = Object.keys(gUI.colTag).find(tag => gUI.colTag[tag] === c);
    let finalValueToStore = newValue; // Default to the raw new value
    let shouldUpdateModel = true; // Assume update is needed initially

    if (gearColumnsToCalculate.includes(editedColTag)) {
        fMyConsoleLog(`   -> Edit in gear calculation column: ${editedColTag} [${r}, ${c}]`);
        // Call the calculation function, passing OLD value for potential revert
        const validatedValue = await fCalcGearLine(r, c, newValue, oldValue);

        if (validatedValue !== null) {
            // fCalcGearLine succeeded and returned the validated value
            finalValueToStore = validatedValue;
            fMyConsoleLog(`   -> fCalcGearLine successful for [${r}, ${c}]. Value to store: "${finalValueToStore}"`);
        } else {
            // fCalcGearLine failed validation or encountered an error
            fMyConsoleLog(`   -> fCalcGearLine failed for [${r}, ${c}]. NOT updating data model for this cell.`);
            shouldUpdateModel = false; // Prevent gUI.arr update
            // fCalcGearLine should have reverted the DOM cell already
        }
    } else {
         fMyConsoleLog(`   -> Edit in standard column: ${editedColTag || 'Unknown'} [${r}, ${c}]`);
         // No special calculation needed for other columns
    }

    // === 5. Update Data Model & Trigger Save (if appropriate) ===
    if (shouldUpdateModel) {
        // Check again if the final value is actually different from the original model value
        // (e.g., fCalcGearLine might return a coerced boolean that matches the original)
        if (gUI.arr[r][c] !== finalValueToStore) {
            gUI.arr[r][c] = finalValueToStore; // Update the data model
            fMyConsoleLog(`   -> Data model gUI.arr[${r}][${c}] updated to: "${finalValueToStore}"`);
            fHandleAutoSaveTextToFirestore(); // Trigger auto-save
        } else {
             fMyConsoleLog(`   -> Data model gUI.arr[${r}][${c}] already matches final value. No update needed.`);
        }
    }

} // END fHandleGridCellEdit




// fDoesObjectHaveR1C1R2C2Properties /////////////////////////////////////////////////////////////
// Purpose -> Checks if a given object has the required properties (r1, c1, r2, c2)
//            to be considered a valid range definition object.
// Inputs  -> range (Object): The object to check.
// Outputs -> (Boolean): True if the object is a valid range definition, false otherwise.
function fDoesObjectHaveR1C1R2C2Properties(range) {
    return range &&
        typeof range.r1 !== 'undefined' &&
        typeof range.c1 !== 'undefined' &&
        typeof range.r2 !== 'undefined' &&
        typeof range.c2 !== 'undefined';
} // END fDoesObjectHaveR1C1R2C2Properties




// fConvertsR1C1R2C2TagOrNumToIndices ////////////////////////////////////////////////////////////
// Purpose -> Converts tag strings or numeric indices within a range definition
//            object into resolved 0-based numeric indices using fResolveRow/fResolveCol.
// Inputs  -> range (Object): The range definition object {r1, c1, r2, c2}.
// Outputs -> (Object): An object {r1, c1, r2, c2} with resolved numeric indices (or NaN).
function fConvertsR1C1R2C2TagOrNumToIndices(range) {
    const r1 = fResolveRow(range.r1);
    const c1 = fResolveCol(range.c1);
    const r2 = fResolveRow(range.r2);
    const c2 = fResolveCol(range.c2);
    return { r1, c1, r2, c2 };
} // END fConvertsR1C1R2C2TagOrNumToIndices




// fCloseAllDropdowns //////////////////////////////////////////////////////////////
// Purpose -> Finds all open menu dropdown panels (elements with class
//            'dropdown-content' and 'show') and removes the 'show' class to hide them.
//            Also resets overflow style on parent main dropdowns.
// Inputs  -> None (Queries DOM).
// Outputs -> None (Modifies DOM element classLists and styles).
function fCloseAllDropdowns() {
  const dropdowns = document.getElementsByClassName("dropdown-content");

  for (let i = 0; i < dropdowns.length; i++) {
    const panel = dropdowns[i];
    // Remove 'show' class to hide the panel
    panel.classList.remove('show');

    // Reset parent's overflow style if it's a main dropdown being closed
    // This prevents submenus from being permanently clipped if closed via window click
    if (!panel.classList.contains('sub-menu') && panel.style.overflowY === 'visible') {
        panel.style.overflowY = 'auto';
    }
  }
} // END fCloseAllDropdowns







// ==========================================================================
// === Sidebar                       (End of Read Write Cell & Range) ===
// ==========================================================================




// fPostToSidebar ///////////////////////////////////////////////////////////////
// Purpose -> Prepends a message (HTML) as a new paragraph (<p>) to the sidebar
//            content area (#sidebar-content). Also adds a plain text version to
//            gUI.plainTextLogEntries for GMScreen updates.
// Inputs  -> htmlMessage (String): The HTML content to prepend to the sidebar display.
//         -> plainTextMessage (String): The plain text version to add to the log array.
// Outputs -> None (Modifies DOM and gUI.plainTextLogEntries).
function fPostToSidebar(htmlMessage, plainTextMessage = null) {
    const sidebarContent = document.getElementById('sidebar-content');
    // Validate sidebar element
    if (!sidebarContent) {
        console.error("fPostToSidebar: Cannot find sidebar content element (#sidebar-content).");
        return;
    }

    // --- Handle DOM Update ---
    // Remove initial placeholder paragraph if it exists
    const placeholder = sidebarContent.querySelector('p');
    if (placeholder && placeholder.textContent === 'Roll log entries will appear here...') {
        placeholder.remove();
    }

    // Create and prepend the new HTML entry
    const newEntry = document.createElement('p');
    newEntry.innerHTML = htmlMessage; // Use innerHTML to render HTML tags
    sidebarContent.prepend(newEntry);
    // Scroll the sidebar content area to the top to show the latest entry
    sidebarContent.scrollTop = 0;

    // --- Handle Plain Text Log Array Update ---
    // If plainTextMessage wasn't provided, attempt to derive it from htmlMessage
    // This is a basic fallback - ideally plain text should always be generated alongside HTML
    const textToLog = (plainTextMessage !== null)
                      ? plainTextMessage
                      : htmlMessage.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]+>/g, '').trim(); // Basic strip tags and convert <br>

    // Push the plain text version to the log array
    gUI.plainTextLogEntries.push(textToLog);

    // Save Turbo text to Firestore
    fHandleAutoSaveTextToFirestore();

    // --- Optional: Immediate GMScreen Update (Consider using throttle/debounce if called too often) ---
    // fSendLogToGMScreenAndPS(); // Direct call - we'll add calls at end-of-action instead

} // END fPostToSidebar




// fShowSidebar ////////////////////////////////////////////////////////////////////
// Purpose -> Makes the Roll Log sidebar visible by adding the 'show' class.
// Inputs  -> None.
// Outputs -> None (Modifies sidebar element's classList).
function fShowSidebar() {
    const sidebar = document.getElementById('roll-log-sidebar');

    // Add 'show' class only if the sidebar exists and isn't already shown
    if (sidebar && !sidebar.classList.contains('show')) {
        sidebar.classList.add('show');
        fMyConsoleLog("▶️ Sidebar Shown");
    } else if (!sidebar) {
        console.error("fShowSidebar: Cannot find sidebar element (#roll-log-sidebar).");
    }
    // else: Sidebar exists and is already shown, do nothing.
} // END fShowSidebar




// fHideSidebar ////////////////////////////////////////////////////////////////////
// Purpose -> Hides the Roll Log sidebar by removing the 'show' class.
// Inputs  -> None.
// Outputs -> None (Modifies sidebar element's classList).
function fHideSidebar() {
    const sidebar = document.getElementById('roll-log-sidebar');

    // Remove 'show' class only if the sidebar exists and is currently shown
    if (sidebar && sidebar.classList.contains('show')) {
        sidebar.classList.remove('show');
        fMyConsoleLog("◀️ Sidebar Hidden");
    } else if (!sidebar) {
        console.error("fHideSidebar: Cannot find sidebar element (#roll-log-sidebar).");
    }
    // else: Sidebar exists and is already hidden, or doesn't exist, do nothing.
} // END fHideSidebar




// fHandleApplyWoundsClick ///////////////////////////////////////////////////////
// Purpose -> Handles clicks on the dynamically added "Apply" wounds button in the
//            sidebar. Reads the wound amount from the button's data attribute,
//            adds it to the current 1st Degree Wounds cell ('VitTbl', 'vit1st'),
//            updates the grid, recalculates Vit Now/Percent, and disables the button.
// Inputs  -> event (MouseEvent): The click event object.
// Outputs -> None (Modifies grid data/DOM via helpers, updates button state).
async function fHandleApplyWoundsClick(event) {
    const button = event.target; // The element that was actually clicked

    // === Validate Button and State ===
    if (!button || !button.classList.contains('apply-wounds-btn')) {
        return; // Click was not on an apply button
    }
    fMyConsoleLog(`🖱️ Sidebar 'Apply Wounds' Button Clicked...`);

    // Prevent double-clicks
    if (button.disabled) {
        fMyConsoleLog("   -> Button already disabled. Ignoring click.");
        return;
    }
    button.disabled = true; // Disable immediately
    button.textContent = 'Applied'; // Change button text

    // === Get Wound Amount ===
    const woundAmountStr = button.dataset.woundAmount;
    const woundAmount = Number(woundAmountStr); // Get amount from data attribute
    if (isNaN(woundAmount) || woundAmount < 0) { // Validate amount
        console.error(`Invalid wound amount stored on button: ${woundAmountStr}`);
        fMyConsoleLog(`❌ Error applying wounds: Invalid amount '${woundAmountStr}'.`);
        await fShowMessage("Error: Could not read a valid wound amount from the button.");
        // Keep button disabled on error? Or re-enable? Currently keeps disabled.
        return;
    }
    fMyConsoleLog(`   -> Wound Amount to Apply: ${woundAmount}`);

    // === Get Current Wounds ===
    const targetRow = 'VitTbl';
    const targetCol = 'vit1st';
    let currentVit1st = fGetGridValue(targetRow, targetCol, true); // Get as number
    if (isNaN(currentVit1st)) {
        fMyConsoleLog(`   -> Warning: Current value in ('${targetRow}', '${targetCol}') is not a number. Treating as 0.`);
        currentVit1st = 0; // Default to 0 if current value is invalid/empty
    }
    fMyConsoleLog(`   -> Current 1st Degree Wounds: ${currentVit1st}`);

    // === Calculate and Update Grid ===
    const newWoundValue = Math.round(currentVit1st + woundAmount); // Apply wounds
    fMyConsoleLog(`   -> Calculated New 1st Degree Wounds: ${newWoundValue}`);

    if (!fSetGridValue(targetRow, targetCol, newWoundValue)) {
        fMyConsoleLog(`❌ Error applying wounds: fSetGridValue failed for ('${targetRow}', '${targetCol}').`);
        await fShowMessage("Error: Failed to update the 1st Degree Wounds cell.");
        // Button remains disabled here as well.
        return;
    }

    // === Update Dependent Cells ===
    fMyConsoleLog("   -> Recalculating Vit Now & Percent...");
    await fVitNowNPercent_Calc(); // Update Vit Now and Vit Now Percent cells

    // Post text to Firestore
    fHandleAutoSaveTextToFirestore();

    fMyConsoleLog("✅ Wounds Applied Successfully.");
} // END fHandleApplyWoundsClick




// fSetupSidebarActionListeners //////////////////////////////////////////////////
// Purpose -> Sets up a delegated event listener on the sidebar content area
//            (#sidebar-content) to handle clicks on interactive elements within it,
//            such as 'Apply Wounds', 'Prep AR', and 'Prep Dmg' buttons.
// Inputs  -> None.
// Outputs -> None (Attaches event listener).
function fSetupSidebarActionListeners() {
    fMyConsoleLog("🖱️ Setting up Sidebar Action Listeners...");
    const sidebarContent = document.getElementById('sidebar-content');

    // Validate sidebar content element exists
    if (!sidebarContent) {
        console.error("fSetupSidebarActionListeners: Cannot setup listeners - #sidebar-content element not found.");
        fMyConsoleLog("⚠️ Sidebar Action Listeners NOT Attached (content area missing).");
        return;
    }

    // Add single delegated listener to the content area
    sidebarContent.addEventListener('click', (event) => {
        const target = event.target; // The actual element clicked

        // Route click based on button class
        if (target.classList.contains('apply-wounds-btn')) {
            fHandleApplyWoundsClick(event); // Handle 'Apply Wounds'
        } else if (target.classList.contains('prep-ar-btn')) {
            fHandlePrepARClick(event);      // Handle 'Prep AR'
        } else if (target.classList.contains('prep-dmg-btn')) {
            fHandlePrepDmgClick(event);     // Handle 'Prep Dmg'
        }
        // Add other 'else if' blocks here for future interactive sidebar elements
    });

    fMyConsoleLog("✅ Sidebar Action Listeners Attached.");
} // END fSetupSidebarActionListeners



// ==========================================================================
// === Menu Bar Setup                 (End of Sidebar) ===
// ==========================================================================



// fSetupMenuButtonListeners ///////////////////////////////////////////////////////
// Purpose -> Adds click event listeners to the main menu bar buttons (Nish, Roll,
//            Free, Luck, Game, Gear). Defines the logic for each button click,
//            including complex precedence for the 'Roll' button (Chaos -> Ad-Hoc -> Ability).
// Inputs  -> btnNish, btnRoll, btnFree, btnLuck, btnGame, dropdownGame, btnGear, dropdownGear (HTMLElements)
// Outputs -> None (Attaches event listeners).
function fSetupMenuButtonListeners(btnNish, btnRoll, btnFree, btnLuck, btnGame, dropdownGame, btnGear, dropdownGear) {

    // === Nish Button Listener ===
    btnNish.addEventListener('click', fHandleNishButtonClick);

    // === Roll Button Listener ===
    btnRoll.addEventListener('click', async (event) => {
        event.stopPropagation(); // Prevent event from bubbling up
        fCloseAllDropdowns();    // Ensure menus are closed
        fSetButtonOrMenuState('Roll'); // Set initial state for this action chain

        const { r: lastClickR, c: lastClickC } = gUI.cellClickInfo; // Coords of last grid cell click
        const { r: checked_r, c: checked_c } = gUI.currentSkRadioChecked; // Coords of currently checked Sk radio
        let handled = false; // Flag to track if an action was taken
        let currentCellTextForAdHoc = null; // Store cell text if needed for ad-hoc

        // --- Action Precedence ---
        // 1. Check for Chaos Gem click first
        if (lastClickR !== null && lastClickC !== null) {
            fMyConsoleLog(`   -> <Roll> Click: Checking Chaos Gem for last clicked cell [${lastClickR}, ${lastClickC}]...`);
            handled = await fHandleChaosGemClick(lastClickR, lastClickC);
            if (handled) {
                fMyConsoleLog("   -> <Roll> Click: Chaos Gem action completed.");
            }
        } else {
            fMyConsoleLog("   -> <Roll> Click: No previous cell click info for Chaos Gem check.");
        }

        // 2. If not Chaos, check for Ad-Hoc roll (if click was outside restricted areas)
        if (!handled && lastClickR !== null && lastClickC !== null) {
            fMyConsoleLog("   -> <Roll> Click: No Chaos Gem used. Checking for Ad-Hoc roll eligibility...");
            const chaosRangeArray = gUI.range?.chaosGems ? [gUI.range.chaosGems] : [];
            const abilityRangeArray = gUI.range?.entireAbiliyNGearTables || [];
            const isChaosCell = fIsCellInRangeArray(lastClickR, lastClickC, chaosRangeArray);
            const isAbilityCell = fIsCellInRangeArray(lastClickR, lastClickC, abilityRangeArray);

            // Only attempt ad-hoc if click was NOT in Chaos or Ability/Gear tables
            if (!isChaosCell && !isAbilityCell) {
                fMyConsoleLog(`   -> Click [${lastClickR}, ${lastClickC}] is outside Chaos/Ability tables. Attempting ad-hoc parse...`);
                // Read current text directly from DOM cell
                const cellElement = gUI.grid2D?.[lastClickR]?.[lastClickC];
                if (cellElement) {
                    currentCellTextForAdHoc = cellElement.textContent?.trim() ?? '';
                    gUI.cellClickInfo.focusText = currentCellTextForAdHoc; // Store for potential error message
                    fMyConsoleLog(`      -> Read current text: "${currentCellTextForAdHoc}", stored in focusText.`);
                    handled = await fHandleAdHocRoll(currentCellTextForAdHoc); // Attempt the roll
                } else {
                    fMyConsoleLog(`      -> Could not find cell element [${lastClickR}, ${lastClickC}] to read current text.`);
                    gUI.cellClickInfo.focusText = null; // Clear if element not found
                }

                if (handled) {
                    fMyConsoleLog("    -> <Roll> Click: Ad-Hoc roll completed.");
                } else {
                    fMyConsoleLog("   -> <Roll> Click: Ad-Hoc roll pattern not found in cell text.");
                }
            } else {
                fMyConsoleLog(`   -> Click [${lastClickR}, ${lastClickC}] is inside restricted Chaos/Ability table. Skipping ad-hoc roll.`);
                gUI.cellClickInfo.focusText = null; // Clear if not applicable
            }
        } else if (!handled) {
            // Log if ad-hoc wasn't checked due to missing click info
            fMyConsoleLog("   -> <Roll> Click: No last cell click info for ad-hoc roll check.");
            gUI.cellClickInfo.focusText = null;
        } else {
            // Clear focusText if Chaos Gem handled the click
            gUI.cellClickInfo.focusText = null;
        }

        // 3. If not Chaos or Ad-Hoc, check for standard Ability roll (Sk checkbox checked)
        if (!handled && checked_r !== null) {
            fMyConsoleLog(`   -> <Roll> Click: No Chaos/Ad-Hoc handled. Active Sk checkbox [${checked_r}, ${checked_c}] found. Triggering standard roll action...`);
            await fMain_AbilityRoll(); // Call the main ability roll handler
            handled = true; // Mark as handled
        } else if (!handled && checked_r === null) {
            fMyConsoleLog("   -> <Roll> Click: No Chaos/Ad-Hoc handled and no Ability checkbox checked.");
        }

        // 4. Show Message if Nothing Was Handled
        if (!handled) {
            fMyConsoleLog("   -> <Roll> Click: No Chaos Gem, Ad-Hoc Roll, or Ability Checkbox action taken.");
            let adHocAttemptedButFailed = (gUI.cellClickInfo.focusText !== null); // Ad-hoc was attempted if focusText was set

            if (adHocAttemptedButFailed) {
                await fShowMessage(`Nothing rollable found in cell "${gUI.cellClickInfo.focusText || ''}"`);
            } else {
                await fShowMessage("Click an Ability checkbox, a usable Chaos Crystal, or a cell with dice notation (e.g., d6, sk20) first!");
            }
            fSetButtonOrMenuState(null); // Reset button state if nothing handled
        } else {
            // If handled by Chaos or Ad-Hoc, reset state immediately.
            // If handled by Ability roll, state reset happens within fMain_AbilityRoll.
            const wasAbilityRoll = (checked_r !== null);
            if (!wasAbilityRoll) {
                fSetButtonOrMenuState(null);
            }
        }
    }); // END Roll Button Listener

    // === Free Button Listener ===
    btnFree.addEventListener('click', (event) => {
        event.stopPropagation();
        fCloseAllDropdowns();
        fSetButtonOrMenuState('Free'); // Set state
        fMain_AbilityRoll();       // Trigger main roll handler
    });

    // === Luck Button Listener ===
    btnLuck.addEventListener('click', (event) => {
        event.stopPropagation();
        fCloseAllDropdowns();
        fSetButtonOrMenuState('Luck'); // Set state
        fMain_AbilityRoll();       // Trigger main roll handler
    });

    // === Game Menu Button Listener ===
    btnGame.addEventListener('click', (event) => {
        event.stopPropagation(); // Prevent window click listener from closing immediately
        const currentlyShown = dropdownGame.classList.contains('show');
        fCloseAllDropdowns(); // Close any other open menus
        // Toggle the Game dropdown
        if (!currentlyShown) {
            dropdownGame.classList.add('show');
        }
    });

    // === Gear Menu Button Listener ===
    btnGear.addEventListener('click', (event) => {
        event.stopPropagation(); // Prevent window click listener from closing immediately
        const currentlyShown = dropdownGear.classList.contains('show');
        fCloseAllDropdowns(); // Close any other open menus
        // Toggle the Gear dropdown
        if (!currentlyShown) {
            dropdownGear.classList.add('show');
        }
    });

} // END fSetupMenuButtonListeners




// fSetButtonOrMenuState ///////////////////////////////////////////////////////////
// Purpose -> Sets the state flags within gUI.buttonOrMenu (isNish, isRoll, etc.)
//            to indicate which button/menu item initiated the current roll action.
//            Resets all flags to false before setting the specified one.
// Inputs  -> buttonType (String | null): Type name ('Nish', 'Roll', 'Free', 'Luck')
//                                         or null to reset all flags.
// Outputs -> None (Modifies gUI.buttonOrMenu).
function fSetButtonOrMenuState(buttonType) {
    // Map input type string to the corresponding property name in gUI.buttonOrMenu
    const validTypes = {
        'Nish': 'isNish',
        'Roll': 'isRoll',
        'Free': 'isFree',
        'Luck': 'isLuck'
        // Add other mappings here if needed later
    };

    // Reset all flags to false initially
    for (const key in gUI.buttonOrMenu) {
        if (Object.hasOwnProperty.call(gUI.buttonOrMenu, key)) {
            gUI.buttonOrMenu[key] = false;
        }
    }

    // Set the specific flag to true if a valid type is provided
    if (buttonType && validTypes[buttonType]) {
        const flagToSet = validTypes[buttonType];
        gUI.buttonOrMenu[flagToSet] = true;
        fMyConsoleLog(`🚦 Button/Menu State Set: ${flagToSet} = true`);
    } else if (buttonType === null) {
        // If buttonType is null, reset is intended (already done)
        fMyConsoleLog("🚦 Button/Menu State Reset (all flags false).");
    } else {
        // Log warning if an invalid type string was passed
        console.warn(`fSetButtonOrMenuState: Invalid buttonType provided: ${buttonType}`);
        fMyConsoleLog(`🚦 Button/Menu State: Invalid type '${buttonType}', all flags remain false.`);
    }

} // END fSetButtonOrMenuState




// fSetupWindowClickListener ///////////////////////////////////////////////////////
// Purpose -> Adds a global click listener to the window. If a click occurs outside
//            of the main menu bar buttons or dropdown menu items, it closes all
//            currently open dropdown menus by calling fCloseAllDropdowns.
// Inputs  -> None.
// Outputs -> None (Attaches event listener).
function fSetupWindowClickListener() {
    window.addEventListener('click', (event) => {
        // Check if the click target is outside the menu bar buttons and dropdown items
        if (event.target && !event.target.closest('.menu-item') && !event.target.closest('#menu-bar > button')) {
            // If click is outside, close all dropdowns
            fCloseAllDropdowns();
        }
    });
} // END fSetupWindowClickListener




// fSetupSubMenuHover //////////////////////////////////////////////////////////////
// Purpose -> Sets up hover event listeners for all submenu items within a given
//            menu bar to handle showing/hiding nested dropdown menus with delays.
// Inputs  -> menuBar (HTMLElement): The main menu bar container element.
// Outputs -> None (Attaches event listeners via fSetupSingleSubMenuItem).
function fSetupSubMenuHover(menuBar) {
    if (!menuBar) return;

    // Find all elements that represent items containing submenus
    const subMenuItems = menuBar.querySelectorAll('.sub-menu-item');

    // Attach hover logic to each submenu item found
    subMenuItems.forEach((item, index) => {
        fSetupSingleSubMenuItem(item, index);
    });
} // END fSetupSubMenuHover



// fClearSubMenuHideTimeout ///////////////////////////////////////////////////////////////
// Purpose -> Clears any active 'hide' timeout associated with a submenu panel.
//            Reads the timeout ID from the panel's dataset.
// Inputs  -> panel (HTMLElement): The submenu panel element.
// Outputs -> None (Clears timeout, modifies panel's dataset).
function fClearSubMenuHideTimeout(panel) {
    // Get timeout ID stored on the element, default to 0 if not found/invalid
    const timeoutId = parseInt(panel.dataset.hideTimeoutId || '0');

    // If a valid timeout ID exists, clear it and remove from dataset
    if (timeoutId) {
        clearTimeout(timeoutId);
        panel.dataset.hideTimeoutId = ''; // Reset dataset property
    }
} // END fClearSubMenuHideTimeout




// fIsAnySiblingSubmenuOpen ////////////////////////////////////////////////////////
// Purpose -> Checks if any sibling submenu items (relative to the provided item)
//            currently have their submenu panels open (i.e., contain the 'show' class).
// Inputs  -> item (HTMLElement): The reference submenu item element.
// Outputs -> (Boolean): True if any sibling submenu is open, false otherwise.
function fIsAnySiblingSubmenuOpen(item) {
    const parent = item.parentElement; // Get the container of the submenus
    if (!parent) return false; // Cannot check siblings if no parent

    // Get all sibling elements that are also submenu items
    const siblings = Array.from(parent.children).filter(el =>
        el !== item && el.classList.contains('sub-menu-item')
    );

    // Check if any sibling has a submenu panel with the 'show' class
    return siblings.some(sibling => {
        const siblingPanel = sibling.querySelector('.dropdown-content.sub-menu');
        return siblingPanel && siblingPanel.classList.contains('show');
    });
} // END fIsAnySiblingSubmenuOpen




// fStartSubMenuHideTimeout ///////////////////////////////////////////////////////////////
// Purpose -> Sets a timeout (default 250ms) to hide a submenu panel. Before hiding,
//            checks if the parent dropdown's overflow style needs to be restored
//            (only if no other sibling submenus are currently open).
// Inputs  -> item (HTMLElement): The submenu item element.
//         -> panel (HTMLElement): The submenu panel element to hide.
//         -> mainDropdown (HTMLElement | null): The parent dropdown panel element.
//         -> delayMs (Number): Delay in milliseconds before hiding (default 250).
// Outputs -> None (Sets timeout, potentially modifies mainDropdown style, modifies panel classList).
function fStartSubMenuHideTimeout(item, panel, mainDropdown, delayMs = 250) {
    // Clear any previously set hide timeout for this panel
    fClearSubMenuHideTimeout(panel);

    // Set a new timeout to hide the panel
    const timeoutId = setTimeout(() => {
        // Before hiding, check if parent overflow needs resetting
        // (Avoids clipping if mouse moves quickly between sibling submenus)
        if (mainDropdown && !fIsAnySiblingSubmenuOpen(item)) {
            mainDropdown.style.overflowY = 'auto'; // Restore default overflow
        }
        // Hide the panel by removing the 'show' class
        panel.classList.remove('show');
    }, delayMs); // Use the specified delay

    // Store the timeout ID on the panel element's dataset
    panel.dataset.hideTimeoutId = timeoutId;
} // END fStartSubMenuHideTimeout




// fSetupSingleSubMenuItem /////////////////////////////////////////////////////////
// Purpose -> Attaches mouseenter/mouseleave event listeners to a single submenu item
//            and its corresponding submenu panel to manage showing/hiding with delays.
// Inputs  -> item (HTMLElement): The submenu item element (.sub-menu-item).
//         -> index (Number): Index (for logging/debugging purposes).
// Outputs -> None (Attaches event listeners).
function fSetupSingleSubMenuItem(item, index) {
    // === Get Element References ===
    const triggerLink = item.querySelector('a'); // Link that triggers the submenu
    const subMenuPanel = item.querySelector('.dropdown-content.sub-menu'); // The submenu panel itself
    const mainDropdown = item.closest('.dropdown-content:not(.sub-menu)'); // The parent dropdown panel

    // Exit if no submenu panel exists for this item
    if (!subMenuPanel) return;

    // Warn if the parent dropdown wasn't found (indicates potential structure issue)
    if (!mainDropdown && triggerLink) {
        console.warn(`fSetupSingleSubMenuItem Item ${index} (${triggerLink?.textContent}): Could not find parent main dropdown!`);
    }

    // === Attach Event Listeners ===

    // --- Mouse Enter Item ---
    // Show submenu immediately, clear hide timer, ensure parent allows overflow
    item.addEventListener('mouseenter', () => {
        fClearSubMenuHideTimeout(subMenuPanel);
        if (mainDropdown) mainDropdown.style.overflowY = 'visible'; // Allow overflow
        subMenuPanel.classList.add('show');
    });

    // --- Mouse Leave Item ---
    // Start timer to hide the submenu
    item.addEventListener('mouseleave', () => {
        fStartSubMenuHideTimeout(item, subMenuPanel, mainDropdown);
    });

    // --- Mouse Enter Submenu Panel ---
    // If mouse moves directly onto the submenu panel, keep it open (clear hide timer)
    subMenuPanel.addEventListener('mouseenter', () => {
        fClearSubMenuHideTimeout(subMenuPanel);
    });

    // --- Mouse Leave Submenu Panel ---
    // If mouse leaves the submenu panel itself, start timer to hide it
    subMenuPanel.addEventListener('mouseleave', () => {
        fStartSubMenuHideTimeout(item, subMenuPanel, mainDropdown);
    });
} // END fSetupSingleSubMenuItem




// fSendLogToGMScreenAndPS ////////////////////////////////////////////////////////////
// Purpose -> Sends bundled log and header data (dynamic + static) sequentially to
//            the GMScreen sheet ('db') and the PartyLog sheet ('ps') via the
//            server-side fSrvSaveURLtoNamesAndLogToDBandPS function. Uses a lock.
// Inputs  -> None (Uses gUI state: plainTextLogEntries, arr, characterInfo, isSendingLog).
// Outputs -> (Promise<Boolean>): Resolves with true if both writes succeeded, false otherwise.
//                                Rejects on critical validation errors before server call.
async function fSendLogToGMScreenAndPS() { // Made async to return a Promise implicitly via await
    // === 1. Check Lock ===
    if (gUI.isSendingLog) {
        fMyConsoleLog("📤 Log & Header send already in progress, skipping.");
        return false; // Indicate skip / potential failure due to lock
    }

    // === 1a. Validate Slot Number ===
    const slotNum = gUI.characterInfo?.slotNum;
    if (!slotNum || typeof slotNum !== 'string' || !slotNum.startsWith('Slot')) {
        const msg = `Cannot send Log & Headers: Invalid or missing slotNum ('${slotNum}').`;
        fMyConsoleLog(`📤 ${msg}`);
        // Consider if this should reject or just return false. Returning false for now.
        // Optionally show message: fShowMessage(msg).catch(e=>console.error(e));
        return false; // Indicate failure due to invalid slot
    }

    // === 2. Set Lock ===
    gUI.isSendingLog = true;
    fMyConsoleLog(`📤 Preparing to send Log & Header data for ${slotNum} (Lock Acquired)...`);

    // Wrap the core logic in a Promise
    return new Promise((resolve, reject) => {
        try {
            // === 3. Prepare Log Content ===
            const logEntriesSnapshot = [...gUI.plainTextLogEntries];
            const reversedLogEntries = logEntriesSnapshot.reverse();
            const combinedLog = reversedLogEntries.join('\n\n\n');
            const truncatedLog = combinedLog.substring(0, gUI.GMSCREEN_LOG_MAX_CHARS);
            fMyConsoleLog(`   -> Log Content Prepared (Entries: ${logEntriesSnapshot.length}, Length: ${truncatedLog.length})`);

            // === 4. Prepare Header Data ===
            const vitMax = fGetGridValue('VitTbl', 'vitMax') ?? '?';
            const vitNow = fGetGridValue('VitTbl', 'vitNow') ?? '?';
            const vitPercent = fGetGridValue('VitTbl', 'VitNowPercent') ?? '?%';
            const vitString = `${vitNow} of ${vitMax} (${vitPercent})`;
            const nishValue = fGetGridValue('Nish', 'Nish') ?? '';
            fMyConsoleLog(`   -> Dynamic Header Data: Vit='${vitString}', Nish='${nishValue}'`);
            const { raceClass, level, playerName, charName } = gUI.characterInfo || {};
            const playerCharString = `${playerName || '?'} (${charName || '?'})`;
            const characterUrl = "https://docs.google.com/spreadsheets/d/" + gIndex.CSID + "/";
            fMyConsoleLog(`   -> Static Header Data: URL='${characterUrl}', RaceClass='${raceClass}', Level='${level}', PlayerChar='${playerCharString}', Slot='${slotNum}'`);

            // === 5. Create Data Bundle ===
            const dataBundle = {
                log: truncatedLog,
                vit: vitString,
                nish: nishValue,
                url: characterUrl,
                raceClass: raceClass || '',
                level: level || '',
                playerChar: playerCharString,
                slotNum: slotNum
            };

            // === 6. Call Server Function ===
            fMyConsoleLog(`   -> Calling fSrvSaveURLtoNamesAndLogToDBandPS with bundled data...`);
            google.script.run
                .withSuccessHandler((success) => {
                    if (success) {
                        fMyConsoleLog("   -> ✅ Log & Headers updated successfully on server targets.");
                    } else {
                        fMyConsoleLog("   -> ⚠️ Log & Headers update partially failed on server. Check server logs.");
                        fShowMessage("Warning: Update failed for one or more target sheets.").catch(e => console.error("Error showing message:", e));
                    }
                    gUI.isSendingLog = false; // Release Lock
                    fMyConsoleLog("   -> Lock Released.");
                    resolve(success); // Resolve the promise with the success status
                })
                .withFailureHandler((error) => {
                    const errorMsg = error?.message || "Unknown server error";
                    console.error(`fSendLogToGMScreenAndPS Failure: ${errorMsg}`, error);
                    fMyConsoleLog(`   -> ❌ Error sending Log & Headers: ${errorMsg}`);
                    gUI.isSendingLog = false; // Release Lock
                    fMyConsoleLog("   -> Lock Released due to error.");
                    fShowMessage(`Error: Could not send updates: ${errorMsg}`).catch(e => console.error("Error showing message:", e));
                    resolve(false); // Resolve false on failure to allow sequence to continue if needed, or reject? Resolve false for now.
                })
                .fSrvSaveURLtoNamesAndLogToDBandPS(dataBundle);

        } catch (err) {
            // Catch synchronous errors during preparation
            console.error("Synchronous error in fSendLogToGMScreenAndPS preparation:", err);
            fMyConsoleLog(`   -> ❌ Synchronous error preparing log send: ${err.message}`);
            gUI.isSendingLog = false; // Release lock
            fMyConsoleLog("   -> Lock Released due to synchronous error.");
            reject(err); // Reject the promise on synchronous error
        }
    });

} // END fSendLogToGMScreenAndPS




// ==========================================================================
// === Menu Bar Click     (End of Menu Bar Setup)) ===
// ==========================================================================




// fSetupMenuActionClickListener //////////////////////////////////////////////
// Purpose -> Sets up a single event listener on the menu bar to handle clicks
//            on menu items using event delegation and data attributes.
// Inputs  -> menuBar (HTMLElement): The menu bar element (#menu-bar) is expected to exist.
// Outputs -> None. Attaches event listener.
function fSetupMenuActionClickListener() { // Removed menuBar parameter, gets element inside
    const menuBar = document.getElementById('menu-bar');
    if (!menuBar) {
        console.error("Setup failed: Menu bar (#menu-bar) not found.");
        fMyConsoleLog("❌ ERROR: Menu bar element not found for action listener setup."); // Added log
        return; // Stop if the menu bar isn't there
    }

    menuBar.addEventListener('click', (event) => {
        const target = event.target.closest('a[data-action]'); // Find the clicked link with a data-action
        if (!target) return; // Exit if the click wasn't on an action link

        event.preventDefault(); // Prevent default link behavior (like navigating)
        const action = target.dataset.action;
        fMyConsoleLog(`🎬 Menu Action Clicked: ${action}`);


        // Close any open dropdowns first
        fCloseAllDropdowns(); // Use the existing helper


        // --- Handle actions based on the data-action attribute ---
        switch (action) {
            // Game Menu Actions
            case 'game-nishStartEnd':       fHandleNishStartOrEnd(); break;
            case 'game-toggleSidebar':      fToggleSidebar(); break;
            case 'game-updateLevelSlotName': fHandleNewLevelSlotName(); break;
            case 'game-gmAward':            fHandleGMAward(); break;
            case 'game-metaFlood':          fMetaFlood(); break;
            case 'game-healingNatural':     fCalc_NaturalHealing(); break;
            case 'game-healingAll':         fHealAllWounds(); break;
            case 'game-restTimeRest':       fHandleRestTimeRest(); break;
            case 'game-restTimeSleep':      fHandleRestTimeSleep(); break;
            case 'game-restTimeNewSession': fHandleRestTimeNewSession(); break;
            case 'game-clearChanneled':     fClearChanneledMeta(); break;
            case 'game-clearCheckboxes':    fClearSk1Sk2Checkboxes(); break;
            case 'game-clearMonsters':      fClearMonsters(); break;
            case 'game-clearMorphs':        fClearMorphs(); break;
            case 'game-clearNish':          fClearCurrentNish(); break;
            case 'game-clearRollLog':       fClearRollLog(); break;
            case 'game-setMaxLuck':         fLuck_SetToMax(); break;
            case 'game-setMaxMeta':         fMeta_SetToMax(); break;
            case 'game-setMaxVit':          fCalc_VitMaxNowPerc(); break;
            case 'game-setMaxAll':          fHandleResetAllToMax(); break;

            // Gear Menu Actions
            case 'gear-toggleGear':         fToggleGearColumns(); break;
            case 'fLoot_RollRndTreasure':   fLoot_RollRndTreasure(); break;
            case 'fLoot_RollArtifact':      fLoot_RollArtifact(); break;
            case 'fLoot_ChaosCrystal':      fLoot_ChaosCrystal(); break;
            case 'fLoot_RollGear':          fLoot_RollGear(); break;
            case 'fLoot_RollSocketGem':     fLoot_RollSocketGem(); break;
            case 'fLoot_RollSockets':       fLoot_RollSockets(); break;
            case 'fLoot_RollValuables':     fLoot_RollValuables(); break;

            // Data Menu Actions
            case 'data-saveNow':            fHandleAutoSaveTextToFirestore(); break;
            case 'data-designerOnly':       fHandleDesignerOnlyClick(); break;

            // Designer Menu Actions
            case 'designer-saveDbSheetVer': fSaveGoogelSheetToFSData(); break;

            // Default case for unhandled actions
            default:
                fMyConsoleLog(`   -> WARNING: No handler defined for action: ${action}`);
                fShowMessage(`Action "${action}" is not yet implemented.`);
        }
    });

    fMyConsoleLog("✅ Delegated Menu Action Click Listener Attached.");
} // END fSetupMenuActionClickListener




// fHandleNishStartOrEnd ///////////////////////////////////////////////////////////
// Purpose -> Handles <Game><Nish Start or End> menu action. Runs Meta Flood,
//            clears channeled meta/durations, sets max AP, logs action, and sends update.
// Inputs  -> None.
// Outputs -> (Promise<void>): Resolves after completing actions.
async function fHandleNishStartOrEnd() {
    fMyConsoleLog("⚙️ Menu Action: Nish Start or End Triggered...");
    await fMetaFlood();          // Async - Logs own message
    fClearChanneledMeta();       // Sync
    await fAct_SetToMax();       // Async - No sidebar log
    fClearIsOnDurationRange();   // Sync

    // Log completion to sidebar (HTML and Plain Text)
    const sidebarMsgHtml = `🚩<span class="blue-bold">Nish Start or End</span>`;
    const sidebarMsgText = `🚩 Nish Start or End`;
    fPostToSidebar(sidebarMsgHtml, sidebarMsgText);
    fShowSidebar();

    fMyConsoleLog("✅ Nish Start or End Action Completed.");

    // Send log update to GMScreen (with slight delay)
    setTimeout(() => fSendLogToGMScreenAndPS(), 0); 

} // END fHandleNishStartOrEnd



// fClearIsOnDurationRange /////////////////////////////////////////////////////////
// Purpose -> Clears all cells within the 'Is On / Duration' ranges defined in
//            gUI.range.isONDur by setting their values to empty strings.
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM).
function fClearIsOnDurationRange() {
    fMyConsoleLog("⚙️ Clearing 'Is On/Duration' Range...");
    let allSucceeded = true;
    const rangesToClear = gUI.range?.isONDur; // Get the array of ranges

    // === Validate Configuration ===
    if (!Array.isArray(rangesToClear) || rangesToClear.length === 0) {
        console.warn("fClearIsOnDurationRange: No 'Is On/Duration' ranges defined in gUI.range.isONDur.");
        fMyConsoleLog("⚠️ Cannot clear 'Is On/Duration': Ranges not defined.");
        // Optional: fShowMessage("Error: 'Is On/Duration' ranges not defined.");
        return;
    }

    // === Clear Cells in Each Range ===
    rangesToClear.forEach(range => {
        // Validate the range object structure
        if (!fDoesObjectHaveR1C1R2C2Properties(range)) {
            console.warn("fClearIsOnDurationRange: Skipping invalid range object within gUI.range.isONDur:", range);
            allSucceeded = false;
            return; // Skip this invalid range
        }

        // Resolve range tags/indices
        const r1 = fResolveRow(range.r1);
        const c1 = fResolveCol(range.c1);
        const r2 = fResolveRow(range.r2);
        const c2 = fResolveCol(range.c2);

        // Validate resolved indices
        if ([r1, c1, r2, c2].some(isNaN)) {
            console.warn(`fClearIsOnDurationRange: Skipping invalid range definition:`, range);
            allSucceeded = false; // Mark failure
            return; // Skip this range
        }

        // Call fSetRangeOfGridValues to set all cells in the range to empty string
        const success = fSetRangeOfGridValues(r1, c1, r2, c2, ''); // Set value to empty string
        if (!success) {
            allSucceeded = false; // Track if any update fails
        }
    });

    // === Log Result ===
    if (!allSucceeded) {
        fMyConsoleLog("⚠️ Failed to clear one or more 'Is On/Duration' ranges.");
        // Optional: fShowMessage("Error clearing some 'Is On/Duration' cells.");
    } else {
        fMyConsoleLog("✅ 'Is On/Duration' Ranges Cleared.");
    }

} // END fClearIsOnDurationRange




// fToggleSidebar //////////////////////////////////////////////////////////////////
// Purpose -> Toggles the visibility of the Roll Log sidebar by calling either
//            fShowSidebar or fHideSidebar based on its current state.
// Inputs  -> None.
// Outputs -> None (Calls show/hide function).
function fToggleSidebar() {
    const sidebar = document.getElementById('roll-log-sidebar');

    // Validate sidebar element exists
    if (!sidebar) {
        console.error("fToggleSidebar: Cannot find sidebar element (#roll-log-sidebar) to toggle.");
        return;
    }

    // Check current visibility state
    const isVisible = sidebar.classList.contains('show');

    // Call the appropriate function to toggle state
    if (isVisible) {
        fHideSidebar();
    } else {
        fShowSidebar();
    }
} // END fToggleSidebar



// fHandleNewLevelSlotName ///////////////////////////////////////////////////////
// Purpose -> Handles the "Update (Level, Slot, Names)" menu action. Force-refreshes
//            user-specific caches (RaceClass, List, MyAbilities) from Sheets to
//            Firestore to gUI, validates the resulting slot number, sends an update
//            log, UPDATES ABILITY DROPDOWNS, and triggers a full grid refresh.
// Inputs  -> None.
// Outputs -> (Promise<void>): Resolves after completing actions or handling errors.
async function fHandleNewLevelSlotName() {
    const funcName = "fHandleNewLevelSlotName";
    fMyConsoleLog(`⚙️ Menu Action: ${funcName} Triggered...`);

    // === Show Initial Loading Message ===
    const updatingMsg = fShowMessage("⏳ Refreshing Caches, Sending Log & Updating Grid...<br><br>This may take a minute.<br><br>Do NOT Close unless program freezes.");

    try { // Wrap the entire sequence in a try block

        // === 1. Parallel Cache Refresh (Force Sheet->FS->gUI for user caches) ===
        const userCachesToRefresh = [
          { workbookAbr: 'MyCS', sheetName: 'RaceClass',    gUIKey: 'myCsRaceClassFSData' },
          { workbookAbr: 'MyCS', sheetName: 'List',         gUIKey: 'myCsListFSData' },
          { workbookAbr: 'MyKL', sheetName: 'MyAbilities',  gUIKey: 'myKlMyAbilitiesFSData' }
        ];
        const refreshPromises = userCachesToRefresh.map(config =>
            fRefreshAndCacheOneFSData(config.workbookAbr, config.sheetName, config.gUIKey)
        );
        fMyConsoleLog(`   -> Starting parallel refresh for ${userCachesToRefresh.length} user caches...`);
        const results = await Promise.allSettled(refreshPromises);
        fMyConsoleLog(`   -> Parallel cache refreshes completed.`);

        // === 2. Process Refresh Results ===
        let allRefreshesSucceeded = true;
        let firstErrorMessage = null;
        let failedCacheKey = null;

        for (let i = 0; i < results.length; i++) {
            const result = results[i];
            const config = userCachesToRefresh[i]; // Get corresponding config
            if (result.status === 'rejected') {
                allRefreshesSucceeded = false;
                failedCacheKey = config.gUIKey;
                firstErrorMessage = result.reason?.message || `Unknown error refreshing ${failedCacheKey}`;
                fMyConsoleLog(`      -> ❌ Refresh REJECTED for ${failedCacheKey}: ${firstErrorMessage}`);
                break; // Stop checking on first failure
            } else if (result.value === false) {
                 // fRefreshAndCacheOneFSData resolved but indicated failure
                allRefreshesSucceeded = false;
                failedCacheKey = config.gUIKey;
                // Note: fRefreshAndCacheOneFSData already showed a message in this case
                firstErrorMessage = `Refresh failed for ${failedCacheKey}. Check logs for details.`;
                fMyConsoleLog(`      -> ❌ Refresh FAILED (returned false) for ${failedCacheKey}.`);
                break; // Stop checking on first failure
            } else {
                 fMyConsoleLog(`      -> ✅ Refresh SUCCEEDED for ${config.gUIKey}.`);
            }
        }

        // Throw error if any refresh failed
        if (!allRefreshesSucceeded) {
            // Use a generic message if the specific one wasn't captured well
            throw new Error(firstErrorMessage || `One or more cache refreshes failed.`);
        }
        fMyConsoleLog(`   -> All user cache refreshes successful.`);

        // === 3. Update Ability Dropdowns === <<<--- ADDED STEP
        fMyConsoleLog("   -> Updating Ability Dropdowns based on refreshed List cache...");
        fProcessCachedAbilityList(); // Process new list and apply dropdowns
        fMyConsoleLog("      -> ✅ Ability Dropdowns updated.");

        // === 4. Slot Validation ===
        fMyConsoleLog("   -> Validating Slot Number from refreshed data...");
        const currentSlot = gUI.characterInfo?.slotNum;
        const slotRegex = /^Slot([1-9])$/i; // Expect "Slot#"

        if (!currentSlot || !slotRegex.test(currentSlot)) {
            const invalidSlotMsg = `Invalid or missing Slot # ("${currentSlot || 'null'}") found after cache refresh. Cannot send log or proceed.`;
            fMyConsoleLog(`      -> ❌ ${invalidSlotMsg}`);
            throw new Error(invalidSlotMsg);
        }
        fMyConsoleLog(`      -> Slot validated: ${currentSlot}`);

        // === 5. Send Log ===
        fMyConsoleLog("   -> Sending log update...");
        const logSendSuccess = await fSendLogToGMScreenAndPS();
        if (!logSendSuccess) {
            fMyConsoleLog("      -> ⚠️ Log send failed or was skipped. Continuing process...");
            // Do not throw error, continue to grid refresh
        } else {
             fMyConsoleLog("      -> ✅ Log send successful.");
        }

        // === 6. Refresh Grid Rows ===
        fMyConsoleLog("   -> Refreshing grid rows (Abilities/Gear)...");
        await fTotalRereshOfAllAbilitiesAndAllGear();
        fMyConsoleLog("      -> ✅ Grid row refresh complete.");

        // === 7. Final Success Message ===
        fHideMessage(); // Hide the initial "Updating..." message
        await fShowMessage("✅ Caches Refreshed, Log Sent & Grid Updated.");
        fMyConsoleLog(`✅ ${funcName} Completed Successfully.`);

    } catch (error) {
        // === Catch All Errors from the Sequence ===
        fHideMessage(); // Ensure loading message is hidden on error
        const errorMsg = `Error during Update (Level, Slot, Names): ${error?.message || error}`;
        console.error(errorMsg, error); // Log full error
        fMyConsoleLog(`   -> ❌ ${errorMsg}`);
        await fShowMessage(`❌ ${errorMsg}`); // Show the final error to the user
        // Implicitly returns undefined on error
    }

} // END fHandleNewLevelSlotName




// fHandleGMAward //////////////////////////////////////////////////////////////
// Purpose -> Handles the <Game><GM Award> menu action. Gets a random award from
//            the DB/Crit cache, filters empty entries, selects one randomly,
//            and posts it to the sidebar and GMScreen/PartyLog.
// Inputs  -> None (Uses gUI.dbCritFSData).
// Outputs -> (Promise<void>): Implicitly returns promise due to async calls.
async function fHandleGMAward() {
    const funcName = "fHandleGMAward";
    fMyConsoleLog(`⚙️ Menu Action: ${funcName} Triggered...`);

    // === 1. Access and Validate Cache ===
    // Cache key is explicitly passed to resolver functions, validation happens there too.
    const cacheKey = 'dbCritFSData';
    if (!gUI[cacheKey]) { // Basic check if cache object exists at all
      console.error(`${funcName}: Cache object gUI['${cacheKey}'] is missing.`);
      // No user message per instructions, just log and exit.
      return;
    }

    // === 2. Resolve Tags & Indices using FSData resolvers ===
    const gmawardColTag = 'GMAward';
    const startRowTag = 'FirstDataRow';
    const gmawardColIndex = fResolveFSDataCol(cacheKey, gmawardColTag);
    const startRowIndex = fResolveFSDataRow(cacheKey, startRowTag);

    // Validation happens within resolvers, they return NaN on failure
    if (isNaN(gmawardColIndex) || isNaN(startRowIndex)) {
        // Error messages are logged by the resolver functions.
        return; // Exit if tags didn't resolve correctly
    }

    // === 3. Extract & Filter Award List ===
    const awardsList = [];
    // Access cache directly now that key is confirmed to exist (basic check)
    const cachedText = gUI[cacheKey].text;
    const numRows = cachedText.length;

    for (let r = startRowIndex; r < numRows; r++) {
        // Accessing the 2D array directly
        const cellValue = cachedText[r]?.[gmawardColIndex];
        const trimmedValue = String(cellValue ?? '').trim(); // Trim and handle null/undefined
        if (trimmedValue !== '') {
            awardsList.push(trimmedValue);
        }
    }

    // === 4. Handle Empty List ===
    if (awardsList.length === 0) {
        fMyConsoleLog(`   -> ${funcName}: No valid GM Awards found in '${gmawardColTag}' column starting from row '${startRowTag}'. Skipping display.`);
        // No user message per instructions, just log and exit.
        return;
    }

    // === 5. Select Random Award ===
    const randomIndex = Math.floor(Math.random() * awardsList.length);
    const selectedAward = awardsList[randomIndex];
    fMyConsoleLog(`   -> Randomly selected award: "${selectedAward}"`);

    // === 6. Format and Post to Sidebar ===
    const sidebarMsgHtml = `<span class="blue-bold">GM Award:</span><br>${selectedAward}`;
    const sidebarMsgText = `GM Award:\n${selectedAward}`;
    fPostToSidebar(sidebarMsgHtml, sidebarMsgText);
    fShowSidebar(); // Ensure sidebar is visible

    // === 7. Log to GMScreen/PartyLog ===
    // Per instructions, this needs to be sent
    fMyConsoleLog(`   -> Queueing log send for GM Award.`);
    setTimeout(() => fSendLogToGMScreenAndPS(), 0);

    fMyConsoleLog(`✅ ${funcName}: Completed.`);
} // END fHandleGMAward




// fMetaFlood ///////////////////////////////////////////////////////////////////
// Purpose -> Handles <Game><Meta><Flood>. Selects Meta col, increases values, caps,
//            updates grid, logs action to sidebar, and triggers GMScreen update.
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM, calls fShowMessage, logs to sidebar/GMScreen).
async function fMetaFlood() {
    fMyConsoleLog("⚙️ Menu Action: Meta Flood...");
    const metaRangeDef = gUI.range?.meta; const metaCaps = gUI.list?.metaFull; const metaColorTags = gUI.list?.metaColor;
    let errorMsg = '';
    if (!metaRangeDef || !fDoesObjectHaveR1C1R2C2Properties(metaRangeDef)) errorMsg = "Meta range definition missing or invalid.";
    else if (!Array.isArray(metaCaps) || metaCaps.length === 0) errorMsg = "Meta caps list (gUI.list.metaFull) missing or invalid.";
    // Allow missing metaColorTags for now
    if (errorMsg) { console.warn(`fMetaFlood: ${errorMsg}`); fMyConsoleLog(`⚠️ Meta Flood failed: ${errorMsg}`); await fShowMessage(`Error: ${errorMsg}`); return; }

    const metaRowTag = metaRangeDef.r1; const startCol = fResolveCol(metaRangeDef.c1); const endCol = fResolveCol(metaRangeDef.c2);
    if ([startCol, endCol].some(isNaN)) { errorMsg = `Could not resolve Meta column tags: ${metaRangeDef.c1}, ${metaRangeDef.c2}.`; console.warn(`fMetaFlood: ${errorMsg}`); fMyConsoleLog(`⚠️ Meta Flood failed: ${errorMsg}`); await fShowMessage(`Error: ${errorMsg}`); return; }
    const numMetaCols = Math.abs(endCol - startCol) + 1;
    if (metaCaps.length > 0 && numMetaCols !== metaCaps.length) { errorMsg = `Mismatch between number of Meta columns (${numMetaCols}) and Meta caps (${metaCaps.length}).`; console.warn(`fMetaFlood: ${errorMsg}`); fMyConsoleLog(`⚠️ Meta Flood failed: ${errorMsg}`); await fShowMessage(`Error: ${errorMsg}`); return; }

    const selectedIndex = Math.floor(Math.random() * numMetaCols); const selectedColIndex = startCol + selectedIndex; const selectedColTag = metaColorTags?.[selectedIndex] ?? `Index ${selectedIndex}`;
    fMyConsoleLog(`   -> Selected Meta Index: ${selectedIndex} (Column ${selectedColIndex} - Tag: ${selectedColTag})`);

    const finalValues = []; let amountToAdd = 1;
    for (let i = selectedIndex; i >= 0; i--) {
        const currentColIndex = startCol + i; const currentColTag = metaColorTags?.[i] ?? `Index ${i}`;
        const currentVal = fGetGridValue(metaRowTag, currentColIndex, true) || 0;
        const newValRaw = currentVal + amountToAdd;
        const cap = (metaCaps && metaCaps[i] !== undefined) ? metaCaps[i] : Infinity;
        const finalVal = Math.min(newValRaw, cap);
        fMyConsoleLog(`      -> Index ${i} (${currentColTag}): Current=${currentVal}, Add=${amountToAdd}, Raw=${newValRaw}, Cap=${cap === Infinity ? 'N/A' : cap} => Final=${finalVal}`);
        finalValues.unshift(finalVal);
        amountToAdd++;
    }

    fMyConsoleLog(`   -> Updating Meta columns ${startCol} to ${selectedColIndex} with final values: [${finalValues.join(', ')}]`);
    const success = fSetRangeOfGridValues(metaRowTag, startCol, metaRowTag, selectedColIndex, finalValues);

    if (!success) {
        errorMsg = `fSetRangeOfGridValues failed to update Meta grid.`;
        fMyConsoleLog(`   -> ⚠️ Meta Flood Error: ${errorMsg}`); await fShowMessage(`Error: ${errorMsg}`);
    } else {
        fMyConsoleLog("✅ Meta Flood Update Complete.");
        const sidebarMsgHtml = `<span class="blue-bold">ℹ️ Meta Flood (Rolled ${selectedColTag}):</span>`;
        const sidebarMsgText = `ℹ️ Meta Flood (Rolled ${selectedColTag}):`;
        fPostToSidebar(sidebarMsgHtml, sidebarMsgText);
        fShowSidebar();

        // Send log update to GMScreen (with slight delay) <<< ADDED CALL >>>
        setTimeout(() => fSendLogToGMScreenAndPS(), 0);
    }
} // END fMetaFlood



// fMetaChannel ////////////////////////////////////////////////////////////////////
// Purpose -> Handles Meta Channeling calculation. Selects Meta Channel column,
//            increments value, updates grid, logs to sidebar. (No GMScreen call needed here,
//            as called by fHandleNishStartOrEnd which sends the final log state).
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM, calls fShowMessage, logs to sidebar).
async function fMetaChannel() {
    fMyConsoleLog("⚙️ Calculating Meta Channel...");
    const channelRangeDef = gUI.range?.metaChannel; const metaColorTags = gUI.list?.metaColor;
    let errorMsg = '';
    if (!channelRangeDef || !fDoesObjectHaveR1C1R2C2Properties(channelRangeDef)) errorMsg = "Meta Channel range definition missing or invalid.";
    // Allow missing metaColorTags
    if (errorMsg) { console.warn(`fMetaChannel: ${errorMsg}`); fMyConsoleLog(`⚠️ Meta Channel failed: ${errorMsg}`); await fShowMessage(`Error: ${errorMsg}`); return; }

    const channelRowTag = channelRangeDef.r1; const startCol = fResolveCol(channelRangeDef.c1); const endCol = fResolveCol(channelRangeDef.c2);
    if ([startCol, endCol].some(isNaN)) { errorMsg = `Could not resolve Meta Channel column tags: ${channelRangeDef.c1}, ${channelRangeDef.c2}.`; console.warn(`fMetaChannel: ${errorMsg}`); fMyConsoleLog(`⚠️ Meta Channel failed: ${errorMsg}`); await fShowMessage(`Error: ${errorMsg}`); return; }

    const numMetaCols = Math.abs(endCol - startCol) + 1;
    const roll1 = Math.floor(Math.random() * numMetaCols); const roll2 = Math.floor(Math.random() * numMetaCols);
    const lowestSelectedIndex = Math.min(roll1, roll2); const finalColIndex = startCol + lowestSelectedIndex;
    const selectedColTag = metaColorTags?.[lowestSelectedIndex] ?? `Index ${lowestSelectedIndex}`;
    fMyConsoleLog(`   -> Meta Channel Rolls: ${roll1}, ${roll2}. Lowest Index: ${lowestSelectedIndex} (Column ${finalColIndex} - Tag: ${selectedColTag})`);

    const currentVal = fGetGridValue(channelRowTag, finalColIndex, true) || 0; const newValue = currentVal + 1;
    fMyConsoleLog(`      -> Index ${lowestSelectedIndex} (${selectedColTag}): Current=${currentVal}, Add=1 => New=${newValue}`);

    const success = fSetGridValue(channelRowTag, finalColIndex, newValue);
    if (!success) {
        errorMsg = `fSetGridValue failed to update Meta Channel grid cell [${channelRowTag}, ${finalColIndex}].`;
        fMyConsoleLog(`   -> ⚠️ Meta Channel Error: ${errorMsg}`); await fShowMessage(`Error: ${errorMsg}`);
    } else {
        fMyConsoleLog("✅ Meta Channel Update Complete.");
        // Build and Display Sidebar Message (HTML and Plain Text)
        const sidebarMsgHtml = `<span class="blue-bold">ℹ️ Meta Channeled (${selectedColTag}):</span> ${currentVal} &rarr; ${newValue}`;
        const sidebarMsgText = `ℹ️ Meta Channeled (${selectedColTag}): ${currentVal} -> ${newValue}`;
        fPostToSidebar(sidebarMsgHtml, sidebarMsgText); // Update sidebar and plain text log
        // No GMScreen update here - handled by calling function
    }
} // END fMetaChannel



// fIsOn_NewNishSet ////////////////////////////////////////////////////////////////
// Purpose -> Processes the 'Is On' / 'Duration' columns at the start of a Nish turn.
//            Decrements positive integer durations by 1. Changes 0, 'i', 'p', 'n'
//            (case-insensitive) to empty strings. Updates grid data and DOM.
// Inputs  -> None (uses gUI.range.isONDur).
// Outputs -> None (modifies gUI.arr and gUI.grid2D via fSetGridValue).
async function fIsOn_NewNishSet() {
    fMyConsoleLog("⚙️ Processing 'Is On/Duration' cells for Nish turn...");

    const rangeDefs = gUI.range?.isONDur; // Get the array of relevant range definitions

    // === Validate Configuration ===
    if (!Array.isArray(rangeDefs) || rangeDefs.length === 0) {
        fMyConsoleLog("⚠️ Cannot process 'Is On': Range definitions missing or empty in gUI.range.isONDur.");
        // Optional: await fShowMessage("Error: 'Is On/Duration' range definitions not found.");
        return;
    }

    // === Initialize Counters ===
    let cellsProcessed = 0;
    let cellsChanged = 0;
    let errorsEncountered = false;

    // === Iterate Through Each Defined Range ===
    for (const range of rangeDefs) {
        // Validate range object structure
        if (!fDoesObjectHaveR1C1R2C2Properties(range)) {
             console.warn("fIsOn_NewNishSet: Skipping invalid range object", range);
             errorsEncountered = true;
             continue;
        }

        // Resolve range tags/indices
        const resolved = fConvertsR1C1R2C2TagOrNumToIndices(range);
        if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
             console.warn("fIsOn_NewNishSet: Skipping range due to unresolved indices", range);
             errorsEncountered = true;
             continue;
        }

        // Determine bounds
        const rMin = Math.min(resolved.r1, resolved.r2);
        const rMax = Math.max(resolved.r1, resolved.r2);
        const cMin = Math.min(resolved.c1, resolved.c2);
        const cMax = Math.max(resolved.c1, resolved.c2);

        // === Process Cells Within Range ===
        for (let r = rMin; r <= rMax; r++) {
            for (let c = cMin; c <= cMax; c++) {
                cellsProcessed++;
                const currentValue = fGetGridValue(r, c); // Get current value
                let newValue = currentValue; // Assume no change initially

                // --- Apply Duration Logic ---
                if (currentValue === null || typeof currentValue === 'undefined') {
                    // Treat truly empty cells as empty string
                    newValue = '';
                } else {
                    const currentValueStrLower = String(currentValue).toLowerCase();
                    // Check for specific non-numeric states to clear
                    if (currentValueStrLower === 'i' || currentValueStrLower === 'p' || currentValueStrLower === 'n') {
                        newValue = ''; // Clear 'i', 'p', 'n'
                    } else {
                        // Try converting to number
                        const numericValue = Number(currentValue);
                        if (!isNaN(numericValue)) {
                            // It's a number
                            if (numericValue > 0) {
                                newValue = numericValue - 1; // Decrement positive duration
                                if (newValue === 0) {
                                     newValue = ''; // Convert resulting 0 to empty string
                                }
                            } else if (numericValue === 0) {
                                newValue = ''; // Convert existing 0 to empty string
                            }
                            // Negative numbers remain unchanged
                        }
                        // Else: Not 'i'/'p'/'n' or a number, keep original value
                    }
                }
                // --- End Duration Logic ---

                // Update grid only if value actually changed
                if (newValue !== currentValue) {
                    if (fSetGridValue(r, c, newValue)) {
                         cellsChanged++;
                         // Optional log: fMyConsoleLog(`   -> Changed cell [${r}, ${c}] from '${currentValue}' to '${newValue}'`);
                    } else {
                        // fSetGridValue logs its own errors
                        errorsEncountered = true;
                    }
                }
            } // end column loop
        } // end row loop
    } // end loop through range definitions

    fMyConsoleLog(`✅ 'Is On/Duration' Processing Complete. Processed: ${cellsProcessed}, Changed: ${cellsChanged}${errorsEncountered ? ' (with errors)' : ''}.`);

} // END fIsOn_NewNishSet



// fCalc_NaturalHealing ////////////////////////////////////////////////////////////
// Purpose -> Handles <Game><Healing><Natural Healing>. Calculates healing, updates
//            wound cells, recalculates Vit Now/Percent, logs results, and sends update.
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM, calls sidebar/GMScreen functions).
async function fCalc_NaturalHealing() {
    fMyConsoleLog("⚙️ Menu Action: Natural Healing...");
    // === 1. Get Vit Max ===
    const vitMaxRange = gUI.range?.vitMax; let errorMsg = '';
    if (!vitMaxRange || !vitMaxRange.r1 || !vitMaxRange.c1) errorMsg = "Vit Max range definition missing.";
    if (errorMsg) { console.warn(`fCalc_NaturalHealing: ${errorMsg}`); fMyConsoleLog(`⚠️ Natural Healing failed: ${errorMsg}`); await fShowMessage(`Error: ${errorMsg}`); return; }
    const vitMax = fGetGridValue(vitMaxRange.r1, vitMaxRange.c1, true);
    if (isNaN(vitMax) || vitMax < 1) { errorMsg = `Vit Max value ('${vitMax}') is invalid or zero. Cannot calculate healing.`; console.warn(`fCalc_NaturalHealing: ${errorMsg}`); fMyConsoleLog(`⚠️ Natural Healing failed: ${errorMsg}`); await fShowMessage(`Error: ${errorMsg}`); return; }
    fMyConsoleLog(`   -> Vit Max for healing calc: ${vitMax}`);

    // === 2. Process Healing for Each Wound Type ===
    let errorsOccurred = false;
    const healingResults = {};
    healingResults['1st'] = await fProcessWoundHealing('vit1stWnds', vitMax, 4, '1st'); if (healingResults['1st'] === null) errorsOccurred = true;
    healingResults['2nd'] = await fProcessWoundHealing('vit2ndWnds', vitMax, 8, '2nd'); if (healingResults['2nd'] === null) errorsOccurred = true;
    healingResults['3rd'] = await fProcessWoundHealing('vit3rdWnds', vitMax, 16, '3rd'); if (healingResults['3rd'] === null) errorsOccurred = true;

    // === 3. Update Vit Now & Percent ===
    if (!errorsOccurred) { await fVitNowNPercent_Calc(); }
    else { fMyConsoleLog("   -> Skipping Vit Now/Percent update due to healing errors."); }

    // === 4. Log Results to Sidebar ===
    let sidebarMsgHtml = `<span class="blue-bold">ℹ️ Natural Healing:</span>`;
    let sidebarMsgText = `ℹ️ Natural Healing:`;
    if (healingResults['1st'] !== null) { sidebarMsgHtml += `<br>${healingResults['1st']} -> 1st Deg Wnds`; sidebarMsgText += `\n${healingResults['1st']} -> 1st Deg Wnds`; }
    if (healingResults['2nd'] !== null) { sidebarMsgHtml += `<br>${healingResults['2nd']} -> 2nd Deg Wnds`; sidebarMsgText += `\n${healingResults['2nd']} -> 2nd Deg Wnds`; }
    if (healingResults['3rd'] !== null) { sidebarMsgHtml += `<br>${healingResults['3rd']} -> 3rd Deg Wnds`; sidebarMsgText += `\n${healingResults['3rd']} -> 3rd Deg Wnds`; }

    fPostToSidebar(sidebarMsgHtml, sidebarMsgText);
    fShowSidebar();
    fMyConsoleLog(`✅ Natural Healing Process Complete ${errorsOccurred ? '(with errors)' : ''}.`);

    // === 5. Send Log Update (with slight delay) ===
    setTimeout(() => fSendLogToGMScreenAndPS(), 0); 

} // END fCalc_NaturalHealing



// fProcessWoundHealing ////////////////////////////////////////////////////////////
// Purpose -> Helper for natural healing. Gets current wounds for a specific degree,
//            rolls appropriate healing die (based on Vit Max / divisor), calculates
//            new wound total (min 0), updates the grid, and returns the amount healed.
// Inputs  -> woundRangeTag (String): Tag for the specific wound cell (e.g., 'vit1stWnds').
//         -> vitMax (Number): Character's maximum vitality.
//         -> divisor (Number): Divisor for Vit Max to determine healing die size (4, 8, 16).
//         -> degreeLabel (String): Label for logging ('1st', '2nd', '3rd').
// Outputs -> (Promise<Number | null>): The actual amount healed (>= 0), or null if an error occurred.
async function fProcessWoundHealing(woundRangeTag, vitMax, divisor, degreeLabel) {
    fMyConsoleLog(`      -> Processing ${degreeLabel} Degree wounds...`);

    // === Get Range Definition ===
    const woundRange = gUI.range?.[woundRangeTag];
    if (!woundRange || !woundRange.r1 || !woundRange.c1) {
        const msg = `Wound range definition missing for tag: ${woundRangeTag}.`;
        console.warn(`fProcessWoundHealing: ${msg}`);
        fMyConsoleLog(`         -> ⚠️ Error: ${msg}`);
        await fShowMessage(`Error processing ${degreeLabel} wounds: ${msg}`);
        return null; // Indicate error
    }

    // === Get Current Wounds ===
    // Default to 0 if invalid/missing, ensure non-negative
    let currentWounds = Math.max(0, fGetGridValue(woundRange.r1, woundRange.c1, true) || 0);
    if (isNaN(currentWounds)) { // Should be caught by || 0, but extra check
        fMyConsoleLog(`         -> Warning: Invalid current wound value for ${degreeLabel}. Assuming 0.`);
        currentWounds = 0;
    }

    // === Calculate Healing ===
    const healingDieSize = Math.max(1, Math.round(vitMax / divisor)); // Die size is at least 1
    const healingRoll = fdRoll(healingDieSize); // Roll the healing die
    fMyConsoleLog(`         -> Healing roll (${degreeLabel}): d${healingDieSize} = ${healingRoll}`);

    // === Calculate New Wounds and Amount Healed ===
    const newWounds = Math.max(0, currentWounds - healingRoll); // Cannot go below 0 wounds
    const actualHealed = currentWounds - newWounds; // Calculate the positive amount healed
    fMyConsoleLog(`         -> Wounds: ${currentWounds} -> ${newWounds} (Healed: ${actualHealed})`);

    // === Update Grid ===
    // Set the new wound value
    if (!fSetGridValue(woundRange.r1, woundRange.c1, newWounds)) {
        const msg = `Failed to update grid for ${degreeLabel} wounds.`;
        console.warn(`fProcessWoundHealing: ${msg}`);
        fMyConsoleLog(`         -> ⚠️ Error: ${msg}`);
        await fShowMessage(`Error updating ${degreeLabel} wounds: ${msg}`);
        return null; // Indicate failure
    }

    // Return the actual amount healed (positive number or zero)
    return actualHealed;

} // END fProcessWoundHealing




// fHealAllWounds //////////////////////////////////////////////////////////////////
// Purpose -> Handles <Game><Healing><All wounds>. Sets wound cells to 0, updates
//            Vit Now/Percent, logs action, and sends update.
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM, calls sidebar/GMScreen functions).
async function fHealAllWounds() {
    fMyConsoleLog("⚙️ Menu Action: Clearing All Wounds...");
    const woundTags = ['vit1stWnds', 'vit2ndWnds', 'vit3rdWnds'];
    let errorsOccurred = false;

    // === Clear Each Wound Type ===
    for (const tag of woundTags) {
        const woundRange = gUI.range?.[tag];
        if (!woundRange || !woundRange.r1 || !woundRange.c1) {
            const msg = `Wound range definition missing for tag: ${tag}.`;
            console.warn(`fHealAllWounds: ${msg}`); fMyConsoleLog(`   -> ⚠️ Error: ${msg}`);
            await fShowMessage(`Error clearing wounds: ${msg}`); errorsOccurred = true; continue;
        }
        if (!fSetGridValue(woundRange.r1, woundRange.c1, 0)) {
            const msg = `Failed to update grid for tag: ${tag}.`;
            fMyConsoleLog(`   -> ⚠️ Error: ${msg}`); await fShowMessage(`Error clearing wounds: ${msg}`);
            errorsOccurred = true;
        } else { fMyConsoleLog(`   -> Cleared wounds for tag: ${tag}`); }
    }

    // === Update Dependent Cells ===
    if (!errorsOccurred) { await fVitNowNPercent_Calc(); }
    else { fMyConsoleLog("   -> Skipping Vit Now/Percent update due to errors clearing wounds."); }

    // === Log to Sidebar ===
    const sidebarMsgHtml = `<span class="blue-bold">ℹ️ All Wounds Healed</span>`;
    const sidebarMsgText = `ℹ️ All Wounds Healed`;
    fPostToSidebar(sidebarMsgHtml, sidebarMsgText);
    fShowSidebar();

    fMyConsoleLog(`✅ Clear All Wounds Process Complete ${errorsOccurred ? '(with errors)' : ''}.`);

    // Send log update to GMScreen (with slight delay) <<< MODIFIED >>>
    setTimeout(() => fSendLogToGMScreenAndPS(), 0);

} // END fHealAllWounds




// fHandleRestTimeRest /////////////////////////////////////////////////////////////
// Purpose -> Handles <Game><Rest> or <Time><Rest>. Runs Meta Flood, logs action,
//            and sends update.
// Inputs  -> None.
// Outputs -> (Promise<void>): Resolves after completing actions.
async function fHandleRestTimeRest() {
    fMyConsoleLog("⚙️ Menu Action: Rest Triggered...");
    await fMetaFlood(); // This logs its own message to sidebar

    // Log action to sidebar (HTML and Plain Text)
    const sidebarMsgHtml = `🕒 <span class="blue-bold">Character Rested</span>`;
    const sidebarMsgText = `🕒 Character Rested`;
    fPostToSidebar(sidebarMsgHtml, sidebarMsgText);
    fShowSidebar();
    fMyConsoleLog("✅ Rest Action Completed.");

    // Send log update to GMScreen (with slight delay) <<< MODIFIED >>>
    setTimeout(() => fSendLogToGMScreenAndPS(), 0);

} // END fHandleRestTimeRest




// fHandleRestTimeNewSession ///////////////////////////////////////////////////////
// Purpose -> Handles <Game><Rest or Time><New Game Session>. Sets Luck to Max,
//            logs action, and sends update.
// Inputs  -> None.
// Outputs -> (Promise<void>): Resolves after completing actions.
async function fHandleRestTimeNewSession() {
    fMyConsoleLog("⚙️ Menu Action: New Game Session Triggered...");
    await fLuck_SetToMax(); // This logs its own message and triggers its own send now

    // Log action to sidebar (HTML and Plain Text)
    const sidebarMsgHtml = `⚡ <span class="blue-bold">New Game Session</span>`;
    const sidebarMsgText = `⚡ New Game Session`;
    fPostToSidebar(sidebarMsgHtml, sidebarMsgText);
    fShowSidebar();

    fMyConsoleLog("✅ New Game Session Action Completed.");

    // Send log update to GMScreen (with slight delay) <<< MODIFIED >>>
    // This ensures this *final* message is also included if fLuck_SetToMax finished quickly
    setTimeout(() => fSendLogToGMScreenAndPS(), 0);

} // END fHandleRestTimeNewSession




// fHandleRestTimeSleep ////////////////////////////////////////////////////////////
// Purpose -> Handles <Game><Rest or Time><Sleep>. Sets Meta to Max, runs Natural
//            Healing, logs action, and sends update.
// Inputs  -> None.
// Outputs -> (Promise<void>): Resolves after completing actions.
async function fHandleRestTimeSleep() {
    fMyConsoleLog("⚙️ Menu Action: Sleep Triggered...");
    fMeta_SetToMax();           // Sync - Logs its own message and triggers send
    await fCalc_NaturalHealing(); // Async - Logs its own message and triggers send

    // Log action to sidebar (HTML and Plain Text)
    const sidebarMsgHtml = `🕒 <span class="blue-bold">Character Slept</span>`;
    const sidebarMsgText = `🕒 Character Slept`;
    fPostToSidebar(sidebarMsgHtml, sidebarMsgText);
    fShowSidebar();

    fMyConsoleLog("✅ Sleep Action Completed.");

    // Send log update to GMScreen (with slight delay) <<< MODIFIED >>>
    // This ensures this *final* message is included if helpers finished quickly
    setTimeout(() => fSendLogToGMScreenAndPS(), 0);

} // END fHandleRestTimeSleep





// fMeta_SetToMax //////////////////////////////////////////////////////////////////
// Purpose -> Handles <Game><Set to Max><Meta>. Sets 'meta' row to max values,
//            logs action, and sends update.
// Inputs  -> None.
// Outputs -> None (Calls fSetRangeOfGridValues, potentially fShowMessage, logs to sidebar/GMScreen).
function fMeta_SetToMax() {
    fMyConsoleLog("⚙️ Menu Action: Setting Meta to Max...");
    const metaRange = gUI.range?.meta; const maxMetaValues = gUI.list?.metaFull;
    let errorMsg = '';
    if (!metaRange || !fDoesObjectHaveR1C1R2C2Properties(metaRange)) errorMsg = "Meta range definition is missing or invalid.";
    else if (!Array.isArray(maxMetaValues) || maxMetaValues.length === 0) errorMsg = "Max Meta values list (gUI.list.metaFull) is missing or empty.";
    if (errorMsg) { console.warn(`fMeta_SetToMax: ${errorMsg}`); fMyConsoleLog(`⚠️ Cannot set Meta to max: ${errorMsg}`); fShowMessage(`Error: ${errorMsg}`); return; }

    const success = fSetRangeOfGridValues(metaRange.r1, metaRange.c1, metaRange.r2, metaRange.c2, maxMetaValues);
    if (!success) {
        fMyConsoleLog(`⚠️ Failed to set Meta to max using fSetRangeOfGridValues.`);
    } else {
        fMyConsoleLog("✅ Meta Set to Max.");
        const sidebarMsgHtml = `<span class="blue-bold">ℹ️ Meta Set to Max</span>`;
        const sidebarMsgText = `ℹ️ Meta Set to Max`;
        fPostToSidebar(sidebarMsgHtml, sidebarMsgText);
        fShowSidebar();

        // Send log update to GMScreen (with slight delay) <<< MODIFIED >>>
        setTimeout(() => fSendLogToGMScreenAndPS(), 0);
    }
} // END fMeta_SetToMax




// fLuck_SetToMax //////////////////////////////////////////////////////////////////
// Purpose -> Handles <Game><Set to Max><Luck>. Calculates max luck, updates cell,
//            logs action, and sends update.
// Inputs  -> None.
// Outputs -> None (Calls helpers, potentially fShowMessage, logs to sidebar/GMScreen).
async function fLuck_SetToMax() {
    fMyConsoleLog("⚙️ Menu Action: Setting Luck to Max...");
    const baseLuck = gUI.list?.luckBoxMax; const luckBoxRange = gUI.range?.luckBox; const luckBoxPlusRange = gUI.range?.luckBoxPlus;
    let errorMsg = '';
    if (typeof baseLuck !== 'number' || isNaN(baseLuck)) errorMsg = "Base Luck value (gUI.list.luckBoxMax) missing or invalid.";
    else if (!luckBoxRange || !luckBoxRange.r1 || !luckBoxRange.c1) errorMsg = "LuckBox range definition missing or incomplete.";
    else if (!luckBoxPlusRange || !luckBoxPlusRange.r1 || !luckBoxPlusRange.c1) errorMsg = "LuckBoxPlus range definition missing or incomplete.";
    if (errorMsg) { console.warn(`fLuck_SetToMax: ${errorMsg}`); fMyConsoleLog(`⚠️ Cannot set Luck to max: ${errorMsg}`); await fShowMessage(`Error: ${errorMsg}`); return; }

    const luckPlusValueRaw = fGetGridValue(luckBoxPlusRange.r1, luckBoxPlusRange.c1); let luckPlusBonus = 0;
    if (luckPlusValueRaw !== null && luckPlusValueRaw !== '' && !isNaN(Number(luckPlusValueRaw))) { luckPlusBonus = Math.round(Number(luckPlusValueRaw)); fMyConsoleLog(`   -> Luck Plus Bonus found: ${luckPlusValueRaw} -> Rounded: ${luckPlusBonus}`); }
    else { fMyConsoleLog(`   -> No valid Luck Plus Bonus found. Using 0.`); }

    const newLuckValue = baseLuck + luckPlusBonus;
    fMyConsoleLog(`   -> Calculated Max Luck: ${baseLuck} (Base) + ${luckPlusBonus} (Bonus) = ${newLuckValue}`);
    const success = fSetGridValue(luckBoxRange.r1, luckBoxRange.c1, newLuckValue);

    if (!success) {
        fMyConsoleLog(`⚠️ Failed to set Luck to max value (${newLuckValue}).`); await fShowMessage(`Error: Failed to update the Luck value in the grid.`);
    } else {
        fMyConsoleLog(`✅ Luck Set to Max (${newLuckValue}).`);
        const sidebarMsgHtml = `<span class="blue-bold">ℹ️ Luck Set to Max</span>`;
        const sidebarMsgText = `ℹ️ Luck Set to Max`;
        fPostToSidebar(sidebarMsgHtml, sidebarMsgText);
        fShowSidebar();

        // Send log update to GMScreen (with slight delay) <<< MODIFIED >>>
        setTimeout(() => fSendLogToGMScreenAndPS(), 0);
    }
} // END fLuck_SetToMax




// fAct_SetToMax ///////////////////////////////////////////////////////////////////
// Purpose -> Sets the current Action Points value (in cell defined by gUI.range.actTotal)
//            to its maximum, calculated as gUI.list.actMax + the integer value of the
//            cell defined by gUI.range.actPlus. Typically called during Nish sequence.
// Inputs  -> None.
// Outputs -> None (Calls fGetGridValue, fSetGridValue, potentially fShowMessage).
async function fAct_SetToMax() {
    fMyConsoleLog("⚙️ Setting Action Points to Max...");

    // === 1. Get Config Data & Ranges ===
    const baseActMax = gUI.list?.actMax;
    const actTotalRange = gUI.range?.actTotal;
    const actPlusRange = gUI.range?.actPlus;

    // === 2. Validate Config Data & Ranges ===
    let errorMsg = '';
    if (typeof baseActMax !== 'number' || isNaN(baseActMax)) errorMsg = "Base Action Points Max value (gUI.list.actMax) missing or invalid.";
    else if (!actTotalRange || !actTotalRange.r1 || !actTotalRange.c1) errorMsg = "Action Points Total range definition missing or incomplete.";
    else if (!actPlusRange || !actPlusRange.r1 || !actPlusRange.c1) errorMsg = "Action Points Plus range definition missing or incomplete.";

    if (errorMsg) {
        console.warn(`fAct_SetToMax: ${errorMsg}`);
        fMyConsoleLog(`⚠️ Cannot set Act to max: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }

    // === 3. Get Act Plus Bonus ===
    const actPlusValueRaw = fGetGridValue(actPlusRange.r1, actPlusRange.c1);
    let actPlusBonus = 0; // Default bonus to 0

    // Convert bonus to integer if it's a valid number
    if (actPlusValueRaw !== null && actPlusValueRaw !== '' && !isNaN(Number(actPlusValueRaw))) {
        actPlusBonus = Math.round(Number(actPlusValueRaw));
        fMyConsoleLog(`   -> Act Plus Bonus found: ${actPlusValueRaw} -> Rounded: ${actPlusBonus}`);
    } else {
        fMyConsoleLog(`   -> No valid Act Plus Bonus found in cell (${actPlusRange.r1}, ${actPlusRange.c1}). Using 0.`);
        // Optional Warning:
        // if (actPlusValueRaw !== null && actPlusValueRaw !== '') {
        //    await fShowMessage(`Warning: Value "${actPlusValueRaw}" in Act Plus cell is not valid number. Using 0 bonus.`);
        // }
    }

    // === 4. Calculate and Set New Act Value ===
    const newActValue = baseActMax + actPlusBonus;
    fMyConsoleLog(`   -> Calculated Max Act: ${baseActMax} (Base) + ${actPlusBonus} (Bonus) = ${newActValue}`);

    const success = fSetGridValue(actTotalRange.r1, actTotalRange.c1, newActValue);

    // === 5. Log Result ===
    if (!success) {
        // fSetGridValue logs specific errors
        fMyConsoleLog(`⚠️ Failed to set Act to max value (${newActValue}) in cell (${actTotalRange.r1}, ${actTotalRange.c1}).`);
        await fShowMessage(`Error: Failed to update the Action Points value in the grid.`);
    } else {
        fMyConsoleLog(`✅ Action Points Set to Max (${newActValue}).`);
        // Note: No sidebar message here as it's usually part of Nish sequence
    }

} // END fAct_SetToMax




// fCalc_VitMaxNowPerc /////////////////////////////////////////////////////////////
// Purpose -> Handles the <Game><Set to Max><Vit Max> menu action. Calculates the
//            character's maximum vitality (Vit Max = Fortitude Sk1 + Vit Bonus),
//            updates the Vit Max cell, then calls fVitNowNPercent_Calc to update
//            the derived Vit Now and Vit Now Percent cells.
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM via helpers, potentially calls fShowMessage).
async function fCalc_VitMaxNowPerc() {
    fMyConsoleLog("⚙️ Menu Action: Setting Vit to Max...");

    // === 1. Get Range Definitions ===
    const fortitudeRange = gUI.range?.fortitudeSk1;
    const vitMaxRange = gUI.range?.vitMax;
    const vitMaxPlusRange = gUI.range?.vitMaxPlus;

    // === 2. Validate Ranges ===
    let errorMsg = '';
    if (!fortitudeRange || !fortitudeRange.r1 || !fortitudeRange.c1) errorMsg = "Fortitude range definition missing.";
    else if (!vitMaxRange || !vitMaxRange.r1 || !vitMaxRange.c1) errorMsg = "Vit Max range definition missing.";
    else if (!vitMaxPlusRange || !vitMaxPlusRange.r1 || !vitMaxPlusRange.c1) errorMsg = "Vit Max Plus range definition missing.";

    if (errorMsg) {
        console.warn(`fCalc_VitMaxNowPerc: ${errorMsg}`);
        fMyConsoleLog(`⚠️ Cannot set Vit to max: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }

    // === 3. Get Fortitude Value ===
    const fortitudeValueRaw = fGetGridValue(fortitudeRange.r1, fortitudeRange.c1);
    const fortitudeValue = Number(fortitudeValueRaw); // Convert to number

    if (isNaN(fortitudeValue)) { // Validate Fortitude value
        errorMsg = `Fortitude Sk1 value ('${fortitudeValueRaw}') is not a valid number.`;
        console.warn(`fCalc_VitMaxNowPerc: ${errorMsg}`);
        fMyConsoleLog(`⚠️ Cannot set Vit to max: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }
    fMyConsoleLog(`   -> Fortitude Sk1 value: ${fortitudeValue}`);

    // === 4. Get Vit Max Plus Bonus ===
    const vitMaxPlusValueRaw = fGetGridValue(vitMaxPlusRange.r1, vitMaxPlusRange.c1);
    let vitMaxPlusBonus = 0; // Default bonus to 0

    // Convert bonus to integer if it's a valid number
    if (vitMaxPlusValueRaw !== null && vitMaxPlusValueRaw !== '' && !isNaN(Number(vitMaxPlusValueRaw))) {
        vitMaxPlusBonus = Math.round(Number(vitMaxPlusValueRaw));
        fMyConsoleLog(`   -> Vit Max Plus Bonus found: ${vitMaxPlusValueRaw} -> Rounded: ${vitMaxPlusBonus}`);
    } else {
        fMyConsoleLog(`   -> No valid Vit Max Plus Bonus found. Using 0.`);
    }

    // === 5. Calculate and Set New Vit Max ===
    const newVitMax = Math.round(fortitudeValue + vitMaxPlusBonus); // Ensure integer
    fMyConsoleLog(`   -> Calculated New Vit Max: ${fortitudeValue} (For) + ${vitMaxPlusBonus} (Bonus) = ${newVitMax}`);

    // Update the Vit Max cell in the grid
    const setMaxSuccess = fSetGridValue(vitMaxRange.r1, vitMaxRange.c1, newVitMax);

    if (!setMaxSuccess) {
        fMyConsoleLog(`⚠️ Failed to set Vit Max value (${newVitMax}) in cell (${vitMaxRange.r1}, ${vitMaxRange.c1}). Aborting further updates.`);
        await fShowMessage(`Error: Failed to update the Vit Max value in the grid.`);
        return; // Stop if essential Vit Max update failed
    }
    fMyConsoleLog(`   -> Successfully set Vit Max to ${newVitMax}.`);

    // === 6. Update Derived Vit Values ===
    // Call helper to update Vit Now and Vit Now Percent based on the new Vit Max
    await fVitNowNPercent_Calc();

    fMyConsoleLog("✅ Vit Set to Max sequence complete.");

} // END fCalc_VitMaxNowPerc




// fVitNowNPercent_Calc ////////////////////////////////////////////////////////////
// Purpose -> Helper function to calculate 'Vit Now' (Vit Max - Total Wounds) and
//            'Vit Now Percent'. Updates the corresponding grid cells. Typically called
//            after Vit Max or Wounds change.
// Inputs  -> None (Reads Vit Max and Wound values from grid).
// Outputs -> None (Modifies Vit Now and Vit Now Percent cells in grid data/DOM).
async function fVitNowNPercent_Calc() {
    fMyConsoleLog("   -> Calculating Vit Now & Percent...");

    // === 1. Get Range Definitions ===
    const vitMaxRange = gUI.range?.vitMax;
    const vit1stRange = gUI.range?.vit1stWnds;
    const vit2ndRange = gUI.range?.vit2ndWnds;
    const vit3rdRange = gUI.range?.vit3rdWnds;
    const vitNowRange = gUI.range?.vitNow;
    const vitNowPercentRange = gUI.range?.vitNowPercent;

    // === 2. Validate Ranges ===
    let errorMsg = '';
    if (!vitMaxRange || !vitMaxRange.r1 || !vitMaxRange.c1) errorMsg = "Vit Max range definition missing.";
    else if (!vit1stRange || !vit1stRange.r1 || !vit1stRange.c1) errorMsg = "Vit 1st Wounds range definition missing.";
    else if (!vit2ndRange || !vit2ndRange.r1 || !vit2ndRange.c1) errorMsg = "Vit 2nd Wounds range definition missing.";
    else if (!vit3rdRange || !vit3rdRange.r1 || !vit3rdRange.c1) errorMsg = "Vit 3rd Wounds range definition missing.";
    else if (!vitNowRange || !vitNowRange.r1 || !vitNowRange.c1) errorMsg = "Vit Now range definition missing.";
    else if (!vitNowPercentRange || !vitNowPercentRange.r1 || !vitNowPercentRange.c1) errorMsg = "Vit Now Percent range definition missing.";

    if (errorMsg) {
        console.warn(`fVitNowNPercent_Calc: ${errorMsg}`);
        fMyConsoleLog(`   -> ⚠️ Calculation aborted: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }

    // === 3. Get Current Vit Max ===
    const currentVitMaxRaw = fGetGridValue(vitMaxRange.r1, vitMaxRange.c1);
    const currentVitMax = Number(currentVitMaxRaw); // Convert to number
    if (isNaN(currentVitMax)) { // Validate Vit Max is usable number
        errorMsg = `Vit Max value ('${currentVitMaxRaw}') needed for calculation is not a number.`;
        console.warn(`fVitNowNPercent_Calc: ${errorMsg}`);
        fMyConsoleLog(`   -> ⚠️ Calculation aborted: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }

    // === 4. Get and Sum Wound Values ===
    // Helper to get wound value, defaulting invalid/empty to 0
    const getWoundVal = (range) => {
        const raw = fGetGridValue(range.r1, range.c1);
        return (raw !== null && raw !== '' && !isNaN(Number(raw))) ? Math.round(Number(raw)) : 0;
    };
    const wounds1st = getWoundVal(vit1stRange);
    const wounds2nd = getWoundVal(vit2ndRange);
    const wounds3rd = getWoundVal(vit3rdRange);
    const totalWounds = wounds1st + wounds2nd + wounds3rd;
    fMyConsoleLog(`      -> Wounds: ${wounds1st}(1st) + ${wounds2nd}(2nd) + ${wounds3rd}(3rd) = ${totalWounds}`);

    // === 5. Calculate and Set Vit Now ===
    const newVitNow = Math.round(currentVitMax - totalWounds); // Ensure integer
    fMyConsoleLog(`      -> Calculated Vit Now: ${currentVitMax} (Max) - ${totalWounds} (Wounds) = ${newVitNow}`);
    const setNowSuccess = fSetGridValue(vitNowRange.r1, vitNowRange.c1, newVitNow);

    if (!setNowSuccess) {
        fMyConsoleLog(`   -> ⚠️ Failed to set Vit Now value (${newVitNow}).`);
        await fShowMessage(`Error: Failed to update the Vit Now value.`);
        // Continue to attempt percentage calculation even if Vit Now fails? Currently yes.
    }

    // === 6. Calculate and Set Vit Now Percentage ===
    // Calculate percentage, handle division by zero if Vit Max is 0
    const percent = (currentVitMax === 0) ? 0 : Math.round((newVitNow / currentVitMax) * 100);
    const percentString = percent + '%'; // Format as string with '%'
    fMyConsoleLog(`      -> Calculated Vit Now Percent: ${percentString}`);

    const setPercentSuccess = fSetGridValue(vitNowPercentRange.r1, vitNowPercentRange.c1, percentString);
    if (!setPercentSuccess) {
        fMyConsoleLog(`   -> ⚠️ Failed to set Vit Now Percent value (${percentString}).`);
        await fShowMessage(`Error: Failed to update the Vit Now Percent value.`);
    }

    fMyConsoleLog("   -> Vit Now & Percent Calculation complete.");

} // END fVitNowNPercent_Calc




// fHandleResetAllToMax ////////////////////////////////////////////////////////////
// Purpose -> Handles <Game><Set to Max><Reset All to Max>. Prompts user, runs reset
//            functions, logs completion, and sends ONE final update.
// Inputs  -> None.
// Outputs -> (Promise<void>): Resolves after completing actions or if cancelled.
async function fHandleResetAllToMax() {
    fMyConsoleLog("⚙️ Menu Action: Reset All to Max Triggered...");
    const promptMessage = `<b>Reset All to Max?</b><br><br>This will:<br>-- Clear Roll Log<br>-- Clear current Nish roll<br>-- Flood Meta<br>-- Clear Channeled Meta<br>-- Set Luck to Max<br>-- Set Action Points to Max<br>-- Heal All Wounds<br>-- Clear Morphs<br>-- Clear 'Is On' Column<br>-- Clear Monsters<b><br>Are you sure?</b>`;
    fMyConsoleLog("   -> Displaying confirmation prompt...");
    const userConfirmed = await fShowPrompt(promptMessage);

    if (userConfirmed) {
        fMyConsoleLog("   -> User confirmed Reset All. Executing actions...");

        // --- Clear Logs Locally (Before other actions add new logs) ---
        const sidebarContent = document.getElementById('sidebar-content');
        if (sidebarContent) sidebarContent.innerHTML = ''; // Clear HTML display
        gUI.plainTextLogEntries = []; // Clear the plain text array directly
        fMyConsoleLog("   -> Cleared local logs (HTML & array).");

        // --- Execute Reset Sequence ---
        // NOTE: These functions log AND call fSendLogToGMScreenAndPS (delayed)
        fClearCurrentNish();         // Sync
        fMeta_SetToMax();          // Async (Logs only)
        fClearChanneledMeta();       // Sync
        await fLuck_SetToMax();      // Async (Logs + Delayed Send)
        await fAct_SetToMax();       // Async (No sidebar log)
        await fHealAllWounds();      // Async (Logs + Delayed Send)
        fClearMorphs();              // Sync
        fClearIsOnDurationRange();   // Sync
        fClearMonsters();            // Sync
        // ----------------------

        // Log final completion message to sidebar (HTML and Plain Text)
        const sidebarMsgHtml = `⚡ <span class="red-bold">RESET ALL TO MAX!</span> ⚡`;
        const sidebarMsgText = `⚡ RESET ALL TO MAX! ⚡`;
        fPostToSidebar(sidebarMsgHtml, sidebarMsgText); // Add final message
        fShowSidebar();

        fMyConsoleLog("✅ Reset All to Max Action Completed.");

        // Send final log state AFTER all actions AND the final message are logged (with slight delay)
        setTimeout(() => fSendLogToGMScreenAndPS(), 0); 

    } else {
        fMyConsoleLog("   -> User cancelled Reset All action.");
    }
} // END fHandleResetAllToMax




// fClearChanneledMeta /////////////////////////////////////////////////////////////
// Purpose -> Handles the <Game><Clear><Channeled Meta> menu action. Clears the
//            values in the Channeled Meta range (defined by gUI.range.metaChannel)
//            by setting them to empty strings using fSetRangeOfGridValues.
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM).
function fClearChanneledMeta() {
    fMyConsoleLog("⚙️ Menu Action: Clearing Channeled Meta...");

    // === 1. Get Range Definition ===
    const metaChannelRange = gUI.range?.metaChannel;

    // === 2. Validate Range Object ===
    if (!metaChannelRange || !fDoesObjectHaveR1C1R2C2Properties(metaChannelRange)) {
        console.warn("fClearChanneledMeta: Channeled Meta range definition is missing or incomplete in gUI.range.metaChannel.");
        fMyConsoleLog("⚠️ Cannot clear Channeled Meta: Range definition missing or incomplete.");
        fShowMessage("Error: Channeled Meta range definition is missing.");
        return;
    }

    // === 3. Clear Range Values ===
    // Call fSetRangeOfGridValues to set all cells in the range to empty string
    const success = fSetRangeOfGridValues(
        metaChannelRange.r1,
        metaChannelRange.c1,
        metaChannelRange.r2,
        metaChannelRange.c2,
        '' // Set value to empty string
    );

    // === 4. Log Result ===
    if (!success) {
        // fSetRangeOfGridValues logs specific errors
        fMyConsoleLog(`⚠️ Failed to clear Channeled Meta range (${metaChannelRange.r1},${metaChannelRange.c1} to ${metaChannelRange.r2},${metaChannelRange.c2}).`);
        // Optional: fShowMessage("Error clearing the channeled meta range.");
    } else {
        fMyConsoleLog("✅ Channeled Meta Range Cleared.");
    }

} // END fClearChanneledMeta




// fClearSk1Sk2Checkboxes ////////////////////////////////////////////////////////
// Purpose -> Handles the <Game><Clear><All Check Boxes...> menu action. Clears
//            (sets to false) all checkboxes within the ranges defined in
//            gUI.range.sk1sk2CheckBoxes using fSetRangeOfGridValues. Also clears the tracker.
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM, clears gUI.currentSkRadioChecked).
function fClearSk1Sk2Checkboxes() {
    fMyConsoleLog("⚙️ Menu Action: Clearing Sk1/Sk2 Checkboxes...");
    let allSucceeded = true;
    const rangesToClear = gUI.range.sk1sk2CheckBoxes; // Get the array of ranges

    // === Validate Configuration ===
    if (!Array.isArray(rangesToClear) || rangesToClear.length === 0) {
        fMyConsoleLog("ℹ️ No Sk1/Sk2 checkbox ranges defined in gUI.range.sk1sk2CheckBoxes.");
        return;
    }

    // === Clear Checkboxes in Each Range ===
    rangesToClear.forEach(range => {
        // Resolve each range definition
        const r1 = fResolveRow(range.r1);
        const c1 = fResolveCol(range.c1);
        const r2 = fResolveRow(range.r2);
        const c2 = fResolveCol(range.c2);

        // Validate resolved indices
        if ([r1, c1, r2, c2].some(isNaN)) {
             console.warn(`fClearSk1Sk2Checkboxes: Skipping invalid range definition:`, range);
             allSucceeded = false; // Mark failure
             return; // Skip this range
        }

        // Call fSetRangeOfGridValues to set all checkboxes in the range to false
        const success = fSetRangeOfGridValues(r1, c1, r2, c2, false);
        if (!success) {
             allSucceeded = false; // Track if any update fails
        }
    });

    // === Clear Tracker ===
    gUI.currentSkRadioChecked = { r: null, c: null }; // Reset the tracker

    // === Log Result ===
    if (!allSucceeded) {
         fMyConsoleLog("⚠️ Failed to clear one or more Sk1/Sk2 Checkbox ranges.");
         // Optional: fShowMessage("Error clearing some checkboxes.");
    } else {
        fMyConsoleLog("✅ Sk1/Sk2 Checkboxes Cleared.");
    }

} // END fClearSk1Sk2Checkboxes




// fClearMonsters ////////////////////////////////////////////////////////////////
// Purpose -> Handles the <Game><Clear><Monsters> menu action. Clears the monster
//            data range (defined by gUI.range.monsters) by setting cell values
//            to a space character (' ') using fSetRangeOfGridValues.
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM).
function fClearMonsters() {
    fMyConsoleLog("⚙️ Menu Action: Clearing Monsters...");
    const monsterRange = gUI.range?.monsters; // Get the range definition

    // === Validate Range Definition ===
    if (!monsterRange || !fDoesObjectHaveR1C1R2C2Properties(monsterRange)) {
        console.warn("fClearMonsters: Monster range definition is missing or incomplete in gUI.range.monsters.");
        fMyConsoleLog("⚠️ Cannot clear monsters: Range definition missing or incomplete.");
        // Optional: fShowMessage("Error: Monster range definition missing.");
        return;
    }

    // === Clear Range Values ===
    const clearValue = ' '; // Use a space character to clear cells
    const success = fSetRangeOfGridValues(
        monsterRange.r1,
        monsterRange.c1,
        monsterRange.r2,
        monsterRange.c2,
        clearValue
    );

    // === Log Result ===
    if (!success) {
         // fSetRangeOfGridValues logs specific errors
         fMyConsoleLog(`⚠️ Failed to clear Monsters range (${monsterRange.r1},${monsterRange.c1} to ${monsterRange.r2},${monsterRange.c2}).`);
         // Optional: fShowMessage("Error clearing the monster data range.");
    } else {
        fMyConsoleLog("✅ Monsters Range Cleared.");
    }
} // END fClearMonsters




// fClearMorphs //////////////////////////////////////////////////////////////////
// Purpose -> Handles the <Game><Clear><Morphs> menu action. Clears the Morph1
//            and Morph2 columns within the Ability and Gear tables (ranges defined
//            in gUI.range.morphs) by setting cell values to a space (' ').
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM).
function fClearMorphs() {
    fMyConsoleLog("⚙️ Menu Action: Clearing Morphs...");
    let allSucceeded = true;
    const morphRanges = gUI.range?.morphs; // Get array of Morph1/Morph2 ranges

    // === Validate Configuration ===
    if (!Array.isArray(morphRanges) || morphRanges.length === 0) {
        console.warn("fClearMorphs: No morph ranges defined in gUI.range.morphs.");
        fMyConsoleLog("⚠️ Cannot clear morphs: Ranges not defined.");
        // Optional: fShowMessage("Error: Morph ranges not defined.");
        return;
    }

    // === Clear Each Morph Range ===
    morphRanges.forEach(range => {
        // Validate the range object structure
        if (!fDoesObjectHaveR1C1R2C2Properties(range)) {
            console.warn("fClearMorphs: Skipping invalid range object within gUI.range.morphs:", range);
            allSucceeded = false;
            return; // Skip this invalid range
         }

        // Call fSetRangeOfGridValues to clear the range with spaces
        const success = fSetRangeOfGridValues(range.r1, range.c1, range.r2, range.c2, ' ');
        if (!success) {
             allSucceeded = false; // Track if any update fails
        }
    });

    // === Log Result ===
    if (!allSucceeded) {
         fMyConsoleLog("⚠️ Failed to clear one or more Morph ranges.");
         // Optional: fShowMessage("Error clearing some morph ranges.");
     } else {
        fMyConsoleLog("✅ Morph Ranges Cleared.");
    }
} // END fClearMorphs




// fClearCurrentNish /////////////////////////////////////////////////////////////
// Purpose -> Handles the <Game><Clear><Nish> menu action. Clears the current Nish
//            value cell (defined by gUI.range.currentNish) by setting its value
//            to a space (' ').
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM).
function fClearCurrentNish() {
    fMyConsoleLog("⚙️ Menu Action: Clearing Current Nish...");
    const nishRange = gUI.range?.currentNish; // Get the range definition

    // === Validate Range Definition ===
    if (!nishRange || !fDoesObjectHaveR1C1R2C2Properties(nishRange)) {
        console.warn("fClearCurrentNish: Nish range definition is missing or incomplete in gUI.range.currentNish.");
        fMyConsoleLog("⚠️ Cannot clear Nish: Range definition missing or incomplete.");
        // Optional: fShowMessage("Error: Nish range definition missing.");
        return;
    }

    // === Clear Cell Value ===
    const clearValue = ' '; // Use a space character to clear the cell
    const success = fSetRangeOfGridValues(
        nishRange.r1,
        nishRange.c1,
        nishRange.r2, // Usually same as r1 for single cell
        nishRange.c2, // Usually same as c1 for single cell
        clearValue
    );

    // === Log Result ===
    if (!success) {
         // fSetRangeOfGridValues logs specific errors
         fMyConsoleLog(`⚠️ Failed to clear Nish range (${nishRange.r1},${nishRange.c1}).`);
         // Optional: fShowMessage("Error clearing the Nish data cell.");
    } else {
        fMyConsoleLog("✅ Current Nish Range Cleared.");
    }
} // END fClearCurrentNish




// fClearRollLog /////////////////////////////////////////////////////////////////
// Purpose -> Handles the <Game><Clear><Roll Log> menu action. Clears the sidebar,
//            plain text log array, displays confirmation, shows sidebar, and sends update.
// Inputs  -> None.
// Outputs -> None (Modifies sidebar DOM, gUI.plainTextLogEntries, calls fShowSidebar, fSendLogToGMScreenAndPS).
function fClearRollLog() {
    fMyConsoleLog("⚙️ Menu Action: Clearing Roll Log...");
    const sidebarContent = document.getElementById('sidebar-content');
    if (!sidebarContent) {
        console.error("fClearRollLog: Could not find sidebar content element (#sidebar-content).");
        fMyConsoleLog("⚠️ Cannot clear Roll Log: Sidebar content element not found.");
        return;
    }

    // Clear the HTML display and add confirmation message
    const clearedMsgHtml = '<p><span class="blue-bold">Roll Log Cleared</span></p>';
    sidebarContent.innerHTML = clearedMsgHtml;

    // Clear the plain text log array and add the cleared message
    const clearedMsgText = 'Roll Log Cleared';
    gUI.plainTextLogEntries = [clearedMsgText];
    fMyConsoleLog("✅ Roll Log Cleared (HTML and plain text array).");

    // Ensure sidebar is visible after clearing <<< ADDED >>>
    fShowSidebar();

    // Send the cleared state (with the confirmation message) to the GMScreen (with slight delay)
    setTimeout(() => fSendLogToGMScreenAndPS(), 0);

} // END fClearRollLog




// fToggleGearColumns //////////////////////////////////////////////////////////////
// Purpose -> Handles the <Gear><Gear (Show/Hide)> menu action. Checks if any column
//            within the gear ranges (defined in gUI.gearTblCols) is currently visible.
//            Calls fHideGridsColumnRange or fShowGridsColumnRange accordingly to toggle visibility.
// Inputs  -> None.
// Outputs -> None (Calls show/hide range functions).
function fToggleGearColumns() {
    const gearRanges = gUI.gearTblCols; // Get the array of gear column ranges

    // === Validate Configuration ===
    if (!Array.isArray(gearRanges) || gearRanges.length === 0) {
        console.error("fToggleGearColumns: gUI.gearTblCols is not a valid array or is empty.");
        fMyConsoleLog("❌ Error: Gear column definition missing or invalid.");
        // Optional: fShowMessage("Error: Gear column range definitions missing.");
        return;
    }

    // === Check Current Visibility ===
    // Determine if *any* column within the defined gear ranges is currently visible
    let isCurrentlyVisible = false;
    for (const range of gearRanges) {
        // Validate range object
        if (!range || typeof range.c1 === 'undefined' || typeof range.c2 === 'undefined') {
            console.warn("fToggleGearColumns: Skipping invalid range object:", range);
            continue;
        }
        // Resolve tags/indices
        const startCol = fResolveCol(range.c1);
        const endCol = fResolveCol(range.c2);
        if (isNaN(startCol) || isNaN(endCol)) {
            console.warn(`fToggleGearColumns: Skipping gear range due to invalid tags/indices: ${range.c1}, ${range.c2}`);
            continue;
        }

        // Check columns within this range
        const cMin = Math.min(startCol, endCol);
        const cMax = Math.max(startCol, endCol);
        for (let c = cMin; c <= cMax; c++) {
            // If one visible column is found, set flag and exit loops
            if (!gUI.hiddenColumns.has(c)) {
                isCurrentlyVisible = true;
                break;
            }
        }
        if (isCurrentlyVisible) break; // Exit outer loop if visibility confirmed
    }

    // === Toggle Visibility ===
    // Call the appropriate show/hide function based on current state
    if (isCurrentlyVisible) {
        fMyConsoleLog("⚙️ Toggling Gear: Currently Visible -> Hiding...");
        fHideGridsColumnRange(gearRanges); // Hide all defined gear ranges
    } else {
        fMyConsoleLog("⚙️ Toggling Gear: Currently Hidden -> Showing...");
        fShowGridsColumnRange(gearRanges); // Show all defined gear ranges
    }
} // END fToggleGearColumns





// fLoot_RollRndTreasure ///////////////////////////////////////////////////////
// Purpose -> Rolls 1d12 to randomly determine and trigger a specific type of
//            loot roll (Valuables, Gear, Chaos Crystal, Socket Gem, Artifact, Sockets).
// Inputs  -> None.
// Outputs -> None (Calls one of the specific fLoot_... placeholder functions).
function fLoot_RollRndTreasure() {
    const funcName = "fLoot_RollRndTreasure";
    fMyConsoleLog(`⚙️ ${funcName}: Rolling for random treasure type...`);

    const roll = fdRoll(12); // Roll 1d12
    fMyConsoleLog(`   -> Random Treasure Roll (d12): ${roll}`);

    // Select the treasure type based on the roll, passing true for isRandomRoll
    switch (true) {
        case roll <= 2: fLoot_RollValuables(true); break;    // 1-2
        case roll <= 4: fLoot_RollGear(true); break;         // 3-4
        case roll <= 6: fLoot_ChaosCrystal(true); break;    // 5-6
        case roll <= 8: fLoot_RollSocketGem(true); break;   // 7-8
        case roll <= 10: fLoot_RollArtifact(true); break;   // 9-10
        default: fLoot_RollSockets(true);                  // 11-12
    }

    // Note: The called function handles sidebar logging and GMScreen update

} // END fLoot_RollRndTreasure




// fLoot_RollValuables /////////////////////////////////////////////////////////
// Purpose -> Rolls level-appropriate Valuables from the dbCritFSData cache and
//            logs the result to the sidebar.
// Inputs  -> isRandomRoll (Boolean, optional): True if called via fLoot_RollRndTreasure (default: false).
// Outputs -> None. Posts selected valuable or error message to sidebar and GMScreen/PS.
async function fLoot_RollValuables(isRandomRoll = false) {
    const funcName = "fLoot_RollValuables";
    const lootType = "Valuables";
    fMyConsoleLog(`⚙️ ${funcName}: Triggered for ${lootType} (isRandomRoll: ${isRandomRoll})...`);

    // === 1. Get Prerequisites ===
    const charLvl = Number(gUI.characterInfo?.level) || 0;
    const treasureColorArr = gUI.list?.metaColor; // Assuming R,O,Y,G,B map to treasure levels
    const cacheKey = 'dbCritFSData';
    const critCache = gUI[cacheKey];

    // === 2. Validate Prerequisites ===
    if (!Array.isArray(treasureColorArr) || treasureColorArr.length !== 5) {
        const errorMsg = `Treasure color list (gUI.list.metaColor) is missing or invalid.`;
        console.error(`${funcName}: ${errorMsg}`);
        fMyConsoleLog(`   -> ❌ ${funcName} Error: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }
    if (!critCache || !critCache.text || !Array.isArray(critCache.text) ||
        !critCache.colTagsMap || typeof critCache.colTagsMap !== 'object' ||
        !critCache.rowTagsMap || typeof critCache.rowTagsMap !== 'object') {
        const errorMsg = `Required cache ${cacheKey} is not loaded or invalid.`;
        console.error(`${funcName}: ${errorMsg}`);
        fMyConsoleLog(`   -> ❌ ${funcName} Error: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }

    // === 3. Resolve Tags & Indices ===
    const treasureColor_C = fResolveFSDataCol(cacheKey, 'TreasureColor');
    const treasureDesc_C = fResolveFSDataCol(cacheKey, 'Treasure'); // Corrected tag based on user prompt
    const startRowTag = 'FirstDataRow'; // Use standard start tag
    const dataFirst_R_idx = fResolveFSDataRow(cacheKey, startRowTag);
    const dataLast_R_idx = critCache.text.length - 1;

    const failedTags = [];
    if (isNaN(treasureColor_C)) failedTags.push('TreasureColor');
    if (isNaN(treasureDesc_C)) failedTags.push('Treasure'); // Check resolved tag
    if (isNaN(dataFirst_R_idx)) failedTags.push(startRowTag);

    if (failedTags.length > 0) {
        const errorMsg = `Could not resolve required tags in ${cacheKey}: ${failedTags.join(', ')}.`;
        console.error(`${funcName}: ${errorMsg}`);
        fMyConsoleLog(`   -> ❌ ${funcName} Error: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }

    if (dataFirst_R_idx > dataLast_R_idx) {
        const errorMsg = `Start row index (${dataFirst_R_idx}) is after last row index (${dataLast_R_idx}) in ${cacheKey}.`;
        console.error(`${funcName}: ${errorMsg}`);
        fMyConsoleLog(`   -> ❌ ${funcName} Error: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }
    fMyConsoleLog(`   -> Resolved Tags: TreasureColor=${treasureColor_C}, Treasure=${treasureDesc_C}. Data Range: ${dataFirst_R_idx}-${dataLast_R_idx}. CharLvl=${charLvl}.`);

    // === 4. Determine Max Treasure Color Index based on Level & Random Rolls ===
    let maxTreasureColorIndexBase;
    if (charLvl <= 4) maxTreasureColorIndexBase = 2;      // Up to Yellow (index 2)
    else if (charLvl <= 9) maxTreasureColorIndexBase = 3; // Up to Green (index 3)
    else maxTreasureColorIndexBase = 4;                   // Up to Blue (index 4)

    const roll1 = fdRoll(maxTreasureColorIndexBase + 1);
    const roll2 = fdRoll(maxTreasureColorIndexBase + 1);
    const maxTreasureColorIndex = Math.min(roll1, roll2) - 1;

    fMyConsoleLog(`   -> Base Max Index=${maxTreasureColorIndexBase}. Rolls=(${roll1}, ${roll2}). Final Max Index=${maxTreasureColorIndex} (${treasureColorArr[maxTreasureColorIndex]}).`);

    // === 5. Filter Eligible Valuables ===
    const eligibleValuables = [];
    for (let r = dataFirst_R_idx; r <= dataLast_R_idx; r++) {
        const rowData = critCache.text[r];
        if (!Array.isArray(rowData)) continue;

        const treasureColor = String(rowData[treasureColor_C] ?? '').toUpperCase();
        const treasureDesc = String(rowData[treasureDesc_C] ?? '').trim();
        const treasureColorIndex = treasureColorArr.indexOf(treasureColor); // Find index of this treasure's color

        // Check if valid color, below max index, and has description
        if (treasureColorIndex !== -1 && treasureColorIndex <= maxTreasureColorIndex && treasureDesc !== '') {
            eligibleValuables.push({
                index: r,
                description: treasureDesc
            });
        }
    }

    if (eligibleValuables.length === 0) {
        const errorMsg = `No valuables found matching level ${charLvl} criteria (Max Color: ${treasureColorArr[maxTreasureColorIndex]}).`;
        fMyConsoleLog(`   -> ⚠️ ${funcName} Warning: ${errorMsg}`);
        await fShowMessage(`Warning: ${errorMsg}`);
        return; // Halt execution
    }
    fMyConsoleLog(`   -> Found ${eligibleValuables.length} eligible valuables.`);

    // === 6. Select Random Eligible Valuable ===
    const randomIndex = Math.floor(Math.random() * eligibleValuables.length);
    const selectedValuable = eligibleValuables[randomIndex];
    fMyConsoleLog(`   -> Selected Valuable: "${selectedValuable.description}" (from original index ${selectedValuable.index}).`);

    // === 7. Format and Post Result ===
    let titleHtml, titleText;
    if (isRandomRoll) {
        titleHtml = `<span class="blue-bold">Loot ${lootType}:</span>`;
        titleText = `Loot ${lootType}:`;
    } else {
        titleHtml = `<span class="red-bold">SPECIFIC</span> <span class="blue-bold">Loot ${lootType}:</span>`;
        titleText = `SPECIFIC Loot ${lootType}:`;
    }
    // Format message body
    const messageBodyHtml = selectedValuable.description;
    const messageBodyText = selectedValuable.description;

    const sidebarMsgHtml = `${titleHtml}<br>${messageBodyHtml}`;
    const sidebarMsgText = `${titleText}\n${messageBodyText}`;

    fPostToSidebar(sidebarMsgHtml, sidebarMsgText);
    fShowSidebar();

    // Ensure log is sent
    setTimeout(() => fSendLogToGMScreenAndPS(), 0);

    fMyConsoleLog(`✅ ${funcName}: Valuables loot posted.`);

} // END fLoot_RollValuables




// fLoot_RollGear //////////////////////////////////////////////////////////////
// Purpose -> Rolls a random, level-appropriate, non-artifact gear item from the
//            dbGearFSData cache and logs it with a random condition to the sidebar.
// Inputs  -> isRandomRoll (Boolean, optional): True if called via fLoot_RollRndTreasure (default: false).
// Outputs -> None. Posts selected gear item or error message to sidebar and GMScreen/PS.
async function fLoot_RollGear(isRandomRoll = false) {
    const funcName = "fLoot_RollGear";
    const lootType = "Gear";
    fMyConsoleLog(`⚙️ ${funcName}: Triggered for ${lootType} (isRandomRoll: ${isRandomRoll})...`);

    // === 1. Get Prerequisites ===
    const charLvl = Number(gUI.characterInfo?.level) || 0;
    const cacheKey = 'dbGearFSData';
    const gearCache = gUI[cacheKey];

    // === 2. Validate Cache ===
    if (!gearCache || !gearCache.text || !Array.isArray(gearCache.text) ||
        !gearCache.colTagsMap || typeof gearCache.colTagsMap !== 'object' ||
        !gearCache.rowTagsMap || typeof gearCache.rowTagsMap !== 'object') {
        const errorMsg = `Required cache ${cacheKey} is not loaded or invalid.`;
        console.error(`${funcName}: ${errorMsg}`);
        fMyConsoleLog(`   -> ❌ ${funcName} Error: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return; // Halt execution
    }

    // === 3. Resolve Tags & Indices ===
    const isArtifact_C = fResolveFSDataCol(cacheKey, 'IsArtifact');
    const itemCr_C = fResolveFSDataCol(cacheKey, 'ItemCR');
    const itemName_C = fResolveFSDataCol(cacheKey, 'Name');
    const dataFirst_R_tag = 'The ID'; // Standard tag for row before first data entry
    const dataFirst_R_idx = fResolveFSDataRow(cacheKey, dataFirst_R_tag);
    const dataLast_R_idx = gearCache.text.length - 1;

    // Validate resolved tags/indices
    const failedTags = [];
    if (isNaN(isArtifact_C)) failedTags.push('IsArtifact');
    if (isNaN(itemCr_C)) failedTags.push('ItemCR');
    if (isNaN(itemName_C)) failedTags.push('Name');
    if (isNaN(dataFirst_R_idx)) failedTags.push(dataFirst_R_tag);

    if (failedTags.length > 0) {
        const errorMsg = `Could not resolve required tags in ${cacheKey}: ${failedTags.join(', ')}.`;
        console.error(`${funcName}: ${errorMsg}`);
        fMyConsoleLog(`   -> ❌ ${funcName} Error: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return; // Halt execution
    }

    const firstDataRowIndex = dataFirst_R_idx + 1; // Actual data starts below the tag row
    if (firstDataRowIndex > dataLast_R_idx) {
        const errorMsg = `Start row index (${firstDataRowIndex}) is after last row index (${dataLast_R_idx}) in ${cacheKey}.`;
        console.error(`${funcName}: ${errorMsg}`);
        fMyConsoleLog(`   -> ❌ ${funcName} Error: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }
    fMyConsoleLog(`   -> Resolved Tags: IsArtifact=${isArtifact_C}, ItemCR=${itemCr_C}, Name=${itemName_C}. Data Range: ${firstDataRowIndex}-${dataLast_R_idx}. CharLvl=${charLvl}.`);

    // === 4. Determine Max CR based on Level ===
    const maxCr = charLvl <= 4 ? 100 : charLvl <= 9 ? 250 : charLvl <= 20 ? 1000 : 10000;
    fMyConsoleLog(`   -> Max ItemCR for Level ${charLvl} is ${maxCr}.`);

    // === 5. Filter Eligible Gear ===
    const eligibleGear = [];
    for (let r = firstDataRowIndex; r <= dataLast_R_idx; r++) {
        const rowData = gearCache.text[r];
        if (!Array.isArray(rowData)) continue;

        const isArtifactVal = rowData[isArtifact_C];
        const isTrulyArtifact = (isArtifactVal === true || String(isArtifactVal).toUpperCase() === 'TRUE');
        const itemCr = Number(rowData[itemCr_C]);
        const itemName = String(rowData[itemName_C] ?? '').trim();

        // Check if: NOT artifact, ItemCR is valid number, ItemCR <= maxCr, and Name is not empty
        if (!isTrulyArtifact && !isNaN(itemCr) && itemCr <= maxCr && itemName !== '') {
            eligibleGear.push({
                index: r,
                name: itemName
            });
        }
    }

    if (eligibleGear.length === 0) {
        const errorMsg = `No non-artifact gear found with ItemCR <= ${maxCr}.`;
        fMyConsoleLog(`   -> ⚠️ ${funcName} Warning: ${errorMsg}`);
        await fShowMessage(`Warning: ${errorMsg}`);
        return; // Halt execution
    }
    fMyConsoleLog(`   -> Found ${eligibleGear.length} eligible gear items.`);

    // === 6. Select Random Eligible Gear ===
    const randomIndex = Math.floor(Math.random() * eligibleGear.length);
    const selectedGear = eligibleGear[randomIndex];
    fMyConsoleLog(`   -> Selected Gear: "${selectedGear.name}" (from original index ${selectedGear.index}).`);

    // === 7. Determine Random Condition ===
    const conditionArr = ['Useless', 'Broken', 'Used', 'Good', 'New', 'High Quality (Cr*2)'];
    const conditionIndex = Math.floor(Math.random() * conditionArr.length);
    const condition = conditionArr[conditionIndex];
    fMyConsoleLog(`   -> Determined Condition: "${condition}"`);

    // === 8. Format and Post Result ===
    let titleHtml, titleText;
    if (isRandomRoll) {
        titleHtml = `<span class="blue-bold">Loot ${lootType}:</span>`;
        titleText = `Loot ${lootType}:`;
    } else {
        titleHtml = `<span class="red-bold">SPECIFIC</span> <span class="blue-bold">Loot ${lootType}:</span>`;
        titleText = `SPECIFIC Loot ${lootType}:`;
    }
    const messageBodyHtml = `${selectedGear.name}<br>Condition: ${condition}`;
    const messageBodyText = `${selectedGear.name}\nCondition: ${condition}`;

    const sidebarMsgHtml = `${titleHtml}<br>${messageBodyHtml}`;
    const sidebarMsgText = `${titleText}\n${messageBodyText}`;

    fPostToSidebar(sidebarMsgHtml, sidebarMsgText);
    fShowSidebar();

    // Ensure log is sent
    setTimeout(() => fSendLogToGMScreenAndPS(), 0);

    fMyConsoleLog(`✅ ${funcName}: Gear loot posted.`);

} // END fLoot_RollGear



// fLoot_ChaosCrystal //////////////////////////////////////////////////////////
// Purpose -> Rolls a Chaos Crystal ability from the dbCritFSData cache, determines
//            its uses based on the MaxUses column (handling "dX" or "X"),
//            and logs the result to the sidebar.
// Inputs  -> isRandomRoll (Boolean, optional): True if called via fLoot_RollRndTreasure (default: false).
// Outputs -> None. Posts selected crystal or error message to sidebar and GMScreen/PS.
async function fLoot_ChaosCrystal(isRandomRoll = false) {
    const funcName = "fLoot_ChaosCrystal";
    const lootType = "Chaos Crystal";
    fMyConsoleLog(`⚙️ ${funcName}: Triggered placeholder for ${lootType} (isRandomRoll: ${isRandomRoll})...`);

    // === 1. Get Prerequisites ===
    const cacheKey = 'dbCritFSData';
    const critCache = gUI[cacheKey];

    // === 2. Validate Cache ===
    if (!critCache || !critCache.text || !Array.isArray(critCache.text) ||
        !critCache.colTagsMap || typeof critCache.colTagsMap !== 'object' ||
        !critCache.rowTagsMap || typeof critCache.rowTagsMap !== 'object') {
        const errorMsg = `Required cache ${cacheKey} is not loaded or invalid.`;
        console.error(`${funcName}: ${errorMsg}`);
        fMyConsoleLog(`   -> ❌ ${funcName} Error: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return; // Halt execution
    }

    // === 3. Resolve Tags & Indices ===
    const chaosCrystalMaxUses_C = fResolveFSDataCol(cacheKey, 'ChaosCrytstalMaxUses');
    const chaosCrystal_C = fResolveFSDataCol(cacheKey, 'ChaosCrystal');
    const startRowTag = 'FirstDataRow';
    const dataFirst_R_idx = fResolveFSDataRow(cacheKey, startRowTag);
    const dataLast_R_idx = critCache.text.length - 1;

    // Validate resolved tags/indices
    const failedTags = [];
    if (isNaN(chaosCrystalMaxUses_C)) failedTags.push('ChaosCrytstalMaxUses');
    if (isNaN(chaosCrystal_C)) failedTags.push('ChaosCrystal');
    if (isNaN(dataFirst_R_idx)) failedTags.push(startRowTag);

    if (failedTags.length > 0) {
        const errorMsg = `Could not resolve required tags in ${cacheKey}: ${failedTags.join(', ')}.`;
        console.error(`${funcName}: ${errorMsg}`);
        fMyConsoleLog(`   -> ❌ ${funcName} Error: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return; // Halt execution
    }

    if (dataFirst_R_idx > dataLast_R_idx) {
        const errorMsg = `Start row index (${dataFirst_R_idx}) is after last row index (${dataLast_R_idx}) in ${cacheKey}.`;
        console.error(`${funcName}: ${errorMsg}`);
        fMyConsoleLog(`   -> ❌ ${funcName} Error: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }

    fMyConsoleLog(`   -> Resolved Tags: MaxUses=${chaosCrystalMaxUses_C}, Crystal=${chaosCrystal_C}. Data Range: ${dataFirst_R_idx}-${dataLast_R_idx}.`);

    // === 4. Filter Valid Crystal Rows ===
    const validRows = [];
    for (let r = dataFirst_R_idx; r <= dataLast_R_idx; r++) {
        const rowData = critCache.text[r];
        if (!Array.isArray(rowData)) continue;

        const maxUsesVal = rowData[chaosCrystalMaxUses_C];
        const abilityVal = rowData[chaosCrystal_C];

        const hasMaxUses = maxUsesVal !== undefined && maxUsesVal !== null && String(maxUsesVal).trim() !== '';
        const hasAbility = abilityVal !== undefined && abilityVal !== null && String(abilityVal).trim() !== '';

        if (hasMaxUses && hasAbility) {
            validRows.push(r);
        }
    }

    if (validRows.length === 0) {
        const errorMsg = `No valid Chaos Crystal definitions found in the data range (${dataFirst_R_idx}-${dataLast_R_idx}).`;
        fMyConsoleLog(`   -> ⚠️ ${funcName} Warning: ${errorMsg}`);
        await fShowMessage(`Warning: ${errorMsg}`);
        return;
    }
    fMyConsoleLog(`   -> Found ${validRows.length} valid crystal rows.`);

    // === 5. Select Random Valid Row ===
    const randomValidIndex = Math.floor(Math.random() * validRows.length);
    const randomRow = validRows[randomValidIndex];
    fMyConsoleLog(`   -> Selected valid row index: ${randomRow}`);

    // === 6. Determine Uses (Revised Logic) ===
    const maxUsesStr = String(critCache.text[randomRow][chaosCrystalMaxUses_C] ?? '1').trim();
    let chaosCrystalUses = 1; // Default uses to 1

    // Try parsing as full die string first (e.g., "2d4+1")
    const rpgRollResult = fRollRPGDieString(maxUsesStr);
    if (rpgRollResult !== null && rpgRollResult >= 1) {
        chaosCrystalUses = rpgRollResult;
        fMyConsoleLog(`      -> Determined uses by parsing "${maxUsesStr}" as RPG string: ${chaosCrystalUses}`);
    } else {
        // If RPG parse failed, try parsing as just a number (e.g., "4") to use as die size
        const dieSize = parseInt(maxUsesStr, 10);
        if (!isNaN(dieSize) && dieSize >= 1) {
            chaosCrystalUses = fdRoll(dieSize); // Roll d(Size)
            fMyConsoleLog(`      -> Determined uses by parsing "${maxUsesStr}" as die size and rolling d${dieSize}: ${chaosCrystalUses}`);
        } else {
            // If both parsing attempts fail, keep the default of 1
            fMyConsoleLog(`      -> Warning: Failed to parse MaxUses string "${maxUsesStr}" as RPG string or die size. Defaulting uses to 1.`);
            chaosCrystalUses = 1;
        }
    }
    fMyConsoleLog(`   -> Final Determined Uses: ${chaosCrystalUses}`);

    // === 7. Get and Clean Ability Text ===
    let chaosCrystalAbility = String(critCache.text[randomRow][chaosCrystal_C] ?? 'Unknown Ability').trim();
    chaosCrystalAbility = chaosCrystalAbility.replace(/[\r\n]/g, ' ');
    fMyConsoleLog(`   -> Selected Ability: "${chaosCrystalAbility}"`);

    // === 8. Format and Post Result ===
    let titleHtml, titleText;
    if (isRandomRoll) {
        titleHtml = `<span class="blue-bold">Loot ${lootType}:</span>`;
        titleText = `Loot ${lootType}:`;
    } else {
        titleHtml = `<span class="red-bold">SPECIFIC</span> <span class="blue-bold">Loot ${lootType}:</span>`;
        titleText = `SPECIFIC Loot ${lootType}:`;
    }
    const usesLabel = (chaosCrystalUses === 1) ? 'Use' : 'Uses';
    const messageBodyHtml = `${usesLabel}(${chaosCrystalUses})<br>${chaosCrystalAbility}`;
    const messageBodyText = `${usesLabel}(${chaosCrystalUses})\n${chaosCrystalAbility}`;

    const sidebarMsgHtml = `${titleHtml}<br>${messageBodyHtml}`;
    const sidebarMsgText = `${titleText}\n${messageBodyText}`;

    fPostToSidebar(sidebarMsgHtml, sidebarMsgText);
    fShowSidebar();

    // Ensure log is sent
    setTimeout(() => fSendLogToGMScreenAndPS(), 0);

    fMyConsoleLog(`✅ ${funcName}: Chaos Crystal loot posted.`);

} // END fLoot_ChaosCrystal




// fLoot_RollSocketGem /////////////////////////////////////////////////////////
// Purpose -> Rolls a level-appropriate Socket Gem from the dbCritFSData cache
//            and logs the result to the sidebar.
// Inputs  -> isRandomRoll (Boolean, optional): True if called via fLoot_RollRndTreasure (default: false).
// Outputs -> None. Posts selected gem or error message to sidebar and GMScreen/PS.
async function fLoot_RollSocketGem(isRandomRoll = false) {
    const funcName = "fLoot_RollSocketGem";
    const lootType = "Socket Gem";
    fMyConsoleLog(`⚙️ ${funcName}: Triggered for ${lootType} (isRandomRoll: ${isRandomRoll})...`);

    // === 1. Get Prerequisites ===
    const charLvl = Number(gUI.characterInfo?.level) || 0;
    const socketColors = gUI.list?.metaColor; // Expect ['R', 'O', 'Y', 'G', 'B']
    const cacheKey = 'dbCritFSData';
    const critCache = gUI[cacheKey];

    // === 2. Validate Prerequisites ===
    if (!Array.isArray(socketColors) || socketColors.length !== 5) {
        const errorMsg = `Socket color list (gUI.list.metaColor) is missing or invalid.`;
        console.error(`${funcName}: ${errorMsg}`);
        fMyConsoleLog(`   -> ❌ ${funcName} Error: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }
    if (!critCache || !critCache.text || !Array.isArray(critCache.text) ||
        !critCache.colTagsMap || typeof critCache.colTagsMap !== 'object' ||
        !critCache.rowTagsMap || typeof critCache.rowTagsMap !== 'object') {
        const errorMsg = `Required cache ${cacheKey} is not loaded or invalid.`;
        console.error(`${funcName}: ${errorMsg}`);
        fMyConsoleLog(`   -> ❌ ${funcName} Error: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }

    // === 3. Resolve Tags & Indices ===
    const gemColor_C = fResolveFSDataCol(cacheKey, 'GemColor');
    const gemDesc_C = fResolveFSDataCol(cacheKey, 'GemDesc');
    const startRowTag = 'FirstDataRow'; // Use standard start tag
    const dataFirst_R_idx = fResolveFSDataRow(cacheKey, startRowTag);
    const dataLast_R_idx = critCache.text.length - 1;

    const failedTags = [];
    if (isNaN(gemColor_C)) failedTags.push('GemColor');
    if (isNaN(gemDesc_C)) failedTags.push('GemDesc');
    if (isNaN(dataFirst_R_idx)) failedTags.push(startRowTag);

    if (failedTags.length > 0) {
        const errorMsg = `Could not resolve required tags in ${cacheKey}: ${failedTags.join(', ')}.`;
        console.error(`${funcName}: ${errorMsg}`);
        fMyConsoleLog(`   -> ❌ ${funcName} Error: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }

    if (dataFirst_R_idx > dataLast_R_idx) {
        const errorMsg = `Start row index (${dataFirst_R_idx}) is after last row index (${dataLast_R_idx}) in ${cacheKey}.`;
        console.error(`${funcName}: ${errorMsg}`);
        fMyConsoleLog(`   -> ❌ ${funcName} Error: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }
    fMyConsoleLog(`   -> Resolved Tags: GemColor=${gemColor_C}, GemDesc=${gemDesc_C}. Data Range: ${dataFirst_R_idx}-${dataLast_R_idx}. CharLvl=${charLvl}.`);

    // === 4. Determine Max Gem Color Index based on Level & Random Rolls ===
    let maxGemColorIndexBase;
    if (charLvl <= 4) maxGemColorIndexBase = 2;      // Up to Yellow (index 2)
    else if (charLvl <= 9) maxGemColorIndexBase = 3; // Up to Green (index 3)
    else maxGemColorIndexBase = 4;                   // Up to Blue (index 4)

    // Roll d(Index + 1) twice and take the minimum result - 1 to get the final index
    const roll1 = fdRoll(maxGemColorIndexBase + 1);
    const roll2 = fdRoll(maxGemColorIndexBase + 1);
    const maxGemColorIndex = Math.min(roll1, roll2) - 1;

    fMyConsoleLog(`   -> Base Max Index=${maxGemColorIndexBase}. Rolls=(${roll1}, ${roll2}). Final Max Index=${maxGemColorIndex} (${socketColors[maxGemColorIndex]}).`);

    // === 5. Filter Eligible Gems ===
    const eligibleGems = [];
    for (let r = dataFirst_R_idx; r <= dataLast_R_idx; r++) {
        const rowData = critCache.text[r];
        if (!Array.isArray(rowData)) continue;

        const gemColor = String(rowData[gemColor_C] ?? '').toUpperCase();
        const gemDesc = String(rowData[gemDesc_C] ?? '').trim();
        const gemColorIndex = socketColors.indexOf(gemColor); // Find index of this gem's color

        // Check if valid color, below max index, and has description
        if (gemColorIndex !== -1 && gemColorIndex <= maxGemColorIndex && gemDesc !== '') {
            eligibleGems.push({
                index: r,
                color: gemColor,
                description: gemDesc
            });
        }
    }

    if (eligibleGems.length === 0) {
        const errorMsg = `No socket gems found matching level ${charLvl} criteria (Max Color: ${socketColors[maxGemColorIndex]}).`;
        fMyConsoleLog(`   -> ⚠️ ${funcName} Warning: ${errorMsg}`);
        await fShowMessage(`Warning: ${errorMsg}`);
        return; // Halt execution
    }
    fMyConsoleLog(`   -> Found ${eligibleGems.length} eligible gems.`);

    // === 6. Select Random Eligible Gem ===
    const randomIndex = Math.floor(Math.random() * eligibleGems.length);
    const selectedGem = eligibleGems[randomIndex];
    fMyConsoleLog(`   -> Selected Gem: Color=${selectedGem.color}, Desc="${selectedGem.description}"`);

    // === 7. Format and Post Result ===
    let titleHtml, titleText;
    if (isRandomRoll) {
        titleHtml = `<span class="blue-bold">Loot ${lootType}:</span>`;
        titleText = `Loot ${lootType}:`;
    } else {
        titleHtml = `<span class="red-bold">SPECIFIC</span> <span class="blue-bold">Loot ${lootType}:</span>`;
        titleText = `SPECIFIC Loot ${lootType}:`;
    }
    // Format message body
    const messageBodyHtml = `${selectedGem.color} Gem:<br>${selectedGem.description}`;
    const messageBodyText = `${selectedGem.color} Gem:\n${selectedGem.description}`;

    const sidebarMsgHtml = `${titleHtml}<br>${messageBodyHtml}`;
    const sidebarMsgText = `${titleText}\n${messageBodyText}`;

    fPostToSidebar(sidebarMsgHtml, sidebarMsgText);
    fShowSidebar();

    // Ensure log is sent
    setTimeout(() => fSendLogToGMScreenAndPS(), 0);

    fMyConsoleLog(`✅ ${funcName}: Socket Gem loot posted.`);

} // END fLoot_RollSocketGem




// fLoot_RollArtifact //////////////////////////////////////////////////////////
// Purpose -> Rolls an Artifact from the dbGearFSData cache, filtering by the
//            'IsArtifact' flag and character level vs AP cost. Logs result to sidebar.
// Inputs  -> isRandomRoll (Boolean, optional): True if called via fLoot_RollRndTreasure (default: false).
// Outputs -> None. Posts selected artifact or error message to sidebar and GMScreen/PS.
async function fLoot_RollArtifact(isRandomRoll = false) {
    const funcName = "fLoot_RollArtifact";
    const lootType = "Artifact";
    fMyConsoleLog(`⚙️ ${funcName}: Triggered placeholder for ${lootType} (isRandomRoll: ${isRandomRoll})...`);

    // === 1. Get Prerequisites ===
    const charLvl = Number(gUI.characterInfo?.level) || 0; // Default to 0 if missing/invalid
    const cacheKey = 'dbGearFSData';
    const gearCache = gUI[cacheKey];

    // === 2. Validate Cache ===
    if (!gearCache || !gearCache.text || !Array.isArray(gearCache.text) ||
        !gearCache.colTagsMap || typeof gearCache.colTagsMap !== 'object' ||
        !gearCache.rowTagsMap || typeof gearCache.rowTagsMap !== 'object') {
        const errorMsg = `Required cache ${cacheKey} is not loaded or invalid.`;
        console.error(`${funcName}: ${errorMsg}`);
        fMyConsoleLog(`   -> ❌ ${funcName} Error: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return; // Halt execution
    }

    // === 3. Resolve Tags & Indices ===
    const isArtifact_C = fResolveFSDataCol(cacheKey, 'IsArtifact');
    const artName_C = fResolveFSDataCol(cacheKey, 'Name');
    const apCost_C = fResolveFSDataCol(cacheKey, 'AP');
    const artDataFirst_R = fResolveFSDataRow(cacheKey, 'The ID'); // Resolve 'The ID' tag row
    const artDataLast_R = gearCache.text.length - 1; // Last row index

    // Validate resolved tags/indices
    const failedTags = [];
    if (isNaN(isArtifact_C)) failedTags.push('IsArtifact');
    if (isNaN(artName_C)) failedTags.push('Name');
    if (isNaN(apCost_C)) failedTags.push('AP');
    if (isNaN(artDataFirst_R)) failedTags.push('The ID (start row)');

    if (failedTags.length > 0) {
        const errorMsg = `Could not resolve required tags in ${cacheKey}: ${failedTags.join(', ')}.`;
        console.error(`${funcName}: ${errorMsg}`);
        fMyConsoleLog(`   -> ❌ ${funcName} Error: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return; // Halt execution
    }

    const firstDataRowIndex = artDataFirst_R + 1; // Actual first data row is one below 'The ID'
    fMyConsoleLog(`   -> Resolved Tags: IsArtifact=${isArtifact_C}, Name=${artName_C}, AP=${apCost_C}. Data Range: ${firstDataRowIndex}-${artDataLast_R}. CharLvl=${charLvl}.`);

    // === 4. Filter Artifacts ===
    const artifactRows = [];
    for (let r = firstDataRowIndex; r <= artDataLast_R; r++) {
        const rowData = gearCache.text[r];
        if (!Array.isArray(rowData)) continue; // Skip malformed rows

        const isArtifactVal = rowData[isArtifact_C];
        const isTrulyArtifact = (isArtifactVal === true || String(isArtifactVal).toUpperCase() === 'TRUE');

        if (isTrulyArtifact) {
            artifactRows.push({ index: r, data: rowData }); // Store index and data
        }
    }

    if (artifactRows.length === 0) {
        const errorMsg = `No items marked as Artifact found in ${cacheKey}.`;
        fMyConsoleLog(`   -> ⚠️ ${funcName} Warning: ${errorMsg}`);
        await fShowMessage(`Warning: ${errorMsg}`);
        return; // Halt execution
    }
    fMyConsoleLog(`   -> Found ${artifactRows.length} total artifacts.`);

    // === 5. Filter by AP Cost ===
    const maxAPCost = Math.max(5, charLvl);
    fMyConsoleLog(`   -> Filtering artifacts by Max AP Cost <= ${maxAPCost} (based on charLvl ${charLvl}).`);
    const eligibleArtifacts = artifactRows.filter(artifact => {
        const apCost = Number(artifact.data[apCost_C]) || Infinity; // Default to Infinity if not a number
        return apCost <= maxAPCost;
    });

    if (eligibleArtifacts.length === 0) {
        const errorMsg = `No artifacts found with AP Cost <= ${maxAPCost}.`;
        fMyConsoleLog(`   -> ⚠️ ${funcName} Warning: ${errorMsg}`);
        // Modify the message slightly for user display
        const userMsg = `No artifacts found suitable for character level ${charLvl} (Max AP Cost: ${maxAPCost}).`;
        await fShowMessage(userMsg);
        return; // Halt execution
    }
    fMyConsoleLog(`   -> Found ${eligibleArtifacts.length} eligible artifacts.`);

    // === 6. Select Random Eligible Artifact ===
    const randomIndex = Math.floor(Math.random() * eligibleArtifacts.length);
    const selectedArtifact = eligibleArtifacts[randomIndex];
    const selectedRowData = selectedArtifact.data;

    const artName = String(selectedRowData[artName_C] || 'Unknown Artifact').trim();
    const apCost = selectedRowData[apCost_C] ?? '?'; // Keep AP cost as string/number from cache
    fMyConsoleLog(`   -> Selected Artifact: "${artName}" (AP: ${apCost}) at original index ${selectedArtifact.index}.`);

    // === 7. Format and Post Result ===
    let titleHtml, titleText;
    if (isRandomRoll) {
        titleHtml = `<span class="blue-bold">Loot ${lootType}:</span>`;
        titleText = `Loot ${lootType}:`;
    } else {
        titleHtml = `<span class="red-bold">SPECIFIC</span> <span class="blue-bold">Loot ${lootType}:</span>`;
        titleText = `SPECIFIC Loot ${lootType}:`;
    }
    const messageBodyHtml = `${artName} (${apCost}AP)`; // Use HTML compatible string
    const messageBodyText = `${artName} (${apCost}AP)`; // Plain text version

    const sidebarMsgHtml = `${titleHtml}<br>${messageBodyHtml}`;
    const sidebarMsgText = `${titleText}\n${messageBodyText}`;

    fPostToSidebar(sidebarMsgHtml, sidebarMsgText);
    fShowSidebar();

    // Ensure log is sent
    setTimeout(() => fSendLogToGMScreenAndPS(), 0);

    fMyConsoleLog(`✅ ${funcName}: Artifact loot posted.`);

} // END fLoot_RollArtifact




// fLoot_RollSockets ///////////////////////////////////////////////////////////
// Purpose -> Rolls a random socketed item type, determines the number and color
//            of sockets based on character level, and logs the result to the sidebar.
// Inputs  -> isRandomRoll (Boolean, optional): True if called via fLoot_RollRndTreasure (default: false).
// Outputs -> None. Posts selected socketed item or error message to sidebar and GMScreen/PS.
async function fLoot_RollSockets(isRandomRoll = false) {
    const funcName = "fLoot_RollSockets";
    const lootType = "Socketed Gear";
    fMyConsoleLog(`⚙️ ${funcName}: Triggered for ${lootType} (isRandomRoll: ${isRandomRoll})...`);

    // === 1. Get Prerequisites ===
    const charLvl = Number(gUI.characterInfo?.level) || 0;
    const socketColors = gUI.list?.metaColor; // Expect ['R', 'O', 'Y', 'G', 'B']

    // === 2. Validate Prerequisites ===
    if (!Array.isArray(socketColors) || socketColors.length !== 5) {
        const errorMsg = `Socket color list (gUI.list.metaColor) is missing or invalid.`;
        console.error(`${funcName}: ${errorMsg}`);
        fMyConsoleLog(`   -> ❌ ${funcName} Error: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }
    fMyConsoleLog(`   -> CharLvl=${charLvl}. Socket Colors: ${socketColors.join(',')}`);

    // === 3. Determine Max Gem Color Index based on Level ===
    let maxGemColorIndexBase;
    if (charLvl <= 4) maxGemColorIndexBase = 2;      // Up to Yellow (index 2)
    else if (charLvl <= 9) maxGemColorIndexBase = 3; // Up to Green (index 3)
    else maxGemColorIndexBase = 4;                   // Up to Blue (index 4)

    // === 4. Determine Number of Gem Slots ===
    // Calculate max slots based on cube root of level (min 1)
    const maxGemSlots = Math.max(1, Math.floor(Math.cbrt(charLvl)));
    // Roll twice and take the minimum
    const numGemSlots = Math.min(fdRoll(maxGemSlots), fdRoll(maxGemSlots));
    fMyConsoleLog(`   -> Max Slots based on Level ${charLvl}: ${maxGemSlots}. Actual Slots Rolled: ${numGemSlots}.`);

    // === 5. Determine Slot Colors ===
    const slotColorArr = [];
    fMyConsoleLog(`   -> Determining ${numGemSlots} slot color(s) (Max Base Index: ${maxGemColorIndexBase})...`);
    for (let i = 0; i < numGemSlots; i++) {
        // Roll d(BaseIndex + 1) twice, take min, subtract 1 for index
        const roll1 = fdRoll(maxGemColorIndexBase + 1);
        const roll2 = fdRoll(maxGemColorIndexBase + 1);
        let colorIndex = Math.min(roll1, roll2) - 1;
        colorIndex = Math.max(0, colorIndex); // Ensure index is not negative
        slotColorArr.push(socketColors[colorIndex]);
        fMyConsoleLog(`      -> Slot ${i+1}: Rolls=(${roll1}, ${roll2}) => Index=${colorIndex} => Color=${socketColors[colorIndex]}`);
    }
    const slotColorsText = slotColorArr.join(', '); // Comma-separated string

    // === 6. Select Item Type ===
    const weaponArr = ['Rnd Owned Body Weapon', 'Selected Body Weapon', 'Rnd Owned Melee Weapon', 'Selected Melee Weapon', 'Rnd Owned Hurled Weapon', 'Selected Hurled Weapon', 'Rnd Owned Ranged Weapon', 'Selected Ranged Weapon'];
    const itemArr = ['Boots', 'Gloves', 'Gauntlet', 'Rnd Owned Armor', 'Selected Armor', 'Pants', 'Belt', 'Tunic/Shirt', 'Ring', 'Arm Band', 'Helmet', 'Tiara', 'Necklace', 'Amulet', 'Pendant/Broach'];
    const itemTypeRoll = fdRoll(3); // 1=Weapon, 2/3=Item
    const selectedArray = (itemTypeRoll === 1) ? weaponArr : itemArr;
    const itemRolled = selectedArray[Math.floor(Math.random() * selectedArray.length)];
    fMyConsoleLog(`   -> Selected Item Type Roll (d3=${itemTypeRoll}): "${itemRolled}"`);

    // === 7. Format and Post Result ===
    let titleHtml, titleText;
    if (isRandomRoll) {
        titleHtml = `<span class="blue-bold">Loot ${lootType}:</span>`;
        titleText = `Loot ${lootType}:`;
    } else {
        titleHtml = `<span class="red-bold">SPECIFIC</span> <span class="blue-bold">Loot ${lootType}:</span>`;
        titleText = `SPECIFIC Loot ${lootType}:`;
    }
    // Format message body
    const slotLabel = (numGemSlots === 1) ? 'slot' : 'slots';
    const messageBodyHtml = `${itemRolled} with ${slotColorsText} ${slotLabel}`;
    const messageBodyText = `${itemRolled} with ${slotColorsText} ${slotLabel}`;

    const sidebarMsgHtml = `${titleHtml}<br>${messageBodyHtml}`;
    const sidebarMsgText = `${titleText}\n${messageBodyText}`;

    fPostToSidebar(sidebarMsgHtml, sidebarMsgText);
    fShowSidebar();

    // Ensure log is sent
    setTimeout(() => fSendLogToGMScreenAndPS(), 0);

    fMyConsoleLog(`✅ ${funcName}: Socketed Gear loot posted.`);

} // END fLoot_RollSockets





// fHandleDesignerOnlyClick ////////////////////////////////////////////////////
// Purpose -> Handles clicks on the "Data" -> "Designer Only" menu item.
//            Initiates the password prompt flow.
// Inputs  -> None.
// Outputs -> None (Calls fPromptForDesignerPassword).
function fHandleDesignerOnlyClick() {
    fMyConsoleLog("⚙️ Menu Action: Designer Only Clicked...");
    fPromptForDesignerPassword(); // Start the password process
} // END fHandleDesignerOnlyClick




// fPromptForDesignerPassword //////////////////////////////////////////////////
// Purpose -> Prompts the user for the Designer Password using window.prompt
//            and calls the server-side validation function if a password is entered.
// Inputs  -> None.
// Outputs -> None (Calls google.script.run or shows messages).
async function fPromptForDesignerPassword() {
    fMyConsoleLog("🔑 Prompting for Designer Password...");

    // Use the browser's native prompt for password input
    const enteredPassword = window.prompt("Enter Designer Password:");

    // Check if the user entered a password (prompt returns null if Cancel is clicked)
    if (enteredPassword !== null) {
        fMyConsoleLog("   -> Password entered. Calling server for validation...");
        // Show a temporary message while verifying
        const verifyingMsg = fShowMessage("🔐 Verifying Password..."); // Don't await

        google.script.run
            .withSuccessHandler((isValid) => {
                // Success handler for the server call
                fHandleDesignerPasswordResult(isValid); // Handle the boolean result
            })
            .withFailureHandler((error) => {
                // Failure handler for the server call (transport error)
                fHideMessage(); // Ensure verifying message is hidden
                const errorMsg = `Error communicating with server for password validation: ${error.message}`;
                console.error("fPromptForDesignerPassword Failure:", error);
                fMyConsoleLog(`   -> ❌ ${errorMsg}`);
                fShowMessage(`❌ ${errorMsg}`); // Show error to user
                // Ensure designer mode is off if communication fails
                gUI.isDesignerMode = false;
                const designerButton = document.getElementById('btn-designer-menu');
                if(designerButton) designerButton.style.display = 'none';
            })
            .fSrvValidateDesignerPassword(enteredPassword); // Call the server function

    } else {
        // User clicked Cancel on the prompt
        fMyConsoleLog("   -> User cancelled password prompt.");
        // Optionally show a message indicating cancellation
        // await fShowMessage("Designer password entry cancelled.");
    }
} // END fPromptForDesignerPassword




// fHandleDesignerPasswordResult ///////////////////////////////////////////////
// Purpose -> Handles the boolean result from the server-side password validation.
//            Shows/hides the Designer button and updates state accordingly.
// Inputs  -> isValid (Boolean): The result from fSrvValidateDesignerPassword.
// Outputs -> None (Modifies DOM, gUI state, shows messages).
function fHandleDesignerPasswordResult(isValid) {
    fMyConsoleLog(`🔑 Handling Password Validation Result: ${isValid}`);
    fHideMessage(); // Hide any "Verifying..." message

    const designerButton = document.getElementById('btn-designer-menu');
    if (!designerButton) {
        console.error("fHandleDesignerPasswordResult: Could not find Designer button (#btn-designer-menu).");
        fShowMessage("Error: Could not find the Designer menu button element.");
        gUI.isDesignerMode = false; // Ensure mode is off
        return;
    }

    if (isValid) {
        fMyConsoleLog("   -> Password CORRECT. Enabling Designer Mode.");
        designerButton.style.display = 'inline-flex'; // Make button visible (use inline-flex like others)
        gUI.isDesignerMode = true; // Set flag
        fShowMessage("✅ Designer Mode Enabled!"); // Show success feedback
    } else {
        fMyConsoleLog("   -> Password INCORRECT.");
        designerButton.style.display = 'none'; // Ensure button is hidden
        gUI.isDesignerMode = false; // Ensure flag is false
        fShowMessage("❌ Incorrect Password."); // Show failure feedback
    }
} // END fHandleDesignerPasswordResult




// ==========================================================================
// === MENU BAR "LIKE"     (End of Menu Bar Click) ===
// ==========================================================================




// fCalculatesEnc_MR_AP ///////////////////////////////////////////////////
// Purpose -> Calculates Movement Rate (MR) tiers and Carry Capacity tiers based on Agility,
//            Strength, and bonuses. Determines the character's current MR by comparing
//            current encumbrance to carry capacity tiers. Updates the MR/Carry table,
//            checkboxes, and the main MR display cell. Calculates total AP of all gear.
// Inputs  -> None (Reads values directly from gUI.arr using tags).
// Outputs -> (Promise<void>): Resolves when calculations and updates are complete. May show
//                              an alert message if over-encumbered.
async function fCalculatesEnc_MR_AP() {
    fMyConsoleLog("⚙️ Calculating Movement Rate and Encumbrance...");

    // === 1. Define Constants ===
    const movementMultipliers = [1, 0.9, 0.8, 0.65, 0.5, 0.25];
    const carryMultipliers = [1, 2, 4, 8, 12, 16];
    const mrColumnTags = ['GearMRCol1', 'GearMRCol2', 'GearMRCol3', 'GearMRCol4', 'GearMRCol5', 'GearMRCol6'];
    const MR_TABLE_ROW = 'GearMRTbl';
    const CARRY_TABLE_ROW = 'GearCarryTbl';
    const CHECKBOX_ROW = 'GearMRCheckBox';

    // === 2. Get Input Values ===
    let errorMsg = '';
    const agilityValue = fGetGridValue('Agi', 'Sk1', true);
    const strengthValue = fGetGridValue('Str', 'Sk1', true);
    const plusMRValue = fGetGridValue('GearPlusMR', 'GearPlusMR', true) || 0; // Default 0 if NaN/empty
    const plusCarryValue = fGetGridValue('GearPlusCarry', 'GearPlusCarry', true) || 0; // Default 0 if NaN/empty
    const currentEncumbrance = fCalcTotalEnc() || 0; // Default 0 if NaN/empty

    // Validate essential inputs
    if (isNaN(agilityValue)) errorMsg += "Agility ('Agi', 'Sk1') is not a valid number. ";
    if (isNaN(strengthValue)) errorMsg += "Strength ('Str', 'Sk1') is not a valid number. ";
    if (isNaN(currentEncumbrance)) errorMsg += "Current Encumbrance ('PossEncTot', 'PossEncTot') is not a valid number.";

    if (errorMsg) {
        console.error(`fCalculatesEnc_MR_AP: Input validation failed: ${errorMsg}`);
        fMyConsoleLog(`❌ MR/Enc Calc Failed: ${errorMsg}`);
        await fShowMessage(`Error calculating MR/Enc: ${errorMsg}`);
        return;
    }

    fMyConsoleLog(`   -> Inputs: Agi=${agilityValue}, Str=${strengthValue}, +MR=${plusMRValue}, +Carry=${plusCarryValue}, CurrentEnc=${currentEncumbrance}`);

    // === 3. Update Gear Table Overview ===
    let updateSuccess = true;
    updateSuccess &&= fSetGridValue('GearSpe', 'GearSpeAndStr', agilityValue);
    updateSuccess &&= fSetGridValue('GearStr', 'GearSpeAndStr', strengthValue);

    if (!updateSuccess) {
        fMyConsoleLog("   -> ⚠️ Warning: Failed to update GearSpe/GearStr overview cells.");
        // Continue calculation even if these fail? For now, yes.
    }

    // === 4. Calculate and Update MR & Carry Tables & Checkboxes ===
    let foundActiveMRLevel = false;
    let finalMovementRate = 0;
    let calculationErrors = false;

    for (let i = 0; i < mrColumnTags.length; i++) {
        const colTag = mrColumnTags[i];

        // Calculate MR and Carry for this column
        const movementRate = Math.round((6 + agilityValue / 5 + plusMRValue) * movementMultipliers[i]);
        const carryCapacity = Math.round((50 + strengthValue + plusCarryValue) * carryMultipliers[i]);

        // Update Grid Cells for this column
        let mrSet = fSetGridValue(MR_TABLE_ROW, colTag, movementRate);
        let carrySet = fSetGridValue(CARRY_TABLE_ROW, colTag, carryCapacity);
        let cbSetInitial = fSetGridValue(CHECKBOX_ROW, colTag, false); // Set to false initially

        if (!mrSet || !carrySet || !cbSetInitial) {
            fMyConsoleLog(`   -> ⚠️ Error setting MR/Carry/Checkbox values for column ${colTag}.`);
            calculationErrors = true;
            // Continue processing other columns despite error? For now, yes.
        } else {
            // fMyConsoleLog(`   -> Col '${colTag}': MR=${movementRate}, Carry=${carryCapacity}`);
        }

        // Check if this is the active MR level
        if (!foundActiveMRLevel && currentEncumbrance <= carryCapacity) {
            fMyConsoleLog(`   -> Active MR Level Found: Col '${colTag}' (Enc ${currentEncumbrance} <= Carry ${carryCapacity})`);
            if (!fSetGridValue(CHECKBOX_ROW, colTag, true)) { // Try to check the box
                fMyConsoleLog(`   -> ⚠️ Error setting Checkbox to TRUE for column ${colTag}.`);
                calculationErrors = true;
            } else {
                foundActiveMRLevel = true;
                finalMovementRate = movementRate;
                fMyConsoleLog(`   -> Final MR set to: ${finalMovementRate}`);
            }
        }
    } // End loop

    // === 5. Update Final MR Cell ===
    if (!fSetGridValue('MR', 'MR', finalMovementRate)) {
        fMyConsoleLog("   -> ⚠️ Error setting final MR value in ('MR', 'MR').");
        calculationErrors = true;
    }

    // === 6. Show Over-Encumbered Alert ===
    if (!foundActiveMRLevel || finalMovementRate === 0) { // Check if no level was found OR MR ended up 0
        fMyConsoleLog("   -> 🚨 Character is over-encumbered!");
        await fShowMessage("You are over encumbered, MR is 0.");
    }

    // === 5. Update Final AP Total Cell ===
    fCalcTotalAP();

    // === 8. Log Completion Status ===
    if (calculationErrors) {
        fMyConsoleLog("❌ MR/Enc/AP Calc Completed with errors.");
    } else {
        fMyConsoleLog("✅ MR/Enc/AP Calc Completed successfully.");
    }

} // END fCalculatesEnc_MR_AP




// fCalcTotalEnc ///////////////////////////////////////////////////////////////////
// Purpose -> Sums all Turbo grid values in the ranges defined by gUI.range.gearEncCol,
//            rounds the result to 2 decimal places (removing trailing zeros), places
//            the result in the target cell defined by gUI.range.currentEnc, and
//            returns the calculated total.
// Inputs  -> None (Uses gUI.range, gUI.arr).
// Outputs -> (Number): The calculated and rounded total encumbrance, or 0 on error.
function fCalcTotalEnc() {
    const funcName = "fCalcTotalEnc";
    fMyConsoleLog(`⚖️ Calculating Total Encumbrance...`);
    let totalEnc = 0;
    let errorsOccurred = false;

    // --- 1. Validate Prerequisite Range Definitions ---
    const encRangeDefs = gUI.range?.gearEncCol;
    const targetCellDef = gUI.range?.currentEnc;

    if (!Array.isArray(encRangeDefs) || encRangeDefs.length === 0) {
        console.error(`${funcName}: Encumbrance source range definition (gUI.range.gearEncCol) is missing or invalid.`);
        fMyConsoleLog(`❌ ${funcName} Error: Encumbrance source range definition missing.`);
        errorsOccurred = true;
    }
    if (!targetCellDef || typeof targetCellDef.r1 === 'undefined' || typeof targetCellDef.c1 === 'undefined') {
        console.error(`${funcName}: Target cell definition (gUI.range.currentEnc is "${gUI.range.currentEnc}") is missing or invalid (requires r1, c1).`);
        fMyConsoleLog(`❌ ${funcName} Error: Target cell definition missing or invalid.`);
        errorsOccurred = true;
    }
    if (errorsOccurred) return 0; // Return 0 if setup is invalid

    // --- 2. Iterate Through Each Encumbrance Source Range ---
    encRangeDefs.forEach((rangeDef, index) => {
        // Validate range object structure
        if (!fDoesObjectHaveR1C1R2C2Properties(rangeDef)) {
            console.warn(`${funcName}: Skipping invalid range object at index ${index}:`, rangeDef);
            errorsOccurred = true;
            return; // Continue to next range definition
        }

        // Resolve range tags/indices
        const resolved = fConvertsR1C1R2C2TagOrNumToIndices(rangeDef);
        if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
            console.warn(`${funcName}: Skipping range at index ${index} due to unresolved indices:`, rangeDef);
            errorsOccurred = true;
            return; // Continue to next range definition
        }

        // Determine bounds
        const rMin = Math.min(resolved.r1, resolved.r2);
        const rMax = Math.max(resolved.r1, resolved.r2);
        const cMin = Math.min(resolved.c1, resolved.c2);
        const cMax = Math.max(resolved.c1, resolved.c2);

        // --- 3. Iterate Through Cells and Sum Values ---
        for (let r = rMin; r <= rMax; r++) {
            for (let c = cMin; c <= cMax; c++) {
                const value = fGetGridValue(r, c);
                const numericValue = Number(value) || 0; // Coerce to number, NaN becomes 0
                totalEnc += numericValue;
                // Optional: Log individual values being added
                // if (numericValue !== 0) fMyConsoleLog(`   -> Adding [${r},${c}]: ${numericValue}`);
            }
        }
    }); // End forEach encRangeDef

    // --- 4. Round the Total ---
    // Round to nearest hundredth. JavaScript handles trailing zero removal automatically.
    const roundedTotalEnc = Math.round(totalEnc * 100) / 100;
    fMyConsoleLog(`   -> Raw Total Enc: ${totalEnc}, Rounded: ${roundedTotalEnc}`);

    // --- 5. Update Target Cell ---
    // Resolve target cell coordinates
    const targetR = fResolveRow(targetCellDef.r1);
    const targetC = fResolveCol(targetCellDef.c1);

    if (isNaN(targetR) || isNaN(targetC)) {
        console.error(`${funcName}: Could not resolve target cell coordinates from gUI.range.currentEnc:`, targetCellDef);
        fMyConsoleLog(`❌ ${funcName} Error: Could not resolve target cell coordinates.`);
        errorsOccurred = true;
    } else {
        // Update the target cell
        if (!fSetGridValue(targetR, targetC, roundedTotalEnc)) {
            // fSetGridValue logs its own errors
            fMyConsoleLog(`   -> ⚠️ Warning: Failed to update target cell [${targetR}, ${targetC}] with total encumbrance.`);
            errorsOccurred = true; // Consider this an error
        } else {
            fMyConsoleLog(`   -> Target cell [${targetR}, ${targetC}] updated with: ${roundedTotalEnc}`);
        }
    }

    // --- 6. Return Result ---
    fMyConsoleLog(`✅ ${funcName} finished ${errorsOccurred ? 'with errors' : 'successfully'}. Returning: ${roundedTotalEnc}`);
    return roundedTotalEnc; // Return the calculated value

} // END fCalcTotalEnc




// fCalcTotalAP //////////////////////////////////////////////////////////////////
// Purpose -> Sums all values in the 'PossAPTot' column ranges defined in
//            gUI.range.gearApTotalCol, ignoring non-numeric values, and updates
//            the target total cell defined by gUI.range.gearAPTotal.
// Inputs  -> None (Uses gUI.range, gUI.arr).
// Outputs -> (Number): The calculated total Action Points from gear, or 0 on error.
function fCalcTotalAP() {
    const funcName = "fCalcTotalAP";
    fMyConsoleLog(`⚙️ Calculating Total Action Points from Gear...`);
    let apTotal = 0;
    let errorsOccurred = false;

    // --- 1. Get Source Range Definitions ---
    const apSourceRangeDefs = gUI.range?.gearApTotalCol;
    const targetCellDef = gUI.range?.gearAPTotal; // Target cell for the grand total

    // --- 2. Validate Prerequisite Range Definitions ---
    if (!Array.isArray(apSourceRangeDefs) || apSourceRangeDefs.length === 0) {
        console.error(`${funcName}: AP source range definition (gUI.range.gearApTotalCol) is missing or invalid.`);
        fMyConsoleLog(`❌ ${funcName} Error: AP source range definition missing.`);
        errorsOccurred = true;
    }
    // Target range validation (ensure r1 and c1 exist)
    if (!targetCellDef || typeof targetCellDef.r1 === 'undefined' || typeof targetCellDef.c1 === 'undefined') {
        console.error(`${funcName}: Target cell definition (gUI.range.gearAPTotal) is missing or invalid (requires r1, c1).`);
        fMyConsoleLog(`❌ ${funcName} Error: Target cell definition missing or invalid.`);
        errorsOccurred = true;
    }

    if (errorsOccurred) return 0; // Return 0 if setup is invalid

    // --- 3. Iterate Through Each Source Range ---
    apSourceRangeDefs.forEach((rangeDef, index) => {
        // Validate range object structure
        if (!fDoesObjectHaveR1C1R2C2Properties(rangeDef)) {
            console.warn(`${funcName}: Skipping invalid range object at index ${index}:`, rangeDef);
            errorsOccurred = true;
            return; // Continue to next range definition
        }

        // Resolve range tags/indices
        const resolved = fConvertsR1C1R2C2TagOrNumToIndices(rangeDef);
        if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
            console.warn(`${funcName}: Skipping range at index ${index} due to unresolved indices:`, rangeDef);
            errorsOccurred = true;
            return; // Continue to next range definition
        }

        // Determine bounds
        const rMin = Math.min(resolved.r1, resolved.r2);
        const rMax = Math.max(resolved.r1, resolved.r2);
        const cMin = Math.min(resolved.c1, resolved.c2);
        const cMax = Math.max(resolved.c1, resolved.c2);

        // --- 4. Iterate Through Cells and Sum Values ---
        for (let r = rMin; r <= rMax; r++) {
            for (let c = cMin; c <= cMax; c++) {
                // Use fGetGridValue with asNumber=true (handles '' -> 0, NaN -> NaN)
                const value = fGetGridValue(r, c, true);

                // Add value only if it's a valid number (isNaN checks for NaN specifically)
                if (!isNaN(value)) {
                    apTotal += value;
                    // Optional: Log individual values being added
                    // if (value !== 0) fMyConsoleLog(`   -> Adding [${r},${c}]: ${value}`);
                } else {
                    // Log if fGetGridValue returned NaN (indicating a non-numeric value was found)
                    // fMyConsoleLog(`   -> Skipping non-numeric value at [${r},${c}]`); // Can be noisy
                }
            }
        }
    }); // End forEach apSourceRangeDefs

    // --- 5. Round the Total ---
    const roundedTotalAp = Math.round(apTotal); // AP should likely be whole numbers
    fMyConsoleLog(`   -> Raw Total AP: ${apTotal}, Rounded: ${roundedTotalAp}`);

    // --- 6. Update Target Cell ---
    // Resolve target cell coordinates
    const targetR = fResolveRow(targetCellDef.r1);
    const targetC = fResolveCol(targetCellDef.c1);

    if (isNaN(targetR) || isNaN(targetC)) {
        console.error(`${funcName}: Could not resolve target cell coordinates from gUI.range.gearAPTotal:`, targetCellDef);
        fMyConsoleLog(`❌ ${funcName} Error: Could not resolve target cell coordinates.`);
        errorsOccurred = true;
    } else {
        // Update the target cell
        if (!fSetGridValue(targetR, targetC, roundedTotalAp)) {
            // fSetGridValue logs its own errors
            fMyConsoleLog(`   -> ⚠️ Warning: Failed to update target cell [${targetR}, ${targetC}] with total AP.`);
            errorsOccurred = true; // Consider this an error
        } else {
            fMyConsoleLog(`   -> Target cell [${targetR}, ${targetC}] updated with: ${roundedTotalAp}`);
        }
    }

    // --- 7. Return Result ---
    fMyConsoleLog(`✅ ${funcName} finished ${errorsOccurred ? 'with errors' : 'successfully'}. Returning: ${roundedTotalAp}`);
    return roundedTotalAp; // Return the calculated value

} // END fCalcTotalAP



// ==========================================================================
// === Grid Button Click     (End of MENU BAR "LIKE") ===
// ==========================================================================




// fHandleGridButtonClick //////////////////////////////////////////////////////
// Purpose -> Handles clicks delegated from the grid specifically for header button images.
//            Routes the click to the appropriate action handler based on the
//            image's 'data-button-action' attribute. Simulates a click on the
//            main '#btn-roll' for the 'action-rollDice' button or the corresponding
//            menu item for 'action-refreshData'.
// Inputs  -> event (MouseEvent): The original click event object.
//         -> buttonImg (HTMLImageElement): The header button image element that was clicked.
// Outputs -> None (Calls other action functions or simulates clicks).
function fHandleGridButtonClick(event, buttonImg) {
    const action = buttonImg.dataset.buttonAction;
    fMyConsoleLog(`🖱️ Header Button Clicked: ${action}`);

    event.preventDefault();  // Prevent any default image link behavior
    event.stopPropagation(); // Stop click from propagating further

    const grid = document.getElementById('grid'); // Needed for scrolling actions

    // === Dispatch Action ===
    switch (action) {
        case 'action-rollDice':
            // Simulate a click on the main Roll button in the menu bar
            const rollButton = document.getElementById('btn-roll');
            if (rollButton) {
                fMyConsoleLog("   -> Simulating click on #btn-roll...");
                rollButton.click(); // Trigger the main roll button's logic
            } else {
                console.error("fHandleGridButtonClick: Could not find #btn-roll element to simulate click!");
                fMyConsoleLog("   -> ❌ Error: Could not find #btn-roll.");
                // Optional: fShowMessage("Error: Could not find the main Roll button.");
            }
            break;
        case 'action-refreshData':
            fMyConsoleLog("   -> Refresh Data action triggered.");
            // Simulate a click on the 'Update (Level, Slot, Names)' menu item
            const updateMenuItem = document.querySelector('a[data-action="game-updateLevelSlotName"]');
            if (updateMenuItem) {
                fMyConsoleLog("   -> Simulating click on 'game-updateLevelSlotName' menu item...");
                updateMenuItem.click(); // Trigger the menu item's logic
            } else {
                 console.error("fHandleGridButtonClick: Could not find menu item a[data-action='game-updateLevelSlotName']!");
                 fMyConsoleLog("   -> ❌ Error: Could not find 'Update (Level, Slot, Names)' menu item.");
                 // Optional: fShowMessage("Error: Could not trigger the Update action.");
            }
            break;
        case 'action-jumpTop':
            fScrollGridToTop(grid); // Scroll grid viewport to top
            break;
        case 'action-jumpBottom':
            fScrollGridToBottom(grid); // Scroll grid viewport to bottom (Gear section)
            break;
        case 'action-showMonsters':
            fRefreshMonsterData(); // Refresh monster data from sheet
            break;
        default:
            console.warn(`Unhandled header button action: ${action}`);
            fShowMessage(`Action "${action}" not yet implemented.`); // Show message for unhandled
    }
} // END fHandleGridButtonClick




// fScrollGridToTop ////////////////////////////////////////////////////////////////
// Purpose -> Scrolls the grid container smoothly to the top (0px scroll).
// Inputs  -> grid (HTMLElement): The grid container element (#grid).
// Outputs -> None (Performs scroll animation).
function fScrollGridToTop(grid) {
    if (grid) {
        // Use smooth scrolling behavior
        grid.scrollTo({ top: 0, behavior: 'smooth' });
    } else {
        // Log warning if grid element wasn't found
        console.warn("fScrollGridToTop: Could not find #grid element to scroll.");
    }
} // END fScrollGridToTop




// fScrollGridToBottom /////////////////////////////////////////////////////////////
// Purpose -> Scrolls the grid container smoothly to center the view vertically
//            on the start of the Gear Table section ('GearTblHeaderStartR').
// Inputs  -> grid (HTMLElement): The grid container element (#grid).
// Outputs -> None (Performs scroll animation).
function fScrollGridToBottom(grid) {
    // Validate grid element
    if (!grid) {
        console.warn("fScrollGridToBottom: Could not find #grid element to scroll.");
        return;
    }

    // Resolve target row index
    const targetRowTag = 'GearTblHeaderStartR';
    const targetRowIndex = fResolveRow(targetRowTag);
    if (isNaN(targetRowIndex)) {
        console.warn(`fScrollGridToBottom: Could not resolve row tag '${targetRowTag}' for scrolling.`);
        return;
    }

    // Get the target cell element (using column 0)
    const targetCell = gUI.grid2D?.[targetRowIndex]?.[0];
    if (!targetCell) {
        console.warn(`fScrollGridToBottom: Could not find cell element for row ${targetRowIndex} (Tag: ${targetRowTag})`);
        return;
    }

    // Calculate the scroll position to center the target row
    // (offsetTop of cell - half viewport height + half cell height)
    const scrollTop = targetCell.offsetTop - (grid.clientHeight / 2) + (targetCell.offsetHeight / 2);

    // Perform smooth scroll
    grid.scrollTo({ top: scrollTop, behavior: 'smooth' });
    fMyConsoleLog(`Scrolling grid to center row ${targetRowIndex} (Tag: ${targetRowTag})`);

} // END fScrollGridToBottom



// fRefreshMonsterData /////////////////////////////////////////////////////////////
// Purpose -> Handles the 'Show Monsters' header button action. Clears the Turbo
//            monster table locally, fetches fresh monster data from the GM Screen DB
//            via the server, and then populates the Turbo table using the returned data.
// Inputs  -> None.
// Outputs -> None (Modifies grid data/DOM, calls server function).
async function fRefreshMonsterData() {
    fMyConsoleLog("⚙️ Refreshing Monster Data from GM Screen DB...");

    // === 1. Get and Validate Turbo Monster Range Definition ===
    // This is the range on the *client-side* Turbo grid we will populate
    const turboMonsterRangeDef = gUI.range?.monsters;
    if (!turboMonsterRangeDef || !fDoesObjectHaveR1C1R2C2Properties(turboMonsterRangeDef)) {
        const msg = "Turbo Monster range definition (gUI.range.monsters) is missing or invalid.";
        console.error(`fRefreshMonsterData: ${msg}`);
        fMyConsoleLog(`❌ Monster Refresh Failed: ${msg}`);
        await fShowMessage(`Error: ${msg}`);
        return;
    }
    // We don't resolve indices here, fUpdateMonsterTable will handle it.

    // === 2. Get GM Screen DB Range Definition ===
    // This is the range we request from the server's 'GMScreen' sheet in the 'db' file
    const gmMonsterRangeDef = gUI.rangeDB?.monstersDB;
     if (!gmMonsterRangeDef || !fDoesObjectHaveR1C1R2C2Properties(gmMonsterRangeDef)) {
        const msg = "GM Screen DB Monster range definition (gUI.rangeDB.monstersDB) is missing or invalid.";
        console.error(`fRefreshMonsterData: ${msg}`);
        fMyConsoleLog(`❌ Monster Refresh Failed: ${msg}`);
        await fShowMessage(`Error: ${msg}`);
        return;
    }


    // === 3. Clear Local Turbo Monster Table ===
    fMyConsoleLog(`   -> Clearing local Turbo monster table...`);
    fClearMonsters(); // Clears based on gUI.range.monsters definition

    // === 4. Call Server Function ===
    fMyConsoleLog(`   -> Fetching GM monster data using key 'db', sheet 'GMScreen', range: ${JSON.stringify(gmMonsterRangeDef)}`);
    // Consider adding a visual loading indicator here

    google.script.run
        // --- Success Handler ---
        .withSuccessHandler((response) => {
            // Remove loading indicator here
            fMyConsoleLog(`   -> Received response from server.`);

            // === Validate Response Structure ===
            if (!response || typeof response !== 'object' || response.error ||
                !response.hasOwnProperty('data') || !response.hasOwnProperty('colTags') || !response.hasOwnProperty('rowTags') ) {
                const errMsg = "Received invalid data structure from server for monsters.";
                console.error(`fRefreshMonsterData Success Handler: ${errMsg}`, response);
                fMyConsoleLog(`   -> ❌ Error: ${errMsg}`);
                fShowMessage(`Error: ${errMsg}`);
                return;
            }

            const { data: gmDataArray, colTags: gmColTags, rowTags: gmRowTags } = response;
            fMyConsoleLog(`   -> Server returned Data (${Array.isArray(gmDataArray) ? gmDataArray.length : 'N/A'}), ColTags (${Object.keys(gmColTags).length}), RowTags (${Object.keys(gmRowTags).length}).`);

            // === Process Received Data ===
            // Call the new helper function to populate the Turbo grid
            fUpdateMonsterTable(gmDataArray, gmColTags, gmRowTags);

        })
        // --- Failure Handler ---
        .withFailureHandler((error) => {
            // Remove loading indicator here
            const errorMsgFromServer = error.message || "Unknown server error";
            const finalErrorMsg = `Failed to fetch monster data from server: ${errorMsgFromServer}`;
            console.error(`fRefreshMonsterData Failure Handler:`, error);
            fMyConsoleLog(`❌ Monster Refresh Failed: ${finalErrorMsg}`);
            fShowMessage(`Error: ${finalErrorMsg}`);
        })
        // === Server Function Call ===
        // Pass the DB key, Sheet Name, and the GM Screen Range Object
        .fSrvGetSheetRangeDataNTags('db', 'GMScreen', gmMonsterRangeDef);

} // END fRefreshMonsterData




// fTotalRereshOfAllAbilitiesAndAllGear ////////////////////////////////////////
// Purpose -> (Stage 1) Iterates through Ability/Gear table rows, validating the 'Ability'
//            cell content against the myCsListFSData cache. Clears rows with empty
//            'Ability' cells, invalid extracted IDs, or IDs not found in the list cache.
//            (Stage 2) For rows that passed Stage 1, fetches static definition data
//            from various caches, updates the grid, and triggers recalculations.
// Inputs  -> None (Relies on gUI state).
// Outputs -> (Promise<void>): Implicitly returns promise due to async calls like fShowMessage.
// Note    -> Stage 1 handles validation/clearing. Stage 2 populates valid rows.
async function fTotalRereshOfAllAbilitiesAndAllGear() {
    const funcName = "fTotalRereshOfAllAbilitiesAndAllGear";
    fMyConsoleLog(`🔄 ${funcName}: Starting Full Ability/Gear Refresh...`);

    // --- 1. Get Target Ranges & Validate Caches ---
    const abilityGearRanges = gUI.range?.entireAbiliyNGearTables;
    const listCache = gUI.myCsListFSData;
    const listCacheKey = 'gUI.myCsListFSData';
    const listColTag = 'AbilitiesNameID';
    let abilitiesNameIdColIndex = -1;
    let requiredCacheMissing = false;

    if (!Array.isArray(abilityGearRanges) || abilityGearRanges.length === 0) {
        fMyConsoleLog(`   -> ❌ Error: Range definition 'gUI.range.entireAbiliyNGearTables' is missing or empty.`);
        requiredCacheMissing = true;
    }
    if (!listCache || !listCache.text || !Array.isArray(listCache.text) ||
        !listCache.colTagsMap || typeof listCache.colTagsMap !== 'object') {
        fMyConsoleLog(`   -> ❌ Error: Required cache ${listCacheKey} is not loaded or invalid.`);
        requiredCacheMissing = true;
    } else {
        abilitiesNameIdColIndex = listCache.colTagsMap[listColTag];
        if (abilitiesNameIdColIndex === undefined || abilitiesNameIdColIndex === null || isNaN(abilitiesNameIdColIndex)) {
            fMyConsoleLog(`   -> ❌ Error: Column tag '${listColTag}' not found in ${listCacheKey}.colTagsMap.`);
            requiredCacheMissing = true;
        }
    }
    // Validate other necessary caches exist before starting the loop
    if (!gUI.dbAbilitiesFSData || !gUI.myKlMyAbilitiesFSData || !gUI.dbElementsFSData || !gUI.dbGearFSData) {
         fMyConsoleLog(`   -> ❌ Error: One or more required data caches (dbAbilities, myKlMyAbilities, dbElements, dbGear) are not loaded.`);
         requiredCacheMissing = true;
    }

    if (requiredCacheMissing) {
         await fShowMessage("Error: Cannot perform refresh due to missing cache or range definitions. Please reload.");
         return;
    }
    fMyConsoleLog(`   -> Validated ranges and caches. Found '${listColTag}' at index ${abilitiesNameIdColIndex}.`);

    // --- 2. Iterate Through Grid Ranges (Stage 1 & 2) ---
    let rowsProcessed = 0;
    let rowsCleared = 0;
    let rowsRefreshed = 0;
    let refreshErrors = 0;
    const nishRowResolved = fResolveRow('NishAtr_R'); // Resolve Nish row once

    for (const range of abilityGearRanges) {
        if (!fDoesObjectHaveR1C1R2C2Properties(range)) {
            console.warn(`${funcName}: Skipping invalid range object in entireAbiliyNGearTables:`, range);
            continue;
        }
        const resolved = fConvertsR1C1R2C2TagOrNumToIndices(range);
        if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
            console.warn(`${funcName}: Skipping range due to unresolved indices:`, range);
            continue;
        }
        const rMin = Math.min(resolved.r1, resolved.r2);
        const rMax = Math.max(resolved.r1, resolved.r2);

        // --- Iterate Through Rows in Range ---
        for (let r = rMin; r <= rMax; r++) {
            rowsProcessed++;
            let rowShouldBeCleared = false; // Flag for Stage 1 clearing
            let abilID = null; // Store valid ID if found

            // --- Stage 1: Validation & Clearing Logic ---
            const abilityNameId = fGetGridValue(r, 'Ability');

            if (!abilityNameId) {
                const sk1Val = fGetGridValue(r, 'Sk1');
                if (sk1Val !== '' && sk1Val !== undefined && sk1Val !== false) {
                    fMyConsoleLog(`   -> Row ${r}: Clearing due to empty 'Ability' cell.`);
                    rowShouldBeCleared = true;
                } else {
                    continue;
                }
            } else {
                abilID = fGetIDFromNameID(abilityNameId);
                if (!abilID) {
                    fMyConsoleLog(`   -> Row ${r}: Clearing due to invalid ID extracted from "${abilityNameId}".`);
                    rowShouldBeCleared = true;
                } else {
                    let foundInList = false;
                    const listCacheText = listCache.text;
                    for (let list_R = 0; list_R < listCacheText.length; list_R++) {
                        const listValue = listCacheText[list_R]?.[abilitiesNameIdColIndex];
                        if (abilID === fGetIDFromNameID(listValue)) {
                            foundInList = true;
                            break;
                        }
                    }
                    if (!foundInList) {
                        fMyConsoleLog(`   -> Row ${r}: Clearing because ID "${abilID}" (from "${abilityNameId}") not found in ${listCacheKey}.`);
                        rowShouldBeCleared = true;
                    }
                }
            }

            if (rowShouldBeCleared) {
                fHandleClearAbilityRow(r);
                rowsCleared++;
                continue; // Skip Stage 2 for this row
            }

            // --- Stage 2: Refresh Valid Row ---
            if (!abilID) {
                console.warn(`${funcName}: Row ${r} was not cleared, but abilID is missing. Skipping Stage 2.`);
                continue;
            }

            fMyConsoleLog(`   -> Row ${r}: Refreshing data for ID "${abilID}"...`);
            rowsRefreshed++;
            try {
                // Fetch Data
                const newSk1Typ = fGetVal_GUICache(abilID, 'SkTyp1', gUI.dbAbilitiesFSData) ?? '';
                const newSk1 = fGetVal_GUICache(abilID, 'TrainedSk1', gUI.myKlMyAbilitiesFSData) ?? '';
                const newAbilNameID = fGetVal_GUICache(abilID, 'Name_ID', gUI.dbElementsFSData) ?? '';
                const newSk2 = fGetVal_GUICache(abilID, 'TrainedSk2', gUI.myKlMyAbilitiesFSData) ?? '';
                const newSk2Typ = fGetVal_GUICache(abilID, 'SkTyp2', gUI.dbAbilitiesFSData) ?? '';
                const newVer = fGetVal_GUICache(abilID, 'Ver', gUI.myKlMyAbilitiesFSData) ?? '';
                const newNotes = fGetVal_GUICache(abilID, 'Notes', gUI.dbElementsFSData) ?? '';
                const newPic = fGetVal_GUICache(abilID, 'Pic', gUI.dbElementsFSData) ?? '';
                const newAct = fGetVal_GUICache(abilID, 'Act', gUI.myKlMyAbilitiesFSData) ?? '';
                const newDur = fGetVal_GUICache(abilID, 'Dur', gUI.myKlMyAbilitiesFSData) ?? '';
                const newRng = fGetVal_GUICache(abilID, 'Rng', gUI.myKlMyAbilitiesFSData) ?? '';
                const newMeta = fGetVal_GUICache(abilID, 'Meta', gUI.myKlMyAbilitiesFSData) ?? '';
                const newRgn = fGetVal_GUICache(abilID, 'Regain', gUI.myKlMyAbilitiesFSData) ?? '';
                const newGearName = fGetVal_GUICache(abilID, 'Name', gUI.dbGearFSData) ?? '';
                const newCrEach = fGetVal_GUICache(abilID, 'ItemCR', gUI.dbGearFSData) ?? '';
                const newIsArtifact = fGetVal_GUICache(abilID, 'IsArtifact', gUI.dbGearFSData) ?? false;
                const newAPEach = fGetVal_GUICache(abilID, 'AP', gUI.dbGearFSData) ?? '';

                // --- Debug Log for Row/Ability ---
                fMyConsoleLog(`   -> r="${r}", newAbilNameID="${newAbilNameID}"`);

                // --- Check if Item is Gear ---
                const isGearItem = gUI.dbGearFSData?.rowTagsMap?.hasOwnProperty(abilID);

                // Update Grid (Static Values)
                let setSuccess = true;
                setSuccess &&= fSetGridValue(r, 'Sk1Typ', newSk1Typ);
                setSuccess &&= fSetGridValue(r, 'Sk1', newSk1);
                if (r !== nishRowResolved) { // EXCEPTION: Do not update Ability name for NishAtr_R
                    setSuccess &&= fSetGridValue(r, 'Ability', newAbilNameID || abilityNameId);
                }
                setSuccess &&= fSetGridValue(r, 'Sk2', newSk2);
                setSuccess &&= fSetGridValue(r, 'Sk2Typ', newSk2Typ);
                setSuccess &&= fSetGridValue(r, 'Ver', newVer);
                setSuccess &&= fSetGridValue(r, 'Notes', newNotes);
                setSuccess &&= fSetGridValue(r, 'Pic', newPic);
                setSuccess &&= fSetGridValue(r, 'Act', newAct);
                setSuccess &&= fSetGridValue(r, 'Dur', newDur);
                setSuccess &&= fSetGridValue(r, 'Rng', newRng);
                setSuccess &&= fSetGridValue(r, 'MetaCost', newMeta);
                setSuccess &&= fSetGridValue(r, 'Regain', newRgn);

                // --- Update Gear-Specific Grid Values (Conditional) ---
                if (isGearItem) {
                    fMyConsoleLog(`      -> Item ${abilID} is Gear. Updating gear fields...`);
                    setSuccess &&= fSetGridValue(r, 'PossName', newGearName);
                    setSuccess &&= fSetGridValue(r, 'PossCrEa', newCrEach);
                    setSuccess &&= fSetGridValue(r, 'PossIsArtifact', newIsArtifact);
                    setSuccess &&= fSetGridValue(r, 'PossAPEa', newAPEach);
                } else {
                     fMyConsoleLog(`      -> Item ${abilID} is not Gear. Skipping gear field updates.`);
                }
                // --- End Conditional Gear Update ---

                if (!setSuccess) {
                     fMyConsoleLog(`      -> ⚠️ Error setting one or more grid values for row ${r}. Proceeding to recalc.`);
                     refreshErrors++;
                }

                // --- Recalculate Gear Line (Conditional) ---
                if (isGearItem) {
                    fMyConsoleLog(`      -> Running fRefreshGearLineCalcs for Gear Item...`);
                    const currentEnc = fGetGridValue(r, 'PossEnc');
                    const currentCr = fGetGridValue(r, 'PossCrTot');
                    const currentAp = fGetGridValue(r, 'PossAPTot');
                    if (!fRefreshGearLineCalcs(r, currentEnc, currentCr, currentAp)) {
                        fMyConsoleLog(`      -> ⚠️ Error occurred during fRefreshGearLineCalcs for row ${r}.`);
                        refreshErrors++;
                    }
                } else {
                    fMyConsoleLog(`      -> Skipping fRefreshGearLineCalcs.`);
                }

            } catch (error) {
                console.error(`${funcName}: Unexpected error processing row ${r} (ID: ${abilID}):`, error);
                fMyConsoleLog(`   -> ❌ Unexpected error during Stage 2 for row ${r}: ${error.message}`);
                refreshErrors++;
            }
        } // End row loop (r)
    } // End range loop

    // --- 3. Overall Recalculation & Save (Outside Loop) ---
    fMyConsoleLog(`   -> Refresh loop complete. Triggering final calculations and save...`);
    await fCalculatesEnc_MR_AP(); // Update overall totals
    fHandleAutoSaveTextToFirestore(); // Save all changes

    fMyConsoleLog(`✅ ${funcName} Complete. Processed: ${rowsProcessed}, Cleared: ${rowsCleared}, Refreshed: ${rowsRefreshed}${refreshErrors > 0 ? ` (${refreshErrors} errors)` : ''}.`);

} // END fTotalRereshOfAllAbilitiesAndAllGear




// ==========================================================================
// === Firestore Text Read/Write     (End of Header Button Click) ===
// ==========================================================================




// fHandleAutoSaveTextToFirestore /////////////////////////////////////////////////////
// Purpose -> Orchestrates the background auto-saving of gUI.arr and gUI.characterInfo
//            to Firestore within the user's email collection.
//            Initiates server call to fSrvSaveTurboDataToFirestore.
// Inputs  -> None.
// Outputs -> None (Initiates async server call).
function fHandleAutoSaveTextToFirestore() {
    fMyConsoleLog("💾 Handling Auto-Save Data (Grid & CharInfo)...");

    // === 1. Check if essential data exists ===
    if (!gUI.arr || !Array.isArray(gUI.arr) || gUI.arr.length === 0) {
        fMyConsoleLog("   -> No grid data (gUI.arr) found to save. Skipping server call.");
        return; // Nothing to save if grid is empty
    }
    if (!gUI.characterInfo || typeof gUI.characterInfo !== 'object') {
         fMyConsoleLog("   -> No character info (gUI.characterInfo) found to save. Skipping server call.");
         // Optional: Consider if saving should proceed with just arr if charInfo is missing
         return;
    }
    if (!gIndex.CSID || typeof gIndex.CSID !== 'string') {
         console.error("fHandleAutoSaveTextToFirestore: Missing gIndex.CSID on client.");
         fMyConsoleLog("   -> ❌ Auto-save aborted: Missing CS ID.");
         return;
    }
    if (!gIndex.Email || typeof gIndex.Email !== 'string') {
         console.error("fHandleAutoSaveTextToFirestore: Missing gIndex.Email on client.");
         fMyConsoleLog("   -> ❌ Auto-save aborted: Missing User Email.");
         return;
    }

    // === 2. Call Server Function ===
    fMyConsoleLog("   -> Calling server function fSrvSaveTurboDataToFirestore...");
    google.script.run
        .withSuccessHandler(fHandleAutoSaveToFirestoreSuccess)
        .withFailureHandler(fHandleAutoSaveToFirestoreFailure)
        .fSrvSaveTurboDataToFirestore(gIndex, gUI.arr, gUI.characterInfo); // Pass email, csId, arr, charInfo

} // END fHandleAutoSaveTextToFirestore




// fHandleAutoSaveToFirestoreSuccess //////////////////////////////////////////////////////
// Purpose -> Success callback for the fSrvSaveTurboTextAndURLtoNamesToFirestore server call.
//            Logs success and provides minimal UI feedback.
// Inputs  -> result (Object): The object returned from the server (expected: { success: true }).
// Outputs -> None.
function fHandleAutoSaveToFirestoreSuccess(result) {
    // Basic check if server explicitly indicated success (optional)
    if (result && result.success) {
        fMyConsoleLog("   -> ✅ Auto-save successful (Server confirmed).");
    } else {
        // Log even if server didn't return explicit success, as long as failure handler wasn't called
        fMyConsoleLog("   -> ✅ Auto-save call completed (Server response did not explicitly indicate failure).");
        // If server returns {success: false, message: '...'}, failure handler should catch it.
    }

    // --- REMOVED Subtle UI Feedback (Flash icon) ---

} // END fHandleAutoSaveToFirestoreSuccess




// fHandleAutoSaveToFirestoreFailure //////////////////////////////////////////////////////
// Purpose -> Failure callback for the fSrvSaveTurboTextAndURLtoNamesToFirestore server call.
//            Logs the error comprehensively to the console. Avoids disruptive user messages.
// Inputs  -> error (Error Object): The error object from the failed server call.
// Outputs -> None.
function fHandleAutoSaveToFirestoreFailure(error) {
    const errorMsg = `Auto-save to Firestore failed: ${error?.message || 'Unknown error'}`;
    console.error("❌ fHandleAutoSaveToFirestoreFailure:", errorMsg, error); // Log detailed error object
    fMyConsoleLog(`   -> ❌ ${errorMsg}`); // Log simplified message via fMyConsoleLog

    // --- Avoid Disruptive Messages ---
    // Generally, do NOT show fShowMessage here for background saves unless absolutely
    // critical or after repeated failures, as it interrupts the user experience.
    // If needed, implement a counter or flag for repeated failures.
    // Example (Conditional Message):
    // gUI.autoSaveFailureCount = (gUI.autoSaveFailureCount || 0) + 1;
    // if (gUI.autoSaveFailureCount > 3) {
    //     fShowMessage("Warning: Repeatedly failed to auto-save grid text.").catch(e => {});
    //     gUI.autoSaveFailureCount = 0; // Reset counter
    // }

} // END fHandleAutoSaveToFirestoreFailure




// fSaveGoogelSheetToFSData ///////////////////////////////////////////////////////
// Purpose -> Handles the "Designer" -> "Save SS Sheet & Ver" menu action. Prompts
//            user for Workbook abbreviation and sheet name, calls server to load
//            data/tags from the specified sheet, then calls server to save the
//            data to Firestore using appropriate collection/document paths.
// Inputs  -> None.
// Outputs -> (Promise<void>): Resolves after completing actions or handling errors.
async function fSaveGoogelSheetToFSData() {
    const funcName = "fSaveGoogelSheetToFSData";
    fMyConsoleLog(`⚙️ Menu Action: ${funcName} Triggered...`);
    const validWorkbooks = ['db', 'mastercs', 'masterkl', 'mycs', 'mykl'];

    // --- 1. Check Designer Mode ---
    if (!gUI.isDesignerMode) {
        fMyConsoleLog("   -> Action blocked: Designer mode is not active.");
        await fShowMessage("❌ This action requires Designer Mode to be enabled.");
        return;
    }

    // --- 2. Prompt for Workbook Name ---
    const workbookPromptText = "Please choose a Google Workbook from 'DB', 'MasterCS', 'MasterKL', 'MyCS', 'MyKL'";
    let workbookAbr = window.prompt(workbookPromptText);
    if (!workbookAbr) {
        fMyConsoleLog("   -> User cancelled workbook name prompt.");
        return; // Exit if user cancelled
    }
    workbookAbr = workbookAbr.trim().toLowerCase(); // Standardize to lowercase
    if (!validWorkbooks.includes(workbookAbr)) {
        fMyConsoleLog(`   -> User entered invalid workbook: "${workbookAbr}"`);
        await fShowMessage(`❌ Invalid Workbook. Must be one of: ${validWorkbooks.join(', ')}`);
        return;
    }
    fMyConsoleLog(`   -> User selected Workbook Abr: "${workbookAbr}"`);


    // --- 3. Prompt for Sheet Name ---
    const sheetName = window.prompt("Enter Google Workbook Sheet (Tab) Name:");
    if (!sheetName) {
        fMyConsoleLog("   -> User cancelled sheet name prompt.");
        return; // Exit if user cancelled
    }
    const trimmedSheetName = sheetName.trim();
    if (!trimmedSheetName) {
        fMyConsoleLog("   -> User entered an empty sheet name.");
        await fShowMessage("❌ Sheet name cannot be empty.");
        return;
    }
    fMyConsoleLog(`   -> User entered Sheet Name: "${trimmedSheetName}"`);


    // --- 4. Validate Game Version, Email, & CSID (needed for lookups/paths) ---
    if (!gIndex.GameVer || typeof gIndex.GameVer !== 'string' || gIndex.GameVer.trim() === '') {
        fMyConsoleLog("   -> Cannot proceed: gIndex.GameVer is missing or invalid on client.");
        await fShowMessage("❌ Error: Game Version is missing.");
        return;
    }
     if (!gIndex.CSID || typeof gIndex.CSID !== 'string') {
         fMyConsoleLog("   -> Cannot proceed: gIndex.CSID is missing or invalid on client.");
         await fShowMessage("❌ Error: Character Sheet ID is missing.");
         return;
    }
     if (!gIndex.Email || typeof gIndex.Email !== 'string') {
         fMyConsoleLog("   -> Cannot proceed: gIndex.Email is missing or invalid on client.");
         await fShowMessage("❌ Error: User Email is missing.");
         return;
    }
    fMyConsoleLog(`   -> Using Game Version: ${gIndex.GameVer}`);
    fMyConsoleLog(`   -> Using CSID: ${gIndex.CSID}`);
    fMyConsoleLog(`   -> Using Email: ${gIndex.Email}`);


    // --- 5. Call Server to Load Data & Tags ---
    fMyConsoleLog(`   -> Calling fSrvLoadFullGoogleSheetAndTags for workbook: "${workbookAbr}", sheet: "${trimmedSheetName}"...`);
    const loadingMsg = fShowMessage(`⏳ Loading data for ${workbookAbr} -> "${trimmedSheetName}"...`);

    try {
        const loadedData = await new Promise((resolve, reject) => {
            google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .fSrvLoadFullGoogleSheetAndTags(workbookAbr, trimmedSheetName, gIndex.CSID);
        });

        // --- 6. Handle Load Success ---
        fHideMessage();
        fMyConsoleLog(`   -> Successfully loaded data from sheet "${trimmedSheetName}" in workbook "${workbookAbr}".`);
        if (!loadedData || typeof loadedData !== 'object' || !loadedData.ColTags || !loadedData.RowTags || !loadedData.sheetText2D) {
            console.error("Invalid data structure received from fSrvLoadFullGoogleSheetAndTags:", loadedData);
            throw new Error("Received invalid data structure from server after loading sheet.");
        }

        // --- 7. Call Server to Save Data to Firestore ---
        fMyConsoleLog(`   -> Calling fSrvSaveFullSheetTextAndTagsToFirestore for ${workbookAbr} -> ${trimmedSheetName}...`);
        const savingMsg = fShowMessage(`💾 Saving data for ${workbookAbr} -> ${trimmedSheetName} to Firestore...`);

        const saveResult = await new Promise((resolve, reject) => {
            google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .fSrvSaveFullSheetTextAndTagsToFirestore(
                    gIndex,             // gIndex
                    workbookAbr,        // workbookAbr
                    trimmedSheetName,   // sheetName
                    loadedData          // data
                );
        });

        // --- 8. Handle Save Result ---
        fHideMessage();
        if (saveResult && saveResult.success) {
            fMyConsoleLog("   -> ✅ Successfully saved sheet data to Firestore.");
            await fShowMessage(`✅ Successfully saved data for ${workbookAbr} -> "${trimmedSheetName}" (Version ${gIndex.GameVer}) to Firestore.`);
        } else {
            const saveErrorMsg = saveResult?.message || "Unknown error saving to Firestore.";
            fMyConsoleLog(`   -> ❌ Firestore Save Failed: ${saveErrorMsg}`);
            await fShowMessage(`❌ Failed to save data to Firestore: ${saveErrorMsg}`);
        }

    } catch (error) {
        // --- 9. Handle Load or Save Errors ---
        fHideMessage();
        const errorMsg = `Error during Full Sheet Save process: ${error?.message || error}`;
        console.error(`${funcName} Error:`, error);
        fMyConsoleLog(`   -> ❌ ${errorMsg}`);
        await fShowMessage(`❌ ${errorMsg}`);
    }

} // END fSaveGoogelSheetToFSData




// fGetVal_FSData //////////////////////////////////////////////////////////////////
// Purpose -> Retrieves a value from an FSData object's text property using original
//            sheet tags or absolute indices. Handles index adjustment based on
//            FSData.r1/c1 and tag lookup using FSData.rowTagsMap/colTagsMap.
// Inputs  -> rRef (String|Number): Row tag or 0-based absolute index from original sheet.
//         -> cRef (String|Number): Column tag or 0-based absolute index from original sheet.
//         -> FSData (Object): The object returned by fSrvGetFirestoreFSData, structured as
//                             { r1, c1, colTagsMap, rowTagsMap, text }.
// Outputs -> (Any | undefined): The value found at the resolved relative position within
//                              FSData.text, or undefined if not found or on error.
function fGetVal_FSData(rRef, cRef, FSData) {
    const funcName = "fGetVal_FSData";

    // === 1. Validate FSData Object ===
    if (!FSData || typeof FSData !== 'object' ||
        typeof FSData.r1 !== 'number' || typeof FSData.c1 !== 'number' ||
        typeof FSData.rowTagsMap !== 'object' || typeof FSData.colTagsMap !== 'object' ||
        !FSData.hasOwnProperty('text')) // Check if 'text' property exists
    {
        console.warn(`${funcName}: Invalid or incomplete FSData object provided.`);
        fMyConsoleLog(`⚠️ ${funcName}: Invalid FSData input.`);
        return undefined;
    }

    const { r1, c1, rowTagsMap, colTagsMap, text } = FSData;
    let relative_r = NaN;
    let relative_c = NaN;

    // === 2. Resolve Row Reference to Relative Index ===
    if (typeof rRef === 'string') {
        if (rowTagsMap.hasOwnProperty(rRef)) {
            relative_r = rowTagsMap[rRef];
        } else {
            // console.warn(`${funcName}: Row tag "${rRef}" not found in FSData.rowTagsMap.`);
            // fMyConsoleLog(`⚠️ ${funcName}: Row tag "${rRef}" not found.`); // Can be noisy
            return undefined; // Tag not found in the relative map
        }
    } else if (typeof rRef === 'number' && rRef >= r1) {
        relative_r = rRef - r1; // Adjust absolute index to relative
    } else {
        // console.warn(`${funcName}: Invalid row reference provided: ${rRef}.`);
        // fMyConsoleLog(`⚠️ ${funcName}: Invalid row reference: ${rRef}.`); // Can be noisy
        return undefined; // Invalid input type or index below start row
    }

    // === 3. Resolve Column Reference to Relative Index ===
    if (typeof cRef === 'string') {
        if (colTagsMap.hasOwnProperty(cRef)) {
            relative_c = colTagsMap[cRef];
        } else {
            // console.warn(`${funcName}: Col tag "${cRef}" not found in FSData.colTagsMap.`);
            // fMyConsoleLog(`⚠️ ${funcName}: Col tag "${cRef}" not found.`); // Can be noisy
            return undefined; // Tag not found
        }
    } else if (typeof cRef === 'number' && cRef >= c1) {
        relative_c = cRef - c1; // Adjust absolute index to relative
    } else {
        // console.warn(`${funcName}: Invalid col reference provided: ${cRef}.`);
        // fMyConsoleLog(`⚠️ ${funcName}: Invalid col reference: ${cRef}.`); // Can be noisy
        return undefined; // Invalid input type or index below start col
    }

    // === 4. Validate Resolved Relative Indices ===
    if (isNaN(relative_r) || isNaN(relative_c) || relative_r < 0 || relative_c < 0) {
        console.warn(`${funcName}: Failed to resolve valid relative indices for (${rRef}, ${cRef}). Resolved to: r=${relative_r}, c=${relative_c}.`);
        fMyConsoleLog(`⚠️ ${funcName}: Failed to resolve valid relative indices.`);
        return undefined;
    }

    // === 5. Retrieve Value from FSData.text based on its structure ===
    let value = undefined;
    const dataType = Array.isArray(text)
                   ? (Array.isArray(text[0]) ? '2D' : '1D')
                   : '0D'; // 0D for single value

    // fMyConsoleLog(`   -> ${funcName}: Ref=(${rRef}, ${cRef}), Rel=(${relative_r}, ${relative_c}), DataType=${dataType}`); // Debugging

    try {
        switch (dataType) {
            case '0D': // Single value result
                // Only valid if relative indices are both 0
                if (relative_r === 0 && relative_c === 0) {
                    value = text;
                } else {
                    fMyConsoleLog(`   -> ${funcName}: Indices (${relative_r}, ${relative_c}) out of bounds for 0D data.`);
                }
                break;

            case '1D': // Single row or single column
                // Determine if it's effectively a row (r1=r2) or col (c1=c2) based on maps/indices
                // We infer based on whether relative_r OR relative_c must be 0.
                if (relative_r === 0 && relative_c >= 0 && relative_c < text.length) {
                    // Treat as single row data, relative_c is the index
                    value = text[relative_c];
                } else if (relative_c === 0 && relative_r >= 0 && relative_r < text.length) {
                    // Treat as single column data, relative_r is the index
                    value = text[relative_r];
                } else {
                    fMyConsoleLog(`   -> ${funcName}: Indices (${relative_r}, ${relative_c}) out of bounds for 1D data (length ${text.length}).`);
                }
                break;

            case '2D': // Standard 2D array
                if (relative_r >= 0 && relative_r < text.length && // Check row bounds
                    text[relative_r] &&                             // Check if row exists
                    relative_c >= 0 && relative_c < text[relative_r].length) // Check col bounds
                {
                    value = text[relative_r][relative_c];
                } else {
                     fMyConsoleLog(`   -> ${funcName}: Indices (${relative_r}, ${relative_c}) out of bounds for 2D data (max [${text.length - 1}, ${text[0]?.length - 1}]).`);
                }
                break;

            default: // Should not happen
                fMyConsoleLog(`   -> ${funcName}: Unknown data type encountered.`);
        }
    } catch (e) {
        console.error(`${funcName}: Error accessing FSData.text at [${relative_r}][${relative_c}]`, e);
        fMyConsoleLog(`⚠️ ${funcName}: Error accessing text data.`);
        value = undefined;
    }

    // fMyConsoleLog(`   -> ${funcName}: Returning value: ${value}`); // Debugging
    return value;

} // END fGetVal_FSData




// ==========================================================================
// === Initialization & Setup Functions     (End of Firestore Text Read/Write) ===
// ==========================================================================




// fSetupGridClickListeners ////////////////////////////////////////////////////////
// Purpose -> Attaches delegated 'click' and 'change' event listeners to the main
//            grid container (#grid) to handle user interactions like cell clicks,
//            checkbox toggles, URL clicks, and dropdown changes.
// Inputs  -> gridElement (HTMLElement): The grid container element.
// Outputs -> None (Attaches event listeners).
function fSetupGridClickListeners(gridElement) {
    // Validate input
    if (!gridElement) {
        console.error("fSetupGridClickListeners: Cannot setup listeners - Grid element not provided.");
        return;
    }

    fMyConsoleLog("🖱️ Setting up Grid Click & Change Listeners...");

    // Delegated 'click' listener (handles cell clicks, checkboxes, URLs, etc.)
    gridElement.addEventListener('click', fHandleGridClick);

    // Delegated 'change' listener (specifically for dropdowns within grid cells)
    gridElement.addEventListener('change', (event) => {
        // Check if the changed element is one of our grid dropdowns
        if (event.target.tagName === 'SELECT' && event.target.classList.contains('grid-dropdown')) {
            fHandleDropdownChange(event); // Call the dropdown change handler
        }
    });

    fMyConsoleLog("✅ Grid Click & Change Listeners Attached.");

} // END fSetupGridClickListeners




// fSetupGridHoverListeners ////////////////////////////////////////////////////////
// Purpose -> Attaches delegated 'mouseover' and 'mouseout' event listeners to the
//            grid container (#grid) to handle showing and hiding cell tooltips.
// Inputs  -> gridElement (HTMLElement): The grid container element.
// Outputs -> None (Attaches event listeners).
function fSetupGridHoverListeners(gridElement) {
    // Validate input
    if (!gridElement) {
        console.error("fSetupGridHoverListeners: Cannot setup hover listeners - Grid element not provided.");
        return;
    }

    fMyConsoleLog("🖱️ Setting up Grid Hover Listeners for Tooltips...");

    // Use mouseover/mouseout for better event delegation with cell children
    gridElement.addEventListener('mouseover', fHandleCellHover); // Handle entering a cell area
    gridElement.addEventListener('mouseout', fHandleCellMouseOut); // Handle leaving a cell area

    fMyConsoleLog("✅ Grid Hover Listeners Attached.");

} // END fSetupGridHoverListeners




// fHideImageModal /////////////////////////////////////////////////////////////////
// Purpose -> Hides the image modal element and clears its image source.
// Inputs  -> None (Uses gUI.modalElement, gUI.modalImageElement).
// Outputs -> None (Modifies modal DOM element styles and attributes).
function fHideImageModal() {
    // Check if modal elements are cached/exist
    if (!gUI.modalElement || !gUI.modalImageElement) return;

    // Hide the main modal container
    gUI.modalElement.style.display = 'none';
    // Clear the image source to prevent showing old image briefly on next open
    gUI.modalImageElement.src = '';
} // END fHideImageModal




// fSetupModalListeners ////////////////////////////////////////////////////////////
// Purpose -> Adds click event listeners to the image modal's close button
//            (#modal-close-btn) and backdrop (#modal-backdrop) to hide the modal.
// Inputs  -> None (Uses gUI.modalCloseBtn, gUI.modalBackdrop).
// Outputs -> None (Attaches event listeners).
function fSetupModalListeners() {
    // Check if modal elements required for listeners are cached/exist
    if (!gUI.modalCloseBtn || !gUI.modalBackdrop) {
         fMyConsoleLog("⚠️ Cannot setup modal listeners: Modal close button or backdrop not found.");
         console.warn("Modal listeners not set up.");
         return;
    }

    fMyConsoleLog("🖱️ Setting up Modal Listeners...");

    // Add listener to close button
    gUI.modalCloseBtn.addEventListener('click', fHideImageModal);

    // Add listener to backdrop (closes modal if background is clicked)
    gUI.modalBackdrop.addEventListener('click', fHideImageModal);

    fMyConsoleLog("✅ Modal Listeners Attached.");

} // END fSetupModalListeners




// fSetupMenuInteractivity /////////////////////////////////////////////////////////
// Purpose -> Orchestrates the setup of all menu bar and sidebar interactivity,
//            including button clicks, dropdown toggles, submenu hover behavior,
//            delegated menu action clicks, and sidebar header/close buttons.
// Inputs  -> None (Gets elements by ID).
// Outputs -> None (Attaches various event listeners).
function fSetupMenuInteractivity() {
    fMyConsoleLog("⚙️ Setting up Menu & Sidebar Interactivity...");
    // === Get Element References ===
    const menuBar = document.getElementById('menu-bar');
    const btnNish = document.getElementById('btn-nish');
    const btnRoll = document.getElementById('btn-roll'); // Keep reference for sidebar button
    const btnFree = document.getElementById('btn-free');
    const btnLuck = document.getElementById('btn-luck');
    const btnGame = document.getElementById('btn-game-menu');
    const dropdownGame = document.getElementById('dropdown-game');
    const btnGear = document.getElementById('btn-gear-menu');
    const dropdownGear = document.getElementById('dropdown-gear');
    const btnData = document.getElementById('btn-data-menu');
    const dropdownData = document.getElementById('dropdown-data');
    const btnDesigner = document.getElementById('btn-designer-menu');     
    const dropdownDesigner = document.getElementById('dropdown-designer'); 
    const sidebarCloseBtn = document.getElementById('sidebar-close-btn');
    const sidebarRollBtn = document.getElementById('sidebar-roll-btn');
    const sidebarRefreshLogBtn = document.getElementById('sidebar-refresh-log-btn');

    // === Validate Elements ===
    if (!menuBar || !btnNish || !btnRoll || !btnFree || !btnLuck ||
        !btnGame || !dropdownGame || !btnGear || !dropdownGear ||
        !btnData || !dropdownData ||
        !btnDesigner || !dropdownDesigner ||
        !sidebarCloseBtn || !sidebarRollBtn || !sidebarRefreshLogBtn)
    {
        console.error("❌ Could not find all required menu/sidebar elements for interactivity setup.");
        // Log specific missing elements for easier debugging
        if(!menuBar) console.error("     -> Missing: #menu-bar");
        if(!btnNish) console.error("     -> Missing: #btn-nish");
        if(!btnRoll) console.error("     -> Missing: #btn-roll");
        if(!btnFree) console.error("     -> Missing: #btn-free");
        if(!btnLuck) console.error("     -> Missing: #btn-luck");
        if(!btnGame) console.error("     -> Missing: #btn-game-menu");
        if(!dropdownGame) console.error("     -> Missing: #dropdown-game");
        if(!btnGear) console.error("     -> Missing: #btn-gear-menu");
        if(!dropdownGear) console.error("     -> Missing: #dropdown-gear");
        if(!btnData) console.error("     -> Missing: #btn-data-menu");
        if(!dropdownData) console.error("     -> Missing: #dropdown-data");
        if(!btnDesigner) console.error("     -> Missing: #btn-designer-menu");
        if(!dropdownDesigner) console.error("     -> Missing: #dropdown-designer");
        if(!sidebarCloseBtn) console.error("     -> Missing: #sidebar-close-btn");
        if(!sidebarRollBtn) console.error("     -> Missing: #sidebar-roll-btn");
        if(!sidebarRefreshLogBtn) console.error("     -> Missing: #sidebar-refresh-log-btn");
        return; // Stop setup if essential elements are missing
    }

    // === Attach Listeners ===
    // Main menu bar button click handlers (Nish, Roll, Free, Luck, Game, Gear)
    fSetupMenuButtonListeners(btnNish, btnRoll, btnFree, btnLuck, btnGame, dropdownGame, btnGear, dropdownGear);

    // --- Specific Listener for Data Menu Button ---
    if (btnData && dropdownData) {
        btnData.addEventListener('click', (event) => {
            event.stopPropagation(); // Prevent window listener from closing it immediately
            const currentlyShown = dropdownData.classList.contains('show');
            fCloseAllDropdowns(); // Close any other open menus
            // Toggle the Data dropdown
            if (!currentlyShown) {
                dropdownData.classList.add('show');
            }
        });
    }

    // --- Specific Listener for Designer Menu Button --- <<< MODIFIED BLOCK >>>
    if (btnDesigner && dropdownDesigner) {
        btnDesigner.addEventListener('click', (event) => {
            event.stopPropagation();
            fMyConsoleLog("🖱️ Designer Menu Button Clicked...");

            // Only show the dropdown if designer mode is already enabled.
            // No need to re-prompt here. Re-prompting will happen per-action later.
            if (gUI.isDesignerMode) {
                const currentlyShown = dropdownDesigner.classList.contains('show');
                fCloseAllDropdowns(); // Close others
                if (!currentlyShown) {
                    dropdownDesigner.classList.add('show');
                    fMyConsoleLog("   -> Showing Designer dropdown.");
                }
            } else {
                // This case shouldn't happen if the button is only visible when mode is true,
                // but as a fallback, ensure the dropdown remains closed.
                fMyConsoleLog("   -> Designer mode is not active. Button click ignored.");
                fCloseAllDropdowns();
            }
        });
    }
    // --- END MODIFIED BLOCK ---

    // Window listener to close dropdowns on outside click
    fSetupWindowClickListener();
    // Delegated listener for actions within dropdown menus
    fSetupMenuActionClickListener(menuBar);
    // Listeners for submenu hover behavior
    fSetupSubMenuHover(menuBar);
    // Listener for the sidebar close button
    sidebarCloseBtn.addEventListener('click', fHideSidebar);

    // --- Sidebar Header Button Listeners ---
    // Sidebar Roll Button (simulates click on main Roll button)
    sidebarRollBtn.addEventListener('click', () => {
        fMyConsoleLog("🖱️ Sidebar Roll Button Clicked -> Simulating Main Roll Button Click...");
        btnRoll.click(); // Trigger the click handler of the main #btn-roll
    });
    // Sidebar Refresh Log Button (calls function to resend log)
    sidebarRefreshLogBtn.addEventListener('click', () => {
        fMyConsoleLog("🖱️ Sidebar Refresh Log Button Clicked -> Calling fSendLogToGMScreenAndPS...");
        fSendLogToGMScreenAndPS(); // Call the function to resend logs
    });
    // --- End Sidebar Listeners ---

    fMyConsoleLog("✅ Menu & Sidebar Interactivity Setup Done");
} // END fSetupMenuInteractivity




// ==========================================================================
// === Initial Data Load      (End of Initialization & Setup Functions) ===
// ==========================================================================




// fOnCSGameDataLoaded ///////////////////////////////////////////////////////////////////
// Purpose -> Callback executed after initial Sheet data retrieval (fSrvReadCSGameSheet).
//            Validates sheet data, checks Firestore for overriding gUI.arr data,
//            then initiates the fetching of background caches (which now includes
//            populating character info) and subsequent grid rendering.
// Inputs  -> data (Object): The structured data object from the server { arr, format, notesArr }.
// Outputs -> None (Initiates subsequent data loading and UI rendering).
async function fOnCSGameDataLoaded(data) { // <<< MADE ASYNC
    fMyConsoleLog("✅ Initial Sheet Data received from server");

    // === 1. Validate and Store Initial Sheet Data ===
    const isSheetDataValid = fStoreAndValidateData(data);
    if (!isSheetDataValid) {
        fMyConsoleLog("❌ Initial sheet data invalid or empty. Halting load process.");
        // fStoreAndValidateData shows messages/logs errors
        return;
    }
    fMyConsoleLog("   -> Stored initial data from Sheet into gUI.");

    // === 2. Check Firestore for Overriding gUI.arr Data ===
    fMyConsoleLog("⚙️ Checking Firestore for saved Grid (gUI.arr) data...");
    if (!gIndex.Email || !gIndex.CSID) {
        fMyConsoleLog("   -> ⚠️ Skipping Firestore gUI.arr check: Missing Email or CSID.");
        // --->>> Setup UI elements needed before cache fetch (Tooltip, Modal) <<<---
        fSetupTooltipAndModal(); // Setup tooltip/modal refs needed by hover listeners etc.

        // --->>> Call Background Cache Fetch (which now populates char info) <<<---
        fMyConsoleLog("   -> Proceeding to fetch background caches (skipped Firestore arr check)...");
        const cachesLoaded = await fBulkCacheFSData(); // Await the cache loading process

        // --->>> Render Grid (if caches loaded) <<<---
        if (cachesLoaded) {
            fRenderGridWithFinalData(); // Render only if caches (and char info population) succeed
        }
        // If cachesLoaded is false, fBulkCacheFSData already showed error and halted.
        return; // Exit this path
    }

    // If Email/CSID exist, proceed with Firestore check for gUI.arr
    google.script.run
        .withSuccessHandler(async (firestoreResponse) => { // <<< MAKE ASYNC
            let usingFirestoreArr = false;
            if (firestoreResponse && firestoreResponse.success === true && firestoreResponse.firestoreArr) {
                // Firestore data exists and is valid
                fMyConsoleLog("   -> ✅ Firestore Grid data found. Overwriting gUI.arr.");
                gUI.arr = firestoreResponse.firestoreArr; // Use unpacked 2D array
                usingFirestoreArr = true;
            } else {
                // Firestore data not found or error during check
                const reason = firestoreResponse?.message || "Reason unknown.";
                fMyConsoleLog(`   -> ℹ️ Firestore Grid check returned false (${reason}). Using Sheet data for gUI.arr.`);
                // gUI.arr already contains Sheet data, no action needed
            }

            // === 3. Proceed with UI Setup, Cache Fetch & Grid Render ===
            fSetupTooltipAndModal(); // Setup tooltip/modal refs

            fMyConsoleLog("   -> Proceeding to fetch background caches...");
            const cachesLoaded = await fBulkCacheFSData(); // Await the cache loading process

            if (cachesLoaded) {
                fRenderGridWithFinalData(); // Render only if caches (and char info population) succeed
            }
            // If cachesLoaded is false, fBulkCacheFSData already showed error and halted.

        })
        .withFailureHandler(async (error) => { // <<< MAKE ASYNC
            // Handle transport errors calling fSrvCheckAndLoadFirestoreGUIarrAs2D
            const errorMsg = `Error checking Firestore for Grid data: ${error.message}`;
            console.error(errorMsg, error);
            fMyConsoleLog(`   -> ❌ ${errorMsg}. Using Sheet data for gUI.arr as fallback.`);

            // --->>> Setup UI elements needed before cache fetch (Tooltip, Modal) <<<---
            fSetupTooltipAndModal(); // Setup tooltip/modal refs needed by hover listeners etc.

            // --->>> Call Background Cache Fetch (using Sheet arr data) <<<---
            fMyConsoleLog("   -> Proceeding to fetch background caches (Firestore arr check failed)...");
            const cachesLoaded = await fBulkCacheFSData(); // Await the cache loading process

            // --->>> Render Grid (if caches loaded) <<<---
            if (cachesLoaded) {
                fRenderGridWithFinalData(); // Render only if caches (and char info population) succeed
            }
            // If cachesLoaded is false, fBulkCacheFSData already showed error and halted.
        })
        .fSrvCheckAndLoadFirestoreGUIarrAs2D(gIndex); // Pass Email and CSID

} // END fOnCSGameDataLoaded




// fBulkCacheFSData //////////////////////////////////////////////////////
// Purpose -> Ensures necessary Firestore cache documents exist (creating MyCS/MyKL ones
//            from Sheets if missing) and then loads all required caches from Firestore
//            into gUI. Populates gUI.characterInfo from the loaded RaceClass cache.
// Inputs  -> None.
// Outputs -> (Promise<Boolean>): Resolves true if all critical steps succeed, false otherwise.
async function fBulkCacheFSData() {
    const funcName = "fBulkCacheFSData";
    fMyConsoleLog(`⚙️ ${funcName}: Verifying/Loading background data caches...`);

    // Define Cache Configurations
    const dbCaches = [
      { workbookAbr: 'DB', sheetName: 'Elements', gUIKey: 'dbElementsFSData' },
      { workbookAbr: 'DB', sheetName: 'Abilities', gUIKey: 'dbAbilitiesFSData' },
      { workbookAbr: 'DB', sheetName: 'Crit',      gUIKey: 'dbCritFSData' },
      { workbookAbr: 'DB', sheetName: 'Gear',      gUIKey: 'dbGearFSData' }
    ];
    const userCaches = [
      { workbookAbr: 'MyCS', sheetName: 'RaceClass',    gUIKey: 'myCsRaceClassFSData' },
      { workbookAbr: 'MyCS', sheetName: 'List',    gUIKey: 'myCsListFSData' },
      { workbookAbr: 'MyKL', sheetName: 'MyAbilities', gUIKey: 'myKlMyAbilitiesFSData' }
    ];
    const allCaches = [...dbCaches, ...userCaches];

    try { // Wrap entire operation

        // === Phase 1: Check & Create MyCS/MyKL Caches (if needed) ===
        fMyConsoleLog(`   -> Phase 1: Verifying MyCS/MyKL document existence in Firestore...`);
        const checkPromises = userCaches.map(config => {
            return new Promise((resolve, reject) => {
                google.script.run
                    .withSuccessHandler(exists => resolve({ exists: exists, config: config }))
                    .withFailureHandler(error => reject({ error: error, config: config }))
                    .fSrvVerifyFirestorePathExists(config.workbookAbr, config.sheetName, gIndex);
            });
        });

        const checkResults = await Promise.allSettled(checkPromises);
        const missingUserCaches = [];

        // Process existence check results
        for (const result of checkResults) {
            if (result.status === 'fulfilled') {
                if (result.value.exists === false) {
                    missingUserCaches.push(result.value.config);
                    fMyConsoleLog(`      -> Document for ${result.value.config.gUIKey} NOT found. Queued for creation.`);
                } else {
                     fMyConsoleLog(`      -> Document for ${result.value.config.gUIKey} exists.`);
                }
            } else {
                // Failure during existence check itself
                const config = result.reason.config;
                const error = result.reason.error;
                throw new Error(`Failed to check existence for ${config.gUIKey}: ${error.message || 'Unknown error'}`);
            }
        }

        // Create missing user caches if any were identified
        if (missingUserCaches.length > 0) {
            fMyConsoleLog(`   -> Creating ${missingUserCaches.length} missing MyCS/MyKL documents...`);
            const createPromises = missingUserCaches.map(config => {
                return new Promise(async (resolve, reject) => { // Make inner function async
                    try {
                        fMyConsoleLog(`      -> Loading Sheet: ${config.workbookAbr}/${config.sheetName}`);
                        const loadedData = await new Promise((res, rej) => {
                            google.script.run
                                .withSuccessHandler(res)
                                .withFailureHandler(rej)
                                .fSrvLoadFullGoogleSheetAndTags(config.workbookAbr, config.sheetName, gIndex.CSID);
                        });

                        // Basic validation of loadedData structure
                         if (!loadedData || typeof loadedData !== 'object' || !loadedData.ColTags || !loadedData.RowTags || !loadedData.sheetText2D || !Array.isArray(loadedData.sheetText2D)) {
                           throw new Error(`Invalid data structure loaded from Sheet for ${config.workbookAbr}/${config.sheetName}.`);
                         }

                        fMyConsoleLog(`      -> Saving to Firestore: ${config.workbookAbr}/${config.sheetName}`);
                        const saveResult = await new Promise((res, rej) => {
                            google.script.run
                                .withSuccessHandler(res)
                                .withFailureHandler(rej)
                                .fSrvSaveFullSheetTextAndTagsToFirestore(gIndex, config.workbookAbr, config.sheetName, loadedData);
                        });

                        if (saveResult && saveResult.success) {
                            fMyConsoleLog(`         -> ✅ Successfully created Firestore doc for ${config.gUIKey}.`);
                            resolve({ success: true, config: config }); // Resolve on success
                        } else {
                             throw new Error(saveResult?.message || `Unknown error saving ${config.gUIKey} to Firestore.`);
                        }
                    } catch (err) {
                         reject({ error: err, config: config }); // Reject with error and config
                    }
                });
            });

            const createResults = await Promise.allSettled(createPromises);
            // Check for failures during creation
            for (const result of createResults) {
                if (result.status === 'rejected') {
                    const config = result.reason.config;
                    const error = result.reason.error;
                    throw new Error(`Failed to create Firestore document for ${config.gUIKey}: ${error.message || 'Unknown error'}`);
                }
                // If fulfilled, success was already logged inside the promise
            }
             fMyConsoleLog(`   -> Finished attempting to create missing MyCS/MyKL documents.`);
        } else {
             fMyConsoleLog(`   -> All MyCS/MyKL documents already exist.`);
        }
        fMyConsoleLog(`   -> Phase 1 Complete.`);

        // === Phase 2: Read ALL Caches from Firestore ===
        fMyConsoleLog(`   -> Phase 2: Reading all required caches from Firestore...`);
        const readPromises = allCaches.map(config => {
             return new Promise((resolve, reject) => {
                 google.script.run
                     .withSuccessHandler(response => resolve({ ...response, config }))
                     .withFailureHandler(error => reject({ error, config }))
                     .fSrvGetFirestoreFSData(config.workbookAbr, config.sheetName, gIndex);
             });
        });

        const readResults = await Promise.allSettled(readPromises);
        let characterInfoPopulated = false; // Ensure this gets set

        // Process read results
        for (const result of readResults) {
            if (result.status === 'fulfilled') {
                const response = result.value;
                const config = response.config;

                // Validate response structure
                if (response.success && response.FSData &&
                    typeof response.FSData.colTagsMap === 'object' &&
                    typeof response.FSData.rowTagsMap === 'object' &&
                    Array.isArray(response.FSData.text))
                {
                    // Store successful data
                    gUI[config.gUIKey] = response.FSData;
                    fMyConsoleLog(`      -> ✅ Successfully read cache: ${config.gUIKey}`);

                    // Populate Character Info if it's the RaceClass cache
                    if (config.gUIKey === 'myCsRaceClassFSData') {
                        fMyConsoleLog(`      -> Triggering fPopulateGuiCharacterInfo...`);
                        const populateSuccess = fPopulateGuiCharacterInfo();
                        if (!populateSuccess) {
                            // Throw critical error if population fails
                            throw new Error("Failed to populate gUI.characterInfo from RaceClass cache.");
                        }
                        characterInfoPopulated = true; // Mark as successful
                    }
                } else {
                    // Server call succeeded but returned success: false or invalid data
                    const readErrorMsg = `Failed to load cache: ${config.gUIKey}. Reason: ${response.message || 'Invalid FSData structure returned.'}`;
                    fMyConsoleLog(`      -> ❌ ${readErrorMsg}`);
                    throw new Error(readErrorMsg); // Halt loading on critical read failure
                }
            } else {
                // Promise was rejected (transport error or critical FS error like NOT_FOUND for DB)
                const config = result.reason.config;
                const error = result.reason.error;
                const readErrorMsg = `Failed to load cache: ${config.gUIKey}. Reason: ${error.message || 'Unknown server communication error.'}`;
                fMyConsoleLog(`      -> ❌ ${readErrorMsg}`);
                console.error(`Error details for ${config.gUIKey}:`, error);
                throw new Error(readErrorMsg); // Halt loading on critical read failure
            }
        } // End loop through read results

        // Final check: Ensure character info was populated
        if (!characterInfoPopulated) {
             // This should only happen if myCsRaceClassFSData load failed, which should have thrown above
             throw new Error("Cache loading process error: Character info was not populated.");
        }

        fMyConsoleLog(`✅ ${funcName}: All required caches loaded & character info populated.`);
        return true; // All critical steps succeeded

    } catch (error) {
        // Catch errors thrown during the process
        fMyConsoleLog(`❌ ${funcName}: Critical error during cache loading: ${error.message}`);
        await fShowMessage(`❌ Critical Error: ${error.message}<br><br>App loading halted.`); // Show error
        return false; // Indicate failure
    }
} // END fBulkCacheFSData



// fRefreshAndCacheOneFSData /////////////////////////////////////////////////
// Purpose -> Refreshes a single cache specified by the inputs. For 'DB' sources, it
//            reads directly from Firestore. For 'MyCS'/'MyKL' sources, it forces
//            an update by reading the Google Sheet, saving to Firestore, and then
//            reading back from Firestore. Updates gUI.characterInfo if the
//            RaceClass cache is refreshed.
// Inputs  -> workbookAbr (String): The workbook abbreviation ('DB', 'MyCS', 'MyKL').
//         -> sheetName (String): The specific sheet name.
//         -> gUIKey (String): The key in the gUI object where the cache data is
//                             stored (e.g., 'dbElementsFSData', 'myCsRaceClassFSData').
// Outputs -> (Promise<Boolean>): Resolves true if the refresh and cache update succeeded, false otherwise.
async function fRefreshAndCacheOneFSData(workbookAbr, sheetName, gUIKey) {
    const funcName = "fRefreshAndCacheOneFSData";
    const cacheDesc = `${gUIKey} (${workbookAbr}/${sheetName})`; // For logging/messages

    // === 1. Input Validation ===
    if (!workbookAbr || typeof workbookAbr !== 'string' ||
        !sheetName || typeof sheetName !== 'string' ||
        !gUIKey || typeof gUIKey !== 'string') {
        const errorMsg = `Invalid input parameters provided to ${funcName}.`;
        console.error(`${funcName}: ${errorMsg} Got:`, { workbookAbr, sheetName, gUIKey });
        fMyConsoleLog(`❌ ${funcName}: ${errorMsg}`);
        await fShowMessage(errorMsg);
        return false;
    }

    fMyConsoleLog(`⚙️ ${funcName}: Starting refresh for ${cacheDesc}...`);

    // === 2. Main Operation with Error Handling ===
    try {
        let fsData = null; // To hold data read from Firestore

        // === 3. Conditional Logic based on Source Type ===
        if (workbookAbr === 'DB') {
            // --- DB Source: Read directly from Firestore ---
            fMyConsoleLog(`   -> DB Source: Reading ${cacheDesc} from Firestore...`);
            try {
                const response = await new Promise((resolve, reject) => {
                    google.script.run
                        .withSuccessHandler(resolve)
                        .withFailureHandler(reject)
                        .fSrvGetFirestoreFSData(workbookAbr, sheetName, gIndex);
                });

                // Validate response
                if (response.success && response.FSData &&
                    typeof response.FSData.colTagsMap === 'object' &&
                    typeof response.FSData.rowTagsMap === 'object' &&
                    Array.isArray(response.FSData.text))
                {
                    fsData = response.FSData; // Store data for Step 4
                    fMyConsoleLog(`      -> ✅ Successfully read ${cacheDesc} from Firestore.`);
                } else {
                    throw new Error(response.message || `Invalid FSData structure returned for ${cacheDesc}.`);
                }
            } catch (error) {
                // Handle rejected promise or thrown validation error
                console.error(`Error reading DB cache ${cacheDesc} from Firestore:`, error);
                throw new Error(`Failed to load critical cache ${cacheDesc}: ${error.message || 'Unknown server error.'}`);
            }

        } else if (workbookAbr === 'MyCS' || workbookAbr === 'MyKL') {
            // --- User Source: Force update (Sheet -> FS -> FS Read) ---
            fMyConsoleLog(`   -> User Source: Force refreshing ${cacheDesc} (Sheet->FS->FS)...`);
            let loadedData = null;

            // --- Step A: Load from Sheet ---
            try {
                 fMyConsoleLog(`      -> A. Loading Sheet: ${workbookAbr}/${sheetName}`);
                 loadedData = await new Promise((resolve, reject) => {
                    google.script.run
                        .withSuccessHandler(resolve)
                        .withFailureHandler(reject)
                        .fSrvLoadFullGoogleSheetAndTags(workbookAbr, sheetName, gIndex.CSID);
                });
                // Validate structure
                 if (!loadedData || typeof loadedData !== 'object' || !loadedData.ColTags || !loadedData.RowTags || !loadedData.sheetText2D || !Array.isArray(loadedData.sheetText2D)) {
                     throw new Error(`Invalid data structure loaded from Sheet for ${workbookAbr}/${sheetName}.`);
                 }
                 fMyConsoleLog(`         -> ✅ Successfully loaded ${cacheDesc} from Sheet.`);
            } catch (error) {
                console.error(`Error loading Sheet for ${cacheDesc}:`, error);
                throw new Error(`Failed to load data from Sheet for ${cacheDesc}: ${error.message || 'Unknown server error.'}`);
            }

            // --- Step B: Save to Firestore ---
            try {
                 fMyConsoleLog(`      -> B. Saving ${cacheDesc} to Firestore...`);
                 const saveResult = await new Promise((resolve, reject) => {
                     google.script.run
                         .withSuccessHandler(resolve)
                         .withFailureHandler(reject)
                         .fSrvSaveFullSheetTextAndTagsToFirestore(gIndex, workbookAbr, sheetName, loadedData);
                 });
                 // Validate response
                 if (!saveResult || !saveResult.success) {
                    throw new Error(saveResult?.message || `Unknown error saving ${cacheDesc} to Firestore.`);
                 }
                 fMyConsoleLog(`         -> ✅ Successfully saved ${cacheDesc} to Firestore.`);
            } catch (error) {
                console.error(`Error saving ${cacheDesc} to Firestore:`, error);
                throw new Error(`Failed to save ${cacheDesc} to Firestore: ${error.message || 'Unknown server error.'}`);
            }

            // --- Step C: Read back from Firestore ---
            try {
                fMyConsoleLog(`      -> C. Reading ${cacheDesc} back from Firestore...`);
                 const response = await new Promise((resolve, reject) => {
                    google.script.run
                        .withSuccessHandler(resolve)
                        .withFailureHandler(reject)
                        .fSrvGetFirestoreFSData(workbookAbr, sheetName, gIndex);
                });
                // Validate response
                if (response.success && response.FSData &&
                    typeof response.FSData.colTagsMap === 'object' &&
                    typeof response.FSData.rowTagsMap === 'object' &&
                    Array.isArray(response.FSData.text))
                {
                    fsData = response.FSData; // Store data for Step 4
                    fMyConsoleLog(`         -> ✅ Successfully read ${cacheDesc} back from Firestore.`);
                } else {
                    throw new Error(response.message || `Invalid FSData structure returned for ${cacheDesc} after update.`);
                }
            } catch (error) {
                 console.error(`Error reading ${cacheDesc} from Firestore after update:`, error);
                 throw new Error(`Failed to read ${cacheDesc} from Firestore after update: ${error.message || 'Unknown server error.'}`);
            }

        } else {
            // --- Invalid workbookAbr ---
            throw new Error(`Invalid workbookAbr provided: "${workbookAbr}"`);
        }

        // === 4. Populate gUI Cache ===
        // This step is reached only if the appropriate path above succeeded and fsData is populated
        gUI[gUIKey] = fsData;
        fMyConsoleLog(`   -> Updated gUI cache key: ${gUIKey}`);

        // === 5. Character Info Update (Common Logic) ===
        if (gUIKey === 'myCsRaceClassFSData') {
            fMyConsoleLog("      -> Triggering fPopulateGuiCharacterInfo...");
            const populateSuccess = fPopulateGuiCharacterInfo();
            if (!populateSuccess) {
                // fPopulateGuiCharacterInfo logs its own errors
                throw new Error("Failed to populate gUI.characterInfo after updating RaceClass cache.");
            }
            fMyConsoleLog("         -> ✅ Successfully populated character info.");
        }

        // === 6. Final Success ===
        fMyConsoleLog(`✅ ${funcName}: Successfully refreshed ${cacheDesc}.`);
        return true;

    } catch (error) {
        // === Catch errors thrown from any step ===
        const errorMsg = `Error during ${funcName} for ${cacheDesc}: ${error.message || 'Unknown error'}`;
        console.error(errorMsg, error);
        fMyConsoleLog(`❌ ${errorMsg}`);
        await fShowMessage(`❌ Error refreshing ${cacheDesc}:<br>${error.message || 'Unknown error'}`);
        return false; // Indicate failure
    }

} // END fRefreshAndCacheOneFSData




// fPopulateGuiCharacterInfo ///////////////////////////////////////////////////////
// Purpose -> Reads data from the gUI.myCsRaceClassFSData cache and populates
//            the gUI.characterInfo object. Called by fBulkCacheFSData.
// Inputs  -> None (Reads gUI.myCsRaceClassFSData).
// Outputs -> (Boolean): True if population is successful, false otherwise.
function fPopulateGuiCharacterInfo() {
    const funcName = "fPopulateGuiCharacterInfo";
    fMyConsoleLog(`   -> ${funcName}: Populating gUI.characterInfo from cache...`);

    // === 1. Validate Cache ===
    const cacheKey = 'myCsRaceClassFSData';
    const cache = gUI[cacheKey];
    if (!cache || !cache.text || !Array.isArray(cache.text)) { // Removed map checks as resolvers handle that
        const errorMsg = `Cannot populate Character Info: Required cache ${cacheKey} is not loaded or invalid.`;
        console.error(`${funcName}: ${errorMsg}`);
        fMyConsoleLog(`      -> ❌ ${funcName} Error: ${errorMsg}`);
        return false;
    }

    // === 2. Resolve Tags using FSData Resolvers ===
    const requiredColTag = 'Val';
    const requiredRowTags = ['RC', 'level', 'playerName', 'charName', 'slot'];

    const colValIndex = fResolveFSDataCol(cacheKey, requiredColTag);
    const rowRCIndex = fResolveFSDataRow(cacheKey, 'RC');
    const rowLevelIndex = fResolveFSDataRow(cacheKey, 'level');
    const rowPlayerNameIndex = fResolveFSDataRow(cacheKey, 'playerName');
    const rowCharNameIndex = fResolveFSDataRow(cacheKey, 'charName');
    const rowSlotIndex = fResolveFSDataRow(cacheKey, 'slot');

    // Validate ALL resolved indices
    const resolvedIndices = [colValIndex, rowRCIndex, rowLevelIndex, rowPlayerNameIndex, rowCharNameIndex, rowSlotIndex];
    const failedTags = [];
    if (isNaN(colValIndex)) failedTags.push('Val');
    if (isNaN(rowRCIndex)) failedTags.push('RC');
    if (isNaN(rowLevelIndex)) failedTags.push('level');
    if (isNaN(rowPlayerNameIndex)) failedTags.push('playerName');
    if (isNaN(rowCharNameIndex)) failedTags.push('charName');
    if (isNaN(rowSlotIndex)) failedTags.push('slot');

    if (failedTags.length > 0) { // Check if any resolution failed
        const errorMsg = `Cannot populate Character Info: Required tag(s) '${failedTags.join(', ')}' not found or invalid in ${cacheKey} maps.`;
        console.error(`${funcName}: ${errorMsg}`);
        fMyConsoleLog(`      -> ❌ ${funcName} Error: ${errorMsg}`);
        return false;
    }
    fMyConsoleLog(`      -> All required tags resolved in ${cacheKey}.`);

    // === 3. Extract Raw Values using Resolved Indices ===
    // const cVal = colValIndex; // No longer needed as separate var
    const rawRC = cache.text?.[rowRCIndex]?.[colValIndex];
    const rawLevel = cache.text?.[rowLevelIndex]?.[colValIndex];
    const rawPlayerName = cache.text?.[rowPlayerNameIndex]?.[colValIndex];
    const rawCharName = cache.text?.[rowCharNameIndex]?.[colValIndex];
    const rawSlot = cache.text?.[rowSlotIndex]?.[colValIndex];

    // === 4. Process Values ===
    const raceClass = String(rawRC ?? '').trim();
    const level = String(rawLevel ?? '').trim();
    const playerName = String(rawPlayerName ?? '').trim().split(' ')[0] || '';
    const charName = String(rawCharName ?? '').trim().split(' ')[0] || '';

    // --- Slot Processing ---
    let slotNum = null;
    const slotString = String(rawSlot ?? '').trim();
    const slotRegex = /^Slot\s+([1-9])$/i;
    const match = slotString.match(slotRegex);

    if (match && match[1]) {
        slotNum = `Slot${match[1]}`; // Cleaned slot number
    } else if (slotString !== '') { // Log warning only if it wasn't blank
        fMyConsoleLog(`      -> ⚠️ ${funcName}: Invalid Slot format found in cache: "${slotString}". Storing null.`);
    }

    // === 5. Update gUI.characterInfo ===
    gUI.characterInfo = {
        slotNum: slotNum,
        raceClass: raceClass,
        level: level,
        playerName: playerName,
        charName: charName
    };
    fMyConsoleLog(`   -> ✅ Successfully populated gUI.characterInfo: ${JSON.stringify(gUI.characterInfo)}`);
    return true;

} // END fPopulateGuiCharacterInfo





// fRenderGridWithFinalData /////////////////////////////////////////////////
// Purpose -> Helper function to initiate the actual grid rendering process.
//            Called after both gUI.arr and gUI.characterInfo have been finalized
//            (either from Sheet or Firestore).
// Inputs -> None (Uses final gUI.arr).
// Outputs -> None (Starts rendering process).
function fRenderGridWithFinalData() {
    fMyConsoleLog("🚀 Initiating Final Grid Render...");
    // Ensure we have valid gUI.arr data before rendering
    if (!gUI.arr || gUI.arr.length === 0) {
         fMyConsoleLog("❌ Cannot render grid: gUI.arr is empty or invalid.");
         const gridDiv = document.getElementById('grid');
         if (gridDiv) gridDiv.innerHTML = '<p style="color:red;">Critical error loading grid data. Please check configuration or reload.</p>';
         return;
    }

    // Trigger the rendering with the post-render callback
    fRenderTurbosFullGrid(() => {
        fRunPostRenderFormatting(); // Apply merges, borders, listeners, etc.
    });
} // END fRenderGridWithFinalData




// fStoreAndValidateData ///////////////////////////////////////////////////////////
// Purpose -> Validates the structure and content of the data object received from
//            the server. Stores valid data arrays (arr, format, notesArr) in the
//            gUI object. Checks for essential elements (#grid). Clears the grid container.
// Inputs  -> data (Object): The data object received from the server.
// Outputs -> (Boolean): True if data and required elements are valid, false otherwise.
function fStoreAndValidateData(data) {
    // === Validate Data Structure ===
    if (!data || typeof data !== 'object' || !data.arr || !data.format || !data.notesArr || data.error || data instanceof Error) {
        console.error("Error or invalid data structure received:", data);
        fMyConsoleLog("❌ Error or invalid data structure received.");
        // Consider showing a user message here
        // fShowMessage("Error: Received invalid data from server.");
        return false;
    }

    // === Store Data in gUI ===
    gUI.arr = data.arr;
    gUI.format = data.format;
    gUI.notes = data.notesArr || []; // Use notes or default to empty array

    // === Validate Data Content ===
    // Check if the main data array is empty or malformed
    if (gUI.arr.length === 0 || !gUI.arr[0] || gUI.arr[0].length === 0) {
        fMyConsoleLog("⚠️ Data array received is empty.");
        gUI.notes = []; // Ensure notes are also empty if data is empty
        // Consider showing a user message?
        // fShowMessage("Warning: Received empty data sheet.");
        return false; // Treat empty data as invalid for rendering
    }

    // === Validate Grid Container ===
    const container = document.getElementById('grid');
    if (!container) {
        console.error("❌ Grid container #grid not found!");
        fMyConsoleLog("❌ Grid container #grid not found!");
        // fShowMessage("Error: Grid container element is missing.");
        return false;
    }

    // === Clear Grid Container ===
    // Prepare grid for new rendering
    container.innerHTML = '';

    return true; // Data is valid and stored
} // END fStoreAndValidateData




// fSetupTooltipAndModal ///////////////////////////////////////////////////////////
// Purpose -> Gets references to the tooltip and image modal DOM elements by ID
//            and caches them in the gUI object for later use. Logs warnings if
//            elements are not found.
// Inputs  -> None.
// Outputs -> None (Modifies gUI object properties).
function fSetupTooltipAndModal() {
    // === Cache Tooltip Element ===
    gUI.tooltipElement = document.getElementById('cell-tooltip');
    if (!gUI.tooltipElement) {
        fMyConsoleLog("⚠️ Tooltip element (#cell-tooltip) missing...");
        console.warn("Tooltip element not found. Hover tooltips will not function.");
    }

    // === Cache Modal Elements ===
    gUI.modalElement = document.getElementById('image-modal');
    gUI.modalImageElement = document.getElementById('modal-image');
    gUI.modalCloseBtn = document.getElementById('modal-close-btn');
    gUI.modalBackdrop = document.getElementById('modal-backdrop');

    // Check if all essential modal elements were found
    if (!fModalElementsAvailable()) { // Use helper to check cached refs
        console.error("❌ One or more modal elements not found in DOM!");
        fMyConsoleLog("⚠️ Modal elements missing, image preview disabled.");
        // Log specific missing elements if needed for debugging
        if (!gUI.modalElement) console.error(" -> Missing: #image-modal");
        if (!gUI.modalImageElement) console.error(" -> Missing: #modal-image");
        if (!gUI.modalCloseBtn) console.error(" -> Missing: #modal-close-btn");
        if (!gUI.modalBackdrop) console.error(" -> Missing: #modal-backdrop");
    }
} // END fSetupTooltipAndModal




// fModalElementsAvailable /////////////////////////////////////////////////////////
// Purpose -> Helper function to check if all required image modal DOM element
//            references have been successfully cached in the gUI object.
// Inputs  -> None (Checks gUI properties).
// Outputs -> (Boolean): True if all required modal elements are present in gUI, false otherwise.
function fModalElementsAvailable() {
    // Check if all expected properties hold truthy values (i.e., the elements were found)
    return gUI.modalElement && gUI.modalImageElement && gUI.modalCloseBtn && gUI.modalBackdrop;
} // END fModalElementsAvailable




// fAttachGridListeners ////////////////////////////////////////////////////////////
// Purpose -> Attaches various delegated event listeners (click, change, blur, hover)
//            to the main grid container element.
// Inputs  -> gridElement (HTMLElement): The grid container element (#grid).
// Outputs -> None (Attaches event listeners).
function fAttachGridListeners(gridElement) {
    // Validate grid element exists
    if (!gridElement) {
        console.error("fAttachGridListeners: Could not find grid element to attach listeners.");
        fMyConsoleLog("❌ Failed to attach grid event listeners.");
        return;
    }

    // Attach click/change listeners (delegated)
    fSetupGridClickListeners(gridElement);

    // Attach blur listener for handling edits in contentEditable cells (using capture phase)
    gridElement.addEventListener('blur', fHandleGridCellEdit, true);

    // Attach hover listeners for tooltips, only if tooltip element exists
    if (gUI.tooltipElement) {
        fSetupGridHoverListeners(gridElement);
    }
} // END fAttachGridListeners




// fRunPostRenderFormatting ////////////////////////////////////////////////////////
// Purpose -> Executes a sequence of functions to apply formatting and attach
//            listeners after the main grid structure has been rendered. This includes
//            merging cells, adding buttons, applying borders/colors, setting visibility,
//            handling sticky headers, applying dropdowns, checking for overflow,
//            fetching dynamic dropdown lists, and setting up final event listeners.
// Inputs  -> None.
// Outputs -> None (Calls various formatting and setup functions).
function fRunPostRenderFormatting() {
    fMyConsoleLog("🚀 Applying Post-Render Formatting...");

    // === Apply Structural Formatting ===
    fApplyGridDynamicMerges(); // Handle merged cells first
    fAddGridsHeaderRowButtons();       // Add image buttons to header cells
    fApplyGridManualBorders(); // Apply borders defined in gUI.manualBorderSections
    fApplyGridColAndRowInitialVisibility(); // Hide initially hidden rows/columns
    fApplyGridManualColoring(); // Apply font colors defined in gUI.fontColorRange
    fSetTurbosGridHeaderRows(); // Apply sticky header styling

    // === Apply Static Interactive Elements ===
    // Apply statically defined dropdowns FIRST (e.g., On, NumMon)
    fApplyDropdownsToGrid();

    // === Fetch Dynamic Dropdown Data and Apply ===
    fFetchAndApplyAbilityDropdowns(); // Fetch ability names and apply those dropdowns

    // === Final Adjustments & Listeners ===
    fMarkGridOverflowingCells(); // Add class to cells with overflow after layout changes
    fClearSk1Sk2Checkboxes(); // Ensure radio button group starts clean (optional)

    // Attach main grid event listeners
    const gridElement = document.getElementById('grid');
    fAttachGridListeners(gridElement);

    // Setup image modal listeners if elements are available
    if (fModalElementsAvailable()) {
        fSetupModalListeners();
    }

    // --- Calculate MR/Enc AFTER grid is fully rendered and formatted ---
    fCalculatesEnc_MR_AP(); // Now called here

    fMyConsoleLog("✅ All Post-Render Formatting Done!");
} // END fRunPostRenderFormatting




// fLoadGameSheet //////////////////////////////////////////////////////////////////
// Purpose -> Initiates the process of loading and displaying the game sheet data.
//            Sets up timing, validates gIndex.CSID, and calls the server-side
//            function (fSrvReadCSGameSheet) to retrieve data, handling success and failure cases.
// Inputs  -> None (Uses global gIndex.CSID).
// Outputs -> None (Initiates server call).
function fLoadGameSheet() {
    // === Initialize Timers ===
    gUI.startTime = performance.now(); // Record start time for performance logging
    gUI.lastLogTime = gUI.startTime;   // Initialize last log time
    fMyConsoleLog("🚀 Requesting GSheet Data...");
    console.log("Sheet ID:", gIndex.CSID); // Log the sheet ID being used

    // === Validate Sheet ID ===
    if (!gIndex.CSID) {
        const errorMsg = "❌ No Sheet ID found. Cannot load data.";
        console.error(errorMsg);
        fMyConsoleLog(errorMsg);
        // Display error message in the grid container if ID is missing
        const gridDiv = document.getElementById('grid');
        if (gridDiv) gridDiv.innerHTML = `<p style="color:red;">${errorMsg} Check URL parameter.</p>`;
        return;
    }

    // === Call Server Function ===
    // Use google.script.run to call the Apps Script function
    google.script.run
        .withSuccessHandler(fOnCSGameDataLoaded) // Callback for successful data retrieval or server-side errors
        .withFailureHandler(error => {     // Callback for transport errors or unhandled exceptions
            const errorMsg = `❌ Failed to call server: ${error.message}`;
            console.error(errorMsg, error);
            fMyConsoleLog(errorMsg);
            // Display error message in the grid container on failure
            const gridDiv = document.getElementById('grid');
            if(gridDiv) gridDiv.innerHTML = `<p style="color:red;">${errorMsg}</p>`;
        })
        .fSrvReadCSGameSheet(gIndex); // The server-side function to call in Turbo.gs

} // END fLoadGameSheet




// ==========================================================================
// === Entry Point                 (End of Initial Data Load) ===
// ==========================================================================




// DOMContentLoaded Hook ///////////////////////////////////////////////////////////
// Purpose -> Main entry point for client-side script execution. Attaches a listener
//            that waits for the HTML DOM to be fully loaded and parsed, then calls
//            initial setup functions to load data and attach event listeners.
window.addEventListener("DOMContentLoaded", () => {
    // Initiate data loading from the Google Sheet
    fLoadGameSheet();

    // Setup interactivity for UI elements
    fSetupMenuInteractivity();       // Menu bar buttons, dropdowns, actions
    fSetupMessageModalListeners();   // Message box (OK button, Escape key)
    fSetupPromptModalListeners();    // Prompt box (Yes/No buttons)
    fSetupSidebarActionListeners();  // Buttons within the Roll Log sidebar
});




</script>