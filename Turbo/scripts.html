<script>
// scripts.html //


// ==========================================================================
// === Global Variables ===
// ==========================================================================




const gUI = {
  arr: [],        // 2D array of data from the sheet
  rowTag: {},     // Map of row tags to 0-based row indices
  colTag: {},     // Map of column tags to 0-based column indices
  format: {},     // Object containing formatting arrays (bg, fonts, borders, merges, etc.)
  notes: [],      // <<< NEW: 2D array of cell notes (parallel to arr)
  grid2D: [],     // 2D array holding references to the created cell DOM elements
  pendingChangesMap: {}, // Holds { 'r,c': newValue } during ability roll cost verification steps (or similar process)

  // Add the manual border definitions here:
  manualBorderSections: [
    // Added 'edges' property based on old fSetAllBorders calls
    { r1: 'Nish', c1: 'ULNish', r2: 'Nish', c2: 'Nish', edges: 'br' },
    { r1: 'MR', c1: 'ULMR', r2: 'MR', c2: 'MR', edges: 'br' },
    { r1: 'meta', c1: 'ULMeta', r2: 'chnl', c2: 'B', edges: 'r' },
    { r1: 'LuckBox', c1: 'ULLuckBox', r2: 'LuckPlus', c2: 'LuckBox', edges: 'r' },
    { r1: 'Act', c1: 'ULAct', r2: 'ActPlus', c2: 'ActTot', edges: 'r' },
    { r1: 'Health', c1: 'vitPlus', r2: 'VitTbl', c2: 'VitNowPercent', edges: 'br' },
    { r1: 'VerUL', c1: 'Ver', r2: 'FrozenHeader', c2: 'Ver', edges: 'r' },
    { r1: 'FrozenHeader', c1: 'PermMorph1', r2: 'AbilTblEnd_R', c2: 'Regain', edges: 'br' },
    { r1: 'FrozenHeader', c1: 'PossNum', r2: 'AbilTblEnd_R', c2: 'PossAPTot', edges: 'br' },
    { r1: 'ULMonsterTbl', c1: 'NumMon', r2: 'LastMon_R', c2: 'MonSize', edges: 'br' },
    { r1: 'AstralGauntHeader_R', c1: 'AstralGauntletSlot', r2: 'AstralGauntHeader_R', c2: 'AstralGauntletHeaderEndC', edges: 'r' },
    { r1: 'Chaos2ndHeader', c1: 'AstralGauntletSlot', r2: 'ChaosWrist', c2: 'LastC', edges: 'br' },
    { r1: 'SocketedGearHeader', c1: 'SocketedGearSlot', r2: 'SocketTblEnd', c2: 'LastC', edges: 'br' },
    { r1: 'GearTblHeaderStartR', c1: 'PermMorph1', r2: 'GearTblEnd_R', c2: 'Regain', edges: 'br' },
    { r1: 'GearTblHeaderStartR', c1: 'PossNum', r2: 'GearTblEnd_R', c2: 'PossAPTot', edges: 'br' },
    { r1: 'GearSpe', c1: 'SpeedHeader', r2: 'GearStr', c2: 'GearPlusMR', edges: 'br' },
    { r1: 'GearMRTbl', c1: 'MRHeader', r2: 'GearMRTbl', c2: 'MRHeaderEndC', edges: 'b' },
    { r1: 'GearCarryTbl', c1: 'MRHeader', r2: 'GearCarryTbl', c2: 'MRHeaderEndC', edges: 'b' },
    { r1: 'GearMRTbl', c1: 'GearMRCol1', r2: 'GearCarryTbl', c2: 'LastC', edges: 'br' },
    { r1: 'PossAPTot', c1: 'CurrentEncHeader', r2: 'PossAPTot', c2: 'PossEncTotEndC', edges: 'br' },
    { r1: 'PossEncTot', c1: 'GearAPTotHeader', r2: 'PossEncTot', c2: 'LastC', edges: 'br' }
    // Add { style: '1px solid #888' } to specific objects if dark grey is desired
  ],
  sk1sk2CheckBoxes: [
    { r1: 'NishAtr_R', c1: 'Sk1ChkBox', r2: 'AbilTblEnd_R', c2: 'Sk1ChkBox'},
    { r1: 'NishAtr_R', c1: 'Sk2ChkBox', r2: 'AbilTblEnd_R', c2: 'Sk2ChkBox'},
    { r1: 'GearTblStart_R', c1: 'Sk1ChkBox', r2: 'GearTblEnd_R', c2: 'Sk1ChkBox'},
    { r1: 'GearTblStart_R', c1: 'Sk2ChkBox', r2: 'GearTblEnd_R', c2: 'Sk2ChkBox'}
  ],
  // Define initially hidden columns/rows using tags or indices
  initialHiddenCols: [
    { c1: 'Key', c2: 'PermMorph1' }, // Range using tags
    { c1: 'PermMorph2', c2: 'PermMorph2' }  // Single column using tags
  //  { c1: 0, c2: 0 }, // Example: Single column using index
  ],
  gearTblCols: [
    { c1: 'PossNum', c2: 'GearTblEndC' }, // Range using tags
  ],
  initialHiddenRows: [
    { r1: 'Agi', r2: 'Arc' } // Range using tags
    // { r1: 0, r2: 1 } // Example: Range using indices
  ],
  // Current Roll object
roll: {
    // --- Input values from Sheet (populated by fResetPopulateNCleanGUIRoll) ---
    sk1CB: false,        // Flag: True if roll originated from Sk1 CheckBox column, false if Sk2
    ability_R: '',               // 0-based row index of the ability/gear being rolled
    skMorph: '',         // Raw morph string from sheet ('Morph1' or 'Morph2' col)
    skTyp: '',           // Base skill type string ('Sk', 'Atr', 'Atk', etc.) from sheet ('Sk1Typ' or 'Sk2Typ' col)
    skSk: '',            // Base skill value (numeric >= 1 or '') from sheet ('Sk1' or 'Sk2' col)
    skIsOn: '',          // Raw 'Is On' status from sheet
    skNameID: '',        // Raw ability/gear name from sheet, may include ID ('Ability' col)
    skName: '',          // Cleaned ability/gear name (ID stripped)
    skAct: '',           // Action Point cost
    skDur: '',           // Raw duration value from sheet
    skMeta: '',          // Raw Meta cost value from sheet
    skUses: '',          // Remaining uses (numeric >= 0 or '') from sheet

    // --- Result values calculated after processing morphs (fProcessMorph, fApplyMorphResults) ---
    resTyp: '',          // Resulting roll type after morphs (defaults to skTyp)
    resSk: '',           // Resulting skill value after skill morphs (resCombine/skSk, resMult, resdctMult, resPlus, resFocus, isUnSk) - base for roll calculation
    resFlatBase: '',     // Skill override value from '=' morph (overrides skSk/resCombine base)
    resFlatResult: '',   // Final roll result override from '==' morph
    resDif: '',          // Difficulty value from '^' morph
    resFocus: '',        // Raw Focus Meta color
    resPlus: '',         // Sum of '+[num]' / '-[num]' morphs (additive modifier to resSk)
    resPlusPlus: '',     // Sum of '++[num]' / '--[num]' morphs (additive modifier to final roll)
    resdctMult: '',      // Cumulative multiplier from '+/-[num]dct' morphs (applies to both resSk and resRoll)
    resMult: '',         // Cumulative multiplier from '*[num]' / '/[num]' morphs (applies to resSk)
    resMultMult: '',     // Cumulative multiplier from '**[num]' / '//[num]' morphs (applies to final roll)
    resCombine: '',      // Combined skill value calculated from numeric morphs + skSk (diminishing returns)

    // --- Dice roll results (calculated by fCalcGUIRollRoll, fCalcGUIRollResRoll) ---
    roll: '',            // Raw dice roll result based on resSk and resTyp (before roll morphs)
    resRoll: '',         // Final roll result after applying roll morphs (resMultMult, resPlusPlus, resdctMult) or override (resFlatResult)

    // --- Flags & Multi-Roll 
    isUnSk: false,       // Flag set to true if 'un' or 'unsk' morph was present
    isFreeRoll: false,   // Flag set to true if 'free' morph was present
    isLuckedRoll: false, // Flag set to true if 'luck' morph was present
    multiRollCount: 1,   // Number of times to roll (defaults to 1)

    // --- Output Formatting ---
    htmlHeader: ''       // Stores the header HTML string for the roll log entry
  },
  dropDownBox: [
    // Is On
    { choices: ['','Y','N',1,2,3,4,5,6,7,8,9,10,'P','I','~','E','*'],
      ranges: [ { r1: 'AbilTblStart_R', c1: 'On', r2: 'AbilTblEnd_R', c2: 'On' } ]
    },
    // Monster #
    { choices: ['',1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30],
      ranges: [ { r1: 'CustMon', c1: 'NumMon', r2: 'LastMon_R', c2: 'NumMon' } ]
    }
  ],
  fontColorRange: [
    { color: '#FF0000', // Red
      ranges: [ { r1: 'FrozenHeader', c1: 'R', r2: 'FrozenHeader', c2: 'R' },
        { r1: 'ULMonsterTbl', c1: 'MonAtk', r2: 'LastMon_R', c2: 'MonDmg' } ]
    },
    { color: '#FFA500', // Orange
      ranges: [ { r1: 'FrozenHeader', c1: 'O', r2: 'FrozenHeader', c2: 'O' } ]
    },
    { color: '#fcba03', // Gold
      ranges: [ { r1: 'FrozenHeader', c1: 'Y', r2: 'FrozenHeader', c2: 'Y' } ]
    },
    { color: '#008000', // Green
      ranges: [ { r1: 'FrozenHeader', c1: 'G', r2: 'FrozenHeader', c2: 'G' } ]
    },
    { color: '#0000FF', // Blue
      ranges: [ { r1: 'FrozenHeader', c1: 'B', r2: 'FrozenHeader', c2: 'B' } ]
    }
  ],
  range: {
    // Define ranges using objects with r1, c1, r2, c2 properties
    morphs: [ // <-- Array is correct because there are MULTIPLE morph ranges
      { r1: 'AbilTblStart_R', c1: 'Morph1', r2: 'AbilTblEnd_R', c2: 'Morph1' },
      { r1: 'AbilTblStart_R', c1: 'Morph2', r2: 'AbilTblEnd_R', c2: 'Morph2' }
    ],
    monsters: { r1: 'CustMon', c1: 'NumMon', r2: 'LastMon_R', c2: 'MonSize' },
    currentNish: { r1: 'Nish', c1: 'Nish', r2: 'Nish', c2: 'Nish' },
    meta: { r1: 'meta', c1: 'R', r2: 'meta', c2: 'B' },
    metaChannel: { r1: 'chnl', c1: 'R', r2: 'chnl', c2: 'B' },
    luckBox: { r1: 'LuckBox', c1: 'LuckBox', r2: 'LuckBox', c2: 'LuckBox' },
    luckBoxPlus: { r1: 'LuckPlus', c1: 'LuckBox', r2: 'LuckPlus', c2: 'LuckBox' },
    actTotal: { r1: 'Act', c1: 'ActTot', r2: 'Act', c2: 'ActTot' },
    actPlus: { r1: 'ActPlus', c1: 'ActTot', r2: 'ActPlus', c2: 'ActTot' },
    fortitudeSk1: { r1: 'For', c1: 'Sk1', r2: 'For', c2: 'Sk1' },
    vitMax: { r1: 'VitTbl', c1: 'vitMax', r2: 'VitTbl', c2: 'vitMax' },
    vitMaxPlus: { r1: 'VitTbl', c1: 'vitPlus', r2: 'VitTbl', c2: 'vitPlus' },
    vit1stWnds: { r1: 'VitTbl', c1: 'vit1st', r2: 'VitTbl', c2: 'vit1st' },
    vit2ndWnds: { r1: 'VitTbl', c1: 'vit2nd', r2: 'VitTbl', c2: 'vit2nd' },
    vit3rdWnds: { r1: 'VitTbl', c1: 'vit3rd', r2: 'VitTbl', c2: 'vit3rd' },
    vitNow: { r1: 'VitTbl', c1: 'vitNow', r2: 'VitTbl', c2: 'vitNow' },
    vitNowPercent: { r1: 'VitTbl', c1: 'VitNowPercent', r2: 'VitTbl', c2: 'VitNowPercent' }
  },
    list: {
    // array lists
    skTyp: ['Atr','Sk','Atk','DMG','Def','AR','Str'], // Note free, luck, un, unSk are not skill Types and dealth with elsewhere
    metaColor: ['R','O','Y','G','B'],
    metaFull: [5,4,3,2,1],
    luckBoxMax: 5,
    actMax: 5,
  },
  // Sets to store the indices of currently hidden columns/rows
  hiddenColumns: new Set(),
  hiddenRows: new Set(),
  startTime: 0,              // Timestamp for tracking load/render time
  lastLogTime: 0,            // Timestamp for tracking delta time between logs
  tooltipElement: null,      // Reference to the #cell-tooltip div
  tooltipTimeoutId: null,    // Stores the timeout ID for the hover delay
  // Image Tab
  modalElement: null,        // Reference to #image-modal container
  modalImageElement: null,   // Reference to #modal-image img tag
  modalCloseBtn: null,       // Reference to #modal-close-btn span
  modalBackdrop: null,       // Reference to #modal-backdrop div
  // Message Box Elements ---
  messageModalOverlay: null, // Reference to #messageModal div
  messageModalText: null,    // Reference to #messageText p tag
  messageModalCloseButton: null, // Reference to #closeMessageModal button
  messagePromiseResolve: null, // Function to resolve the message promise [cite: 1]
  // Prompt Box Elements --- <<< NEW SECTION ADDED ---
  promptModalOverlay: null,    // Reference to #promptModal div
  promptModalText: null,       // Reference to #promptText p tag
  promptYesButton: null,       // Reference to #promptYesButton button
  promptNoButton: null,        // Reference to #promptNoButton button
  promptPromiseResolve: null,  // Function to resolve the prompt promise
  promptPromiseReject: null,   // Function to reject the prompt promise (optional usage)

  // Other items
  currentSkRadioChecked: { r: null, c: null }, // Tracks coords of the single checked Sk1/Sk2 box
  HOVER_DELAY_MS: 300,       // Delay before showing tooltip (milliseconds)
  TOOLTIP_OFFSET_Y: 15,      // Tooltip vertical offset from cursor (px)
  TOOLTIP_OFFSET_X: 10,      // Tooltip horizontal offset from cursor (px)
  ROW_HEIGHT_PX: 20,          // Matches grid-auto-rows in style.html, used for sticky offset calculation
  isDebugMode: true    // Turns console logging on (true) or off (false)
};



// ==========================================================================
// === Low-Level Utilities              (End of Global Variables) ===
// ==========================================================================




// fMyConsoleLog //////////////////////////////////////////////////////////////////////////////////////////////////
function fMyConsoleLog(msg) {
    if (!gUI.isDebugMode) return; // Exit early if debug mode is off to prevent actual game play console log bloat

    const now = performance.now();
    const delta = ((now - gUI.lastLogTime) / 1000).toFixed(2);
    const total = ((now - gUI.startTime) / 1000).toFixed(2);
    gUI.lastLogTime = now;
    console.log(`Status Log: [${total}s] ${msg} (+${delta}s)`);
}; // END fMyConsoleLog




// resolveRow //////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Converts a string tag (from gUI.rowTag) or numeric index to a 0-based row index
const resolveRow = v => {
    if (typeof v === 'string') return gUI.rowTag[v]; // Lookup tag
    if (typeof v === 'number' && v >= 0) return v;  // Assume valid index
    console.warn(`resolveRow failed for value:`, v); // Log warning if invalid
    return NaN; // Return NaN for errors
}; // END resolveRow




// resolveCol //////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Converts a string tag (from gUI.colTag) or numeric index to a 0-based col index
const resolveCol = v => {
     if (typeof v === 'string') return gUI.colTag[v]; // Lookup tag
     if (typeof v === 'number' && v >= 0) return v;  // Assume valid index
     console.warn(`resolveCol failed for value:`, v); // Log warning if invalid
     return NaN; // Return NaN for errors
}; // END resolveCol




// fGetContrastColor //////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Determines if black ('#000000') or white ('#ffffff') text has better contrast against a given background hex color.
// From current scripts.html
function fGetContrastColor(hexColor) {
    const defaultColor = '#000000'; // Default to black text
    if (!hexColor || typeof hexColor !== 'string') return defaultColor;

    try {
        // Remove # if present
        let hex = hexColor.startsWith('#') ? hexColor.substring(1) : hexColor;

        // Basic validation & expand shorthand hex (e.g., "03F" -> "0033FF")
        if (hex.length === 3) {
            hex = hex.split('').map(char => char + char).join('');
        } else if (hex.length !== 6) {
            return defaultColor; // Invalid hex length
        }

        // Convert hex to RGB
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);

        if (isNaN(r) || isNaN(g) || isNaN(b)) return defaultColor; // Invalid hex characters

        // Calculate luminance using a common formula (YIQ)
        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

        // If luminance is > 0.5, the background is light, use dark text. Otherwise, use light text.
        return luminance > 0.5 ? '#000000' : '#ffffff';

    } catch (e) {
        console.error("Error calculating contrast color for:", hexColor, e);
        return defaultColor; // Fallback on error
    }
}; // END fGetContrastColor




// fIndicesToA1 ////////////////////////////////////////////////////////////////////
// Purpose -> Converts 0-based row/column indices to standard A1 notation string.
// Inputs  -> r1, c1, r2, c2 (Number): 0-based start/end row and column indices.
// Outputs -> (String): A1 notation string (e.g., "C5:F10").
function fIndicesToA1(r1, c1, r2, c2) {
    // Validate inputs are numbers >= 0
    if ([r1, c1, r2, c2].some(idx => typeof idx !== 'number' || idx < 0 || isNaN(idx))) {
        console.error(`fIndicesToA1: Invalid indices provided (${r1},${c1},${r2},${c2})`);
        return null; // Return null or throw error
    }
    const startColA1 = fColToA1(c1);
    const endColA1 = fColToA1(c2);
    // Add 1 to rows for A1 notation (which is 1-based)
    const startRowA1 = r1 + 1;
    const endRowA1 = r2 + 1;

    // Format: Top-left cell : Bottom-right cell
    return `${startColA1}${startRowA1}:${endColA1}${endRowA1}`;

} // END fIndicesToA1




// fColToA1 //////////////////////////////////////////////////////////////////////////////////////////////////
// Convert numeric column index (0-based) to Excel-style A1 notation (e.g., 0 -> 'A', 25 -> 'Z', 26 -> 'AA')
// From current scripts.html
function fColToA1(col) {
    let label = '';
    let c = col; // Use local variable
    while (c >= 0) {
        label = String.fromCharCode((c % 26) + 65) + label;
        c = Math.floor(c / 26) - 1;
    }
    return label;
}; // END fColToA1




// getBorderStyleCSS //////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Helper to generate CSS border string from border side data {style: 'STYLE', color?: '#hex'}
// Extracted from current scripts.html fSetCellBorders helper
function getBorderStyleCSS(borderSideData) {
    if (!borderSideData || !borderSideData.style) return null; // Return null if no explicit border style

    const styleStr = borderSideData.style; // e.g., 'SOLID', 'DOTTED'
    // Color support can be added later if Turbo.gs sends it
    const color = borderSideData.color || '#000000'; // Default explicit borders to black if color missing
    let cssStyle = 'solid', cssWidth = '1px';

    // Map Google Sheet BorderStyle enum strings to CSS border properties
    switch (styleStr) {
        case 'DOTTED': cssStyle = 'dotted'; break;
        case 'DASHED': cssStyle = 'dashed'; break;
        case 'SOLID': cssStyle = 'solid'; break;
        case 'SOLID_MEDIUM': cssStyle = 'solid'; cssWidth = '2px'; break;
        case 'SOLID_THICK': cssStyle = 'solid'; cssWidth = '3px'; break;
        case 'DOUBLE': cssStyle = 'double'; cssWidth = '3px'; break;
        // default: 'solid', '1px' already set
    }
    return `${cssWidth} ${cssStyle} ${color}`;
}; // END getBorderStyleCSS




// ==========================================================================
// === Core Cell Creation Helpers       (End of Low-Level Utilities) ===
// ==========================================================================




// fIsSkRadioGroupMember ////////////////////////////////////////////////////////////
// Purpose -> Checks if a given cell coordinate (r, c) falls within any of the ranges
//            defined in gUI.sk1sk2CheckBoxes, indicating it's part of the radio group.
// Inputs -> r (Number): The 0-based row index.
//        -> c (Number): The 0-based column index.
// Outputs -> (Boolean): True if the cell is part of the Sk1/Sk2 radio group ranges, false otherwise.
function fIsSkRadioGroupMember(r, c) {
    const ranges = gUI.sk1sk2CheckBoxes; // Reads all defined ranges
    if (!Array.isArray(ranges)) {
        console.warn("fIsSkRadioGroupMember: gUI.sk1sk2CheckBoxes is not a valid array.");
        return false;
    }
    if (typeof r !== 'number' || typeof c !== 'number' || isNaN(r) || isNaN(c)) {
         console.warn(`fIsSkRadioGroupMember: Invalid input coordinates (${r}, ${c})`);
        return false; // Invalid input coordinates
    }


    // Loop through each defined range for the Sk1/Sk2 checkboxes
    for (const range of ranges) {
        if (!fIsValidRangeObject(range)) { // Use existing helper function
             console.warn("fIsSkRadioGroupMember: Skipping invalid range object", range);
            continue; // Skip malformed ranges
        }

        // Resolve the tags/indices for the current range
        const resolved = fResolveRangeIndices(range); // Use existing helper function
        if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
             console.warn("fIsSkRadioGroupMember: Skipping range due to unresolved indices", range);
            continue; // Skip ranges with invalid tags/indices
        }

        const rMin = Math.min(resolved.r1, resolved.r2);
        const rMax = Math.max(resolved.r1, resolved.r2);
        const cMin = Math.min(resolved.c1, resolved.c2);
        const cMax = Math.max(resolved.c1, resolved.c2);

        // Check if the input r, c falls within this range
        if (r >= rMin && r <= rMax && c >= cMin && c <= cMax) {
            return true; // Found a match, it's part of the group
        }
    }

    // If no range matched after checking all of them
    return false;
}; // END fIsSkRadioGroupMember



// fMakeCheckBox //////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Returns a checkbox element reflecting boolean value in gUI.arr[r][c].
// MODIFIED: Sets 'disabled' based on cell background color.
// MODIFIED: Adds 'data-sk-group' attribute if checkbox is part of the Sk1/Sk2 radio group.
function fMakeCheckBox(r, c) {
    const value = gUI.arr[r]?.[c];
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.dataset.r = r; // Add row index to data attribute
    checkbox.dataset.c = c; // Add column index to data attribute

    // --- Check background color to set disabled state ---
    const bgColor = gUI.format?.bg?.[r]?.[c];
    // Define 'non-white'. Assumes default/white is null, empty, #fff, or #ffffff. Adjust if needed.
    const isNonWhite = bgColor && bgColor.toLowerCase() !== '#ffffff' && bgColor.toLowerCase() !== '#fff';
    checkbox.disabled = isNonWhite; // Disable if background is NOT white/default
    // --- End background check ---

    // Handle boolean true/false and string "TRUE"/"FALSE" (case-insensitive)
    const valStr = String(value).toUpperCase();
    checkbox.checked = value === true || valStr === "TRUE";

    // --- Add data attribute if this checkbox is part of the Sk radio group ---
    if (fIsSkRadioGroupMember(r, c)) { // Checks membership using the function above
        checkbox.dataset.skGroup = 'true'; // Adds the attribute if it IS a member
    }
    // --- End Sk radio group check ---

    return checkbox;
}; // END fMakeCheckBox




// ==========================================================================
// === Core Rendering & Grid Tag Setup  (End of Core Cell Creation Helpers) ===
// ==========================================================================


////////////////////////////////////////////////////////////////////////////////////////////////////////// START fCreateAndFormatCell and helpers




// fCreateAndFormatCell ////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Creates and formats a single cell div with content, URL/image/note tags, and style.
// Inputs  -> r, c, value, rowFormat (see original for detailed descriptions)
// Outputs -> HTMLElement: Configured cell div
function fCreateAndFormatCell(r, c, value, rowFormat) {
    const cell = document.createElement("div"); 
    cell.className = "cell"; 

    const originalValue = value ?? ""; 
    const valStr = String(originalValue).toUpperCase(); 
    const isCheckbox = value === true || 
                       value === false || valStr === "TRUE" || valStr === "FALSE"; 

    const bgColor = rowFormat.bg?.[c]; 
    const isEditable = fCheckIfEditable(bgColor, isCheckbox); 
    fSetCellAttributes(cell, r, c, isEditable); 
    fCheckAndTagNote(cell, r, c); 

    // Check if dropdown applies
    const dropConfig = fFindDropdownMatch(r, c); 
    if (dropConfig) { 
        const select = fMakeDropdown(r, c, dropConfig, value); 
        cell.appendChild(select); 
    } else { 
        const { displayValue, isUrl } = fCheckAndTagUrl(cell, originalValue); 
        fPopulateCellContent(cell, r, c, displayValue, isCheckbox); 
    } 

    fApplyCellFormatting(cell, c, bgColor, rowFormat); 

    return cell; // 
} // END fCreateAndFormatCell




// fFindDropdownMatch ///////////////////////////////////////////////////////////////////////////
// Purpose -> Checks if (r,c) falls within any gUI.dropDownBox.range. Returns the config or null.
// Outputs -> (Object|null): The dropdown config object or null.
function fFindDropdownMatch(r, c) {
    for (const config of gUI.dropDownBox) {
        for (const range of config.ranges) {
            const r1 = resolveRow(range.r1), r2 = resolveRow(range.r2);
            const c1 = resolveCol(range.c1), c2 = resolveCol(range.c2);
            if (
                !isNaN(r1) && !isNaN(r2) && !isNaN(c1) && !isNaN(c2) &&
                r >= Math.min(r1, r2) && r <= Math.max(r1, r2) &&
                c >= Math.min(c1, c2) && c <= Math.max(c1, c2)
            ) return config;
        }
    }
    return null;
} // END fFindDropdownMatch




// fMakeDropdown ///////////////////////////////////////////////////////////////////////////////
// Purpose -> Builds a <select> element populated with dropdown choices.
// Inputs  -> r (row), c (col), config (from dropDownBox), currentVal (value in cell)
// Outputs -> HTMLSelectElement
function fMakeDropdown(r, c, config, currentVal) {
    const select = document.createElement("select");
    select.dataset.r = r;
    select.dataset.c = c;

    for (const choice of config.choices) {
        const option = document.createElement("option");
        option.value = String(choice);
        option.textContent = String(choice);
        if (String(choice) === String(currentVal)) option.selected = true;
        select.appendChild(option);
    }

    select.classList.add("dropdown-cell");
    return select;
} // END fMakeDropdown





// fCheckIfEditable ///////////////////////////////////////////////////////////////////
// Returns true if cell should be editable based on background and type.
function fCheckIfEditable(bgColor, isCheckbox) {
    const isWhiteBg = (!bgColor || bgColor.toLowerCase() === '#ffffff' || bgColor === 'white');
    return isWhiteBg && !isCheckbox;
};



// fSetCellAttributes ////////////////////////////////////////////////////////////////
// Sets row, col, and contentEditable attributes if applicable.
function fSetCellAttributes(cell, r, c, isEditable) {
    cell.dataset.r = r;
    cell.dataset.c = c;
    if (isEditable) {
        cell.contentEditable = true;
        cell.style.justifyContent = 'flex-start';
        cell.style.textAlign = 'left';
    }
};




// fCheckAndTagNote //////////////////////////////////////////////////////////////////
// Adds 'has-note' class if gUI.notes contains a non-empty value for this cell.
function fCheckAndTagNote(cell, r, c) {
    const noteText = gUI.notes?.[r]?.[c]?.trim();
    if (noteText) cell.classList.add('has-note');
};



// fCheckAndTagUrl ///////////////////////////////////////////////////////////////////
// Checks for URLs and images, adds relevant classes and dataset props.
// Returns { displayValue, isUrl }
function fCheckAndTagUrl(cell, value) {
    const trimmed = typeof value === 'string' ? value.trim() : '';
    const isUrl = trimmed.startsWith('http://') || trimmed.startsWith('https://');
    let displayValue = value;
    if (!isUrl) return { displayValue, isUrl };

    cell.classList.add('url-link');
    cell.dataset.url = trimmed;

    const driveMatch = trimmed.match(/drive\.google\.com\/file\/d\/([-\w]+)/);
    const imgExts = /\.(png|jpg|jpeg|gif|webp|svg)$/i;

    if (driveMatch && driveMatch[1]) {
        const fileId = driveMatch[1];
        const url = 'https://drive.google.com/uc?export=view&id=' + fileId;
        cell.classList.add('image-link');
        cell.dataset.imageSrc = url;
    } else if (imgExts.test(trimmed)) {
        cell.classList.add('image-link');
        cell.dataset.imageSrc = trimmed;
    }

    return { displayValue, isUrl };
};



// fPopulateCellContent /////////////////////////////////////////////////////////////
// Adds checkbox or text content to the cell, stripping IDs if needed.
function fPopulateCellContent(cell, r, c, displayValue, isCheckbox) {
    if (isCheckbox) {
        cell.appendChild(fMakeCheckBox(r, c));
    } else {
        const idPattern = /\s{2,}_\w{6}$/;
        const text = (typeof displayValue === 'string' && idPattern.test(displayValue))
            ? displayValue.replace(idPattern, '')
            : displayValue;
        cell.textContent = text;
    }
};





// fApplyCellFormatting /////////////////////////////////////////////////////////////
// Applies bgColor, font styles, wrap, etc.
function fApplyCellFormatting(cell, c, bgColor, rowFormat, isUrl) {
    if (bgColor) cell.style.backgroundColor = bgColor;
    const finalFontColor = null; // Placeholder if color logic is ever needed
    cell.style.color = finalFontColor || '';

    const { weight, fontSize, fontStyle, fontFamily, wrap } = rowFormat;
    if (weight?.[c]) cell.style.fontWeight = weight[c];
    if (fontSize?.[c]) cell.style.fontSize = `${fontSize[c]}px`;
    if (fontStyle?.[c]) cell.style.fontStyle = fontStyle[c];
    if (fontFamily?.[c]) cell.style.fontFamily = fontFamily[c];
    if (wrap?.[c]) cell.classList.add('wrap');
};




////////////////////////////////////////////////////////////////////////////////////////////////////////// END fCreateAndFormatCell and helpers



////////////////////////////////////////////////////////////////////////////////////////////////////////// START fRenderFullGrid and helpers




// fRenderFullGrid /////////////////////////////////////////////////////////////////////////////////
// Main controller that handles grid rendering logic using helpers.
function fRenderFullGrid(callback) {
    fMyConsoleLog("⚙️ Rendering Full Grid...");
    const grid = document.getElementById("grid");
    const gameArr = gUI.arr;
    const format = gUI.format || {};

    if (!fInitGridAndSettings(grid, gameArr)) return;

    const numRows = gameArr.length;
    const numCols = gameArr[0].length;

    fSetGridColumnWidths(grid, format, numCols);
    fSetGridTagsFromHeaders();

    gUI.grid2D = Array.from({ length: numRows }, () => Array(numCols).fill(null));
    fMyConsoleLog(`🏎️ Rendering ${numRows} rows in chunks of 50...`);

    const renderChunk = fRenderChunkFactory(grid, gameArr, format, 50, callback);
    requestAnimationFrame(renderChunk);
};






// fInitGridAndSettings ///////////////////////////////////////////////////////////////////////////////
// Validates DOM/grid array, clears DOM, and logs errors if necessary.
function fInitGridAndSettings(grid, gameArr) {
    if (!grid) {
        console.error("❌ Grid container #grid not found!");
        return false;
    }

    if (!Array.isArray(gameArr) || gameArr.length === 0 || !Array.isArray(gameArr[0])) {
        console.error("❌ gUI.arr is empty or malformed. Cannot render grid.");
        grid.innerHTML = '<p style="color:red;">Error: Invalid data array for rendering.</p>';
        return false;
    }

    grid.innerHTML = ""; // Clear old grid content
    return true;
};




// fSetGridColumnWidths /////////////////////////////////////////////////////////////////////////////
// Applies gridTemplateColumns to the #grid container from colWidths in format.
function fSetGridColumnWidths(grid, format, numCols) {
    const colWidths = format.colWidths || [];
    const gridTemplateColumns = colWidths.map(w => `${w || 60}px`).join(' ');
    grid.style.gridTemplateColumns = gridTemplateColumns;
    fMyConsoleLog(`📐 Applied ${numCols} column widths`);
};




// fBuildRowFormat /////////////////////////////////////////////////////////////////////////////////
// Extracts the row format object from the full format object for one row.
function fBuildRowFormat(format, rowIdx) {
    return {
        bg: format.bg?.[rowIdx],
        fontColorHex: format.fontColorHex?.[rowIdx],
        weight: format.weight?.[rowIdx],
        fontSize: format.fontSize?.[rowIdx],
        fontStyle: format.fontStyle?.[rowIdx],
        fontFamily: format.fontFamily?.[rowIdx],
        wrap: format.wrap?.[rowIdx]
    };
};



// fAppendRowCells /////////////////////////////////////////////////////////////////////////////////
// Renders one row of cells and appends to fragment and gUI.grid2D.
function fAppendRowCells(fragment, rowIdx, rowData, rowFormat, numCols) {
    for (let c = 0; c < numCols; c++) {
        const value = rowData?.[c];
        const cell = fCreateAndFormatCell(rowIdx, c, value, rowFormat);
        gUI.grid2D[rowIdx][c] = cell;
        fragment.appendChild(cell);
    }
};




// fRenderChunkFactory /////////////////////////////////////////////////////////////////////////////
// Returns a closure that handles chunked rendering using requestAnimationFrame.
function fRenderChunkFactory(grid, gameArr, format, chunkSize, callback) {
    let r = 0;
    const numRows = gameArr.length;
    const numCols = gameArr[0].length;

    return function renderChunk() {
        const fragment = document.createDocumentFragment();
        const endRow = Math.min(r + chunkSize, numRows);

        for (let rowIdx = r; rowIdx < endRow; rowIdx++) {
            const rowData = gameArr[rowIdx];
            const rowFormat = fBuildRowFormat(format, rowIdx);
            fAppendRowCells(fragment, rowIdx, rowData, rowFormat, numCols);
        }

        grid.appendChild(fragment);
        r = endRow;

        if (r < numRows) {
            requestAnimationFrame(renderChunk);
        } else {
            fMyConsoleLog(`✅ Grid Rendered (${numRows} rows)`);
            if (typeof callback === 'function') {
                fMyConsoleLog("🚀 Applying Post-Render Formatting...");
                setTimeout(callback, 0);
            }
        }
    };
};





////////////////////////////////////////////////////////////////////////////////////////////////////////// END fRenderFullGrid and helpers




// ==========================================================================
// === Grid Formatting & Visibility  (End of Core Rendering & Grid Tag Setup) ===
// ==========================================================================




// fSetHeader //////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Hides rows 0-1, offsets the grid, and freezes rows 2-4 as sticky headers.
// Adapted from older scripts.html, uses classes from style.html
function fSetHeader() {
    fMyConsoleLog("🔒 Applying Sticky Header...");
    const numRows = gUI.grid2D.length;
    if (numRows < 5) { // Need at least rows 0, 1, 2, 3, 4
        fMyConsoleLog("⚠️ Not enough rows for sticky header.");
        return;
    }
    const numCols = gUI.grid2D[0]?.length || 0;

    // Hide rows 0 and 1
    for (let r = 0; r <= 1; r++) {
        for (let c = 0; c < numCols; c++) {
            const cell = gUI.grid2D?.[r]?.[c];
            if (cell) cell.style.display = 'none';
        }
    }

    // Apply sticky class and dynamic top offset to Rows 2, 3, 4
    for (let r = 2; r <= 4; r++) {
        const offset = (r - 2) * gUI.ROW_HEIGHT_PX; // Updated reference // Offset starts at 0 for row 2

        for (let c = 0; c < numCols; c++) {
            const cell = gUI.grid2D?.[r]?.[c];
            if (!cell || cell.style.display === 'none') continue; // Skip hidden cells (e.g., merged away)

            cell.classList.add('sticky-header'); // Add class defined in style.html
            cell.style.top = `${offset}px`; // Set dynamic top offset

            // Re-apply background color to prevent sticky-header class background overriding original
            // (Requires background to be set during fRenderFullGrid)
            const bgColor = gUI.format?.bg?.[r]?.[c];
            cell.style.backgroundColor = bgColor || '#ffffff'; // Fallback to white if no specific bg
        }
    }

    // Add class to row below sticky section (Row 5) for visual effect
    if (numRows > 5) {
        const belowRowIndex = 5;
         for (let c = 0; c < numCols; c++) {
             const cell = gUI.grid2D?.[belowRowIndex]?.[c];
             if (cell && cell.style.display !== 'none') {
                 cell.classList.add('below-sticky');
             }
         }
    }
    fMyConsoleLog("✅ Sticky Header Applied");
}; // END fSetHeader




// fUpdateGridColumnTemplate //////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Recalculates and applies the grid-template-columns style based on gUI.hiddenColumns
// MODIFIED: Added console logs for debugging
function fUpdateGridColumnTemplate() {
    const grid = document.getElementById("grid");
    if (!grid || !gUI.format.colWidths || !gUI.arr || gUI.arr.length === 0) {
        console.error("   -> fUpdateGridColumnTemplate: Missing prerequisites."); return;
    }

    const numCols = gUI.arr[0].length;
    const colWidths = gUI.format.colWidths || [];
    let templateCols = [];
    let hiddenColsInTemplate = []; // DEBUG LOG

    for (let c = 0; c < numCols; c++) {
        if (gUI.hiddenColumns.has(c)) { // Check the Set
            templateCols.push("0px");
            hiddenColsInTemplate.push(c); // DEBUG LOG
        } else {
            const width = colWidths[c] || 60;
            templateCols.push(`${width}px`);
        }
    }
    const newTemplateString = templateCols.join(' ');

    grid.style.gridTemplateColumns = newTemplateString; // Apply the style

}; // END fUpdateGridColumnTemplate




// fSetColumnVisibility //////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Hides or shows a single column by index and updates grid template
// MODIFIED: Reverted to visibility:collapse, kept updateTemplate param and logs
function fSetColumnVisibility(colIndex, isVisible, updateTemplate = true) {
    if (isNaN(colIndex) || colIndex < 0 || !gUI.grid2D[0] || colIndex >= gUI.grid2D[0].length) {
        console.warn(`   -> Invalid column index ${colIndex}`); return;
    }

    const numRows = gUI.grid2D.length;
    const currentlyHidden = gUI.hiddenColumns.has(colIndex);
    const action = isVisible ? 'Showing' : 'Hiding';

    // Corrected condition from previous step
    if ((isVisible && currentlyHidden) || (!isVisible && !currentlyHidden)) {
        // fMyConsoleLog(`👁️ ${action} Column ${colIndex}...`); // Keep commented out for range ops

        if (isVisible) {
            gUI.hiddenColumns.delete(colIndex);
        } else {
            gUI.hiddenColumns.add(colIndex);
        }

        // Toggle cell visibility style for all cells in the column
        let cellsModifiedCount = 0; // DEBUG LOG counter
        for (let r = 0; r < numRows; r++) {
            const cell = gUI.grid2D[r]?.[colIndex];
            if (cell) {
                // *** CHANGE HERE: Use visibility: collapse instead of display: none ***
                cell.style.visibility = isVisible ? '' : 'collapse';
                cellsModifiedCount++; // DEBUG LOG counter
            }
        }

        // Regenerate the grid template only if requested
        if (updateTemplate) {
             fUpdateGridColumnTemplate();
        }
    }
}; // END fSetColumnVisibility




// fSetRowVisibility //////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Hides or shows a single row by index by setting cell display style.
function fSetRowVisibility(rowIndex, isVisible) {
     if (isNaN(rowIndex) || rowIndex < 0 || rowIndex >= gUI.grid2D.length) {
        console.warn(`Invalid row index ${rowIndex} for fSetRowVisibility`);
        return;
    }

    const numCols = gUI.grid2D[0]?.length || 0;
    const action = isVisible ? 'Showing' : 'Hiding';

    // --- REMOVED the check: if ((isVisible && !currentlyHidden) || (!isVisible && currentlyHidden)) ---
    // --- Always perform the action and update the Set ---

    if (isVisible) {
        gUI.hiddenRows.delete(rowIndex); // Remove from Set if showing
    } else {
        gUI.hiddenRows.add(rowIndex); // Add to Set if hiding
    }

    // Toggle display style for all cells in the row
    let foundCellCount = 0;
    for (let c = 0; c < numCols; c++) {
        const cell = gUI.grid2D[rowIndex]?.[c];
         if (cell) {
             foundCellCount++;
             cell.style.display = isVisible ? '' : 'none';
             if (!isVisible) { // Reset sticky styles if hiding
                 cell.classList.remove('sticky-header', 'below-sticky');
                 cell.style.position = ''; cell.style.top = ''; cell.style.zIndex = '';
             }
         } else {
             if (c < 5) console.warn(` -> Cell gUI.grid2D[${rowIndex}][${c}] not found!`);
          }
    }

    // If we just showed a row that might be sticky (2,3,4,5), re-apply header styles.
    // Note: Rows 0,1 are handled by fSetHeader directly.
    if (isVisible && rowIndex >= 2 && rowIndex <= 5) {
         fSetHeader(); // Re-run fSetHeader to ensure stickiness is correct
    }
    // --- REMOVED the else block that logged "already in desired state" ---

}; // END fSetRowVisibility




// fApplyDynamicMerges //////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Merges cells based on gUI.format.merges data using grid span and hiding covered cells.
// New function replacing older fMergeAllCellBlocks / fMergeCells logic
function fApplyDynamicMerges() {
    fMyConsoleLog("🧩 Applying Merges...");
    const merges = gUI.format?.merges || []; // Array of {row, col, rowspan, colspan}

    for (const mergeInfo of merges) {
        const r = mergeInfo.row;
        const c = mergeInfo.col;
        const rs = mergeInfo.rowspan;
        const cs = mergeInfo.colspan;

        // Get the top-left anchor cell of the merge area
        const anchor = gUI.grid2D?.[r]?.[c];
        if (!anchor) {
             console.warn(`⚠️ Merge anchor cell not found at [${r},${c}]`);
             continue;
        }

        // Apply grid span styles to the anchor cell
        if (cs > 1) anchor.style.gridColumn = `span ${cs}`;
        if (rs > 1) anchor.style.gridRow = `span ${rs}`;

        // Hide the other cells covered by the merge
        for (let rSub = r; rSub < r + rs; rSub++) {
            for (let cSub = c; cSub < c + cs; cSub++) {
                if (rSub === r && cSub === c) continue; // Don't hide the anchor itself

                const cellToHide = gUI.grid2D?.[rSub]?.[cSub];
                if (cellToHide) {
                    cellToHide.style.display = 'none';
                }
            }
        }
    }
     fMyConsoleLog("✅ Merges Applied");
}; // END fApplyDynamicMerges




// fApplyManualBorders //////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Applies border styles to ALL cells within predefined sections using tags,
//            replicating the old fSetBorderColor behavior (top/left on all, optional right/bottom on edges).
function fApplyManualBorders() {
    fMyConsoleLog("🖌️ Applying Manual Borders (Old Style)...");
    let appliedCount = 0;

    gUI.manualBorderSections.forEach(section => {
        const rowStart = resolveRow(section.r1);
        const colStart = resolveCol(section.c1);
        const rowEnd = resolveRow(section.r2);
        const colEnd = resolveCol(section.c2);
        const borderStyle = section.style || '1px solid #000'; // Default to black
        const edges = section.edges || ''; // Get edge flags, default to empty string

        // Validate resolved indices
        if ([rowStart, colStart, rowEnd, colEnd].some(v => isNaN(v))) {
            console.warn("Skipping manual border section due to invalid tags:", section);
            return; // Skip this section if tags don't resolve
        }

        // Apply borders replicating old fSetBorderColor logic
        for (let r = rowStart; r <= rowEnd; r++) {
            for (let c = colStart; c <= colEnd; c++) {
                const cell = gUI.grid2D?.[r]?.[c];
                // Skip non-existent cells or those hidden by merging
                if (!cell || cell.style.display === 'none') continue;

                let appliedThisCell = false;

                // Apply Top and Left to ALL cells in the rectangle
                cell.style.borderTop = borderStyle;
                cell.style.borderLeft = borderStyle;
                appliedThisCell = true; // Count applying top/left as one application for logging

                // Apply Right border only if it's the last column AND edges flag allows 'r'
                if (edges.includes('r') && c === colEnd) {
                    cell.style.borderRight = borderStyle;
                }

                // Apply Bottom border only if it's the last row AND edges flag allows 'b'
                if (edges.includes('b') && r === rowEnd) {
                    cell.style.borderBottom = borderStyle;
                }

                if(appliedThisCell) appliedCount++;

            } // end col loop
        } // end row loop
    }); // end forEach section

    fMyConsoleLog(`✅ Manual Borders Applied (Old Style - ${appliedCount} styles set)`);
}; // END fApplyManualBorders




// fApplyManualColoring ////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Applies specific font colors to predefined ranges based on gUI.fontColorRange (new array structure).
//            Includes contrast check against background color.
// MODIFIED: Iterates through an array of color objects, using the 'color' property directly.
function fApplyManualColoring() {
    fMyConsoleLog("🎨 Applying Manual Font Colors (Hex Config)...");
    const colorConfigArray = gUI.fontColorRange; // Now expects an array

    // Check if the config is a valid array
    if (!Array.isArray(colorConfigArray)) {
        fMyConsoleLog("ℹ️ Manual font color configuration (gUI.fontColorRange) is not an array or is missing.");
        return;
    }
    if (colorConfigArray.length === 0) {
        fMyConsoleLog("ℹ️ Manual font color configuration is empty.");
        return;
    }

    let colorsAppliedCount = 0;
    let contrastAppliedCount = 0;

    // Iterate through each color definition object in the array
    colorConfigArray.forEach((colorDef, index) => {
        // Validate the structure of the current color definition object
        if (!colorDef || typeof colorDef.color !== 'string' || !Array.isArray(colorDef.ranges)) {
             console.warn(`Skipping invalid color definition at index ${index}:`, colorDef);
             return; // Skip to the next definition in the forEach loop
        }

        const cssColor = colorDef.color; // Get the hex color string directly
        const ranges = colorDef.ranges;   // Get the array of ranges for this color

        // Iterate through each range object for the current color
        ranges.forEach(range => {
            if (!fIsValidRangeObject(range)) {
                 console.warn(`Skipping invalid range object for color '${cssColor}':`, range);
                 return;
            }

            const resolved = fResolveRangeIndices(range);
            if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
                 console.warn(`Could not resolve tags for range in color '${cssColor}':`, range);
                 return;
            }

            const rMin = Math.min(resolved.r1, resolved.r2);
            const rMax = Math.max(resolved.r1, resolved.r2);
            const cMin = Math.min(resolved.c1, resolved.c2);
            const cMax = Math.max(resolved.c1, resolved.c2);

            // Iterate through cells in the resolved range
            for (let r = rMin; r <= rMax; r++) {
                for (let c = cMin; c <= cMax; c++) {
                    const cell = gUI.grid2D?.[r]?.[c];
                    if (!cell || cell.style.display === 'none') continue;

                    let cellBgColor = window.getComputedStyle(cell).backgroundColor;
                     if (cellBgColor && cellBgColor.startsWith('rgb')) {
                        try {
                            const rgb = cellBgColor.match(/\d+/g).map(Number);
                             cellBgColor = '#' + rgb.map(x => { const hex = x.toString(16); return hex.length === 1 ? '0' + hex : hex; }).join('');
                         } catch (e) {
                             cellBgColor = cell.style.backgroundColor || gUI.format?.bg?.[r]?.[c] || '#ffffff';
                         }
                     } else {
                         cellBgColor = cell.style.backgroundColor || gUI.format?.bg?.[r]?.[c] || '#ffffff';
                     }
                    const cleanBgColor = cellBgColor.toLowerCase();
                    const intendedFontColor = cssColor.toLowerCase(); // Use the hex color

                    // Apply color, considering contrast
                    if (intendedFontColor === cleanBgColor) {
                        cell.style.color = fGetContrastColor(cleanBgColor);
                        contrastAppliedCount++;
                    } else {
                        cell.style.color = intendedFontColor;
                        colorsAppliedCount++;
                    }
                } // end col loop
            } // end row loop
        }); // end forEach range
    }); // end forEach colorDef

    fMyConsoleLog(`✅ Manual Colors Applied (${colorsAppliedCount} direct, ${contrastAppliedCount} contrast).`);

}; // END fApplyManualColoring



////////////////////////////////////////////////////////////////////////////////////////////////////////// START fAddHeaderButtons and helpers




// fAddHeaderButtons ////////////////////////////////////////////////////////////////
// Purpose -> Finds specific cells designated as header buttons and inserts them.
// Inputs  -> None
// Outputs -> None (Modifies DOM)
function fAddHeaderButtons() {
    fMyConsoleLog("⚙️ Adding Header Buttons...");
    let buttonsAdded = 0;

    const headerButtonConfigs = [
        {
            rowTag: 'Button_R',
            colTag: 'DieButtonC',
            action: 'action-rollDice',
            imageUrl: 'https://raw.githubusercontent.com/bmobley333/TurboApp/main/Pics/Buttons/Button_d20.png',
            altText: 'Roll Dice',
            titleText: 'Roll Dice'
        },
        {
            rowTag: 'Button_R',
            colTag: 'RefreshButtonC',
            action: 'action-refreshData',
            imageUrl: 'https://raw.githubusercontent.com/bmobley333/TurboApp/main/Pics/Buttons/Button_Refresh.png',
            altText: 'Refresh Data',
            titleText: 'Refresh Data'
        },
        {
            rowTag: 'Button_R',
            colTag: 'UpArrowButtonC',
            action: 'action-jumpTop',
            imageUrl: 'https://raw.githubusercontent.com/bmobley333/TurboApp/main/Pics/Buttons/Button_UpArrow.png',
            altText: 'Jump to Top',
            titleText: 'Jump to Top'
        },
        {
            rowTag: 'Button_R',
            colTag: 'DownArrowButtonC',
            action: 'action-jumpBottom',
            imageUrl: 'https://raw.githubusercontent.com/bmobley333/TurboApp/main/Pics/Buttons/Button_DownArrow.png',
            altText: 'Jump to Bottom',
            titleText: 'Jump to Bottom'
        },
        {
            rowTag: 'Button_R',
            colTag: 'MonsterButtonC',
            action: 'action-showMonsters',
            imageUrl: 'https://raw.githubusercontent.com/bmobley333/TurboApp/main/Pics/Buttons/Button_Monster.png',
            altText: 'Show Monsters',
            titleText: 'Show Monsters'
        }
    ];

    headerButtonConfigs.forEach(config => {
        const cell = fGetResolvedCell(config.rowTag, config.colTag);
        if (!cell) return;

        const img = fCreateHeaderButtonImage(config);
        fApplyHeaderButtonToCell(cell, img);
        buttonsAdded++;
    });

    fMyConsoleLog(buttonsAdded > 0
        ? `✅ Added ${buttonsAdded} Header Button(s).`
        : `ℹ️ No valid Header Buttons found or added.`);
};



// fGetResolvedCell ////////////////////////////////////////////////////////////////
// Purpose -> Resolve a cell element in gUI.grid2D from rowTag and colTag.
// Inputs  -> rowTag: string, colTag: string
// Outputs -> Cell element or null
function fGetResolvedCell(rowTag, colTag) {
    const r = resolveRow(rowTag);
    const c = resolveCol(colTag);

    if (isNaN(r) || isNaN(c)) {
        console.warn(`⚠️ Header Button: Could not resolve tags [${rowTag}, ${colTag}]`);
        return null;
    }

    const cell = gUI.grid2D?.[r]?.[c];
    if (!cell) {
        console.warn(`⚠️ Header Button: Cell element not found at resolved [${r}, ${c}] for tags [${rowTag}, ${colTag}]`);
        return null;
    }

    return cell;
};




// fCreateHeaderButtonImage ///////////////////////////////////////////////////////
// Purpose -> Create and return a styled <img> element for a header button.
// Inputs  -> config: button config object with imageUrl, altText, titleText, action
// Outputs -> <img> element
function fCreateHeaderButtonImage(config) {
    const img = document.createElement('img');
    img.src = config.imageUrl;
    img.alt = config.altText;
    img.title = config.titleText;
    img.dataset.buttonAction = config.action;
    img.classList.add('header-button-img');
    return img;
};




// fApplyHeaderButtonToCell ///////////////////////////////////////////////////////
// Purpose -> Clear the cell, insert image, apply styling.
// Inputs  -> cell: HTMLElement, img: HTMLElement
// Outputs -> None (modifies DOM)
function fApplyHeaderButtonToCell(cell, img) {
    cell.innerHTML = '';
    cell.appendChild(img);

    cell.style.justifyContent = 'center';
    cell.style.alignItems = 'center';
    cell.style.padding = '0';
};










////////////////////////////////////////////////////////////////////////////////////////////////////////// END fAddHeaderButtons and helpers


// fMarkOverflowingCells //////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Adds 'overflow-left' class to cells where content width exceeds cell width.
//            Optimized to reduce forced reflows by batching reads and writes.
function fMarkOverflowingCells() {
    fMyConsoleLog("↔️ Checking Cell Overflow (Optimized)...");
    const cells = document.querySelectorAll('#grid .cell:not([style*="display: none"])');
    let cellsToModify = []; // Array to store { cellElement: cell, shouldOverflow: boolean }

    // --- Phase 1: Read ---
    // Read dimensions without modifying the DOM
    cells.forEach(cell => {
        // Read clientWidth and scrollWidth
        const clientW = cell.clientWidth;
        const scrollW = cell.scrollWidth;
        // Determine if overflow class should be applied (using a small tolerance)
        const shouldOverflow = scrollW > clientW + 1;
        // Store the result and the element reference
        cellsToModify.push({ cellElement: cell, shouldOverflow: shouldOverflow });
    });

    // --- Phase 2: Write ---
    // Apply class changes based on stored results
    let count = 0;
    cellsToModify.forEach(item => {
        const cell = item.cellElement;
        const currentlyHasClass = cell.classList.contains('overflow-left');

        if (item.shouldOverflow && !currentlyHasClass) {
            cell.classList.add('overflow-left');
            count++;
        } else if (!item.shouldOverflow && currentlyHasClass) {
            cell.classList.remove('overflow-left');
            // Optionally count removals or just net additions: count++;
        }
        // If shouldOverflow === currentlyHasClass, do nothing.
    });

    fMyConsoleLog(`✅ Overflow Checked (Optimized - ${count} cells newly marked)`);
}; // END fMarkOverflowingCells




// fHideColumnRange //////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Hides multiple ranges of columns defined by an array of objects. Updates template once.
// MODIFIED: Added console logs for debugging
function fHideColumnRange(rangeArray) {
    fMyConsoleLog(`👁️ Hiding Column Ranges...`);
    if (!Array.isArray(rangeArray)) {
        console.error("   -> ❌ Invalid input: fHideColumnRange requires an array.", rangeArray);
        return;
    }

    let anyColumnsChanged = false;

    // Loop through each range object in the array
    for (const range of rangeArray) {
        if (!range || typeof range.c1 === 'undefined' || typeof range.c2 === 'undefined') {
             console.warn("   -> Skipping invalid range object:", range);
             continue;
        }
        const startCol = resolveCol(range.c1);
        const endCol = resolveCol(range.c2);

        if (isNaN(startCol) || isNaN(endCol)) {
            console.warn(`   -> Skipping range due to invalid tags/indices: ${range.c1}, ${range.c2}`);
            continue; // Skip this range if tags don't resolve
        }

        const cMin = Math.min(startCol, endCol);
        const cMax = Math.max(startCol, endCol);

        // Loop through columns within the current range
        for (let c = cMin; c <= cMax; c++) {
            const currentlyHidden = gUI.hiddenColumns.has(c);
            if (!currentlyHidden) {
                // Call will log its own details now
                fSetColumnVisibility(c, false, false); // Hide column, DO NOT update template yet
                anyColumnsChanged = true;
            } else {
            }
        }
    } // End loop through rangeArray

    // Update the grid template ONCE after processing all ranges
    if (anyColumnsChanged) {
        fUpdateGridColumnTemplate();
        fMyConsoleLog(`✅ Column Ranges Hidden.`);
    } else {
        fMyConsoleLog(`ℹ️ All Specified Column Ranges Already Hidden (or no valid ranges found).`);
    }
}; // END fHideColumnRange




// fShowColumnRange //////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Shows multiple ranges of columns defined by an array of objects. Updates template once.
function fShowColumnRange(rangeArray) {
    fMyConsoleLog(`👁️ Showing Column Ranges...`);
    if (!Array.isArray(rangeArray)) {
        console.error("❌ Invalid input: fShowColumnRange requires an array.", rangeArray);
        return;
    }

    let anyColumnsChanged = false;

    // Loop through each range object in the array
    for (const range of rangeArray) {
        if (!range || typeof range.c1 === 'undefined' || typeof range.c2 === 'undefined') {
             console.warn("Skipping invalid range object in fShowColumnRange:", range);
             continue;
        }
        const startCol = resolveCol(range.c1);
        const endCol = resolveCol(range.c2);

        if (isNaN(startCol) || isNaN(endCol)) {
            console.warn(`Skipping range due to invalid tags/indices in fShowColumnRange: ${range.c1}, ${range.c2}`);
            continue; // Skip this range if tags don't resolve
        }

        // Ensure startCol <= endCol
        const cMin = Math.min(startCol, endCol);
        const cMax = Math.max(startCol, endCol);

        // Loop through columns within the current range
        for (let c = cMin; c <= cMax; c++) {
             const currentlyHidden = gUI.hiddenColumns.has(c);
             if (currentlyHidden) { // Only act if column IS hidden
                 fSetColumnVisibility(c, true, false); // Show column, DO NOT update template yet
                 anyColumnsChanged = true;
             }
        }
    } // End loop through rangeArray

    // Update the grid template ONCE after processing all ranges
    if (anyColumnsChanged) {
        fUpdateGridColumnTemplate();
        fMyConsoleLog(`✅ Column Ranges Shown.`);
    } else {
         fMyConsoleLog(`ℹ️ All Specified Column Ranges Already Visible (or no valid ranges found).`);
    }
}; // END fShowColumnRange




// fApplyInitialVisibility //////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Applies the initial hidden state for columns and rows based on gUI definitions
// MODIFIED: Added console logs for debugging
function fApplyInitialVisibility() {
    fMyConsoleLog("👁️ Applying Initial Visibility...");

    // Initial Columns - Use fHideColumnRange
    if (gUI.initialHiddenCols && gUI.initialHiddenCols.length > 0) {
        fHideColumnRange(gUI.initialHiddenCols); // Calls the range function
    } else {
         fMyConsoleLog("   -> ℹ️ No initial columns defined to hide.");
    }


    // Initial Rows - Still uses fSetRowVisibility individually
    if (gUI.initialHiddenRows && gUI.initialHiddenRows.length > 0) {
        fMyConsoleLog("   -> 👁️ Hiding Initial Rows...");
        gUI.initialHiddenRows.forEach(range => {
             const r1 = resolveRow(range.r1); const r2 = resolveRow(range.r2);
             if (isNaN(r1) || isNaN(r2)) { console.warn("   -> Invalid row tag in initialHiddenRows:", range); return; }
             const startRow = Math.min(r1, r2); const endRow = Math.max(r1, r2);
             for (let r = startRow; r <= endRow; r++) { fSetRowVisibility(r, false); }
        });
         fMyConsoleLog("   -> ✅ Initial Rows Hidden.");
    } else {
        fMyConsoleLog("   -> ℹ️ No initial rows defined to hide.");
    }

}; // END fApplyInitialVisibility




// ==========================================================================
// === Grid Hover                 (End of Grid Formatting & Visibility) ===
// ==========================================================================




// fPositionTooltip //////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Calculates and sets the position of the tooltip, keeping it within the viewport.
// Inputs -> tooltip (HTMLElement): The tooltip element.
//       -> event (MouseEvent): The mouse event that triggered the hover.
function fPositionTooltip(tooltip, event) {
    if (!tooltip || !event) return;

    // Get cursor position from the event
    const cursorX = event.pageX;
    const cursorY = event.pageY;

    // Get tooltip dimensions (might require a brief display toggle if not already visible, but usually okay)
    // If it was just made visible, dimensions should be available.
    const tooltipRect = tooltip.getBoundingClientRect(); // Use getBoundingClientRect for dimensions including border
    const tooltipWidth = tooltipRect.width;
    const tooltipHeight = tooltipRect.height;

    // Get viewport dimensions
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const scrollX = window.scrollX; // Horizontal scroll offset
    const scrollY = window.scrollY; // Vertical scroll offset

    // Calculate initial desired position (below and right of cursor)
    let newTop = cursorY + gUI.TOOLTIP_OFFSET_Y;  // Updated reference
    let newLeft = cursorX + gUI.TOOLTIP_OFFSET_X; // Updated reference

    // Adjust if tooltip goes off the right edge of the viewport
    if (newLeft + tooltipWidth > viewportWidth + scrollX) {
        newLeft = cursorX - tooltipWidth - gUI.TOOLTIP_OFFSET_X; // Updated reference // Move to the left of the cursor
        // Optional: Add check if it now goes off the left edge too (unlikely with reasonable tooltip width)
        if (newLeft < scrollX) { newLeft = scrollX + 5; } // Stick near left edge if needed
    }

    // Adjust if tooltip goes off the bottom edge of the viewport
    if (newTop + tooltipHeight > viewportHeight + scrollY) {
        newTop = cursorY - tooltipHeight - gUI.TOOLTIP_OFFSET_Y; // Updated reference // Move above the cursor
        // Optional: Add check if it now goes off the top edge too
        if (newTop < scrollY) { newTop = scrollY + 5; } // Stick near top edge if needed
    }

    // Apply the calculated position
    tooltip.style.top = `${newTop}px`;
    tooltip.style.left = `${newLeft}px`;

}; // END fPositionTooltip



////////////////////////////////////////////////////////////////////////////////////////////////////////// START fHandleCellHover and helpers




// fHandleCellHover /////////////////////////////////////////////////////////////////////////////////
// Delegated mouseenter/mouseover handler for grid cells (shows tooltips for overflow + notes)
function fHandleCellHover(event) {
    if (!gUI.tooltipElement) return; // Updated reference

    const cell = fGetValidTargetCell(event);
    if (!cell) {
        fHideTooltip();
        return;
    }

    // No need to call fHideTooltip here because fStartTooltipTimer clears the old one.
    fStartTooltipTimer(cell, event);
};



// fGetValidTargetCell ////////////////////////////////////////////////////////////////////////////////
// Returns the closest .cell from the event or null if invalid.
function fGetValidTargetCell(event) {
    return event.target.closest('.cell');
};




// fHideTooltip ///////////////////////////////////////////////////////////////////////////////////////
// Clears timeout and hides tooltip.
function fHideTooltip() {
    clearTimeout(gUI.tooltipTimeoutId); // Updated reference
    gUI.tooltipTimeoutId = null; // Clear the stored ID as well
    if (gUI.tooltipElement) gUI.tooltipElement.style.display = 'none'; // Updated reference
};




// fShouldShowTooltip ////////////////////////////////////////////////////////////////////////////////
// Returns boolean: true if cell is overflowing or has a note.
function fShouldShowTooltip(r, c, cell) {
    const isOverflowing = cell.scrollWidth > cell.clientWidth + 1;
    const noteText = gUI.notes?.[r]?.[c]?.trim();
    return isOverflowing || !!noteText;
};




// fBuildTooltipContent /////////////////////////////////////////////////////////////////////////////
// Builds tooltip HTML content from overflow text and note.
function fBuildTooltipContent(r, c, cell) {
    const isOverflowing = cell.scrollWidth > cell.clientWidth + 1;
    const noteText = gUI.notes?.[r]?.[c]?.trim();
    let tooltipContent = '';

    if (isOverflowing) {
        tooltipContent = cell.textContent;
    }

    if (noteText) {
        if (tooltipContent) tooltipContent += "\n---\n";
        tooltipContent += `Note: ${noteText}`;
    }

    return tooltipContent.replace(/\n/g, '<br>');
};




// fStartTooltipTimer /////////////////////////////////////////////////////////////////////////////
// Sets a timeout to show tooltip after HOVER_DELAY_MS.
function fStartTooltipTimer(cell, event) {
    // Clear any existing timeout before starting a new one
    clearTimeout(gUI.tooltipTimeoutId); // Updated reference

    gUI.tooltipTimeoutId = setTimeout(() => { // Updated reference
        const r = parseInt(cell.dataset.r, 10);
        const c = parseInt(cell.dataset.c, 10);

        if (isNaN(r) || isNaN(c)) {
            console.warn("Tooltip hover: Invalid r/c data attributes.", cell.dataset);
            fHideTooltip();
            return;
        }

        if (fShouldShowTooltip(r, c, cell)) {
            gUI.tooltipElement.innerHTML = fBuildTooltipContent(r, c, cell); // Updated reference
            gUI.tooltipElement.style.display = 'block';                     // Updated reference
            fPositionTooltip(gUI.tooltipElement, event);                    // Updated reference
        } else {
            fHideTooltip();
        }

    }, gUI.HOVER_DELAY_MS); // Updated reference
};




////////////////////////////////////////////////////////////////////////////////////////////////////////// END fHandleCellHover and helpers




// fHandleCellMouseOut //////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Handles mouseout/mouseleave events delegated from the grid to hide the tooltip.
// Inputs -> event (MouseEvent): The mouse event.
function fHandleCellMouseOut(event) {
    // Clear the pending timeout *immediately* if the mouse leaves before the delay finishes
    clearTimeout(gUI.tooltipTimeoutId); // Updated reference
    gUI.tooltipTimeoutId = null; // Reset the timeout ID // Updated reference

    // Hide the tooltip if it's currently visible
    if (gUI.tooltipElement) { // Updated reference
        gUI.tooltipElement.style.display = 'none'; // Updated reference
    }
}; // END fHandleCellMouseOut




// ==========================================================================
// === Dropdown Boxes           (End of Grid Hover or appropriate section) ===
// ==========================================================================




// fCreateDropdownElement ///////////////////////////////////////////////////////////////////
// Purpose -> Creates an HTML select element for a grid cell dropdown.
// Inputs  -> r (Number): Row index.
//         -> c (Number): Column index.
//         -> choices (Array): Array of option values for the dropdown.
//         -> currentValue (Any): The current value from gUI.arr to pre-select.
// Outputs -> (HTMLElement): The configured <select> element.
function fCreateDropdownElement(r, c, choices, currentValue) {
    const select = document.createElement('select');
    select.classList.add('grid-dropdown'); // Add class for styling
    select.dataset.r = r; // Store row index
    select.dataset.c = c; // Store col index

    // Ensure currentValue is a string for comparison (select values are strings)
    const currentValStr = String(currentValue ?? '');

    choices.forEach(choice => {
        const option = document.createElement('option');
        option.value = choice;
        option.textContent = choice;
        // Pre-select the option matching the current value
        if (String(choice) === currentValStr) {
            option.selected = true;
        }
        select.appendChild(option);
    });

    return select;

} // END fCreateDropdownElement




// fHandleDropdownChange ////////////////////////////////////////////////////////////////////
// Purpose -> Handles the 'change' event for grid dropdowns. Updates gUI.arr.
// Inputs  -> event (Event): The change event object from the select element.
// Outputs -> None (Modifies gUI.arr).
function fHandleDropdownChange(event) {
    const select = event.target;
    const r = parseInt(select.dataset.r, 10);
    const c = parseInt(select.dataset.c, 10);
    const newValue = select.value; // The selected value is always a string

    // Validate indices
    if (isNaN(r) || isNaN(c) || !gUI.arr?.[r]) {
         console.warn(`Dropdown change handler: Invalid coordinates [${r}, ${c}] from dataset.`);
         return;
    }

    // Attempt to convert back to number if original choices included numbers
    // This is a simple heuristic; might need refinement if choices mix strings/numbers ambiguously
    const originalChoice = gUI.dropDownBox
        .find(config => config.ranges.some(range => { // Find the config that applies to this cell
            const resolved = fResolveRangeIndices(range);
            return !isNaN(resolved.r1) && !isNaN(resolved.c1) && !isNaN(resolved.r2) && !isNaN(resolved.c2) &&
                   r >= Math.min(resolved.r1, resolved.r2) && r <= Math.max(resolved.r1, resolved.r2) &&
                   c >= Math.min(resolved.c1, resolved.c2) && c <= Math.max(resolved.c1, resolved.c2);
        }))?.choices.find(choice => String(choice) === newValue);

    const finalValue = (typeof originalChoice === 'number') ? Number(newValue) : newValue;

    // Update data model if value actually changed
    if (gUI.arr[r][c] !== finalValue) {
        gUI.arr[r][c] = finalValue;
        fMyConsoleLog(`Dropdown [${r}, ${c}] changed to: "${finalValue}" (Type: ${typeof finalValue})`);
        // Note: DOM select element is already updated visually by the browser.
        // If we need to trigger other updates based on this change, add them here.
    }

} // END fHandleDropdownChange




// fApplyDropdownsToGrid ////////////////////////////////////////////////////////////////////
// Purpose -> Iterates through gUI.dropDownBox configs and replaces relevant cell content with dropdowns.
// Inputs  -> None (Uses gUI.dropDownBox, gUI.arr, gUI.grid2D).
// Outputs -> None (Modifies DOM).
function fApplyDropdownsToGrid() {
    fMyConsoleLog("🧬 Applying Dropdowns to Grid...");
    let dropdownsApplied = 0;

    if (!gUI.dropDownBox || !Array.isArray(gUI.dropDownBox)) {
        fMyConsoleLog("ℹ️ No dropdown configurations found in gUI.dropDownBox.");
        return;
    }

    gUI.dropDownBox.forEach(config => {
        if (!config.choices || !config.ranges || !Array.isArray(config.choices) || !Array.isArray(config.ranges)) {
            console.warn("Skipping invalid dropdown config:", config);
            return;
        }

        config.ranges.forEach(range => {
            if (!fIsValidRangeObject(range)) {
                 console.warn("Skipping invalid range object within dropdown config:", range);
                 return;
            }
            const resolved = fResolveRangeIndices(range);
            if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
                 console.warn("Skipping dropdown range due to unresolved indices:", range);
                 return;
            }

            const rMin = Math.min(resolved.r1, resolved.r2);
            const rMax = Math.max(resolved.r1, resolved.r2);
            const cMin = Math.min(resolved.c1, resolved.c2);
            const cMax = Math.max(resolved.c1, resolved.c2);

            for (let r = rMin; r <= rMax; r++) {
                for (let c = cMin; c <= cMax; c++) {
                    const cell = gUI.grid2D?.[r]?.[c];
                    // Only apply to existing, visible cells that aren't checkboxes or already dropdowns
                    if (cell && cell.style.display !== 'none' && !cell.querySelector('input[type="checkbox"]') && !cell.querySelector('select.grid-dropdown')) {
                         const currentValue = gUI.arr?.[r]?.[c];
                         const dropdown = fCreateDropdownElement(r, c, config.choices, currentValue);
                         cell.innerHTML = ''; // Clear existing content (like text value)
                         cell.appendChild(dropdown);
                         cell.style.padding = '0'; // Remove padding to fit dropdown
                         cell.style.overflow = 'visible'; // Allow dropdown to overflow cell bounds visually
                         dropdownsApplied++;
                    }
                }
            }
        });
    });

    fMyConsoleLog(`✅ Applied ${dropdownsApplied} Dropdowns.`);

} // END fApplyDropdownsToGrid



// ==========================================================================
// === Grid Interaction Logic          (End of Dropdown Boxes ) ===
// ==========================================================================




////////////////////////////////////////////////////////////////////////////////////////////////////////// START fHandleGridCheckboxClick and helpers




// fHandleGridCheckboxClick ////////////////////////////////////////////////////////////////////
// Purpose -> Handles checkbox click events from fHandleGridClick.
// Inputs  -> event (MouseEvent)
// Outputs -> None (modifies gUI.arr and DOM)
function fHandleGridCheckboxClick(event) {
    const checkbox = event.target;
    if (!fIsValidGridCheckbox(checkbox)) return;

    const r = parseInt(checkbox.dataset.r, 10);
    const c = parseInt(checkbox.dataset.c, 10);
    if (!fIsValidGridCoords(r, c)) {
        console.warn("Checkbox click handler: Invalid row/column index or missing grid element.", checkbox.dataset);
        return;
    }

    const isChecked = checkbox.checked;
    const isSkGroupMember = checkbox.dataset.skGroup === 'true';

    if (isSkGroupMember) {
        fHandleSkGroupCheckboxClick(r, c, isChecked);
    } else {
        gUI.arr[r][c] = isChecked;
        fMyConsoleLog(`Checkbox [${r}, ${c}] toggled to: ${isChecked}`);
    }
};



// fIsValidGridCheckbox ////////////////////////////////////////////////////////////////////////
// Purpose -> Ensure the clicked element is a valid checkbox inside a grid cell.
// Inputs  -> checkbox (HTMLElement)
// Outputs -> true if valid, false otherwise
function fIsValidGridCheckbox(checkbox) {
    return checkbox &&
           checkbox.tagName === 'INPUT' &&
           checkbox.type === 'checkbox' &&
           checkbox.closest('.cell') &&
           !checkbox.disabled;
};




// fIsValidGridCoords ////////////////////////////////////////////////////////////////////////
// Purpose -> Ensure the coordinates are valid integers and point to existing grid rows.
// Inputs  -> r: row index, c: col index
// Outputs -> true if valid, false otherwise
function fIsValidGridCoords(r, c) {
    return !isNaN(r) && !isNaN(c) &&
           r >= 0 && c >= 0 &&
           gUI.arr[r] && gUI.grid2D[r];
};




// fHandleSkGroupCheckboxClick ////////////////////////////////////////////////////////////////
// Purpose -> Logic for checkboxes that are part of an sk-radio group.
// Inputs  -> r, c: current coordinates, isChecked: boolean
// Outputs -> None (modifies gUI.arr and gUI.currentSkRadioChecked)
function fHandleSkGroupCheckboxClick(r, c, isChecked) {
    const oldR = gUI.currentSkRadioChecked.r;
    const oldC = gUI.currentSkRadioChecked.c;

    if (isChecked) {
        if (oldR !== null && oldC !== null && (oldR !== r || oldC !== c)) {
            fUncheckOldSkGroupBox(oldR, oldC);
        }
        gUI.currentSkRadioChecked = { r, c };
        gUI.arr[r][c] = true;
        fMyConsoleLog(`Radio group: Checked box [${r}, ${c}]`);
    } else {
        if (oldR === r && oldC === c) {
            gUI.currentSkRadioChecked = { r: null, c: null };
        }
        gUI.arr[r][c] = false;
        fMyConsoleLog(`Radio group: Unchecked box [${r}, ${c}]`);
    }
};




// fUncheckOldSkGroupBox //////////////////////////////////////////////////////////////////////
// Purpose -> Uncheck the previously checked box in the sk-radio group, if one exists.
// Inputs  -> oldR, oldC: previous coordinates
// Outputs -> None (modifies DOM and gUI.arr)
function fUncheckOldSkGroupBox(oldR, oldC) {
    const oldCellDiv = gUI.grid2D[oldR]?.[oldC];
    const oldCheckbox = oldCellDiv?.querySelector('input[data-sk-group="true"]');

    if (oldCheckbox) {
        oldCheckbox.checked = false;
        gUI.arr[oldR][oldC] = false;
        fMyConsoleLog(`Radio group: Unchecked previous box [${oldR}, ${oldC}]`);
    } else {
        console.warn(`Radio group: Could not find previous checkbox element at [${oldR}, ${oldC}] to uncheck.`);
    }
};



////////////////////////////////////////////////////////////////////////////////////////////////////////// END fHandleGridCheckboxClick and helpers




////////////////////////////////////////////////////////////////////////////////////////////////////////// START fHandleGridClick and helpers




// fHandleGridClick ///////////////////////////////////////////////////////////////////////////////
// Delegated click handler for cells: routes to header buttons, checkboxes, URLs, etc.
// MODIFIED: 'action-rollDice' case now calls fHandleRollDiceAction
function fHandleGridClick(event) {
    const target = event.target;

    // --- Check for Header Button Click FIRST ---
    const buttonImg = target.closest('.header-button-img[data-button-action]');
    if (buttonImg) {
        fHandleHeaderButtonClick(event, buttonImg);
        return; // Handled the button click
    }

    // --- End Header Button Check ---
    const cellDiv = target.closest('.cell');
    if (!cellDiv) return;

    if (fIsCheckboxClick(target)) {
        fHandleGridCheckboxClick(event);
        return;
    }

    if (fIsEditableCell(cellDiv)) return;

    if (fIsUrlLinkCell(cellDiv)) {
        fHandleUrlClick(cellDiv);
        return;
    }

    // Future: Add general cell click behaviors here
} // END fHandleGridClick




// fIsCheckboxClick ////////////////////////////////////////////////////////////////////////////////
// Returns true if target is a checkbox input.
function fIsCheckboxClick(target) {
    return target.tagName === 'INPUT' && target.type === 'checkbox';
} // END fIsCheckboxClick




// fIsEditableCell /////////////////////////////////////////////////////////////////////////////////
// Returns true if the clicked cell is contentEditable.
function fIsEditableCell(cellDiv) {
    return cellDiv?.isContentEditable;
} // END fIsEditableCell




// fIsUrlLinkCell /////////////////////////////////////////////////////////////////////////////////
// Returns true if cell has class 'url-link'.
function fIsUrlLinkCell(cellDiv) {
    return cellDiv?.classList.contains('url-link');
} // END fIsUrlLinkCell




// fHandleDriveLink ///////////////////////////////////////////////////////////////////////////////
// Opens Google Drive links in new tab due to embed restrictions.
function fHandleDriveLink(url) {
    fMyConsoleLog(`🖱️ Opening Drive Link in new tab: ${url.substring(0, 100)}...`);
    window.open(url, '_blank');
} // END fHandleDriveLink




// fHandleImageModal /////////////////////////////////////////////////////////////////////////////
// Opens a standard image link in modal.
function fHandleImageModal(imageUrl) {
    fMyConsoleLog(`🖱️ Clicked Standard Image Link: ${imageUrl.substring(0, 100)}...`);
    fShowImageTab(imageUrl);
} // END fHandleImageModal



// fShowImageTab //////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Displays the image in new tab with the specified image URL in the img tag.
// Inputs -> imageUrl (String): The direct URL of the image to display.
function fShowImageTab(imageUrl) { 
    console.log("--- fShowImageTab Start ---");
    console.log(" Image URL:", imageUrl);
    // Check renamed global variables within gUI object
    if (!gUI.modalElement || !gUI.modalImageElement) { // Updated references
        console.error("Cannot show modal: Modal elements not found in globals.");
        return;
    }
    console.log("Modal elements found.");
    fMyConsoleLog(`🖼️ Showing image: ${imageUrl.substring(0, 100)}...`);

    // Set the image source using renamed global variable for IMG
    console.log("Setting image src...");
    gUI.modalImageElement.src = imageUrl; // Updated reference

    // Display the modal
    console.log("Setting modal display to flex...");
    gUI.modalElement.style.display = 'flex'; // Updated reference
    console.log("--- fShowImageTab End ---");

}; // END fShowImageTab




// fHandleWebLink /////////////////////////////////////////////////////////////////////////////////
// Opens non-image, non-Drive links in a new tab.
function fHandleWebLink(url) {
    fMyConsoleLog(`🖱️ Clicked Web Link: ${url.substring(0, 100)}...`);
    window.open(url, '_blank');
} // END fHandleWebLink




// fHandleUrlClick ////////////////////////////////////////////////////////////////////////////////
// Determines URL type and routes to appropriate handler.
function fHandleUrlClick(cellDiv) {
    const originalUrl = cellDiv.dataset.url;
    if (!originalUrl) {
        console.warn("Clicked URL link cell, but data-url attribute was missing.", cellDiv);
        return;
    }

    const isDrive = originalUrl.includes('drive.google.com/file/d/');
    const isImage = cellDiv.classList.contains('image-link') && !isDrive;
    const imageUrl = cellDiv.dataset.imageSrc;

    if (isDrive) {
        fHandleDriveLink(originalUrl);
    } else if (isImage && imageUrl) {
        fHandleImageModal(imageUrl);
    } else {
        fHandleWebLink(originalUrl);
    }
} // END fHandleUrlClick




////////////////////////////////////////////////////////////////////////////////////////////////////////// END fHandleGridClick and helpers




// fHandleGridCellEdit ////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Handles blur events delegated from the grid container for contenteditable cells.
//            Updates the gUI.arr data if the cell's text content has changed.
// Inputs  -> event (FocusEvent): The blur event object.
// Outputs -> None. (Modifies gUI.arr).
function fHandleGridCellEdit(event) {
    const cellDiv = event.target;

    // Check if the blurred element is actually a cell div that is contenteditable
    if (!cellDiv || !cellDiv.classList.contains('cell') || cellDiv.contentEditable !== 'true') {
        return; // Exit if not an editable cell div
    }

    // Get row/col from the data attributes
    const r = parseInt(cellDiv.dataset.r, 10);
    const c = parseInt(cellDiv.dataset.c, 10);

    // Validate indices
    if (isNaN(r) || isNaN(c) || r < 0 || c < 0 || !gUI.arr[r]) {
         console.warn("Cell edit handler: Invalid row/column index from data attributes.", cellDiv.dataset);
         return;
    }

    // Get the new value from the cell's text content
    const newValue = cellDiv.textContent;

    // Get the old value from the data model (handle null/undefined)
    const oldValue = String(gUI.arr[r][c] ?? ''); // Coerce to string for comparison

    // Compare and update data model ONLY if changed
    if (newValue !== oldValue) {
        gUI.arr[r][c] = newValue; // Update the underlying data model
        fMyConsoleLog(`Cell [${r}, ${c}] changed to: "${newValue}"`);
        // Optional: Add visual feedback for 'saved' state, or trigger server update later
    }
    // else { // Optional log removed for cleanliness
    //   // console.log(`Cell [${r}, ${c}] content unchanged.`);
    // }

}; // END fHandleGridCellEdit




////////////////////////////////////////////////////////////////////////////////////////////////////////// START fClearCheckboxesInGridRange and helpers




// fIsValidRangeObject //////////////////////////////////////////////////////////////////////////////
// Checks if the range object has valid r1, c1, r2, c2 properties.
function fIsValidRangeObject(range) {
    return range &&
        typeof range.r1 !== 'undefined' &&
        typeof range.c1 !== 'undefined' &&
        typeof range.r2 !== 'undefined' &&
        typeof range.c2 !== 'undefined';
};



// fResolveRangeIndices /////////////////////////////////////////////////////////////////////////////
// Converts tag or index values to resolved numerical indices.
function fResolveRangeIndices(range) {
    const r1 = resolveRow(range.r1);
    const c1 = resolveCol(range.c1);
    const r2 = resolveRow(range.r2);
    const c2 = resolveCol(range.c2);
    return { r1, c1, r2, c2 };
};




////////////////////////////////////////////////////////////////////////////////////////////////////////// END fClearCheckboxesInGridRange and helpers




// fCloseAllDropdowns //////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Finds all dropdown content panels and removes the 'show' class to hide them.
function fCloseAllDropdowns() {
  const dropdowns = document.getElementsByClassName("dropdown-content");
  for (let i = 0; i < dropdowns.length; i++) {
    const panel = dropdowns[i];
    panel.classList.remove('show');
    // Reset parent overflow only if it's a main dropdown being closed this way
    if (!panel.classList.contains('sub-menu') && panel.style.overflowY === 'visible') {
        panel.style.overflowY = 'auto';
    }
  }
}; // END fCloseAllDropdowns



// ==========================================================================
// === Tags & Read Write Cells & Range                        (End of Grid Hover) ===
// ==========================================================================


// fSetGridTagsFromHeaders //////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Populates gUI.rowTag and gUI.colTag from tag headers in gUI.arr (Col 0 for rows, Row 0 for columns)
// Note: Uses more robust version from current scripts.html
function fSetGridTagsFromHeaders() {
    fMyConsoleLog("⚙️ Parsing Grid Tags...");
    gUI.rowTag = {};
    gUI.colTag = {};

    const gameArr = gUI.arr;
    if (!gameArr || gameArr.length === 0 || !gameArr[0]) {
        console.warn("⚠️ Cannot parse tags, gUI.arr is empty or malformed.");
        fMyConsoleLog("⚠️ Grid Tags: Data empty.");
        return;
    }

    const rows = gameArr.length;
    const cols = gameArr[0].length;

    // Row Tags (Column 0)
    for (let r = 0; r < rows; r++) {
        const rowCell = gameArr[r][0]; // Using direct access as optional chaining wasn't the fix
        if (typeof rowCell === 'string' && rowCell) { // Ensure it's a non-empty string
            rowCell.split(',').forEach(tag => {
                const trimmedTag = tag.trim();
                if (trimmedTag) gUI.rowTag[trimmedTag] = r;
            });
        }
    }

    // Col Tags (Row 0)
    const colHeaderRow = gameArr[0];
    if (colHeaderRow) {
        for (let c = 0; c < cols; c++) {
            const colCell = colHeaderRow[c]; // Check if cell exists
            if (typeof colCell === 'string' && colCell) { // Ensure it's a non-empty string
                colCell.split(',').forEach(tag => {
                    const trimmedTag = tag.trim();
                    if (trimmedTag) gUI.colTag[trimmedTag] = c;
                });
            }
        }
    }
    fMyConsoleLog("✅ Grid Tags Parsed");
}; // END fSetGridTagsFromHeaders




// fGetGridValue ///////////////////////////////////////////////////////////////////
// Purpose -> Retrieves a value from gUI.arr using tags or indices, with optional type coercion.
// Inputs -> rowRef (String|Number): Row tag or 0-based index.
//        -> colRef (String|Number): Column tag or 0-based index.
//        -> asNumber (Boolean): If true, attempt to parse the value as a number (default: false).
// Outputs -> (Any|NaN): The value from the grid, or NaN if type coercion fails or cell not found.
function fGetGridValue(rowRef, colRef, asNumber = false) {
    const r = resolveRow(rowRef);
    const c = resolveCol(colRef);

    if (isNaN(r) || isNaN(c)) {
        console.warn(`fGetGridValue: Could not resolve (${rowRef}, ${colRef}) to valid indices.`);
        return NaN; // Return NaN for unresolved refs
    }

    const value = gUI.arr?.[r]?.[c];

    if (value === undefined || value === null || value === '') {
        // Treat empty/null/undefined as potentially 0 if requesting a number, else undefined
        return asNumber ? 0 : undefined;
    }

    if (asNumber) {
        const numValue = Number(value);
        if (isNaN(numValue)) {
            console.warn(`fGetGridValue: Value at (${rowRef}, ${colRef}) -> [${r}, ${c}] ("${value}") is not a valid number.`);
            return NaN; // Return NaN if conversion fails
        }
        return numValue;
    }

    return value;
} // END fGetGridValue




// fSetGridValue ///////////////////////////////////////////////////////////////////
// Purpose -> Updates a value in gUI.arr and the corresponding cell display in gUI.grid2D.
//            Forces Meta/Channel Meta values < 1 to be stored and displayed as ''.
// Inputs -> rowRef (String|Number): Row tag or 0-based index.
//        -> colRef (String|Number): Column tag or 0-based index.
//        -> newValue (Any): The new value to set.
// Outputs -> (Boolean): true if successful, false otherwise.
// MODIFIED: Added check for Meta/Channel rows to enforce < 1 becomes ''.
function fSetGridValue(rowRef, colRef, newValue) {
    const r = resolveRow(rowRef);
    const c = resolveCol(colRef);
    let valueToSet = newValue; // Use a temporary variable

    if (isNaN(r) || isNaN(c)) {
        console.warn(`fSetGridValue: Could not resolve (${rowRef}, ${colRef}) to valid indices.`);
        return false;
    }

    if (!gUI.arr?.[r]) {
        console.warn(`fSetGridValue: Row ${r} does not exist in gUI.arr.`);
        return false;
    }

    // --- NEW: Check if this is a Meta or Channel Meta cell ---
    const metaRowTags = ['meta', 'chnl'];
    const metaColTags = gUI.list?.metaColor || ['R', 'O', 'Y', 'G', 'B']; // Use list or fallback
    const isMetaCell = metaRowTags.includes(rowRef) && metaColTags.includes(colRef);

    if (isMetaCell) {
        // Convert potential numeric strings/numbers to number for checking
        const numericValue = Number(valueToSet);
        // Check if it's a valid number AND less than 1
        if (!isNaN(numericValue) && numericValue < 1) {
            valueToSet = ''; // Force to empty string
            fMyConsoleLog(`   -> Adjusted Meta cell [${r}, ${c}] value to '' because input was < 1.`);
        } else if (valueToSet === null || typeof valueToSet === 'undefined') {
             valueToSet = ''; // Also force null/undefined to empty string for meta cells
        }
    }
    // --- End Meta Check ---

    // Update data model with the (potentially adjusted) value
    gUI.arr[r][c] = valueToSet;

    // Update DOM if cell exists
    const cell = gUI.grid2D?.[r]?.[c];
    if (cell) {
        // Handle checkboxes separately
        const checkbox = cell.querySelector('input[type="checkbox"]');
        if (checkbox) {
             const valStr = String(valueToSet).toUpperCase();
             checkbox.checked = valueToSet === true || valStr === "TRUE";
        } else if (cell.querySelector('select.grid-dropdown')) {
            // Handle dropdowns if necessary (might need explicit update)
            const dropdown = cell.querySelector('select.grid-dropdown');
            dropdown.value = String(valueToSet ?? ''); // Set dropdown value
        } else {
            // Update text content for other cells (including Meta cells now forced to '')
            const idPattern = /\s{2,}_\w{6}$/;
            const text = (typeof valueToSet === 'string' && idPattern.test(valueToSet))
                         ? valueToSet.replace(idPattern, '')
                         : valueToSet;
            cell.textContent = text ?? ''; // Use empty string for null/undefined
        }
         // fMyConsoleLog(`DOM updated for [${r}, ${c}]`); // Optional log
    } else {
        console.warn(`fSetGridValue: Cell element not found in gUI.grid2D at [${r}, ${c}]. Data model updated, DOM not.`);
        // return false; // Decide if DOM update failure should cause function failure
    }

    // Use original newValue in log for clarity on what was initially passed
    // fMyConsoleLog(`Grid set [${r}, ${c}] = ${valueToSet} (Input: ${newValue})`); // Optional more detailed log
    return true;
} // END fSetGridValue




// fSetRangeValues /////////////////////////////////////////////////////////////////
// Purpose -> Updates values in a specified grid range (data and DOM) from a provided array OR a single value.
// Inputs -> r1 (String|Number): Starting row tag or 0-based index.
//        -> c1 (String|Number): Starting column tag or 0-based index.
//        -> r2 (String|Number): Ending row tag or 0-based index.
//        -> c2 (String|Number): Ending column tag or 0-based index.
//        -> valueOrArray (Array|Any): 1D/2D array matching range dimensions, OR a single value to fill the range.
// Outputs -> (Boolean): true if successful, false otherwise.
function fSetRangeValues(r1Ref, c1Ref, r2Ref, c2Ref, valueOrArray) {
    fMyConsoleLog(`⚙️ Setting range values: ${r1Ref},${c1Ref} to ${r2Ref},${c2Ref}...`);

    // --- 1. Resolve Indices ---
    const r1 = resolveRow(r1Ref);
    const c1 = resolveCol(c1Ref);
    const r2 = resolveRow(r2Ref);
    const c2 = resolveCol(c2Ref);

    if ([r1, c1, r2, c2].some(isNaN)) {
        console.warn(`fSetRangeValues: Could not resolve one or more references: (${r1Ref}, ${c1Ref}, ${r2Ref}, ${c2Ref}) -> (${r1}, ${c1}, ${r2}, ${c2}).`);
        fMyConsoleLog(`❌ fSetRangeValues failed: Invalid range references.`);
        return false;
    }

    // --- 2. Determine Mode: Single Value Fill or Array Mapping ---
    let isSingleValueFill = !Array.isArray(valueOrArray);
    let singleFillValue = null;
    let newValArr = null; // Will hold the array only if not in single value mode

    if (isSingleValueFill) {
        singleFillValue = valueOrArray;
        fMyConsoleLog(`   -> Mode: Single value fill ('${singleFillValue}')`);
    } else {
        newValArr = valueOrArray; // It's an array, assign it
        fMyConsoleLog(`   -> Mode: Array mapping`);
        // --- 2a. Validate Input Array (only if not single value fill) ---
        if (newValArr.length === 0 && (rMax - rMin + 1 > 0 && cMax - cMin + 1 > 0)) {
             // Allow empty array only if range is also effectively empty (e.g., r1=r2, c1=c2 but cell doesn't exist)
             // If range has cells but array is empty, it's an error.
             console.warn(`fSetRangeValues: Provided newValArr is an empty array, but range is not empty.`);
             fMyConsoleLog(`❌ fSetRangeValues failed: Input array empty for non-empty range.`);
            return false;
        }
    }

    // --- 3. Determine Range Dimensions ---
    const rMin = Math.min(r1, r2);
    const rMax = Math.max(r1, r2);
    const cMin = Math.min(c1, c2);
    const cMax = Math.max(c1, c2);
    const rangeRows = rMax - rMin + 1;
    const rangeCols = cMax - cMin + 1;

    // --- 4. Validate Array Dimensions (only if not single value fill) ---
    if (!isSingleValueFill) {
        let arrRows = 0;
        let arrCols = 0;
        let isInputArray2D = false;

        if (newValArr.length > 0) {
            if (Array.isArray(newValArr[0])) {
                // Likely 2D array
                isInputArray2D = true;
                arrRows = newValArr.length;
                arrCols = newValArr[0].length;
                if (!newValArr.every(row => Array.isArray(row) && row.length === arrCols)) {
                    console.warn(`fSetRangeValues: Input 2D array has inconsistent column lengths.`);
                    fMyConsoleLog(`❌ fSetRangeValues failed: Input 2D array malformed.`);
                    return false;
                }
            } else {
                // Likely 1D array
                arrRows = 1;
                arrCols = newValArr.length;
                if (rangeCols === 1 && rangeRows > 1) { // Adjust if target is a single column
                    arrRows = newValArr.length;
                    arrCols = 1;
                }
            }
        }
         // Else: newValArr is empty array, dimensions remain 0, handled above

        // Check if dimensions match
        if (rangeRows !== arrRows || rangeCols !== arrCols) {
            console.warn(`fSetRangeValues: Dimension mismatch. Range: ${rangeRows}x${rangeCols}, Array: ${arrRows}x${arrCols}.`);
            fMyConsoleLog(`❌ fSetRangeValues failed: Dimension mismatch.`);
            return false;
        }
    }
     // --- End Array Validation ---

    // --- 5. Update Data and DOM ---
    let updateCount = 0;
    let updateErrors = 0;
    for (let r = rMin; r <= rMax; r++) {
        if (!gUI.arr[r] || !gUI.grid2D[r]) {
            console.warn(`fSetRangeValues: Row ${r} does not exist in gUI.arr or gUI.grid2D. Skipping row.`);
            updateErrors += rangeCols;
            continue;
        }
        for (let c = cMin; c <= cMax; c++) {
            let newValue;
            // --- Determine the value to set ---
            if (isSingleValueFill) {
                newValue = singleFillValue;
            } else {
                // Calculate corresponding index in newValArr
                const arrRowIdx = r - rMin;
                const arrColIdx = c - cMin;
                const isInputArray2D = Array.isArray(newValArr[0]); // Check again inside loop just to be safe
                newValue = isInputArray2D
                         ? newValArr[arrRowIdx]?.[arrColIdx]
                         : (rangeCols === 1 && rangeRows > 1 ? newValArr[arrRowIdx] : newValArr[arrColIdx]);
            }

            // --- Update data model ---
            gUI.arr[r][c] = newValue;

            // --- Update DOM if cell exists ---
            const cell = gUI.grid2D[r]?.[c];
            if (cell) {
                if (cell.style.display === 'none') continue; // Skip cells hidden by merges

                const valStr = String(newValue).toUpperCase();
                const isCheckboxValue = newValue === true || newValue === false || valStr === "TRUE" || valStr === "FALSE";
                const checkbox = cell.querySelector('input[type="checkbox"]');

                if (checkbox) {
                    checkbox.checked = newValue === true || valStr === "TRUE";
                    // Optionally disable/enable checkbox based on fill value?
                    // checkbox.disabled = (newValue === ' '); // Example: disable if clearing
                } else if (cell.contentEditable === 'true' || !isCheckboxValue) {
                    const idPattern = /\s{2,}_\w{6}$/;
                     const text = (typeof newValue === 'string' && idPattern.test(newValue))
                                  ? newValue.replace(idPattern, '')
                                  : newValue;
                    cell.textContent = text ?? '';
                } else {
                    // Handle potential mismatch (e.g., trying to put text in a checkbox cell)
                    console.warn(`fSetRangeValues: Mismatch or unexpected value type at [${r}, ${c}] for cell type.`);
                    cell.textContent = newValue ?? ''; // Default to text content
                }
                updateCount++;
            } else {
                console.warn(`fSetRangeValues: Cell element not found in gUI.grid2D at [${r}, ${c}]. Data model updated, DOM not.`);
                updateErrors++;
            }
        }
    }

    fMyConsoleLog(`✅ fSetRangeValues: ${isSingleValueFill ? 'Filled' : 'Updated'} ${updateCount} cells. ${updateErrors > 0 ? `(${updateErrors} errors)` : ''}`);
    return updateErrors === 0;

} // END fSetRangeValues



// ==========================================================================
// === Sidebar                       (End of Read Write Cell & Range) ===
// ==========================================================================




// fPrependToSidebar /////////////////////////////////////////////////////////////////
// Purpose -> Prepends a message string (which can contain HTML) as a new paragraph
//            to the sidebar content area. Removes the initial placeholder message.
// Inputs -> message (String): The text or HTML content to prepend.
// Outputs -> None (Modifies DOM).
// MODIFIED: Uses prepend. Removed scroll-to-bottom. Uses innerHTML.
function fPrependToSidebar(message) {
    const sidebarContent = document.getElementById('sidebar-content');
    if (!sidebarContent) {
        console.error("❌ Cannot find sidebar content element (#sidebar-content)");
        return;
    }

    // Check for and remove the initial placeholder paragraph if it exists
    const placeholder = sidebarContent.querySelector('p');
    if (placeholder && placeholder.textContent === 'Roll log entries will appear here...') {
        placeholder.remove();
    }

    // Create a new paragraph element
    const newEntry = document.createElement('p');
    newEntry.innerHTML = message; // <<< Use innerHTML to render tags

    // Prepend the new entry to the sidebar content
    sidebarContent.prepend(newEntry);

}; // END fPrependToSidebar




// fRollLogMsg ////////////////////////////////////////////////////////////////////////
// Purpose -> Sends message to sidebar warning area.
// Inputs  -> msg (String): Message to display.
function fRollLogMsg(msg) {
    if (msg) {
        console.warn(msg);
        fPrependToSidebar(msg);
        fShowSidebar();
    }
} // END fRollLogMsg




// fShowSidebar //////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Makes the Roll Log sidebar visible.
function fShowSidebar() {
    const sidebar = document.getElementById('roll-log-sidebar');
    if (sidebar && !sidebar.classList.contains('show')) { // Only log if changing state
        sidebar.classList.add('show');
        fMyConsoleLog("▶️ Sidebar Shown");
    } else if (!sidebar) {
        console.error("❌ Cannot find sidebar element (#roll-log-sidebar)");
    }
}; // END fShowSidebar




// fHideSidebar //////////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Hides the Roll Log sidebar.
function fHideSidebar() {
    const sidebar = document.getElementById('roll-log-sidebar');
    if (sidebar && sidebar.classList.contains('show')) { // Only log if changing state
        sidebar.classList.remove('show');
        fMyConsoleLog("◀️ Sidebar Hidden");
    } else if (!sidebar) {
        console.error("❌ Cannot find sidebar element (#roll-log-sidebar)");
    }
}; // END fHideSidebar




// ==========================================================================
// === Menu Bar Setup                 (End of Sidebar) ===
// ==========================================================================



// fSetupMenuButtonListeners ///////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Adds click listeners to the main menu bar buttons (Nish, Roll, Game, Gear).
// MODIFIED: Added btnRoll parameter and listener
// MODIFIED: btnRoll listener now calls fHandleRollDiceAction
function fSetupMenuButtonListeners(btnNish, btnRoll, btnGame, dropdownGame, btnGear, dropdownGear) { // <<< Added btnRoll

    // Listener for 'Nish' button (Direct Action)
    btnNish.addEventListener('click', (event) => {
        event.stopPropagation();
        fCloseAllDropdowns();
        console.log("ACTION: Nish button clicked (logic pending)");
        fMyConsoleLog("🖱️ Nish Clicked");
        // @@ Add logic for Nish button here later
    });

    // Listener for 'Roll' button (Direct Action) // <<< UPDATED LISTENER
    btnRoll.addEventListener('click', (event) => {
        event.stopPropagation();
        fCloseAllDropdowns();
        fHandleRollDiceAction(); // <<< Call the shared action function
    });

    // Listener for 'Game' button (Toggle Dropdown)
    btnGame.addEventListener('click', (event) => {
        event.stopPropagation();
        const currentlyShown = dropdownGame.classList.contains('show');
        fCloseAllDropdowns(); // Close others first
        if (!currentlyShown) {
            dropdownGame.classList.add('show');
        }
    });

    // Listener for 'Gear' button (Toggle Dropdown)
    btnGear.addEventListener('click', (event) => {
        event.stopPropagation();
        const currentlyShown = dropdownGear.classList.contains('show');
        fCloseAllDropdowns(); // Close others first
        if (!currentlyShown) {
            dropdownGear.classList.add('show');
        }
    });

}; // END fSetupMenuButtonListeners




// fSetupWindowClickListener ///////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Adds listener to the window to close dropdowns when clicking outside the menu area.
function fSetupWindowClickListener() {
    window.addEventListener('click', (event) => {
        // If the click is not on a main menu button or within a menu item, close dropdowns
        if (event.target && !event.target.closest('.menu-item') && !event.target.closest('#menu-bar > button')) {
            fCloseAllDropdowns();
        }
    });
}; // END fSetupWindowClickListener




////////////////////////////////////////////////////////////////////////////////////////////////////////// START fSetupSubMenuHover and helpers




// fSetupSubMenuHover ///////////////////////////////////////////////////////////////////////////////
// Main function: sets up hover logic for all .sub-menu-item elements under menuBar.
function fSetupSubMenuHover(menuBar) {
    if (!menuBar) return;

    const subMenuItems = menuBar.querySelectorAll('.sub-menu-item');
    subMenuItems.forEach((item, index) => {
        fSetupSingleSubMenuItem(item, index);
    });
};


// fClearHideTimeout /////////////////////////////////////////////////////////////////////////////////
// Clears any active hide timeout on a submenu panel.
function fClearHideTimeout(panel) {
    const timeoutId = parseInt(panel.dataset.hideTimeoutId || '0');
    if (timeoutId) {
        clearTimeout(timeoutId);
        panel.dataset.hideTimeoutId = '';
    }
};




// fIsAnySiblingSubmenuOpen /////////////////////////////////////////////////////////////////////////
// Checks if any other sibling .sub-menu-item has an open submenu panel.
function fIsAnySiblingSubmenuOpen(item) {
    const parent = item.parentElement;
    if (!parent) return false;

    const siblings = Array.from(parent.children).filter(el =>
        el !== item && el.classList.contains('sub-menu-item')
    );

    return siblings.some(sibling => {
        const siblingPanel = sibling.querySelector('.dropdown-content.sub-menu');
        return siblingPanel && siblingPanel.classList.contains('show');
    });
};




// fStartHideTimeout /////////////////////////////////////////////////////////////////////////////////
// Sets a timeout to hide a submenu panel and possibly restore overflow.
function fStartHideTimeout(item, panel, mainDropdown, delayMs = 250) {
    fClearHideTimeout(panel);
    const timeoutId = setTimeout(() => {
        if (mainDropdown && !fIsAnySiblingSubmenuOpen(item)) {
            mainDropdown.style.overflowY = 'auto';
        }
        panel.classList.remove('show');
    }, delayMs);
    panel.dataset.hideTimeoutId = timeoutId;
};




// fSetupSingleSubMenuItem //////////////////////////////////////////////////////////////////////////
// Attaches hover listeners and timeout logic to a single submenu item.
function fSetupSingleSubMenuItem(item, index) {
    const triggerLink = item.querySelector('a');
    const subMenuPanel = item.querySelector('.dropdown-content.sub-menu');
    const mainDropdown = item.closest('.dropdown-content:not(.sub-menu)');

    if (!subMenuPanel) return;
    if (!mainDropdown && triggerLink) {
        console.warn(`Item ${index} (${triggerLink?.textContent}): Could not find parent main dropdown!`);
    }

    item.addEventListener('mouseenter', () => {
        fClearHideTimeout(subMenuPanel);
        if (mainDropdown) mainDropdown.style.overflowY = 'visible';
        subMenuPanel.classList.add('show');
    });

    item.addEventListener('mouseleave', () => {
        fStartHideTimeout(item, subMenuPanel, mainDropdown);
    });

    subMenuPanel.addEventListener('mouseenter', () => {
        fClearHideTimeout(subMenuPanel);
    });

    subMenuPanel.addEventListener('mouseleave', () => {
        fStartHideTimeout(item, subMenuPanel, mainDropdown);
    });
};




////////////////////////////////////////////////////////////////////////////////////////////////////////// End fSetupSubMenuHover and helpers



// ==========================================================================
// === Menu Bar Click     (End of Menu Bar Setup)) ===
// ==========================================================================




// fSetupDelegatedMenuActionClick //////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Adds delegated listener to the menu bar to handle clicks on items with data-action.
// MODIFIED: Added case for 'game-clearCheckboxes'
function fSetupDelegatedMenuActionClick(menuBar) {
     if (!menuBar) return; // Should not happen based on main check, but safe practice

     menuBar.addEventListener('click', (event) => {
         // Handle clicks on action links
         const targetLink = event.target.closest('.dropdown-content a[data-action]');
         if (targetLink) {
             event.preventDefault();
             event.stopPropagation();
             const action = targetLink.getAttribute('data-action');
             fMyConsoleLog(`🖱️ Menu Action Triggered: ${action}`);
             fCloseAllDropdowns(); // Close dropdown after selection

             // --- Action Dispatcher ---
             switch (action) {

                     // Game Menu
                     case 'game-toggleSidebar': fToggleSidebar(); break;
                     // Healing
                     case 'game-healingNatural': fCalc_NaturalHealing(); break;
                     case 'game-healingAll': fHealAllWounds(); break;
                     // Set to Max grid cells/ranges
                     case 'game-setMaxMeta': fMeta_SetToMax(); break;
                     case 'game-setMaxLuck': fLuck_SetToMax(); break;
                     case 'game-setMaxVit': fCalc_VitMaxNowPerc(); break;
                     // Clear grid cells/ranges
                     case 'game-clearChanneled': fClearChanneledMeta(); break;
                     case 'game-clearCheckboxes': fClearSk1Sk2Checkboxes(); break;
                     case 'game-clearMonsters': fClearMonsters(); break;
                     case 'game-clearMorphs': fClearMorphs(); break;
                     case 'game-clearNish': fClearCurrentNish(); break;
                     case 'game-clearRollLog': fClearRollLog(); break;

                     // Gear Menu
                     case 'gear-toggleGear': fToggleGearColumns(); break;
                 default:
                     console.log(`ACTION: Menu item clicked: ${action} (No handler defined yet)`);
                     fMyConsoleLog(`🖱️ Menu: ${action} (No handler)`);
             }
             // --- End Action Dispatcher ---

         } // End if(targetLink)

         // Handle clicks on sub-menu trigger links (prevent default)
         const subMenuTriggerLink = event.target.closest('.sub-menu-item > a');
         if (subMenuTriggerLink && !targetLink) { event.preventDefault(); }

     }); // <-- End of menuBar CLICK listener

}; // END fSetupDelegatedMenuActionClick



// fToggleSidebar ///////////////////////////////////////////////////////////////////
// Purpose -> Checks the current visibility state of the sidebar and toggles it.
// Inputs -> None
// Outputs -> None
function fToggleSidebar() {
    const sidebar = document.getElementById('roll-log-sidebar');
    if (!sidebar) {
        console.error("❌ Cannot find sidebar element (#roll-log-sidebar) to toggle.");
        return;
    }

    // Check if the sidebar is currently shown
    const isVisible = sidebar.classList.contains('show');

    // Call the appropriate function
    if (isVisible) {
        fHideSidebar();
    } else {
        fShowSidebar();
    }
}; // END fToggleSidebar




// fCalc_NaturalHealing ////////////////////////////////////////////////////////////////////
// Purpose -> Reduces 1st, 2nd, 3rd degree wounds based on Vit Max rolls, updates grid, and logs to sidebar.
// Inputs  -> None
// Outputs -> None (Modifies grid, calls sidebar functions)
async function fCalc_NaturalHealing() {
    fMyConsoleLog("⚙️ Menu Action: Natural Healing...");

    // --- Get Vit Max ---
    const vitMaxRange = gUI.range?.vitMax;
    if (!vitMaxRange || !vitMaxRange.r1 || !vitMaxRange.c1) {
        const msg = "Vit Max range definition missing.";
        console.warn(`fCalc_NaturalHealing: ${msg}`);
        fMyConsoleLog(`⚠️ Natural Healing failed: ${msg}`);
        await fShowMessage(`Error: ${msg}`);
        return;
    }
    const vitMax = fGetGridValue(vitMaxRange.r1, vitMaxRange.c1, true);
    if (isNaN(vitMax) || vitMax < 1) {
        const msg = `Vit Max value ('${vitMax}') is invalid or zero. Cannot calculate healing.`;
        console.warn(`fCalc_NaturalHealing: ${msg}`);
        fMyConsoleLog(`⚠️ Natural Healing failed: ${msg}`);
        await fShowMessage(`Error: ${msg}`);
        return;
    }
    fMyConsoleLog(`   -> Vit Max for healing calc: ${vitMax}`);

    // --- Process Each Wound Type ---
    let errorsOccurred = false;
    const healingResults = {}; // Store results for sidebar

    healingResults['1st'] = await fProcessWoundHealing('vit1stWnds', vitMax, 4, '1st');
    if (healingResults['1st'] === null) errorsOccurred = true;

    healingResults['2nd'] = await fProcessWoundHealing('vit2ndWnds', vitMax, 8, '2nd');
    if (healingResults['2nd'] === null) errorsOccurred = true;

    healingResults['3rd'] = await fProcessWoundHealing('vit3rdWnds', vitMax, 16, '3rd');
    if (healingResults['3rd'] === null) errorsOccurred = true;

    // --- Update Vit Now & Percent ---
    if (!errorsOccurred) {
        await fVitNowNPercent_Calc(); // Update dependent Vit fields
    } else {
        fMyConsoleLog("   -> Skipping Vit Now/Percent update due to healing errors.");
    }

    // --- Build and Display Sidebar Message ---
    let sidebarMsg = `<span class="blue-bold">ℹ️ Natural Healing:</span>`;
    if (healingResults['1st'] !== null) sidebarMsg += `<br>${healingResults['1st']} -> 1st Deg Wnds`;
    if (healingResults['2nd'] !== null) sidebarMsg += `<br>${healingResults['2nd']} -> 2nd Deg Wnds`;
    if (healingResults['3rd'] !== null) sidebarMsg += `<br>${healingResults['3rd']} -> 3rd Deg Wnds`;

    fPrependToSidebar(sidebarMsg);
    fShowSidebar();

    // Update Vit
    fCalc_VitMaxNowPerc();

    fMyConsoleLog(`✅ Natural Healing Process Complete ${errorsOccurred ? '(with errors)' : ''}.`);

} // END fCalc_NaturalHealing




// fProcessWoundHealing ////////////////////////////////////////////////////////////////////
// Purpose -> Helper to get, calculate, and set healing for a specific wound degree.
// Inputs  -> woundRangeTag (String): The tag for the wound cell (e.g., 'vit1stWnds').
//         -> vitMax (Number): The character's maximum vitality.
//         -> divisor (Number): The divisor for Vit Max to determine healing die size (4, 8, 16).
//         -> degreeLabel (String): Label for logging ('1st', '2nd', '3rd').
// Outputs -> (Promise<Number|null>): The actual amount healed, or null if an error occurred.
async function fProcessWoundHealing(woundRangeTag, vitMax, divisor, degreeLabel) {
    fMyConsoleLog(`      -> Processing ${degreeLabel} Degree wounds...`);

    // Get range definition
    const woundRange = gUI.range?.[woundRangeTag];
    if (!woundRange || !woundRange.r1 || !woundRange.c1) {
        const msg = `Wound range definition missing for tag: ${woundRangeTag}.`;
        console.warn(`fProcessWoundHealing: ${msg}`);
        fMyConsoleLog(`         -> ⚠️ Error: ${msg}`);
        await fShowMessage(`Error processing ${degreeLabel} wounds: ${msg}`);
        return null;
    }

    // Get current wounds (default to 0 if invalid/missing, ensure non-negative)
    let currentWounds = Math.max(0, fGetGridValue(woundRange.r1, woundRange.c1, true) || 0);
    if (isNaN(currentWounds)) {
        fMyConsoleLog(`         -> Warning: Invalid current wound value for ${degreeLabel}. Assuming 0.`);
        currentWounds = 0;
    }

    // Calculate healing die size (must be at least 1)
    const healingDieSize = Math.max(1, Math.round(vitMax / divisor));
    const healingRoll = fCSd(healingDieSize);
    fMyConsoleLog(`         -> Healing roll (${degreeLabel}): d${healingDieSize} = ${healingRoll}`);

    // Calculate new wounds (minimum 0)
    const newWounds = Math.max(0, currentWounds - healingRoll);
    const actualHealed = currentWounds - newWounds; // <<< CALCULATE ACTUAL HEALED AMOUNT
    fMyConsoleLog(`         -> Wounds: ${currentWounds} -> ${newWounds} (Healed: ${actualHealed})`);

    // Set the new wound value in the grid
    if (!fSetGridValue(woundRange.r1, woundRange.c1, newWounds)) {
        const msg = `Failed to update grid for ${degreeLabel} wounds.`;
        console.warn(`fProcessWoundHealing: ${msg}`);
        fMyConsoleLog(`         -> ⚠️ Error: ${msg}`);
        await fShowMessage(`Error updating ${degreeLabel} wounds: ${msg}`);
        return null; // Indicate failure
    }

    return actualHealed; // <<< RETURN ACTUAL HEALED AMOUNT

} // END fProcessWoundHealing




// fHealAllWounds /////////////////////////////////////////////////////////////////////////
// Purpose -> Sets 1st, 2nd, and 3rd degree wounds to 0, updates Vit Now/Percent, and logs to sidebar.
// Inputs  -> None
// Outputs -> None (Modifies grid, calls sidebar functions)
async function fHealAllWounds() {
    fMyConsoleLog("⚙️ Menu Action: Clearing All Wounds...");

    const woundTags = ['vit1stWnds', 'vit2ndWnds', 'vit3rdWnds'];
    let errorsOccurred = false;

    // Loop through each wound type tag
    for (const tag of woundTags) {
        const woundRange = gUI.range?.[tag];

        // Validate range definition
        if (!woundRange || !woundRange.r1 || !woundRange.c1) {
            const msg = `Wound range definition missing for tag: ${tag}.`;
            console.warn(`fHealAllWounds: ${msg}`);
            fMyConsoleLog(`   -> ⚠️ Error: ${msg}`);
            await fShowMessage(`Error clearing wounds: ${msg}`);
            errorsOccurred = true;
            continue; // Skip to next tag if definition missing
        }

        // Set the value to 0
        if (!fSetGridValue(woundRange.r1, woundRange.c1, 0)) {
            const msg = `Failed to update grid for tag: ${tag}.`;
            console.warn(`fHealAllWounds: ${msg}`);
            fMyConsoleLog(`   -> ⚠️ Error: ${msg}`);
            await fShowMessage(`Error clearing wounds: ${msg}`);
            errorsOccurred = true;
            // Continue trying to clear other wound types even if one fails
        } else {
             fMyConsoleLog(`   -> Cleared wounds for tag: ${tag}`);
        }
    }

    // Update Vit Now & Percent only if all updates were successful
    if (!errorsOccurred) {
        await fVitNowNPercent_Calc(); // Update dependent Vit fields
    } else {
        fMyConsoleLog("   -> Skipping Vit Now/Percent update due to errors clearing wounds.");
    }

    // Build and Display Sidebar Message (always show message, even if errors occurred during set)
    const sidebarMsg = `<span class="blue-bold">ℹ️ All Wounds Healed</span>`;
    fPrependToSidebar(sidebarMsg);
    fShowSidebar();

    fMyConsoleLog(`✅ Clear All Wounds Process Complete ${errorsOccurred ? '(with errors)' : ''}.`);

} // END fHealAllWounds




// fMeta_SetToMax ///////////////////////////////////////////////////////////////
// Purpose -> Sets the current Meta values (Row: 'meta', Cols: 'R' to 'B') to their maximums
//            based on gUI.list.metaFull and gUI.range.meta. Triggered by menu.
// Inputs  -> None
// Outputs -> None (Calls fSetRangeValues which modifies grid data and DOM)
function fMeta_SetToMax() {
    fMyConsoleLog("⚙️ Menu Action: Setting Meta to Max...");

    // --- 1. Get Range and Max Values ---
    const metaRange = gUI.range?.meta;
    const maxMetaValues = gUI.list?.metaFull;

    // --- 2. Validate Inputs ---
    if (!metaRange || typeof metaRange.r1 === 'undefined' || typeof metaRange.c1 === 'undefined' || typeof metaRange.r2 === 'undefined' || typeof metaRange.c2 === 'undefined') {
        console.warn("fMeta_SetToMax: Meta range definition is missing or incomplete in gUI.range.meta.");
        fMyConsoleLog("⚠️ Cannot set Meta to max: Range definition missing or incomplete.");
        fShowMessage("Error: Meta range definition is missing."); // User feedback
        return;
    }
    if (!Array.isArray(maxMetaValues) || maxMetaValues.length === 0) {
        console.warn("fMeta_SetToMax: Max Meta values are missing or empty in gUI.list.metaFull.");
        fMyConsoleLog("⚠️ Cannot set Meta to max: Max values list missing or empty.");
        fShowMessage("Error: Max Meta values list is missing."); // User feedback
        return;
    }

    // --- 3. Call fSetRangeValues ---
    // Note: fSetRangeValues expects a 1D array if the target range is 1 row high.
    // It automatically maps the array elements across the columns of that row.
    const success = fSetRangeValues(
        metaRange.r1,
        metaRange.c1,
        metaRange.r2,
        metaRange.c2,
        maxMetaValues // Pass the 1D array directly
    );

    // --- 4. Log Result ---
    if (!success) {
        // fSetRangeValues logs its own errors, but we add context here
        fMyConsoleLog(`⚠️ Failed to set Meta to max using fSetRangeValues.`);
        // Optional: fShowMessage("Error setting Meta values."); // User feedback if needed
    } else {
        fMyConsoleLog("✅ Meta Set to Max.");
        // --- Build and Display Sidebar Message ---
        const sidebarMsg = `<span class="blue-bold">ℹ️ Meta Set to Max:</span>`;
        fPrependToSidebar(sidebarMsg);
        fShowSidebar();
    }

} // END fMeta_SetToMax




// fLuck_SetToMax ///////////////////////////////////////////////////////////////
// Purpose -> Sets the current Luck value (gUI.range.luckBox) to its maximum,
//            calculated as gUI.list.luckBoxMax + integer value of gUI.range.luckBoxPlus.
//            Triggered by menu action 'game-setMaxLuck'.
// Inputs  -> None
// Outputs -> None (Calls fGetGridValue, fSetGridValue which modify grid data and DOM)
async function fLuck_SetToMax() {
    fMyConsoleLog("⚙️ Menu Action: Setting Luck to Max...");

    // --- 1. Get Base Value and Range Definitions ---
    const baseLuck = gUI.list?.luckBoxMax;
    const luckBoxRange = gUI.range?.luckBox;
    const luckBoxPlusRange = gUI.range?.luckBoxPlus;

    // --- 2. Validate Base Value and Ranges ---
    if (typeof baseLuck !== 'number' || isNaN(baseLuck)) {
        console.warn("fLuck_SetToMax: Base Luck value is missing or invalid in gUI.list.luckBoxMax.");
        fMyConsoleLog("⚠️ Cannot set Luck to max: Base Luck value missing or invalid.");
        await fShowMessage("Error: Base Luck value definition is missing or invalid."); // User feedback
        return;
    }
    if (!luckBoxRange || typeof luckBoxRange.r1 === 'undefined' || typeof luckBoxRange.c1 === 'undefined') {
        // Only need r1, c1 for single cell get/set
        console.warn("fLuck_SetToMax: LuckBox range definition is missing or incomplete in gUI.range.luckBox.");
        fMyConsoleLog("⚠️ Cannot set Luck to max: LuckBox range definition missing or incomplete.");
        await fShowMessage("Error: LuckBox range definition is missing."); // User feedback
        return;
    }
    if (!luckBoxPlusRange || typeof luckBoxPlusRange.r1 === 'undefined' || typeof luckBoxPlusRange.c1 === 'undefined') {
        // Only need r1, c1 for single cell get
        console.warn("fLuck_SetToMax: LuckBoxPlus range definition is missing or incomplete in gUI.range.luckBoxPlus.");
        fMyConsoleLog("⚠️ Cannot set Luck to max: LuckBoxPlus range definition missing or incomplete.");
        await fShowMessage("Error: LuckBoxPlus range definition is missing."); // User feedback
        return;
    }

    // --- 3. Get Luck Plus Bonus Value ---
    const luckPlusValueRaw = fGetGridValue(luckBoxPlusRange.r1, luckBoxPlusRange.c1);
    let luckPlusBonus = 0; // Default bonus to 0

    // Check if raw value is a number or a string that can be converted to one
    if (luckPlusValueRaw !== null && luckPlusValueRaw !== '' && !isNaN(Number(luckPlusValueRaw))) {
        luckPlusBonus = Math.round(Number(luckPlusValueRaw)); // Round to nearest integer
        fMyConsoleLog(`   -> Luck Plus Bonus found: ${luckPlusValueRaw} -> Rounded: ${luckPlusBonus}`);
    } else {
        fMyConsoleLog(`   -> No valid Luck Plus Bonus found in cell (${luckBoxPlusRange.r1}, ${luckBoxPlusRange.c1}). Using 0.`);
        // Optional: Show a message if the value was present but invalid?
        // if (luckPlusValueRaw !== null && luckPlusValueRaw !== '') {
        //    await fShowMessage(`Warning: The value "${luckPlusValueRaw}" in the Luck Plus cell is not a valid number. Using 0 bonus.`);
        // }
    }

    // --- 4. Calculate New Luck Value ---
    const newLuckValue = baseLuck + luckPlusBonus;
    fMyConsoleLog(`   -> Calculated Max Luck: ${baseLuck} (Base) + ${luckPlusBonus} (Bonus) = ${newLuckValue}`);

    // --- 5. Set New Value in Grid ---
    const success = fSetGridValue(luckBoxRange.r1, luckBoxRange.c1, newLuckValue);

    // --- 6. Log Result ---
    if (!success) {
        // fSetGridValue logs specific errors
        fMyConsoleLog(`⚠️ Failed to set Luck to max value (${newLuckValue}) in cell (${luckBoxRange.r1}, ${luckBoxRange.c1}).`);
        await fShowMessage(`Error: Failed to update the Luck value in the grid.`); // User feedback
    } else {
        fMyConsoleLog(`✅ Luck Set to Max (${newLuckValue}).`);
        const sidebarMsg = `<span class="blue-bold">ℹ️ Luck Set to Max:</span>`;
        fPrependToSidebar(sidebarMsg);
        fShowSidebar();
    }

} // END fLuck_SetToMax



// fAct_SetToMax ///////////////////////////////////////////////////////////////
// Purpose -> Sets the current Act Total value (gUI.range.actTotal) to its maximum,
//            calculated as gUI.list.actMax + integer value of gUI.range.actPlus.
// Inputs  -> None
// Outputs -> None (Calls fGetGridValue, fSetGridValue which modify grid data and DOM)
async function fAct_SetToMax() {
    fMyConsoleLog("⚙️ Setting Action Points to Max...");

    // --- 1. Get Base Value and Range Definitions ---
    const baseActMax = gUI.list?.actMax;
    const actTotalRange = gUI.range?.actTotal;
    const actPlusRange = gUI.range?.actPlus;

    // --- 2. Validate Base Value and Ranges ---
    if (typeof baseActMax !== 'number' || isNaN(baseActMax)) {
        console.warn("fAct_SetToMax: Base Act Max value is missing or invalid in gUI.list.actMax.");
        fMyConsoleLog("⚠️ Cannot set Act to max: Base Act Max value missing or invalid.");
        await fShowMessage("Error: Base Action Points Max value definition is missing or invalid."); // User feedback
        return;
    }
    if (!actTotalRange || typeof actTotalRange.r1 === 'undefined' || typeof actTotalRange.c1 === 'undefined') {
        // Only need r1, c1 for single cell get/set
        console.warn("fAct_SetToMax: Act Total range definition is missing or incomplete in gUI.range.actTotal.");
        fMyConsoleLog("⚠️ Cannot set Act to max: Act Total range definition missing or incomplete.");
        await fShowMessage("Error: Action Points Total range definition is missing."); // User feedback
        return;
    }
    if (!actPlusRange || typeof actPlusRange.r1 === 'undefined' || typeof actPlusRange.c1 === 'undefined') {
        // Only need r1, c1 for single cell get
        console.warn("fAct_SetToMax: Act Plus range definition is missing or incomplete in gUI.range.actPlus.");
        fMyConsoleLog("⚠️ Cannot set Act to max: Act Plus range definition missing or incomplete.");
        await fShowMessage("Error: Action Points Plus range definition is missing."); // User feedback
        return;
    }

    // --- 3. Get Act Plus Bonus Value ---
    const actPlusValueRaw = fGetGridValue(actPlusRange.r1, actPlusRange.c1);
    let actPlusBonus = 0; // Default bonus to 0

    // Check if raw value is a number or a string that can be converted to one
    if (actPlusValueRaw !== null && actPlusValueRaw !== '' && !isNaN(Number(actPlusValueRaw))) {
        actPlusBonus = Math.round(Number(actPlusValueRaw)); // Round to nearest integer
        fMyConsoleLog(`   -> Act Plus Bonus found: ${actPlusValueRaw} -> Rounded: ${actPlusBonus}`);
    } else {
        fMyConsoleLog(`   -> No valid Act Plus Bonus found in cell (${actPlusRange.r1}, ${actPlusRange.c1}). Using 0.`);
        // Optional: Show a message if the value was present but invalid?
        // if (actPlusValueRaw !== null && actPlusValueRaw !== '') {
        //    await fShowMessage(`Warning: The value "${actPlusValueRaw}" in the Act Plus cell is not a valid number. Using 0 bonus.`);
        // }
    }

    // --- 4. Calculate New Act Value ---
    const newActValue = baseActMax + actPlusBonus;
    fMyConsoleLog(`   -> Calculated Max Act: ${baseActMax} (Base) + ${actPlusBonus} (Bonus) = ${newActValue}`);

    // --- 5. Set New Value in Grid ---
    // Use actTotalRange for setting the value
    const success = fSetGridValue(actTotalRange.r1, actTotalRange.c1, newActValue);

    // --- 6. Log Result ---
    if (!success) {
        // fSetGridValue logs specific errors
        fMyConsoleLog(`⚠️ Failed to set Act to max value (${newActValue}) in cell (${actTotalRange.r1}, ${actTotalRange.c1}).`);
        await fShowMessage(`Error: Failed to update the Action Points value in the grid.`); // User feedback
    } else {
        fMyConsoleLog(`✅ Action Points Set to Max (${newActValue}).`);
    }

} // END fAct_SetToMax




// fCalc_VitMaxNowPerc ///////////////////////////////////////////////////////////////
// Purpose -> Sets the Vit Max value based on Fortitude + Vit Bonus, then updates
//            current Vit and percentage via helper. Triggered by menu action 'game-setMaxVit'.
// Inputs  -> None
// Outputs -> None (Calls helper, fGetGridValue, fSetGridValue which modify grid data/DOM)
async function fCalc_VitMaxNowPerc() {
    fMyConsoleLog("⚙️ Menu Action: Setting Vit to Max...");

    // --- 1. Get Range Definitions ---
    const fortitudeRange = gUI.range?.fortitudeSk1;
    const vitMaxRange = gUI.range?.vitMax;
    const vitMaxPlusRange = gUI.range?.vitMaxPlus;

    // --- 2. Validate Ranges ---
    let errorMsg = '';
    if (!fortitudeRange || !fortitudeRange.r1 || !fortitudeRange.c1) errorMsg = "Fortitude range definition missing.";
    else if (!vitMaxRange || !vitMaxRange.r1 || !vitMaxRange.c1) errorMsg = "Vit Max range definition missing.";
    else if (!vitMaxPlusRange || !vitMaxPlusRange.r1 || !vitMaxPlusRange.c1) errorMsg = "Vit Max Plus range definition missing.";

    if (errorMsg) {
        console.warn(`fCalc_VitMaxNowPerc: ${errorMsg}`);
        fMyConsoleLog(`⚠️ Cannot set Vit to max: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }

    // --- 3. Get Fortitude Value ---
    const fortitudeValueRaw = fGetGridValue(fortitudeRange.r1, fortitudeRange.c1);
    const fortitudeValue = Number(fortitudeValueRaw);

    if (isNaN(fortitudeValue)) {
        const msg = `Fortitude Sk1 value ('${fortitudeValueRaw}') is not a valid number.`;
        console.warn(`fCalc_VitMaxNowPerc: ${msg}`);
        fMyConsoleLog(`⚠️ Cannot set Vit to max: ${msg}`);
        await fShowMessage(`Error: ${msg}`);
        return;
    }
    fMyConsoleLog(`   -> Fortitude Sk1 value: ${fortitudeValue}`);

    // --- 4. Get Vit Max Plus Bonus ---
    const vitMaxPlusValueRaw = fGetGridValue(vitMaxPlusRange.r1, vitMaxPlusRange.c1);
    let vitMaxPlusBonus = 0; // Default bonus to 0

    if (vitMaxPlusValueRaw !== null && vitMaxPlusValueRaw !== '' && !isNaN(Number(vitMaxPlusValueRaw))) {
        vitMaxPlusBonus = Math.round(Number(vitMaxPlusValueRaw)); // Round to nearest integer
        fMyConsoleLog(`   -> Vit Max Plus Bonus found: ${vitMaxPlusValueRaw} -> Rounded: ${vitMaxPlusBonus}`);
    } else {
        fMyConsoleLog(`   -> No valid Vit Max Plus Bonus found. Using 0.`);
    }

    // --- 5. Calculate and Set New Vit Max ---
    const newVitMax = Math.round(fortitudeValue + vitMaxPlusBonus); // Ensure integer result
    fMyConsoleLog(`   -> Calculated New Vit Max: ${fortitudeValue} (For) + ${vitMaxPlusBonus} (Bonus) = ${newVitMax}`);

    const setMaxSuccess = fSetGridValue(vitMaxRange.r1, vitMaxRange.c1, newVitMax);

    if (!setMaxSuccess) {
        fMyConsoleLog(`⚠️ Failed to set Vit Max value (${newVitMax}) in cell (${vitMaxRange.r1}, ${vitMaxRange.c1}). Aborting further updates.`);
        await fShowMessage(`Error: Failed to update the Vit Max value in the grid.`);
        return; // Stop if we couldn't set the new max value
    }
    fMyConsoleLog(`   -> Successfully set Vit Max to ${newVitMax}.`);

    // --- 6. Call Helper to Update Vit Now and Percentage ---
    await fVitNowNPercent_Calc(); // Calls the helper function below

    fMyConsoleLog("✅ Vit Set to Max sequence complete.");

} // END fCalc_VitMaxNowPerc




// fVitNowNPercent_Calc /////////////////////////////////////////////////////////
// Purpose -> Helper to calculate Vit Now (Vit Max - Wounds) and Vit Now Percent.
//            Updates the respective grid cells. Called by fCalc_VitMaxNowPerc.
// Inputs  -> None (Reads required values from grid using gUI.range definitions)
// Outputs -> None (Calls fGetGridValue, fSetGridValue which modify grid data/DOM)
async function fVitNowNPercent_Calc() {
    fMyConsoleLog("   -> Calculating Vit Now & Percent...");

    // --- 1. Get Range Definitions ---
    const vitMaxRange = gUI.range?.vitMax;
    const vit1stRange = gUI.range?.vit1stWnds;
    const vit2ndRange = gUI.range?.vit2ndWnds;
    const vit3rdRange = gUI.range?.vit3rdWnds;
    const vitNowRange = gUI.range?.vitNow;
    const vitNowPercentRange = gUI.range?.vitNowPercent;

    // --- 2. Validate Ranges ---
    let errorMsg = '';
    if (!vitMaxRange || !vitMaxRange.r1 || !vitMaxRange.c1) errorMsg = "Vit Max range definition missing.";
    else if (!vit1stRange || !vit1stRange.r1 || !vit1stRange.c1) errorMsg = "Vit 1st Wounds range definition missing.";
    else if (!vit2ndRange || !vit2ndRange.r1 || !vit2ndRange.c1) errorMsg = "Vit 2nd Wounds range definition missing.";
    else if (!vit3rdRange || !vit3rdRange.r1 || !vit3rdRange.c1) errorMsg = "Vit 3rd Wounds range definition missing.";
    else if (!vitNowRange || !vitNowRange.r1 || !vitNowRange.c1) errorMsg = "Vit Now range definition missing.";
    else if (!vitNowPercentRange || !vitNowPercentRange.r1 || !vitNowPercentRange.c1) errorMsg = "Vit Now Percent range definition missing.";

    if (errorMsg) {
        console.warn(`fVitNowNPercent_Calc: ${errorMsg}`);
        fMyConsoleLog(`   -> ⚠️ Calculation aborted: ${errorMsg}`);
        await fShowMessage(`Error: ${errorMsg}`);
        return;
    }

    // --- 3. Get Current Vit Max (should be the newly set value) ---
    const currentVitMaxRaw = fGetGridValue(vitMaxRange.r1, vitMaxRange.c1);
    const currentVitMax = Number(currentVitMaxRaw);
    if (isNaN(currentVitMax)) {
        const msg = `Vit Max value ('${currentVitMaxRaw}') needed for calculation is not a number.`;
        console.warn(`fVitNowNPercent_Calc: ${msg}`);
        fMyConsoleLog(`   -> ⚠️ Calculation aborted: ${msg}`);
        await fShowMessage(`Error: ${msg}`);
        return;
    }

    // --- 4. Get and Sum Wound Values ---
    const getWoundVal = (range) => {
        const raw = fGetGridValue(range.r1, range.c1);
        // Return rounded integer if valid number, otherwise 0
        return (raw !== null && raw !== '' && !isNaN(Number(raw))) ? Math.round(Number(raw)) : 0;
    };
    const wounds1st = getWoundVal(vit1stRange);
    const wounds2nd = getWoundVal(vit2ndRange);
    const wounds3rd = getWoundVal(vit3rdRange);
    const totalWounds = wounds1st + wounds2nd + wounds3rd;
    fMyConsoleLog(`      -> Wounds: ${wounds1st}(1st) + ${wounds2nd}(2nd) + ${wounds3rd}(3rd) = ${totalWounds}`);

    // --- 5. Calculate and Set Vit Now ---
    const newVitNow = Math.round(currentVitMax - totalWounds); // Ensure integer
    fMyConsoleLog(`      -> Calculated Vit Now: ${currentVitMax} (Max) - ${totalWounds} (Wounds) = ${newVitNow}`);
    const setNowSuccess = fSetGridValue(vitNowRange.r1, vitNowRange.c1, newVitNow);
    if (!setNowSuccess) {
        fMyConsoleLog(`   -> ⚠️ Failed to set Vit Now value (${newVitNow}).`);
        await fShowMessage(`Error: Failed to update the Vit Now value.`);
        // Continue to attempt percentage calculation? Or return? Let's continue for now.
    }

    // --- 6. Calculate and Set Vit Now Percentage ---
    const percent = (currentVitMax === 0) ? 0 : Math.round((newVitNow / currentVitMax) * 100);
    const percentString = percent + '%';
    fMyConsoleLog(`      -> Calculated Vit Now Percent: ${percentString}`);
    const setPercentSuccess = fSetGridValue(vitNowPercentRange.r1, vitNowPercentRange.c1, percentString);
     if (!setPercentSuccess) {
        fMyConsoleLog(`   -> ⚠️ Failed to set Vit Now Percent value (${percentString}).`);
        await fShowMessage(`Error: Failed to update the Vit Now Percent value.`);
    }

    fMyConsoleLog("   -> Vit Now & Percent Calculation complete.");

} // END fVitNowNPercent_Calc




// fClearChanneledMeta ////////////////////////////////////////////////////////////
// Purpose -> Clears the channeled meta range defined in gUI.range.metaChannel using fSetRangeValues.
// Inputs  -> None
// Outputs -> None (Calls fSetRangeValues which modifies grid data and DOM)
function fClearChanneledMeta() {
    fMyConsoleLog("⚙️ Menu Action: Clearing Channeled Meta...");

    // --- 1. Get Range Definition ---
    const metaChannelRange = gUI.range?.metaChannel; // Get the range definition object

    // --- 2. Validate Range Object ---
    if (!metaChannelRange || typeof metaChannelRange.r1 === 'undefined' || typeof metaChannelRange.c1 === 'undefined' || typeof metaChannelRange.r2 === 'undefined' || typeof metaChannelRange.c2 === 'undefined') {
        console.warn("fClearChanneledMeta: Channeled Meta range definition is missing or incomplete in gUI.range.metaChannel.");
        fMyConsoleLog("⚠️ Cannot clear Channeled Meta: Range definition missing or incomplete.");
        fShowMessage("Error: Channeled Meta range definition is missing."); // User feedback
        return;
    }

    // --- 3. Call fSetRangeValues ---
    // Call fSetRangeValues using properties from the metaChannelRange object
    const success = fSetRangeValues(
        metaChannelRange.r1,
        metaChannelRange.c1,
        metaChannelRange.r2,
        metaChannelRange.c2,
        '' // Set the range to empty strings
    );

    // --- 4. Log Result ---
    if (!success) {
        // fSetRangeValues logs specific errors, add context here
        // Log uses the actual tags from the object for clarity in case of failure
        fMyConsoleLog(`⚠️ Failed to clear Channeled Meta range (${metaChannelRange.r1},${metaChannelRange.c1} to ${metaChannelRange.r2},${metaChannelRange.c2}) using fSetRangeValues.`);
        // Optional: Show an error message to the user if needed
        // fShowMessage("Error clearing the channeled meta range.");
    } else {
        fMyConsoleLog("✅ Channeled Meta Range Cleared.");
    }

} // END fClearChanneledMeta



// fClearSk1Sk2Checkboxes ///////////////////////////////////////////////////////
// Purpose -> Clears all checkboxes defined in gUI.sk1sk2CheckBoxes using fSetRangeValues.
// Inputs  -> None
// Outputs -> None (Calls fSetRangeValues which modifies grid data and DOM)
function fClearSk1Sk2Checkboxes() {
    fMyConsoleLog("⚙️ Menu Action: Clearing Sk1/Sk2 Checkboxes...");
    let allSucceeded = true;
    const rangesToClear = gUI.sk1sk2CheckBoxes; // Get the predefined ranges

    if (!Array.isArray(rangesToClear) || rangesToClear.length === 0) {
        fMyConsoleLog("ℹ️ No Sk1/Sk2 checkbox ranges defined in gUI.sk1sk2CheckBoxes.");
        return;
    }

    rangesToClear.forEach(range => {
        // We still need to resolve each range object before calling fSetRangeValues
        const r1 = resolveRow(range.r1);
        const c1 = resolveCol(range.c1);
        const r2 = resolveRow(range.r2);
        const c2 = resolveCol(range.c2);

        // Validate the resolved indices from the range object
        if ([r1, c1, r2, c2].some(isNaN)) {
             console.warn(`fClearSk1Sk2Checkboxes: Skipping invalid range definition:`, range);
             allSucceeded = false; // Mark failure if any range is invalid
             return; // Skip this range object in the forEach loop
        }

        // Call fSetRangeValues for the current range, setting to false
        // This updates both gUI.arr and the checkbox DOM state
        const success = fSetRangeValues(r1, c1, r2, c2, false);
        if (!success) {
             allSucceeded = false; // Track if any call to fSetRangeValues fails
        }
    });

     if (!allSucceeded) {
         fMyConsoleLog("⚠️ Failed to clear one or more Sk1/Sk2 Checkbox ranges.");
         // Consider showing an error message: fShowMessage("Error clearing some checkboxes.");
     } else {
        fMyConsoleLog("✅ Sk1/Sk2 Checkboxes Cleared.");
     }

} // END fClearSk1Sk2Checkboxes




// fClearMonsters ///////////////////////////////////////////////////////////////
// Purpose -> Clears the monster data range defined in gUI.range.monsters using fSetRangeValues.
// Inputs  -> None
// Outputs -> None (Calls fSetRangeValues which modifies grid data and DOM)
function fClearMonsters() {
    fMyConsoleLog("⚙️ Menu Action: Clearing Monsters...");
    const monsterRange = gUI.range?.monsters; // Get the range definition object

    // Validate the range object exists and has the needed properties
    if (!monsterRange || typeof monsterRange.r1 === 'undefined' || typeof monsterRange.c1 === 'undefined' || typeof monsterRange.r2 === 'undefined' || typeof monsterRange.c2 === 'undefined') {
        console.warn("fClearMonsters: Monster range definition is missing or incomplete in gUI.range.monsters.");
        fMyConsoleLog("⚠️ Cannot clear monsters: Range definition missing or incomplete.");
        return;
    }

    const clearValue = ' '; // Use a space to clear the cells

    // Call fSetRangeValues using properties from the monsterRange object
    const success = fSetRangeValues(
        monsterRange.r1,
        monsterRange.c1,
        monsterRange.r2,
        monsterRange.c2,
        clearValue
    );

    if (!success) {
         // Log uses the actual tags from the object for clarity
         fMyConsoleLog(`⚠️ Failed to clear Monsters range (${monsterRange.r1},${monsterRange.c1} to ${monsterRange.r2},${monsterRange.c2}) using fSetRangeValues.`);
         // Optional: Show an error message to the user
         // fShowMessage("Error clearing the monster data range.");
    } else {
        fMyConsoleLog("✅ Monsters Range Cleared.");
    }
} // END fClearMonsters





// fClearMorphs /////////////////////////////////////////////////////////////////
// Purpose -> Clears the Morph1 and Morph2 ranges defined in gUI.range.morphs.
// Inputs  -> None
// Outputs -> None (Calls fSetRangeValues which modifies grid data and DOM)
function fClearMorphs() {
    fMyConsoleLog("⚙️ Menu Action: Clearing Morphs...");
    let allSucceeded = true;
    const morphRanges = gUI.range?.morphs; // Use optional chaining just in case

    if (!Array.isArray(morphRanges) || morphRanges.length === 0) {
        console.warn("fClearMorphs: No morph ranges defined in gUI.range.morphs.");
        fMyConsoleLog("⚠️ Cannot clear morphs: Ranges not defined.");
        return;
    }

    morphRanges.forEach(range => {
        if (!range || typeof range.r1 === 'undefined' || typeof range.c1 === 'undefined' || typeof range.r2 === 'undefined' || typeof range.c2 === 'undefined') {
            console.warn("fClearMorphs: Skipping invalid range object within gUI.range.morphs:", range);
            allSucceeded = false;
            return; // Skip this invalid range object in the loop
        }
        // Call fSetRangeValues for the current morph range, clearing with a space
        const success = fSetRangeValues(range.r1, range.c1, range.r2, range.c2, ' ');
        if (!success) {
             allSucceeded = false; // Track if any call fails
        }
    });

     if (!allSucceeded) {
         fMyConsoleLog("⚠️ Failed to clear one or more Morph ranges using fSetRangeValues.");
         // fShowMessage("Error clearing some morph ranges."); // Optional user message
     } else {
        fMyConsoleLog("✅ Morph Ranges Cleared.");
     }
} // END fClearMorphs




// fClearCurrentNish ////////////////////////////////////////////////////////////
// Purpose -> Clears the current Nish range defined in gUI.range.currentNish.
// Inputs  -> None
// Outputs -> None (Calls fSetRangeValues which modifies grid data and DOM)
function fClearCurrentNish() {
    fMyConsoleLog("⚙️ Menu Action: Clearing Current Nish...");
    const nishRange = gUI.range?.currentNish; // Get the range definition object

    // Validate the range object
    if (!nishRange || typeof nishRange.r1 === 'undefined' || typeof nishRange.c1 === 'undefined' || typeof nishRange.r2 === 'undefined' || typeof nishRange.c2 === 'undefined') {
        console.warn("fClearCurrentNish: Nish range definition is missing or incomplete in gUI.range.currentNish.");
        fMyConsoleLog("⚠️ Cannot clear Nish: Range definition missing or incomplete.");
        return;
    }

    const clearValue = ' '; // Use a space to clear the cells

    // Call fSetRangeValues using properties from the nishRange object
    const success = fSetRangeValues(
        nishRange.r1,
        nishRange.c1,
        nishRange.r2,
        nishRange.c2,
        clearValue
    );

    if (!success) {
         fMyConsoleLog(`⚠️ Failed to clear Nish range (<span class="math-inline">\{nishRange\.r1\},</span>{nishRange.c1} to <span class="math-inline">\{nishRange\.r2\},</span>{nishRange.c2}) using fSetRangeValues.`);
         // Optional: fShowMessage("Error clearing the Nish data range.");
    } else {
        fMyConsoleLog("✅ Current Nish Range Cleared.");
    }
} // END fClearCurrentNish




// fClearRollLog ////////////////////////////////////////////////////////////////
// Purpose -> Clears the Roll Log sidebar and displays a confirmation message.
// Inputs  -> None
// Outputs -> None (Modifies DOM)
function fClearRollLog() {
    fMyConsoleLog("⚙️ Menu Action: Clearing Roll Log...");
    const sidebarContent = document.getElementById('sidebar-content');

    if (!sidebarContent) {
        console.error("fClearRollLog: Could not find sidebar content element (#sidebar-content).");
        fMyConsoleLog("⚠️ Cannot clear Roll Log: Sidebar content element not found.");
        return;
    }

    // Clear existing content and add the styled "Cleared" message
    // Uses the .blue-bold class from style.html [cite: 579]
    sidebarContent.innerHTML = '<p><span class="blue-bold">Roll Log Cleared</span></p>';

    fMyConsoleLog("✅ Roll Log Cleared.");
} // END fClearRollLog




// fToggleGearColumns ///////////////////////////////////////////////////////////////
// Purpose -> Checks if gear columns (defined in gUI.gearTblCols) are currently visible
//          and calls the appropriate show/hide range function to toggle their state.
function fToggleGearColumns() {
    const gearRanges = gUI.gearTblCols;

    // Basic validation of the configuration
    if (!Array.isArray(gearRanges) || gearRanges.length === 0) {
        console.error("❌ Cannot toggle gear columns: gUI.gearTblCols is not a valid array or is empty.");
        fMyConsoleLog("❌ Error: Gear column definition missing or invalid.");
        return;
    }

    let isCurrentlyVisible = false;

    // Check if *any* column within the defined gear ranges is currently visible
    // Loop through each range object in the array (e.g., [{ c1: 'TagA', c2: 'TagB' }])
    for (const range of gearRanges) {
        if (!range || typeof range.c1 === 'undefined' || typeof range.c2 === 'undefined') {
            console.warn("Skipping invalid range object in fToggleGearColumns:", range);
            continue;
        }
        const startCol = resolveCol(range.c1);
        const endCol = resolveCol(range.c2);

        if (isNaN(startCol) || isNaN(endCol)) {
            console.warn(`Skipping gear range due to invalid tags/indices: ${range.c1}, ${range.c2}`);
            continue; // Skip this range if tags don't resolve
        }

        const cMin = Math.min(startCol, endCol);
        const cMax = Math.max(startCol, endCol);

        // Loop through columns within the current resolved range
        for (let c = cMin; c <= cMax; c++) {
            // If we find *one* column in the gear range that is NOT hidden, then gear is visible
            if (!gUI.hiddenColumns.has(c)) {
                isCurrentlyVisible = true;
                break; // Exit inner loop once visibility is confirmed
            }
        }

        if (isCurrentlyVisible) {
            break; // Exit outer loop once visibility is confirmed
        }
    } // End loop through gearRanges

    // Call the appropriate action based on the determined visibility
    if (isCurrentlyVisible) {
        fMyConsoleLog("⚙️ Toggling Gear: Currently Visible -> Hiding...");
        fHideColumnRange(gearRanges); // Hide all defined gear ranges
    } else {
        fMyConsoleLog("⚙️ Toggling Gear: Currently Hidden -> Showing...");
        fShowColumnRange(gearRanges); // Show all defined gear ranges
    }
}; // END fToggleGearColumns




// ==========================================================================
// === Header Button Click     (End of Menu Bar Click) ===
// ==========================================================================



// fHandleHeaderButtonClick ///////////////////////////////////////////////////////////////////////
// Routes header button clicks to specific action handlers.
// MODIFIED: Added call to fRefreshMonsterData for action-showMonsters
function fHandleHeaderButtonClick(event, buttonImg) {
    const action = buttonImg.dataset.buttonAction;
    fMyConsoleLog(`🖱️ Header Button Clicked: ${action}`);

    event.preventDefault();
    event.stopPropagation();
    const grid = document.getElementById('grid');

    switch (action) {
        case 'action-rollDice':
            fHandleRollDiceAction();
            break;
        case 'action-refreshData':
            console.log("ACTION: Refresh Data button clicked (logic pending)");
            break;
        case 'action-jumpTop':
            fScrollGridToTop(grid);
            break;
        case 'action-jumpBottom':
            fScrollGridToBottom(grid);
            break;
        case 'action-showMonsters':
            // console.log("ACTION: Show Monsters button clicked (logic pending)"); // OLD
            fRefreshMonsterData(); // <<< NEW: Call the refresh function
            break;
        default:
            console.warn(`Unhandled header button action: ${action}`);
    }
} // END fHandleHeaderButtonClick


// fScrollGridToTop ///////////////////////////////////////////////////////////////////////////////
// Scrolls the grid to the top smoothly.
function fScrollGridToTop(grid) {
    if (grid) {
        grid.scrollTo({ top: 0, behavior: 'smooth' });
    } else {
        console.warn("Could not find #grid element to scroll top.");
    }
} // END fScrollGridToTop




// fScrollGridToBottom ////////////////////////////////////////////////////////////////////////////
// Scrolls the grid to center on a specific tagged row.
function fScrollGridToBottom(grid) {
    if (!grid) {
        console.warn("Could not find #grid element to scroll bottom.");
        return;
    }

    const targetRowIndex = resolveRow('GearTblHeaderStartR');
    if (isNaN(targetRowIndex)) {
        console.warn("Could not resolve row tag 'GearTblHeaderStartR' for scrolling.");
        return;
    }

    const targetCell = gUI.grid2D?.[targetRowIndex]?.[0];
    if (!targetCell) {
        console.warn(`Could not find cell for row ${targetRowIndex} (Tag: GearTblHeaderStartR)`);
        return;
    }

    const scrollTop = targetCell.offsetTop - (grid.clientHeight / 2) + (targetCell.offsetHeight / 2);
    grid.scrollTo({ top: scrollTop, behavior: 'smooth' });
    fMyConsoleLog(`Scrolling grid to center row ${targetRowIndex} (Tag: GearTblHeaderStartR)`);
} // END fScrollGridToBottom



// fRefreshMonsterData ///////////////////////////////////////////////////////////////
// Purpose -> Clears the first row of the monster range and fetches fresh data for the rest from the <Game> Google Sheet.
// Inputs  -> None
// Outputs -> None (Modifies grid via fSetRangeValues, calls server)
async function fRefreshMonsterData() {
    fMyConsoleLog("⚙️ Refreshing Monster Data...");

    // --- 1. Get and Validate Monster Range ---
    const monsterRangeDef = gUI.range?.monsters;
    if (!monsterRangeDef || !fIsValidRangeObject(monsterRangeDef)) {
        const msg = "Monster range definition (gUI.range.monsters) is missing or invalid.";
        console.error(`fRefreshMonsterData: ${msg}`);
        fMyConsoleLog(`❌ Monster Refresh Failed: ${msg}`);
        await fShowMessage(`Error: ${msg}`);
        return;
    }

    // --- 2. Resolve Indices ---
    const resolved = fResolveRangeIndices(monsterRangeDef);
    if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
        const msg = `Could not resolve monster range tags: ${JSON.stringify(monsterRangeDef)}`;
        console.error(`fRefreshMonsterData: ${msg}`);
        fMyConsoleLog(`❌ Monster Refresh Failed: ${msg}`);
        await fShowMessage(`Error: ${msg}`);
        return;
    }
    const { r1, c1, r2, c2 } = resolved; // Use resolved 0-based indices

    // --- 3. Clear First Row Locally ---
    fMyConsoleLog(`   -> Clearing first monster row (${r1}) locally...`);
    if (!fSetRangeValues(r1, c1, r1, c2, '')) { // Set to empty string
        const msg = `Failed to clear the first row of the monster range locally.`;
        console.warn(`fRefreshMonsterData: ${msg}`);
        fMyConsoleLog(`   -> ⚠️ Warning: ${msg}`);
        // Continue even if local clear fails? Or stop? Let's continue for now.
        // await fShowMessage(`Warning: ${msg}`); // Optional user feedback
    }

    // --- 4. Fetch Remaining Rows from Server ---
    const fetchStartRow = r1 + 1;
    if (fetchStartRow > r2) {
        fMyConsoleLog("   -> No remaining monster rows to fetch from server (range was only 1 row).");
        fMyConsoleLog("✅ Monster Refresh Complete (only local clear).");
        // Optional: Show success message?
        // await fShowMessage("Monster header cleared.");
        return; // Nothing more to do
    }

    // Convert remaining range to A1 notation
    const a1Notation = fIndicesToA1(fetchStartRow, c1, r2, c2);
    if (!a1Notation) {
        const msg = "Failed to generate A1 notation for fetching monster data.";
        console.error(`fRefreshMonsterData: ${msg}`);
        fMyConsoleLog(`❌ Monster Refresh Failed: ${msg}`);
        await fShowMessage(`Error: ${msg}`);
        return;
    }

    fMyConsoleLog(`   -> Fetching monster data from Sheet range: ${a1Notation}`);
    // @@ Optional: Add a loading indicator here

    google.script.run
        .withSuccessHandler((dataArray) => {
            // @@ Optional: Remove loading indicator here
            fMyConsoleLog(`   -> Received ${dataArray?.length || 0} rows of monster data from server.`);

            if (!Array.isArray(dataArray)) {
                 const errMsg = "Received invalid data format from server for monsters.";
                 console.error(`fRefreshMonsterData Success Handler: ${errMsg}`, dataArray);
                 fMyConsoleLog(`   -> ❌ Error: ${errMsg}`);
                 fShowMessage(`Error: ${errMsg}`); // Use await if fShowMessage needs it
                 return;
            }

            // Update the grid locally with the fetched data
            fMyConsoleLog(`   -> Updating local grid rows ${fetchStartRow}-${r2}...`);
            if (!fSetRangeValues(fetchStartRow, c1, r2, c2, dataArray)) {
                 const errMsg = "Failed to update the grid with fetched monster data.";
                 console.warn(`fRefreshMonsterData Success Handler: ${errMsg}`);
                 fMyConsoleLog(`   -> ⚠️ Warning: ${errMsg}`);
                 fShowMessage(`Warning: ${errMsg}`); // Use await if needed
            } else {
                fMyConsoleLog("✅ Monster Refresh Complete.");
                // Optional: Show success message
                // fShowMessage("Monster data refreshed successfully.");
            }
        })
        .withFailureHandler((error) => {
            // @@ Optional: Remove loading indicator here
            const errorMsg = `Failed to fetch monster data from server: ${error.message}`;
            console.error(`fRefreshMonsterData Failure Handler:`, error);
            fMyConsoleLog(`❌ Monster Refresh Failed: ${errorMsg}`);
            fShowMessage(`Error: ${errorMsg}`); // Use await if needed
        })
        .fCSGetRangeData(SHEET_ID, a1Notation); // Call the new server function

} // END fRefreshMonsterData



// ==========================================================================
// === Initialization & Setup Functions     (End of Header Button Click) ===
// ==========================================================================




// fSetupGridClickListeners ////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Attaches delegated click and change listeners to the grid container.
// Inputs  -> gridElement (HTMLElement): The grid container element.
// Outputs -> None.
function fSetupGridClickListeners(gridElement) {

    // Validate input
    if (!gridElement) {
        console.error("❌ Cannot setup grid listeners: Grid element not provided.");
        return;
    }

    // Log setup start
    fMyConsoleLog("🖱️ Setting up Grid Click & Change Listeners...");

    // Add the single delegated handler for various click types (checkboxes, URLs, buttons)
    gridElement.addEventListener('click', fHandleGridClick);

    // Add delegated handler for dropdown changes <<< NEW LISTENER ADDED
    gridElement.addEventListener('change', (event) => {
        // Check if the changed element is one of our grid dropdowns
        if (event.target.tagName === 'SELECT' && event.target.classList.contains('grid-dropdown')) {
            fHandleDropdownChange(event);
        }
    });

    // Log setup end
    fMyConsoleLog("✅ Grid Click & Change Listeners Attached.");

}; // END fSetupGridClickListeners




// fSetupGridHoverListeners ////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Attaches delegated mouseover and mouseout listeners to the grid container for tooltips.
// Inputs -> gridElement (HTMLElement): The grid container element.
function fSetupGridHoverListeners(gridElement) {
    if (!gridElement) {
        console.error("❌ Cannot setup hover listeners: Grid element not provided.");
        return;
    }

    fMyConsoleLog("🖱️ Setting up Grid Hover Listeners for Tooltips...");

    // Use mouseover and mouseout for better detection as mouse moves over cell children
    gridElement.addEventListener('mouseover', fHandleCellHover);
    gridElement.addEventListener('mouseout', fHandleCellMouseOut);

    fMyConsoleLog("✅ Grid Hover Listeners Attached.");

}; // END fSetupGridHoverListeners




// fHideImageModal ///////////////////////////////////////////////////////////////////////////////
// Purpose -> Hides the image modal and resets image source and visibility.
function fHideImageModal() {
    if (!gUI.modalElement || !gUI.modalImageElement) return;

    gUI.modalElement.style.display = 'none';
    gUI.modalImageElement.src = '';
};




// fSetupModalListeners //////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Adds click listeners to the modal close button and backdrop.
function fSetupModalListeners() {
    // Globals moved to gUI are set in fSetupTooltipAndModal via fOnDataLoaded
    // gUI.modalElement, gUI.modalImageElement, gUI.modalCloseBtn, gUI.modalBackdrop
    if (!gUI.modalCloseBtn || !gUI.modalBackdrop) { // Updated references
         fMyConsoleLog("⚠️ Cannot setup modal listeners: Modal close button or backdrop not found.");
         console.warn("Modal listeners not set up.");
         return;
    }

    fMyConsoleLog("🖱️ Setting up Modal Listeners...");

    // Close button click - calls renamed/updated function
    gUI.modalCloseBtn.addEventListener('click', fHideImageModal); // Updated reference

    // Backdrop click - calls renamed/updated function
    gUI.modalBackdrop.addEventListener('click', fHideImageModal); // Updated reference

    fMyConsoleLog("✅ Modal Listeners Attached.");

}; // END fSetupModalListeners




// fSetupMenuInteractivity //////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Orchestrates the setup of all menu-related event listeners.
// MODIFIED: Added btnRoll reference and check
function fSetupMenuInteractivity() {
    fMyConsoleLog("⚙️ Setting up Menu Interactivity...");

    // --- Get Element References ---
    const menuBar = document.getElementById('menu-bar');
    const btnNish = document.getElementById('btn-nish');
    const btnRoll = document.getElementById('btn-roll'); // <<< Get Roll button ref
    const btnGame = document.getElementById('btn-game-menu');
    const dropdownGame = document.getElementById('dropdown-game');
    const btnGear = document.getElementById('btn-gear-menu');
    const dropdownGear = document.getElementById('dropdown-gear');
    const sidebarCloseBtn = document.getElementById('sidebar-close-btn');

    // Check if *main* elements exist before adding listeners
    // Added check for btnRoll and sidebarCloseBtn
    if (!menuBar || !btnNish || !btnRoll || !btnGame || !dropdownGame || !btnGear || !dropdownGear || !sidebarCloseBtn) { // <<< Added btnRoll check
        console.error("❌ Could not find all required menu/sidebar elements for interactivity setup.");
        if(!btnRoll) console.error("     -> Missing: #btn-roll"); // Log if specific button missing
        if(!sidebarCloseBtn) console.error("     -> Missing: #sidebar-close-btn");
        return; // Stop if essential elements are missing
    }

    // --- Call Helper Functions to Attach Listeners ---
    // Pass btnRoll to the button listener setup function
    fSetupMenuButtonListeners(btnNish, btnRoll, btnGame, dropdownGame, btnGear, dropdownGear); // <<< Pass btnRoll
    fSetupWindowClickListener();
    fSetupDelegatedMenuActionClick(menuBar);
    fSetupSubMenuHover(menuBar);

    // --- Add Sidebar Close Button Listener ---
    sidebarCloseBtn.addEventListener('click', fHideSidebar);

    fMyConsoleLog("✅ Menu Interactivity Setup Done");

}; // END fSetupMenuInteractivity




// ==========================================================================
// === Initial Data Load      (End of Initialization & Setup Functions) ===
// ==========================================================================




////////////////////////////////////////////////////////////////////////////////////////////////////////// START fOnDataLoaded and helpers




// fOnDataLoaded ////////////////////////////////////////////////////////////////////////////////////
// Receives data from server and kicks off render + post-processing sequence.
function fOnDataLoaded(data) {
    fMyConsoleLog("✅ Data received from server");

    const isValid = fStoreAndValidateData(data);
    if (!isValid) return;

    fSetupTooltipAndModal(); // Grabs DOM refs and assigns to gUI

    fRenderFullGrid(() => { // Callback runs after initial render pass
        fRunPostRenderFormatting(); // Applies merges, borders, listeners etc.
    });
};


// fStoreAndValidateData ////////////////////////////////////////////////////////////////////////////
// Validates incoming data and updates gUI; returns true if valid, false if not.
function fStoreAndValidateData(data) {
    if (!data || typeof data !== 'object' || !data.arr || !data.format || !data.notesArr || data.error || data instanceof Error) {
        console.error("Error or invalid data received:", data);
        fMyConsoleLog("❌ Error or invalid data structure received.");
        return false;
    }

    gUI.arr = data.arr;
    gUI.format = data.format;
    gUI.notes = data.notesArr || [];

    if (gUI.arr.length === 0 || !gUI.arr[0] || gUI.arr[0].length === 0) {
        fMyConsoleLog("⚠️ Data array received is empty.");
        gUI.notes = [];
        return false;
    }

    const container = document.getElementById('grid');
    if (!container) {
        console.error("❌ Grid container #grid not found!");
        return false;
    }

    container.innerHTML = '';
    return true;
};




// fSetupTooltipAndModal ////////////////////////////////////////////////////////////////////////////
// Grabs DOM references for tooltip and modal elements and assigns them to gUI properties; logs if missing.
function fSetupTooltipAndModal() {
    gUI.tooltipElement = document.getElementById('cell-tooltip'); // Updated reference
    if (!gUI.tooltipElement) { // Updated reference
        fMyConsoleLog("⚠️ Tooltip element missing...");
    }

    gUI.modalElement = document.getElementById('image-modal');        // Updated reference
    gUI.modalImageElement = document.getElementById('modal-image');   // Updated reference
    gUI.modalCloseBtn = document.getElementById('modal-close-btn');   // Updated reference
    gUI.modalBackdrop = document.getElementById('modal-backdrop');    // Updated reference

    if (!fModalElementsAvailable()) { // Checks the gUI properties now
        console.error("❌ One or more modal elements not found in DOM!");
        fMyConsoleLog("⚠️ Modal elements missing, image preview disabled.");
        // No need to nullify gUI properties here, just check before use
    }
};




// fModalElementsAvailable //////////////////////////////////////////////////////////////////////////
// Checks if all modal elements are found within the gUI object.
function fModalElementsAvailable() {
    return gUI.modalElement && gUI.modalImageElement && gUI.modalCloseBtn && gUI.modalBackdrop; // Updated references
};




// fAttachGridListeners ////////////////////////////////////////////////////////////////////////////
// Attaches click, edit, and hover listeners to grid if found.
function fAttachGridListeners(gridElement) {
    if (!gridElement) {
        console.error("❌ Could not find grid element to attach listeners.");
        fMyConsoleLog("❌ Failed to attach grid event listeners.");
        return;
    }

    fSetupGridClickListeners(gridElement);
    gridElement.addEventListener('blur', fHandleGridCellEdit, true); // Use capture phase for blur
    if (gUI.tooltipElement) { // Check if tooltip exists before adding its listeners // Updated reference
        fSetupGridHoverListeners(gridElement);
    }
};




// scripts.html //


// fRunPostRenderFormatting ////////////////////////////////////////////////////////////////////////
// Runs all post-render visual adjustments, formatting, and listener hookups.
function fRunPostRenderFormatting() {
    fMyConsoleLog("🚀 Applying Post-Render Formatting...");
    fApplyDynamicMerges();
    fAddHeaderButtons();
    fApplyManualBorders();
    fApplyInitialVisibility();
    fApplyManualColoring(); 
    fSetHeader(); 

    // --- Apply Dropdowns AFTER merges/visibility might hide cells ---
    fApplyDropdownsToGrid(); // <<< ADDED CALL HERE

    // --- These should generally run last ---
    fMarkOverflowingCells(); // Check overflow after layout changes 
    fClearSk1Sk2Checkboxes(); // Reset checkboxes if needed 

    const gridElement = document.getElementById('grid');
    fAttachGridListeners(gridElement); // Attach delegated listeners

    if (fModalElementsAvailable()) { // Check gUI properties 
        fSetupModalListeners(); 
    }

    fMyConsoleLog("✅ All Post-Render Formatting Done!");
}; // END fRunPostRenderFormatting




////////////////////////////////////////////////////////////////////////////////////////////////////////// END fOnDataLoaded and helpers



// fLoadGameSheet //////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Starts the process: Calls GAS backend (fCSGetGameSheet5) to get sheet data.
// From current scripts.html (includes failure handler)
function fLoadGameSheet() {
    gUI.startTime = performance.now(); // Reset global start time // Updated reference
    gUI.lastLogTime = gUI.startTime; // Updated reference
    fMyConsoleLog("🚀 Requesting GSheet Data...");
    console.log("Sheet ID:", SHEET_ID); // Use the global SHEET_ID injected in index.html

    if (!SHEET_ID) {
        const errorMsg = "❌ No Sheet ID found. Cannot load data.";
        console.error(errorMsg);
        fMyConsoleLog(errorMsg);
        const gridDiv = document.getElementById('grid');
        if (gridDiv) gridDiv.innerHTML = `<p style="color:red;">${errorMsg} Check URL parameter.</p>`;
        return;
    }

    google.script.run
        .withSuccessHandler(fOnDataLoaded) // Handles both success and thrown errors from server
        .withFailureHandler(error => { // Handles transport errors or totally unhandled server exceptions
            const errorMsg = `❌ Failed to call server: ${error.message}`;
            console.error(errorMsg, error);
            fMyConsoleLog(errorMsg);
            const gridDiv = document.getElementById('grid');
            if(gridDiv) gridDiv.innerHTML = `<p style="color:red;">${errorMsg}</p>`;
        })
        .fCSGetGameSheet5(SHEET_ID); // Call the server-side function in Turbo.gs
}; // END fLoadGameSheet




// ==========================================================================
// === Entry Point                 (End of Initial Data Load) ===
// ==========================================================================




// DOMContentLoaded Hook //////////////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Starts the UI logic and listeners once the page DOM is ready
window.addEventListener("DOMContentLoaded", () => {
    fLoadGameSheet(); 
    fSetupMenuInteractivity();
    fSetupMessageModalListeners();
    fSetupPromptModalListeners(); 
});




</script>