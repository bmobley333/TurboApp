<!-- gamelogic.html -->


<script>



// ==========================================================================
// === Die Roll Button         (End of N/A) ===
// ==========================================================================




// fHandleRollDiceAction /////////////////////////////////////////////////////////////////////////
// Purpose -> Top-level handler for "Roll Dice" action. Populates gUI.roll, validates inputs,
//            runs morph/roll/resolution logic, and posts result.
// Inputs  -> None (uses gUI.currentSkRadioChecked).
// Outputs -> None (updates gUI and DOM).
async function fHandleRollDiceAction() {
    fMyConsoleLog("üé≤ Roll Dice Action Triggered");

    const { r, c } = gUI.currentSkRadioChecked;
    // Validate target is a valid Sk1/Sk2 checkbox
    if (!await fValidateAbilityCB(r, c)) return; // Early exit if invalid target

    // Populate gUI.roll from sheet and clean it
    if (!await fResetPopulateNCleanGUIRoll(r, c)) return; // Early exit if population fails

    // Confirm ability has valid name and type
    if (!await fVerifyAbility()) return; // Early exit if ability invalid

    // Process morphs (can potentially show messages, but doesn't typically halt flow)
    await fProcessMorph();

    // *** CHECK THE RESULT of the verification function ***
    const costsOk = await fVerifyNSetActMetaLuckUsesOnEtc();
    if (!costsOk) {
        fMyConsoleLog("üö¶ Halting Roll Dice Action due to cost verification failure or cancellation.");
        return; // *** EXIT HERE if costs not met/verified ***
    }

    // --- Costs OK, proceed with calculations and logging ---
    fCalcGUIRollResSk();
    fCalcGUIRollRoll();
    fCalcGUIRollResRoll();
    fCalcRollLogPrepend();

    fMyConsoleLog("‚úÖ Roll Dice Action Completed"); // Optional: Log completion

} // END fHandleRollDiceAction




// fAppendToHTMLHeader /////////////////////////////////////////////////////////////
// Purpose -> Appends a new line (with <br> separator for next newHeader or Title section) to the gUI.roll.htmlHeader string.
// Inputs  -> newHeader (String): The string to append.
// Outputs -> None (modifies gUI.roll.htmlHeader).
function fAppendToHTMLHeader(newHeader) {
        gUI.roll.htmlHeader += `${newHeader}<br>`;
} // END fAppendToHTMLHeader





// fValidateAbilityCB /////////////////////////////////////////////////////////////////////////
// Purpose -> Confirms that (row, col) is a valid Sk1/Sk2 checkbox based on gUI.sk1sk2CheckBoxes.
// Inputs  -> row (Number), col (Number): 0-based indices.
// Outputs -> (Boolean): true if valid, false otherwise.
// MODIFIED: Made async to await fShowMessage
async function fValidateAbilityCB(row, col) {
    const isValid = fIsSkRadioGroupMember(row, col);
    if (!isValid) {
        await fShowMessage("‚ö†Ô∏è Please select a valid Ability checkbox first!");
    }
    return isValid;
} // END fValidateAbilityCB




// fResetPopulateNCleanGUIRoll //////////////////////////////////////////////////////////////////
// Purpose -> Extracts and cleans ability row data into gUI.roll based on Sk1 or Sk2 checkbox.
// Inputs  -> r (Number), c (Number): Row and column from selected radio.
// Outputs -> (Boolean): true if success, false if extraction/cleaning fails.
async function fResetPopulateNCleanGUIRoll(r, c) {
    try {
        const getVal = tag => gUI.arr[r]?.[resolveCol(tag)] ?? '';
        const isSk1 = (c === resolveCol('Sk1ChkBox'));

        // --- Initial Population ---
        gUI.roll = {
            ability_R: r,
            sk1CB: isSk1,
            skMorph: isSk1 ? getVal('Morph1') : getVal('Morph2'),
            skTyp: isSk1 ? getVal('Sk1Typ') : getVal('Sk2Typ'),
            skSk: isSk1 ? getVal('Sk1') : getVal('Sk2'),
            skIsOn: getVal('On'),
            skNameID: getVal('Ability'),
            skName: '',
            skAct: isSk1 ? getVal('Act') : '',
            skDur: isSk1 ? getVal('Dur') : '',
            skMeta: isSk1 ? getVal('Meta') : '',
            skUses: isSk1 ? getVal('Uses') : '',
            resTyp: '',
            resSk: '',
            resFlatBase: '',
            resFlatResult: '',
            resDif: '',
            resFocus: '',
            resPlus: '',
            resPlusPlus: '',
            resdctMult: '',
            resMult: '',
            resMultMult: '',
            resCombine: '',
            isUnSk: false,
            roll: '',
            resRoll: '',
            htmlHeader: ''
         };
        const rData = gUI.roll;
        // --- Clean string fields ---
        rData.skName = String(rData.skNameID || '').replace(/\s{2,}_\w{6}$/, '').trim();
        rData.skMorph = String(rData.skMorph || '').trim().replace(/^,+/, '');
        rData.skTyp = String(rData.skTyp || '').trim();
        rData.skIsOn = String(rData.skIsOn || '').trim();
        rData.skDur = String(rData.skDur || '').trim();
        rData.skMeta = String(rData.skMeta || '').trim();
        // --- Clean numeric fields ---
        const sk = parseInt(rData.skSk, 10);
        rData.skSk = (!isNaN(sk) && sk >= 1) ? sk : '';

        const act = parseInt(String(rData.skAct || '').trim(), 10);
        rData.skAct = (!isNaN(act) && act >= 1) ? act : '';

        const uses = parseInt(rData.skUses, 10);
        rData.skUses = !isNaN(uses) ? uses : ''; // Allow any valid number (including negatives)
        // --- Default resTyp to skTyp ---
        rData.resTyp = rData.skTyp;
        // --- Final status log ---
        fMyConsoleLog(`‚öôÔ∏è Populated & Cleaned gUI.roll for row ${r} (isSk1: ${isSk1})`);
        return true;

    } catch (err) {
        // --- Error Handling ---
        console.error("‚ùå Error populating/cleaning gUI.roll:", err);
        fPrependToSidebar(`‚ùå Error processing skill data: ${err.message}`);
        fShowSidebar();
        return false;
    }
} // END fResetPopulateNCleanGUIRoll



// fVerifyAbility /////////////////////////////////////////////////////////////////////////
// Purpose -> Validates current gUI.roll by checking name and skill type.
// Inputs  -> None (uses gUI.roll and gUI.list).
// Outputs -> (Boolean): true if ability is valid, false otherwise.
// MODIFIED: Made async to await fShowMessage
async function fVerifyAbility() {
    const { skName, skTyp, sk1CB } = gUI.roll;
    // --- Check: Ability name must exist ---
    if (!skName) {
        await fShowMessage("‚ö†Ô∏è Please select an Ability with a name!");
        return false;
    }

    // --- Check: Skill Typ must be a string ---
    if (!skTyp || typeof skTyp !== 'string') {
        const is2ndCol = !sk1CB;
        await fShowMessage(`‚ö†Ô∏è No skill Typ found${is2ndCol ? '<br><br>You may have wanted the 1st column.' : ''}`);
        return false;
    }

    // --- Check: Skill type must match known types (case-insensitive) ---
    const skTypLower = skTyp.trim().toLowerCase();
    const isValidSkTyp = gUI.list.skTyp.some(type => type.toLowerCase() === skTypLower);
    if (!isValidSkTyp) {
        await fShowMessage(`‚ö†Ô∏è ${skTyp} is an invalid Skill Type!`);
        return false;
    }

    // --- Passed all checks ---
    return true;
} // END fVerifyAbility



// fProcessMorph /////////////////////////////////////////////////////////////////////////////////////////
// Purpose -> Processes gUI.roll.skMorph string to extract modifiers and flags into res* fields.
// Inputs  -> None (reads gUI.roll.skMorph, gUI.roll.skSk, gUI.list).
// Outputs -> None (updates gUI.roll directly).
async function fProcessMorph() {
    const skMorph = gUI.roll.skMorph || '';
    if (!skMorph) {
        fMyConsoleLog("‚ÑπÔ∏è No skMorph string to process.");
        return;
    }

    // Split morph string and compile lowercased version
    const morphComponents = skMorph.split(',').map(x => x.trim()).filter(Boolean);
    const morphLower = morphComponents.map(x => x.toLowerCase());

    // Accumulator object for temp results
    const acc = {
        foundResTyp: false,
        lastResTypMatch: '',
        lastFocusIndex: -1,
        foundResPlus: false,
        totalPlus: 0,
        combineNumbers: [],
        foundResPlusPlus: false,
        totalPlusPlus: 0,
        foundResMult: false,
        totalMult: 1.0,
        foundResMultMult: false,
        totalMultMult: 1.0,
        lastFlatBaseMatch: '',
        lastFlatResultMatch: '',
        lastDifMatch: '',
        foundResdctMult: false,
        totalResdctMult: 1.0
    };
    // Await the parsing function which now handles async messages
    await fParseMorphComponents(morphComponents, morphLower, acc);

    fApplyMorphResults(acc);
    fMyConsoleLog("‚öôÔ∏è Processed skMorph string.");
} // END fProcessMorph




// fParseMorphComponents ////////////////////////////////////////////////////////////////////////////////
// Purpose -> Parses each morph component and mutates gUI.roll and acc accordingly.
// MODIFIED: Made async, changed forEach to for...of, added await to fShowMessage, added DCT logic
async function fParseMorphComponents(morphComponents, morphLower, acc) {
    const plusMinusRegex = /^([-+])(\d+)$/;
    const numberOnlyRegex = /^\d+$/;
    const plusPlusMinusMinusRegex = /^(?:(\+\+)|(--))(\d+)$/;
    const multDivRegex = /^([*\/])(\d+(\.\d+)?)$/;
    const multMultDivDivRegex = /^(?:(\*\*)|(\/\/))(\d+(\.\d+)?)$/;
    const equalsRegex = /^=(\d+)$/;
    const equalsEqualsRegex = /^==(\d+)$/;
    const caretRegex = /^\^(\d+)$/;
    const dctRegex = /^([-+])(\d+)([dct])$/i; // <<< ADDED: Case-insensitive

    // Use for...of loop instead of forEach to allow await
    let index = 0; // Manual index tracking needed for morphLower
    for (const component of morphComponents) {

        const lower = morphLower[index];
        // --- isUnSk Check
        if (lower === 'un' || lower === 'unsk') gUI.roll.isUnSk = true;
        // --- resTyp Check (find LAST match)
        if (gUI.list.skTyp.some(t => t.toLowerCase() === lower)) {
            acc.lastResTypMatch = component;
            acc.foundResTyp = true;
        }

        // --- resFocus Check (find index of LAST match)
        const focusIndex = gUI.list.metaColor.indexOf(lower);
        if (focusIndex > -1) acc.lastFocusIndex = focusIndex;

        // --- resPlus Check
        const plusMatch = component.match(plusMinusRegex);
        if (plusMatch) {
            const val = parseInt(plusMatch[2], 10);
            acc.totalPlus += (plusMatch[1] === '+' ? val : -val);
            acc.foundResPlus = true;
        }

        // --- resCombine Check (collect numbers)
        if (numberOnlyRegex.test(component)) acc.combineNumbers.push(parseInt(component, 10));
        // --- resPlusPlus Check
        const ppMatch = component.match(plusPlusMinusMinusRegex);
        if (ppMatch) {
            const val = parseInt(ppMatch[3], 10);
            acc.totalPlusPlus += (ppMatch[1] === '++' ? val : -val);
            acc.foundResPlusPlus = true;
        }

        // --- resMult Check
        const m1 = component.match(multDivRegex);
        if (m1) {
            const val = parseFloat(m1[2]);
            if (m1[1] === '*') {
                 acc.totalMult *= val;
            } else if (val !== 0) {
                 acc.totalMult /= val;
            } else {
                // Use await here
                await fShowMessage("‚ùå Morph includes illegal '/0'. Please correct and try again.");
                console.warn("resMult divide by zero:", component);
                // Consider adding 'return;' or 'throw new Error(...);' here if this error should halt processing
            }
            acc.foundResMult = true;
        }

        // --- resMultMult Check
        const m2 = component.match(multMultDivDivRegex);
        if (m2) {
            const val = parseFloat(m2[3]);
            if (m2[1] === '**') {
                acc.totalMultMult *= val;
            } else if (val !== 0) {
                acc.totalMultMult /= val;
            } else {
                // Use await here
                await fShowMessage("‚ùå Morph includes illegal '//0'. Please correct and try again.");
                console.warn("resMultMult divide by zero:", component);
                // Consider adding 'return;' or 'throw new Error(...);' here if this error should halt processing
            }
            acc.foundResMultMult = true;
        }

        // --- resdctMult Check
        const dctMatch = component.match(dctRegex);
        if (dctMatch) {
            const sign = dctMatch[1];
            const num = parseInt(dctMatch[2], 10);
            const type = dctMatch[3].toLowerCase();
            let multiplier = 1.0;
            if (num !== 0) { // Ignore if number is 0
                const isPositive = (sign === '+');
                switch (type) {
                    case 'c':
                        const critFactor = 2 * num;
                        if (critFactor === 0) { // Avoid division by zero
                            console.warn("DCT Morph resulted in divide by zero (critFactor):", component);
                            multiplier = 1; // Or handle as error
                        } else {
                             multiplier = isPositive ? critFactor : (1 / critFactor);
                        }
                        break;
                    case 't':
                        // 10^0 is 1, so 1/1 is 1. Handle large numbers if needed.
                        const tremFactor = Math.pow(10, num);
                        multiplier = isPositive ? tremFactor : (1 / tremFactor);
                        break;
                    case 'd':
                        const dTierTerm = (1 + (num / 3));
                        if (dTierTerm === 0) { // Avoid division by zero
                             console.warn("DCT Morph resulted in divide by zero (dTierTerm):", component);
                             multiplier = 1;  // Or handle as error
                         } else {
                              multiplier = isPositive ? dTierTerm : (1 / dTierTerm);
                         }
                        break;
                }

                 // Additional check for invalid multipliers (NaN, Infinity) before applying
                 if (!isNaN(multiplier) && isFinite(multiplier) && multiplier > 0) {
                     // Apply the multiplier cumulatively
                     acc.totalResdctMult *= multiplier;
                     acc.foundResdctMult = true;
                 } else {
                      console.warn(`Invalid DCT multiplier calculated for "${component}": ${multiplier}. Skipping this morph.`);
                     // Optional await fShowMessage(`‚ö†Ô∏è Invalid result for morph "${component}". Check value.`);
                 }
            }
        }
        // --- End resdctMult Check ---

        // --- resFlatBase Check (find LAST match)
        const eq1 = component.match(equalsRegex);
        if (eq1) acc.lastFlatBaseMatch = eq1[1];

        // 10. resFlatResult Check (find LAST match)
        const eq2 = component.match(equalsEqualsRegex);
        if (eq2) acc.lastFlatResultMatch = eq2[1];

        // --- resDif Check (find LAST match)
        const dif = component.match(caretRegex);
        if (dif) acc.lastDifMatch = dif[1];

        index++; // Increment manual index
    } // <<< End of for...of loop
} // END fParseMorphComponents




// fApplyMorphResults ////////////////////////////////////////////////////////////////////////////////
// Purpose -> Applies accumulated morph data to gUI.roll.
function fApplyMorphResults(acc) {
    const r = gUI.roll;
    // MUST BE FIRST: Assign resFlatBase (also sets skSk)
    if (acc.lastFlatBaseMatch !== '') {
        const num = parseInt(acc.lastFlatBaseMatch, 10);
        if (!isNaN(num)) {
            r.resFlatBase = num;
            r.skSk = num;
        }
    }

    // Assign resTyp (last match found else gUI.roll.skTyp)
    if (acc.foundResTyp) {
        r.resTyp = acc.lastResTypMatch || r.skTyp;
    }

    // Assign resFocus (index of last match found)
    if (acc.lastFocusIndex > -1) {
        r.resFocus = acc.lastFocusIndex;
    }

    // Assign resPlus
    if (acc.foundResPlus) {
        r.resPlus = acc.totalPlus;
    }

    // Assign resCombine
    if (typeof r.skSk === 'number' && r.skSk >= 1) { // Ensure skSk is a valid number before adding
        acc.combineNumbers.push(r.skSk);
    }
    if (acc.combineNumbers.length > 0) {
        acc.combineNumbers.sort((a, b) => b - a);
        let value = 0, divisor = 1;
        for (const num of acc.combineNumbers) {
            value += num / divisor;
            divisor *= 2;
        }
        r.resCombine = Math.round(value);
    }

    // Assign resPlusPlus
    if (acc.foundResPlusPlus) {
        r.resPlusPlus = acc.totalPlusPlus;
    }

    // Assign resMult
    if (acc.foundResMult) {
        r.resMult = Number(acc.totalMult.toFixed(6)); // Use more precision if needed
    }

    // Assign resMultMult
    if (acc.foundResMultMult) {
        r.resMultMult = Number(acc.totalMultMult.toFixed(6)); // Use more precision if needed
    }

    // Assign resdctMult
    if (acc.foundResdctMult) {
        // Rounding dct to 6 decimal places, adjust if needed
        r.resdctMult = Number(acc.totalResdctMult.toFixed(6));
    }

    // Assign resFlatResult (convert last match to integer)
    if (acc.lastFlatResultMatch !== '') {
        const num = parseInt(acc.lastFlatResultMatch, 10);
        if (!isNaN(num)) r.resFlatResult = num;
    }

    // Assign resDif (convert last match to integer)
    if (acc.lastDifMatch !== '') {
        const num = parseInt(acc.lastDifMatch, 10);
        if (!isNaN(num)) r.resDif = num;
    }
} // END fApplyMorphResults





// fVerifyNSetActMetaLuckUsesOnEtc ///////////////////////////////////////////////////////////
// Purpose -> Verify ability costs (Act, Meta, Luck, Uses) and process 'IsOn' state.
//            Prompts user if insufficient Action Points. Halts if insufficient Meta/Luck/Uses.
//            Applies *all* decrements/changes *only* after *all* checks pass or are overridden.
// Inputs  -> None (uses gUI.roll and grid helpers).
// Outputs -> (Promise<Boolean>): Resolves true if costs are met/overridden and applied,
//                                resolves false if cancelled by user or insufficient resources.
async function fVerifyNSetActMetaLuckUsesOnEtc() {
    fMyConsoleLog("üõ°Ô∏è Verifying Costs & Processing 'Is On'..."); // Updated log
    const pendingChanges = []; // Array to hold { r, c, value } objects
    const pendingHeaders = []; // Array to hold strings for fAppendToHTMLHeader

    // --- 1. Action Points (Act) ---
    const actResult = await fAct_VerifyAndProcessCost();
    if (!actResult.success) return false; // Halt if Act cost failed or was cancelled
    pendingChanges.push(...actResult.changes); // Add changes from Act
    pendingHeaders.push(...actResult.headers); // Add headers from Act

    // --- 2. Uses ---
    const usesResult = await fUses_VerifyAndProcessCost();
    if (!usesResult.success) return false; // Halt if Uses cost failed or was cancelled
    pendingChanges.push(...usesResult.changes); // Add changes from Uses
    pendingHeaders.push(...usesResult.headers); // Add headers from Uses

    // --- 3. Is On (Copy Duration) --- <<< UPDATED SECTION
    const isOnResult = await fIsOn_VerifyAndProcessCost();
    // This function currently always returns success: true, so no check needed, but keep pattern
    // if (!isOnResult.success) return false; // If verification is added later
    pendingChanges.push(...isOnResult.changes); // Add changes from IsOn
    pendingHeaders.push(...isOnResult.headers); // Add headers from IsOn (currently none)

    // --- Placeholder sections for other costs ---
    // @@ Add Meta check logic call here -> const metaResult = await fMeta_VerifyAndProcessCost();
    // if (!metaResult.success) return false;
    // pendingChanges.push(...metaResult.changes);
    // pendingHeaders.push(...metaResult.headers);

    // @@ Add Luck check logic call here -> const luckResult = await fLuck_VerifyAndProcessCost();
    // if (!luckResult.success) return false;
    // pendingChanges.push(...luckResult.changes);
    // pendingHeaders.push(...luckResult.headers);

    // --- If all checks passed or were overridden, apply all changes ---
    fMyConsoleLog("‚úÖ All Verifications Passed. Applying Changes...");

    // Apply pending header messages
    pendingHeaders.forEach(header => fAppendToHTMLHeader(header));

    // Apply pending grid changes
    let applyErrors = false;
    pendingChanges.forEach(change => {
        if (!fSetGridValue(change.r, change.c, change.value)) {
             applyErrors = true;
             // fSetGridValue already logs errors
        }
    });
    if (applyErrors) {
        fMyConsoleLog("‚ùå Errors occurred while applying cost/state changes to the grid.");
        await fShowMessage("Error applying some cost/state changes. Please check grid state.");
        return false; // Consider if partial success is acceptable or if this should be false
    }

    fMyConsoleLog("‚úÖ Costs Verified & Changes Applied Successfully.");
    return true; // Signal success

} // END fVerifyNSetActMetaLuckUsesOnEtc





// fAct_VerifyAndProcessCost /////////////////////////////////////////////////////////
// Purpose -> Helper for fVerifyNSetActMetaLuckUsesOnEtc: Checks Action Point cost.
//            Prompts user if insufficient. Calculates changes but does NOT apply them.
// Inputs  -> None (reads gUI.roll.skAct, gUI.roll.skName, and uses grid helpers).
// Outputs -> (Promise<Object>): { success: Boolean, changes: Array, headers: Array }
//            'changes' contains { r, c, value } objects for grid updates.
//            'headers' contains strings for sidebar messages.
async function fAct_VerifyAndProcessCost() {
    const { skAct, skName } = gUI.roll;
    const actCost = Number(skAct);
    const changes = []; // Initialize empty array for pending changes
    const headers = []; // Initialize empty array for pending headers

    // Only process if there is an actual Action Point cost
    if (actCost > 0) {
        // Get current Action Points total
        let currentAct = fGetGridValue('Act', 'ActTot', true);

        // Check if reading the value failed (returns NaN)
        if (isNaN(currentAct)) {
            await fShowMessage(`‚ùå Error reading current Action Points from cell ('Act', 'ActTot'). Cannot proceed.`);
            fMyConsoleLog("üö´ Failed to verify Act cost: Could not read Action Points.");
            return { success: false, changes: [], headers: [] }; // Return failure
        }

        // Check if cost exceeds current points
        if (actCost > currentAct) {
            fMyConsoleLog(`‚ö†Ô∏è Insufficient Action Points (Need ${actCost}, Have ${currentAct})`);
            // Prompt user if they want to proceed (go negative)
            const proceed = await fShowPrompt(`Not Enough Action Points (${currentAct}) to use '${skName}' (Cost: ${actCost})<br><br>Do you want to go negative?`);
            if (!proceed) {
                fMyConsoleLog("üö´ User cancelled Act cost due to insufficient points.");
                return { success: false, changes: [], headers: [] }; // User chose No
            }
            // User chose Yes, log it and add header note
            fMyConsoleLog("‚úÖ User chose to proceed despite insufficient Action Points.");
            headers.push(`‚ö†Ô∏è NEGATIVE ACT POINTS: ${currentAct - actCost}`); // Add header to pending list
        }

        // Calculate the new Action Points total
        const newActTotal = currentAct - actCost;
        // Add the intended change to the pending list
        changes.push({ r: 'Act', c: 'ActTot', value: newActTotal });
        fMyConsoleLog(`   -> Action Points: ${currentAct} -> ${newActTotal} (Pending)`);
    } else {
        // No action cost, trivially succeed this check
        fMyConsoleLog("   -> No Action Point cost for this ability.");
    }

    // If we reached here, the cost was 0, met, or overridden successfully. Return success and pending changes/headers.
    return { success: true, changes: changes, headers: headers };
} // END fAct_VerifyAndProcessCost




// fUses_VerifyAndProcessCost ////////////////////////////////////////////////////////
// Purpose -> Helper for fVerifyNSetActMetaLuckUsesOnEtc: Checks Uses cost.
//            Prompts user if insufficient. Calculates changes but does NOT apply them.
// Inputs  -> None (reads gUI.roll.skUses, gUI.roll.skName, gUI.roll.ability_R and uses grid helpers).
// Outputs -> (Promise<Object>): { success: Boolean, changes: Array, headers: Array }
//            'changes' contains { r, c, value } objects for grid updates.
//            'headers' contains strings for sidebar messages.
async function fUses_VerifyAndProcessCost() {
    const { skUses, skName, ability_R } = gUI.roll;
    const changes = []; // Initialize empty array for pending changes
    const headers = []; // Initialize empty array for pending headers

    // Check if skUses exists and is a valid number
    const usesCost = 1; // cost per use is always 1
    const currentUses = Number(skUses);

    if (skUses === '' || isNaN(currentUses)) {
        // If skUses is empty string, null, undefined, or NaN, assume no 'Uses' cost applies.
        fMyConsoleLog("   -> No 'Uses' cost defined for this ability.");
        return { success: true, changes: [], headers: [] }; // Pass the check if no uses are defined
    }

    // Calculate the new value after decrementing
    const newUses = currentUses - usesCost;

    // Check if uses are already depleted or will be depleted
    if (currentUses <= 0) {
        fMyConsoleLog(`‚ö†Ô∏è Insufficient Uses Left (Have ${currentUses})`);
        // Prompt user if they want to proceed (go negative)
        const proceed = await fShowPrompt(`Not Enough Uses Left (${currentUses}) to use '${skName}' (Cost: ${usesCost})<br><br>Do you want to go negative?`);
        if (!proceed) {
            fMyConsoleLog("üö´ User cancelled Uses cost due to insufficient points.");
            return { success: false, changes: [], headers: [] }; // User chose No
        }
        // User chose Yes, log it and add header note if needed
        fMyConsoleLog("‚úÖ User chose to proceed despite insufficient Uses.");
        headers.push(`‚ö†Ô∏è NEGATIVE USES: ${newUses}`); // Add header to pending list
    }

    // Add the intended change to the pending list
    // Use gUI.roll.ability_R (the original row index) for the row reference
    changes.push({ r: ability_R, c: 'Uses', value: newUses });
    fMyConsoleLog(`   -> Uses: ${currentUses} -> ${newUses} (Pending)`);

    // If we reached here, the cost was met or overridden successfully. Return success and pending changes/headers.
    return { success: true, changes: changes, headers: headers };
} // END fUses_VerifyAndProcessCost






// fIsOn_VerifyAndProcessCost ////////////////////////////////////////////////////////
// Purpose -> Helper for fVerifyNSetActMetaLuckUsesOnEtc: Prepares to copy Duration to Is On
//            *if* the roll originated from the Sk1 checkbox (gUI.roll.sk1CB === true).
//            There is no other verification, just prepares the change object conditionally.
// Inputs  -> None (reads gUI.roll.sk1CB, gUI.roll.skDur, gUI.roll.ability_R).
// Outputs -> (Promise<Object>): { success: Boolean, changes: Array, headers: Array }
//            'changes' contains { r, c, value } objects for grid updates if condition met.
//            'headers' is always empty for this function.
// NOTE: Made async for consistency with other helpers, though not strictly required now.
async function fIsOn_VerifyAndProcessCost() {
    const { skDur, ability_R, sk1CB } = gUI.roll; // Destructure sk1CB
    const changes = []; // Initialize empty array for pending changes
    const headers = []; // Always empty for this function

    // --- Add conditional check for sk1CB ---
    if (sk1CB === true) {
        // Condition met: Prepare the change object to copy skDur to the 'On' column
        // skDur is already cleaned in fResetPopulateNCleanGUIRoll
        changes.push({ r: ability_R, c: 'On', value: skDur });
        fMyConsoleLog(`   -> Is On: Set to Dur value '${skDur}' (Pending, Sk1 condition met)`);
    } else {
        // Condition not met: Do nothing, just log
        fMyConsoleLog(`   -> Is On: No change (Condition sk1CB === true not met)`);
    }
    // --- End conditional check ---

    // This function always succeeds as there's no verification step beyond the condition
    return { success: true, changes: changes, headers: headers };
} // END fIsOn_VerifyAndProcessCost





// fCalcGUIRollResSk /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Calculates final resulting skill value (gUI.roll.resSk) using morph-derived modifiers.
// Inputs  -> None (reads from gUI.roll).
// Outputs -> None (writes gUI.roll.resSk).
function fCalcGUIRollResSk() {
    let currentResSk;

    // Use resCombine if it's a valid number; fallback to skSk if needed
    if (typeof gUI.roll.resCombine === 'number') {
        currentResSk = gUI.roll.resCombine;
        fMyConsoleLog("   -> Using resCombine as base for resSk calculation.");
    } else if (typeof gUI.roll.skSk === 'number') {
        currentResSk = gUI.roll.skSk;
    } else {
        currentResSk = NaN;
    }

    // --- Modifier Application Pipeline ---
    // Only proceed if we have a valid numeric base
    if (!isNaN(currentResSk)) {

        // Apply resMult (multiplicative)
        if (typeof gUI.roll.resMult === 'number' && gUI.roll.resMult !== '') {
            currentResSk *= gUI.roll.resMult;
        }

        // Apply resdctMult (multiplicative)
        if (typeof gUI.roll.resdctMult === 'number' && gUI.roll.resdctMult !== '') {
             currentResSk *= gUI.roll.resdctMult;
        }

        // Apply resPlus (additive)
        if (typeof gUI.roll.resPlus === 'number' && gUI.roll.resPlus !== '') {
            currentResSk += gUI.roll.resPlus;
        }

        // Apply resFocus (focus index adds 5 * (1 + index))
        if (typeof gUI.roll.resFocus === 'number' && gUI.roll.resFocus >= 0) {
            currentResSk += 5 * (1 + gUI.roll.resFocus);
        }


        // Apply isUnSk (cut in half) AFTER all multipliers and additions
        if (gUI.roll.isUnSk === true) {
            currentResSk *= 0.5;
        }

        // --- Final Adjustment: Clamp Tiny Positive Values ---
        // Only clamp if it's positive but less than 1
        if (currentResSk > 0 && currentResSk < 1) {
            currentResSk = 1;
        }

        // --- Diagnostic Output ---
        // console.log(`DEBUG fCalcGUIRollResSk: Value before final check/assignment:`, currentResSk);
        // --- Final Assignment: Round valid positive results, else empty ---
        // Ensure result is a number and >= 1 after all calculations
        if (!isNaN(currentResSk) && currentResSk >= 1) {
            gUI.roll.resSk = Math.round(currentResSk);
        } else {
            gUI.roll.resSk = ''; // Set to empty if result is NaN, less than 1, etc.
        }
    } else {
        // Invalid input or no valid base found, leave resSk empty
        gUI.roll.resSk = '';
    }

    fMyConsoleLog(`‚öôÔ∏è Calculated final resSk: ${gUI.roll.resSk}`);
} // END fCalcGUIRollResSk




// fCalcGUIRollRoll /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Determines dice roll result (gUI.roll.roll) based on resSk and resTyp.
// Inputs  -> None (reads gUI.roll.resSk, gUI.roll.resTyp).
// Outputs -> None (writes gUI.roll.roll).
function fCalcGUIRollRoll() {
    const resSkValue = gUI.roll.resSk;
    const resTypValue = (typeof gUI.roll.resTyp === 'string') ? gUI.roll.resTyp.trim().toLowerCase() : '';
    // --- Validate resSk (must be a number >= 1) ---
    if (typeof resSkValue !== 'number' || resSkValue < 1) {
        gUI.roll.roll = '';
        fMyConsoleLog(`‚ÑπÔ∏è Cannot calculate roll: Invalid resSk value (${resSkValue}).`);
        return;
    }


    // --- Determine roll function based on resTyp ---
    switch (resTypValue) {


        // No type ‚Üí skip rolling
        case '': gUI.roll.roll = ''; break;


        // Skill or Attribute or Str roll
        case 'sk':
        case 'atr':
        case 'str': gUI.roll.roll = fCSDSk(resSkValue); break;


        // Attack roll
        case 'atk': gUI.roll.roll = fCSAtk(resSkValue); break;
        // Damage roll
        case 'dmg': gUI.roll.roll = fCSDDmg(resSkValue); break;
        // Defense roll
        case 'def': gUI.roll.roll = fCSDef(resSkValue); break;
        // Armor roll (may return decimal)
        case 'ar': gUI.roll.roll = fCSDArmor(resSkValue); break;
        // Unexpected usage of 'unsk' as final roll type
        case 'un':
        case 'unsk':
            console.warn(`fCalcGUIRollRoll: Roll type '${resTypValue}' used directly. Consider adjusting morph.`);
            gUI.roll.roll = fCSDSk(resSkValue);
            break;


        // Unknown roll type
        default:
            console.warn(`fCalcGUIRollRoll: Unknown resTyp '${resTypValue}'. Cannot calculate roll.`);
            gUI.roll.roll = '';
            break;
    }


    // --- Final Logging ---
    fMyConsoleLog(`‚öôÔ∏è Calculated roll (${resTypValue}): ${gUI.roll.roll}`);
} // END fCalcGUIRollRoll



// fCalcGUIRollResRoll /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Calculates final gUI.roll.resRoll using overrides or morph-based modifiers.
// Inputs  -> None (reads gUI.roll).
// Outputs -> None (writes gUI.roll.resRoll).
function fCalcGUIRollResRoll() {

    // --- Check for Flat Result Override ---
    // Check if resFlatResult is a number and not empty string
    const flatResult = (typeof gUI.roll.resFlatResult === 'number' && gUI.roll.resFlatResult !== '')
         ? gUI.roll.resFlatResult : null;

    if (flatResult !== null) {
        const isArType = (typeof gUI.roll.resTyp === 'string') && gUI.roll.resTyp.trim().toLowerCase() === 'ar';
        // Round appropriately based on type (AR needs decimals)
        const roundedFlatResult = isArType ? Number(flatResult.toFixed(2)) : Math.round(flatResult);
        gUI.roll.resRoll = Math.max(0, roundedFlatResult); // Clamp at 0 minimum
        fMyConsoleLog(`‚öôÔ∏è Calculated resRoll (override, ${isArType ? 'AR-rounded' : 'INT-rounded'}): ${gUI.roll.resRoll}`);
        return; // Exit early as override takes precedence
    }

    // --- Validate Base Roll ---
    // Check if initial roll is a number and not empty string
    const initialRoll = gUI.roll.roll;
    if (typeof initialRoll !== 'number' || initialRoll === '' || isNaN(initialRoll)) { // Added isNaN check
        gUI.roll.resRoll = '';
        fMyConsoleLog(`‚ÑπÔ∏è Cannot calculate resRoll: Invalid initial roll value (${initialRoll}).`);
        return;
    }

    // --- Apply Modifiers ---
    let currentResRoll = initialRoll;
    // Apply resMultMult
    if (typeof gUI.roll.resMultMult === 'number' && gUI.roll.resMultMult !== '') {
        currentResRoll *= gUI.roll.resMultMult;
    }

    // Apply resPlusPlus
    if (typeof gUI.roll.resPlusPlus === 'number' && gUI.roll.resPlusPlus !== '') {
        currentResRoll += gUI.roll.resPlusPlus;
    }

    // Apply resdctMult (multiplicative) <<< ADDED BLOCK ---
    if (typeof gUI.roll.resdctMult === 'number' && gUI.roll.resdctMult !== '') {
        currentResRoll *= gUI.roll.resdctMult;
    }
    // --- End resdctMult Block ---

    // --- Final Rounding, Clamping, and Assignment ---
    if (!isNaN(currentResRoll)) {
        const isArType = (typeof gUI.roll.resTyp === 'string') && gUI.roll.resTyp.trim().toLowerCase() === 'ar';
        // Round appropriately
        const roundedResRoll = isArType ? Number(currentResRoll.toFixed(2)) : Math.round(currentResRoll);
        gUI.roll.resRoll = Math.max(0, roundedResRoll); // Clamp at 0 minimum
    } else {
        gUI.roll.resRoll = ''; // Set to empty if calculation resulted in NaN
        console.warn("fCalcGUIRollResRoll: Calculation resulted in NaN.");
    }

    fMyConsoleLog(`‚öôÔ∏è Calculated final resRoll: ${gUI.roll.resRoll}`);
} // END fCalcGUIRollResRoll





// fCalcGUIRollResRoll /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Calculates final gUI.roll.resRoll using overrides or morph-based modifiers.
// Inputs  -> None (reads gUI.roll).
// Outputs -> None (writes gUI.roll.resRoll).
function fCalcGUIRollResRoll() {

    // --- Check for Flat Result Override ---
    const flatResult = (typeof gUI.roll.resFlatResult === 'number' && gUI.roll.resFlatResult !== '') ? gUI.roll.resFlatResult : null;

    if (flatResult !== null) {
        const isArType = (typeof gUI.roll.resTyp === 'string') && gUI.roll.resTyp.trim().toLowerCase() === 'ar';
        const roundedFlatResult = isArType ? Number(flatResult.toFixed(2)) : Math.round(flatResult);
        gUI.roll.resRoll = Math.max(0, roundedFlatResult);
        fMyConsoleLog(`‚öôÔ∏è Calculated resRoll (override, ${isArType ? 'AR-rounded' : 'INT-rounded'}): ${gUI.roll.resRoll}`);
        return;
    }

    // --- Validate Base Roll ---
    const initialRoll = gUI.roll.roll;
    if (typeof initialRoll !== 'number' || initialRoll === '') {
        gUI.roll.resRoll = '';
        fMyConsoleLog(`‚ÑπÔ∏è Cannot calculate resRoll: Invalid initial roll value (${initialRoll}).`);
        return;
    }

    // --- Apply Modifiers ---
    let currentResRoll = initialRoll;
    if (typeof gUI.roll.resMultMult === 'number' && gUI.roll.resMultMult !== '') currentResRoll *= gUI.roll.resMultMult;
    if (typeof gUI.roll.resPlusPlus === 'number' && gUI.roll.resPlusPlus !== '') currentResRoll += gUI.roll.resPlusPlus;
    // --- Final Rounding, Clamping, and Assignment ---
    if (!isNaN(currentResRoll)) {
        const isArType = (typeof gUI.roll.resTyp === 'string') && gUI.roll.resTyp.trim().toLowerCase() === 'ar';
        const roundedResRoll = isArType ? Number(currentResRoll.toFixed(2)) : Math.round(currentResRoll);
        gUI.roll.resRoll = Math.max(0, roundedResRoll);
    } else {
        gUI.roll.resRoll = '';
        console.warn("fCalcGUIRollResRoll: Calculation resulted in NaN.");
    }

    fMyConsoleLog(`‚öôÔ∏è Calculated final resRoll: ${gUI.roll.resRoll}`);
} // END fCalcGUIRollResRoll






// fCalcRollLogPrepend /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Builds final roll result log message and prepends it to the sidebar.
// Inputs  -> None (reads gUI.roll).
// Outputs -> None (calls fPrependToSidebar, fShowSidebar).
function fCalcRollLogPrepend() {
    const html = fBuildRollLogHTML();
    fPrependToSidebar(html);
    fShowSidebar();
    fMyConsoleLog("üì∞ Roll Log message prepended.");
} // END fCalcRollLogPrepend




// fBuildRollLogHTML /////////////////////////////////////////////////////////////////////////////////
// Purpose -> Constructs and returns the formatted HTML log line based on gUI.roll data.
// Inputs  -> None (reads gUI.roll).
// Outputs -> (String): HTML string to insert in sidebar.
function fBuildRollLogHTML() {

    // --- Build Title ---
    const skTyp = (typeof gUI.roll.skTyp === 'string') ? gUI.roll.skTyp.trim() : '';
    const resTyp = (typeof gUI.roll.resTyp === 'string') ? gUI.roll.resTyp.trim() : '';
    let title = `<span class="sidebar-ability-name">${gUI.roll.skName || 'Unknown Ability'}</span>`;
    if (skTyp) title += ` ${skTyp}`;
    if (resTyp && resTyp !== skTyp) title += ` (<span class="red-bold">now</span> ${resTyp})`;
    // --- Get Morph String ---
    const morph = (typeof gUI.roll.skMorph === 'string' && gUI.roll.skMorph !== ',') ? gUI.roll.skMorph.trim() : '';

    // --- Build Roll Base String (Type(Sk->ResSk)) ---
    let rollBase = resTyp || skTyp;
    const skSk = gUI.roll.skSk;
    const resSk = gUI.roll.resSk;
    if (typeof skSk === 'number' && skSk !== '') {
        rollBase += `(${skSk}${(typeof resSk === 'number' && resSk !== '' && resSk !== skSk) ? `->${resSk}` : ''})`;
    } else if (typeof resSk === 'number' && resSk !== '') {
        rollBase += `(${resSk})`;
    }

    // --- Build Roll Result String (~Roll->ResRoll) ---
    const roll = gUI.roll.roll;
    const resRoll = gUI.roll.resRoll;
    let rollResult = '';
    if ((typeof roll === 'number' || (typeof roll === 'string' && roll !== '')) && roll != null) {
        rollResult += ` ~${roll}`;
        if ((typeof resRoll === 'number' || (typeof resRoll === 'string' && resRoll !== '')) && resRoll != null && resRoll !== roll) {
            rollResult += `->${resRoll}`;
        }
    } else if ((typeof resRoll === 'number' || (typeof resRoll === 'string' && resRoll !== '')) && resRoll != null) {
        rollResult += ` ~${resRoll}`;
    }

    // --- Build Difficulty (^Dif) ---
    const dif = gUI.roll.resDif;
    let rollDif = (typeof dif === 'number' || (typeof dif === 'string' && dif !== '')) && dif != null ? `^${dif}` : '';

    // --- Build Success Delta (=/+Œî) ---
    let rollSuccess = '';
    if (typeof resRoll === 'number' && typeof dif === 'number') {
        const delta = resRoll - dif;
        rollSuccess = delta >= 0 ? ` =+${delta} ‚úÖ` : ` =${delta} ‚ùå`;
    }

    // --- Combine Roll1 Summary and add possible TC ---
    let roll1 = `${rollBase}${rollResult}${rollDif}${rollSuccess}`.trim();
    const tc = fCStc();
    if (roll1 && tc) roll1 += `   ${tc}`;
    // --- Build Final HTML ---
    let html = gUI.roll.htmlHeader;
    if (title) html += `${title}`;
    if (morph) html += `<br>morph: ${morph}`;
    if (roll1) html += `<br>${roll1}`;
    return html;
} // END fBuildRollLogHTML



// ==========================================================================
// === Base Die Rolling          (End of Die Roll Button ) ===
// ==========================================================================


// fCSd //////////////////////////////////////////////////////////////////////
// Purpose -> Standard linear distribution die roll.
// Inputs  -> die (Number): The number of sides on the die.
// Outputs -> (Number): The result of the roll (1 to die).
function fCSd(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSd received invalid die size: ${die}`);
    return 1; // Return 1 for invalid input
  }
  return Math.floor(Math.random() * numDie) + 1;
} // END fCSd



// fCSD //////////////////////////////////////////////////////////////////////
// Purpose -> Make an old fashioned, but smooth, MetaScape d(die) roll (no T or C).
//            Uses a non-linear distribution.
// Inputs  -> die (Number): The base value for the roll.
// Outputs -> (Number): The result of the roll.
function fCSD(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSD received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  // Prevent division by zero or near-zero in Math.random()
  let randomDivisor = Math.random();
  if (randomDivisor < 0.0001) randomDivisor = 0.0001; // Set a minimum divisor

  return Math.floor((numDie * Math.random()) / randomDivisor) + 1;
} // END fCSD



// fCStc /////////////////////////////////////////////////////////////////////
// Purpose -> Rolls 1d16 to determine Tremendous ('T') or Critical ('C') result.
// Inputs  -> None.
// Outputs -> (String): "T", "C", or "".
function fCStc() {
  const roll = fCSd(16); // Use the translated fCSd
  // Fetch color formatting from gUI if available, otherwise use plain text
  const treS = gUI?.style?.treS ?? '';   // Tremendous Start
  const redBS = gUI?.style?.redBS ?? ''; // Red Bold Start
  const endS = gUI?.style?.endS ?? '';   // Span End

  return roll === 1
    ? `<span class="tremendous">T</span>`
    : roll === 2
    ? `<span class="red-bold">C</span>`
    : "";
} // END fCStc




// fCSdBetween ///////////////////////////////////////////////////////////////
// Purpose -> Rolls d(high - low + 1) + (low - 1). e.g., fCSdBetween(6,8) = 6, 7, or 8.
// Inputs  -> low (Number): The lowest possible result.
//         -> high (Number): The highest possible result.
// Outputs -> (Number): Random integer between low and high (inclusive).
function fCSdBetween(low, high) {
  const numLow = Number(low);
  const numHigh = Number(high);
  if (isNaN(numLow) || isNaN(numHigh) || numLow > numHigh) {
    console.error(`fCSdBetween received invalid range: ${low}-${high}`);
    return numLow; // Return low value on error
  }
  // Roll d(high - low + 1) then add (low - 1)
  return fCSd(numHigh - numLow + 1) + (numLow - 1);
} // END fCSdBetween




// fCSDSk ////////////////////////////////////////////////////////////////////
// Purpose -> Returns the average of a d(die * 2) and an fCSD(die) roll.
// Inputs  -> die (Number): The base skill value.
// Outputs -> (Number): The result of the skill roll.
function fCSDSk(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSDSk received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  return Math.round((fCSd(numDie * 2) + fCSD(numDie)) / 2);
} // END fCSDSk




// fCSAtk ////////////////////////////////////////////////////////////////////
// Purpose -> Returns the average of a d(die * 2) and an fCSD(die) roll.
// Inputs  -> die (Number): The base skill value.
// Outputs -> (Number): The result of the skill roll.
// For 'now' is identical to fCSDSk
function fCSAtk(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSAtk received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  return Math.round((fCSd(numDie * 2) + fCSD(numDie)) / 2);
} // END fCSAtk



// fCSDef ////////////////////////////////////////////////////////////////////
// Purpose -> Returns a PC Defense roll (based on fCSD).
// Inputs  -> die (Number): The base defense value.
// Outputs -> (Number): The result of the defense roll.
function fCSDef(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSDef received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  // Formula from MSGLib: fCSD(die) * 0.75
  return Math.round(fCSD(numDie) * 0.75);
} // END fCSDef




// fCSRollUnSkilled //////////////////////////////////////////////////////////
// Purpose -> Rolls an ability as UnSkilled. Reduces base die value first.
// Inputs  -> die (Number): The original base skill value.
// Outputs -> (Number): The result of the unskilled roll.
function fCSRollUnSkilled(die) {
  const numDie = Number(die); // Ensure input is treated as a number
  if (isNaN(numDie) || numDie < 1) {
    console.error(`fCSRollUnSkilled received invalid die value: ${die}`);
    return 1; // Return 1 for invalid input
  }
  // Calculate the reduced die value for unskilled rolls
  const newDie = Math.max(2, Math.min(numDie / 2, 5 + Math.sqrt(numDie)));
  // Formula from MSGLib: avg(d(newDie*2), d(newDie*2), fCSD(newDie)) / 3
  return Math.round((fCSd(newDie * 2) + fCSd(newDie * 2) + fCSD(newDie)) / 3);
} // END fCSRollUnSkilled




// fCSRollUnSkilledDmg ///////////////////////////////////////////////////////
// Purpose -> Rolls PC Unskilled Damage (currently uses standard unskilled roll).
// Inputs  -> pcDmg (Number): The base damage value.
// Outputs -> (Number): The result of the unskilled damage roll.
function fCSRollUnSkilledDmg(pcDmg) {
  // Simply calls the standard unskilled function for now
  return fCSRollUnSkilled(pcDmg);
} // END fCSRollUnSkilledDmg




// fCSRollUnSkilledArmor /////////////////////////////////////////////////////
// Purpose -> Rolls PC Unskilled Armor.
// Inputs  -> pcAR (Number): The base armor value.
// Outputs -> (Number): The result of the unskilled armor roll (min 1, rounded to tenth).
function fCSRollUnSkilledArmor(pcAR) {
  // Formula from MSGLib: max(1, trunc( (fCSRollUnSkilled(pcAR) / 8) * 10 ) / 10 )
  const unskilledRoll = fCSRollUnSkilled(pcAR);
  // MSGLib uses 8 here, not 15 like fCSDArmor
  const result = Math.trunc((unskilledRoll / 8) * 10) / 10;
  return Math.max(1, result); // Ensure minimum of 1
} // END fCSRollUnSkilledArmor




// fCSDDmg ///////////////////////////////////////////////////////////////////
// Purpose -> Rolls PC Damage (currently uses standard fCSDSk roll).
// Inputs  -> pcDmg (Number): The base damage value.
// Outputs -> (Number): The result of the damage roll.
function fCSDDmg(pcDmg) {
  // Simply calls the standard skill roll function for now
  return fCSDSk(pcDmg);
} // END fCSDDmg




// fCSDArmor /////////////////////////////////////////////////////////////////
// Purpose -> Rolls PC Armor.
// Inputs  -> pcAR (Number): The base armor value.
// Outputs -> (Number): The result of the armor roll (min 1, rounded to tenth).
function fCSDArmor(pcAR) {
  // Formula from MSGLib: max(1, trunc( (fCSDSk(pcAR) / 15) * 10 ) / 10 )
  const skillRoll = fCSDSk(pcAR);
  // MSGLib uses 15 here, not 8 like fCSRollUnSkilledArmor
  const result = Math.trunc((skillRoll / 15) * 100) / 100;
  return Math.max(1, result); // Ensure minimum of 1
} // END fCSDArmor



// ==========================================================================
// === Message Box             (End of Base Die Rolling ) ===
// ==========================================================================


// fShowMessage ///////////////////////////////////////////////////////////////////
// Purpose -> Displays the message modal box and returns a Promise that resolves when closed.
// Inputs -> message (String): The text or HTML to display in the message box.
// Outputs -> (Promise): Resolves when the modal is hidden.
// MODIFIED: Now async, returns a Promise, stores resolve function in gUI.
async function fShowMessage(message) {
    // --- Try to cache elements if not already done ---
    if (!gUI.messageModalOverlay) {
        gUI.messageModalOverlay = document.getElementById('messageModal');
        // If caching now, log it for debugging timing issues
        if (gUI.messageModalOverlay) console.log("fShowMessage: Just-in-time cache for #messageModal");
    }
    if (!gUI.messageModalText) {
        gUI.messageModalText = document.getElementById('messageText');
        if (gUI.messageModalText) console.log("fShowMessage: Just-in-time cache for #messageText");
    }
    // --- End Caching Attempt ---

    // Now, re-check if elements exist *after* attempting to cache
    if (!gUI.messageModalOverlay || !gUI.messageModalText) {
        // Log the original error if elements are *still* not found
        console.error("Message modal elements not cached or found in the DOM!");
        if (!gUI.messageModalOverlay) console.error("Missing: #messageModal");
        if (!gUI.messageModalText) console.error("Missing: #messageText");
        // Optionally: Fallback to a simpler alert if modal isn't ready
        // alert("Modal Error!\n" + message);
        return Promise.reject(new Error("Message modal elements not found.")); // Reject if elements missing
    }

    // Set message content (using innerHTML allows basic tags like <br>)
    gUI.messageModalText.innerHTML = message;
    // Show the modal
    gUI.messageModalOverlay.style.display = 'flex'; // Using flex as defined in CSS

    // Create and return a new Promise
    return new Promise((resolve) => {
        gUI.messagePromiseResolve = resolve; // Store the resolve function globally
    });
} // END fShowMessage




// fHideMessage ///////////////////////////////////////////////////////////////////
// Purpose -> Hides the message modal box and resolves the pending promise.
// Inputs -> None
// Outputs -> None
// MODIFIED: Calls the stored resolve function if it exists.
function fHideMessage() {
    if (gUI.messageModalOverlay) {
        gUI.messageModalOverlay.style.display = 'none';
    } else {
        // This shouldn't happen if elements were cached, but log just in case
        console.error("Message modal overlay element (#messageModal) not found when trying to hide.");
    }

    // Resolve the promise if a resolve function is stored
    if (typeof gUI.messagePromiseResolve === 'function') {
        gUI.messagePromiseResolve(); // Call the stored resolve function
        gUI.messagePromiseResolve = null; // Clear the stored function
        fMyConsoleLog("Message Promise Resolved"); // Optional log
    }
} // END fHideMessage




// fSetupMessageModalListeners /////////////////////////////////////////////////////
// Purpose -> Sets up event listeners for the message modal close mechanisms.
// Inputs -> None
// Outputs -> None
// NOTE: No changes needed here, as the listeners already call fHideMessage,
//       which now handles resolving the promise.
function fSetupMessageModalListeners() {

    fMyConsoleLog("üñ±Ô∏è Setting up Message Modal Listeners...");
    // --- Get elements directly here, don't rely solely on gUI cache ---
    const overlayElement = document.getElementById('messageModal');
    const closeButtonElement = document.getElementById('closeMessageModal');
    // We still need the overlay for the other listeners, might as well fetch it too.
    // Check if elements were found *now*
    if (!overlayElement) {
        console.error("Setup failed: Message modal overlay element (#messageModal) not found *during listener setup*.");
        fMyConsoleLog("‚ö†Ô∏è Message Modal Listeners NOT Attached (overlay missing).");
        return;
    }
    if (!closeButtonElement) {
        console.error("Setup failed: Message modal close button (#closeMessageModal) not found *during listener setup*.");
        fMyConsoleLog("‚ö†Ô∏è Message Modal Listeners NOT Attached (button missing).");
        return; // Don't add listeners if button is missing
    }
    // --- End direct element fetching ---


    // Listener for the close button - Attach to the element we just found
    closeButtonElement.addEventListener('click', fHideMessage); // Calls the (now modified) hide function


    // Listener for clicking the background overlay - Attach to the element we just found
    overlayElement.addEventListener('click', (event) => {
        if (event.target === overlayElement) { // Check directly against the fetched element
            fHideMessage(); // Calls the (now modified) hide function
        }
    });
    // Listener for the Escape key (uses document, and checks overlay visibility)
    document.addEventListener('keydown', (event) => {
        // Check overlay visibility using the fetched element reference
        if (overlayElement.style.display !== 'none' && event.key === 'Escape') {
             fHideMessage(); // Calls the (now modified) hide function
        }
    });
    fMyConsoleLog("‚úÖ Message Modal Listeners Attached.");

} // END fSetupMessageModalListeners



// ==========================================================================
// === Prompt Box              (End of Message Box) ===
// ==========================================================================


// fShowPrompt ///////////////////////////////////////////////////////////////////
// Purpose -> Displays the prompt modal box and returns a Promise that resolves with true (Yes) or false (No).
// Inputs -> message (String): The text or HTML to display in the prompt box.
// Outputs -> (Promise): Resolves with true if 'Yes' clicked, false if 'No' clicked.
async function fShowPrompt(message) {
    // --- Try to cache elements if not already done ---
    if (!gUI.promptModalOverlay) gUI.promptModalOverlay = document.getElementById('promptModal');
    if (!gUI.promptModalText) gUI.promptModalText = document.getElementById('promptText');
    // --- End Caching Attempt ---

    // Check if elements exist *after* attempting to cache
    if (!gUI.promptModalOverlay || !gUI.promptModalText) {
        console.error("Prompt modal elements not cached or found in the DOM!");
        if (!gUI.promptModalOverlay) console.error("Missing: #promptModal");
        if (!gUI.promptModalText) console.error("Missing: #promptText");
        return Promise.reject(new Error("Prompt modal elements not found.")); // Reject if elements missing
    }

    // Set prompt content
    gUI.promptModalText.innerHTML = message;
    // Show the modal
    gUI.promptModalOverlay.style.display = 'flex';
    // Create and return a new Promise
    // We store both resolve and reject, although reject might not be used often for simple Yes/No
    return new Promise((resolve, reject) => {
        gUI.promptPromiseResolve = resolve; // Store the resolve function
        gUI.promptPromiseReject = reject;   // Store the reject function
    });
} // END fShowPrompt




// fHandlePromptResponse ///////////////////////////////////////////////////////////
// Purpose -> Hides the prompt modal and resolves the pending promise with the user's choice.
// Inputs -> userResponse (Boolean): true for 'Yes', false for 'No'.
// Outputs -> None
function fHandlePromptResponse(userResponse) {
    // Hide the modal first
    if (gUI.promptModalOverlay) {
        gUI.promptModalOverlay.style.display = 'none';
    } else {
        console.error("Prompt modal overlay element (#promptModal) not found when trying to hide.");
    }

    // Resolve the promise if a resolve function is stored
    if (typeof gUI.promptPromiseResolve === 'function') {
        gUI.promptPromiseResolve(userResponse); // Call the stored resolve function with the response
        fMyConsoleLog(`Prompt Promise Resolved with: ${userResponse}`); // Optional log
    } else {
        console.error("Prompt promise resolve function not found when trying to resolve.");
    }

    // Clear the stored functions after use
    gUI.promptPromiseResolve = null;
    gUI.promptPromiseReject = null;
} // END fHandlePromptResponse




// fSetupPromptModalListeners //////////////////////////////////////////////////////
// Purpose -> Sets up event listeners for the prompt modal 'Yes' and 'No' buttons.
// Inputs -> None
// Outputs -> None
function fSetupPromptModalListeners() {
    fMyConsoleLog("üñ±Ô∏è Setting up Prompt Modal Listeners...");
    // --- Cache elements if not already done (or get directly) ---
    if (!gUI.promptYesButton) gUI.promptYesButton = document.getElementById('promptYesButton');
    if (!gUI.promptNoButton) gUI.promptNoButton = document.getElementById('promptNoButton');
    // We don't necessarily need the overlay reference here unless adding Escape/background click handling

    // Check if buttons were found *now*
    if (!gUI.promptYesButton) {
        console.error("Setup failed: Prompt 'Yes' button (#promptYesButton) not found *during listener setup*.");
        fMyConsoleLog("‚ö†Ô∏è Prompt Modal Listeners NOT Attached (Yes button missing).");
        return;
    }
    if (!gUI.promptNoButton) {
        console.error("Setup failed: Prompt 'No' button (#promptNoButton) not found *during listener setup*.");
        fMyConsoleLog("‚ö†Ô∏è Prompt Modal Listeners NOT Attached (No button missing).");
        return;
    }
    // --- End direct element fetching/caching ---

    // Listener for the 'Yes' button
    gUI.promptYesButton.addEventListener('click', () => fHandlePromptResponse(true));
    // Listener for the 'No' button
    gUI.promptNoButton.addEventListener('click', () => fHandlePromptResponse(false));
    // @@Optional: Add Escape key listener here if needed (could call fHandlePromptResponse(false) or reject)
    // document.addEventListener('keydown', (event) => {
    //   if (gUI.promptModalOverlay && gUI.promptModalOverlay.style.display !== 'none' && event.key === 'Escape') {
    //     fHandlePromptResponse(false); // Or potentially reject if you use the reject function
    //   }
    // });
    fMyConsoleLog("‚úÖ Prompt Modal Listeners Attached.");
} // END fSetupPromptModalListeners






</script>