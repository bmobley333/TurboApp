<!-- gamelogic.html -->

<script>
  // ==========================================================================
  // === Die Roll Button         (End of N/A) ===
  // ==========================================================================

  // fHandleRollDiceAction ///////////////////////////////////////////////////////////
  // Purpose -> Top-level handler for initiating an ability/gear roll, triggered by
  //            Roll/Free/Luck buttons or programmatically by Nish button.
  //            Coordinates validation, data population, morph processing, cost verification,
  //            branching to specific roll logic (standard, attack, defense, etc.),
  //            cost application, Nish cell update, and final logging to sidebar.
  // Inputs  -> None (Relies on gUI state: currentSkRadioChecked, buttonOrMenu).
  // Outputs -> None (Orchestrates updates to gUI, DOM, and sidebar).
  async function fHandleRollDiceAction() {
    fMyConsoleLog("üé≤ Roll Dice Action Triggered");

    // === 1. Initial Validation & Base gUI.roll Setup ===
    const { r, c } = gUI.currentSkRadioChecked; // Get currently selected ability checkbox coords
    // Validate checkbox selection
    if (!(await fValidateAbilityCB(r, c))) {
      fSetButtonOrMenuState(null); // Reset button state on early exit
      return;
    }
    // Populate gUI.roll with base data from the selected ability row
    if (!(await fResetPopulateNCleanGUIRoll(r, c))) {
      fSetButtonOrMenuState(null); // Reset button state on early exit
      return;
    }
    // Verify essential ability info (Name, Type) exists in gUI.roll
    if (!(await fVerifyAbility())) {
      fSetButtonOrMenuState(null); // Reset button state on early exit
      return;
    }

    // === 2. Nish Ability Pre-Sequence Check ===
    // Check if the roll is for the Nish ability itself and if it wasn't triggered by the Nish button
    const nishRowIndex = resolveRow("NishAtr_R");
    const isNishAbilityRoll = gUI.roll.ability_R === nishRowIndex;

    if (isNishAbilityRoll && !gUI.buttonOrMenu.isNish) {
      // If Nish triggered by Checkbox + Roll/Free/Luck, run the pre-roll sequence
      fMyConsoleLog(
        "   -> Nish ability triggered via Checkbox + Roll/Free/Luck. Executing Nish sequence first..."
      );
      await fExecuteNishSequence();
    } else if (isNishAbilityRoll && gUI.buttonOrMenu.isNish) {
      // If triggered by Nish button, sequence was already run by fHandleNishButtonClick
      fMyConsoleLog(
        "   -> Nish ability triggered via Nish Button. Pre-sequence already executed."
      );
    }

    // === 3. Process Morph String ===
    // Parse the morph string for modifiers and flags (e.g., 'free', 'luck', '#3')
    fMyConsoleLog("   -> Processing morph string...");
    await fProcessMorph();
    // Ensure multiRollCount is defined (defaults to 1 if not set by morph)
    if (typeof gUI.roll.multiRollCount === "undefined") {
      gUI.roll.multiRollCount = 1;
      fMyConsoleLog(
        "   -> Warning: multiRollCount was undefined after morph processing, defaulting to 1."
      );
    }

    // === 4. Determine Final Flags & Prepare for Costs/Rolls ===
    const multiRollCount = gUI.roll.multiRollCount;
    // Combine button state and morph flags to get final free/luck status
    const isFreeRoll =
      gUI.buttonOrMenu.isFree ||
      gUI.roll.isFreeRoll ||
      (isNishAbilityRoll && gUI.buttonOrMenu.isNish);
    const isLuckedRoll = gUI.buttonOrMenu.isLuck || gUI.roll.isLuckedRoll;
    // Update gUI.roll state with final flags
    gUI.roll.isFreeRoll = isFreeRoll;
    gUI.roll.isLuckedRoll = isLuckedRoll;
    // Get final roll type and check for difficulty morph
    const resTyp = gUI.roll.resTyp;
    const hasDifficultyMorph =
      typeof gUI.roll.resDif === "number" && gUI.roll.resDif !== "";

    fMyConsoleLog(`   -> Final Roll Type: ${resTyp}`);
    fMyConsoleLog(`   -> Final Multi-Roll Count: ${multiRollCount}`);
    fMyConsoleLog(`   -> Final Is Free Roll: ${isFreeRoll}`);
    fMyConsoleLog(`   -> Final Is Lucked Roll: ${isLuckedRoll}`);
    fMyConsoleLog(
      `   -> Final Has Difficulty Morph (^): ${hasDifficultyMorph}`
    );

    // Initialize for cost verification and log building
    const pendingHeaders = []; // Headers for sidebar log (cost info)
    let allCostsMet = true; // Flag for cost verification status
    let userCancelled = false; // Flag if user cancels via prompt
    gUI.pendingChangesMap = {}; // Reset map for pending grid updates

    // Helper to add changes to the map (avoids direct mutation in verification functions)
    const addChangesToMap = (changesArray) => {
      if (!Array.isArray(changesArray)) return;
      changesArray.forEach((change) => {
        if (
          change &&
          typeof change.r !== "undefined" &&
          typeof change.c !== "undefined"
        ) {
          const key = `${change.r},${change.c}`;
          gUI.pendingChangesMap[key] = change.value;
        } else {
          console.warn("addChangesToMap received invalid change:", change);
        }
      });
    };

    // === 5. Add Pre-Cost Headers & Verify Costs ===
    // Add headers for Luck/Free status *before* cost verification
    if (isLuckedRoll) {
      pendingHeaders.push(
        '‚ö†Ô∏è <span class="blue-bold">Lucked Roll Below:</span>'
      );
    }
    // Add Free header unless Nish sequence already added a divider
    if (isFreeRoll && !(isNishAbilityRoll && gUI.buttonOrMenu.isNish)) {
      pendingHeaders.push('‚ö†Ô∏è <span class="blue-bold">Free Roll Below:</span>');
    }
    // Optional: Add note if Nish button bypassed costs
    // else if (isFreeRoll && isNishAbilityRoll && gUI.buttonOrMenu.isNish) {
    //     pendingHeaders.push('‚ÑπÔ∏è Nish Button: Standard costs bypassed.');
    // }

    // --- Verify Costs (Skip if Free Roll) ---
    if (!isFreeRoll) {
      fMyConsoleLog("üõ°Ô∏è Verifying Costs (Luck and/or Standard)...");

      // Verify Luck Cost (if applicable)
      if (isLuckedRoll) {
        fMyConsoleLog("   -> Verifying Luck Cost...");
        const luckCost = 1;
        const currentLuck = fGetGridValue("LuckBox", "LuckBox", true); // Get current luck
        if (isNaN(currentLuck)) {
          // Handle error reading luck
          await fShowMessage("‚ùå Error reading current Luck value.");
          fMyConsoleLog(
            "üö´ Failed Luck Cost Verification: Could not read LuckBox."
          );
          allCostsMet = false;
        } else if (currentLuck < luckCost) {
          // Handle insufficient luck
          await fShowMessage("‚ùå Not Enough Luck!");
          fMyConsoleLog("üö´ Failed Luck Cost Verification: Insufficient Luck.");
          allCostsMet = false;
        } else {
          // Luck cost met
          const newLuck = currentLuck - luckCost;
          addChangesToMap([{ r: "LuckBox", c: "LuckBox", value: newLuck }]); // Add change to map
          fMyConsoleLog(
            `      -> Luck Cost OK (${currentLuck} -> ${newLuck}). Change added to map.`
          );
        }
      }

      // Verify Standard Costs (Only if not Lucked and previous checks passed)
      if (!isLuckedRoll && allCostsMet) {
        fMyConsoleLog("   -> Verifying Standard Costs...");
        // Verify Uses
        const usesResult = await fUses_VerifyAndProcessCost(multiRollCount);
        if (!usesResult.success) {
          allCostsMet = false;
          userCancelled = usesResult.cancelledByUser;
        } else {
          addChangesToMap(usesResult.changes);
          pendingHeaders.push(...usesResult.headers);
        }
        // Verify Action Points
        if (allCostsMet) {
          const actResult = await fAct_VerifyAndProcessCost();
          if (!actResult.success) {
            allCostsMet = false;
            userCancelled = actResult.cancelledByUser;
          } else {
            addChangesToMap(actResult.changes);
            pendingHeaders.push(...actResult.headers);
          }
        }
        // Process 'Is On' / Duration (copies duration if Sk1)
        if (allCostsMet) {
          const isOnResult = await fIsOn_VerifyAndProcessCost();
          addChangesToMap(isOnResult.changes);
          pendingHeaders.push(...isOnResult.headers);
        }
        // Verify Skill Meta Cost
        if (allCostsMet) {
          const skMetaResult = await fSkMeta_VerifyAndProcessCost(
            gUI.pendingChangesMap
          );
          if (!skMetaResult.success) {
            allCostsMet = false;
          } else {
            addChangesToMap(skMetaResult.changes);
            pendingHeaders.push(...skMetaResult.headers);
          }
        }
        // Verify Focus Meta Cost
        if (allCostsMet) {
          const focusMetaResult = await fFocus_VerifyAndProcessCost(
            gUI.pendingChangesMap
          );
          if (!focusMetaResult.success) {
            allCostsMet = false;
          } else {
            addChangesToMap(focusMetaResult.changes);
            pendingHeaders.push(...focusMetaResult.headers);
          }
        }
      }

      // Halt if ANY cost verification failed or was cancelled
      if (!allCostsMet || userCancelled) {
        const reason = userCancelled
          ? "cost verification cancelled by user"
          : "insufficient resources";
        fMyConsoleLog(
          `üö¶ Halting Roll Dice Action due to ${reason}. Costs NOT applied.`
        );
        gUI.pendingChangesMap = {}; // Clear pending changes
        fSetButtonOrMenuState(null); // Reset button state
        return; // Exit function
      }
      fMyConsoleLog(
        "‚úÖ All necessary costs verified successfully. Changes prepared in map."
      );
    } else {
      // Free roll, skip cost verification
      fMyConsoleLog(`‚úÖ Skipping ALL Cost Verification (Free Roll).`);
      gUI.pendingChangesMap = {}; // Ensure map is clear
    }
    // --- End Cost Verification ---

    // === 6. Build Initial Log Header ===
    // Combine pending headers, ability title, and morph string
    let initialLogHtml = "";
    pendingHeaders.forEach((header) => (initialLogHtml += `${header}<br>`));
    let title = `<span class="sidebar-ability-name">${
      gUI.roll.skName || "Unknown Ability"
    }</span>`;
    if (gUI.roll.skTyp) title += ` ${gUI.roll.skTyp}`;
    if (gUI.roll.resTyp && gUI.roll.resTyp !== gUI.roll.skTyp)
      title += ` (<span class="red-bold">now</span> ${gUI.roll.resTyp})`; // Show if type changed
    initialLogHtml += title;
    const morph =
      typeof gUI.roll.skMorph === "string" && gUI.roll.skMorph !== ","
        ? gUI.roll.skMorph.trim()
        : "";
    if (morph) initialLogHtml += `<br>morph: ${morph}`; // Add morph string if present
    initialLogHtml = initialLogHtml.trim();
    gUI.roll.htmlHeader = initialLogHtml; // Store for potential use by roll helpers

    // === 7. Branch Roll Logic ===
    let finalLogHtml = ""; // To hold the complete sidebar log entry HTML
    let helperSucceeded = false; // Flag: Did the specific roll logic succeed?
    let wasMonsterInteractionRoll = false; // Flag: Was it Atk/Def/Dmg/AR vs monsters?
    const resTypLower = resTyp.toLowerCase(); // Lowercase roll type for switch/if

    // Branch based on final roll type and presence of difficulty morph
    if (resTypLower === "atk" && !hasDifficultyMorph) {
      fMyConsoleLog("‚öîÔ∏è Performing Player Attack Rolls...");
      const monsterRollResult = await fPerformPlayerAttackRolls(initialLogHtml);
      if (monsterRollResult.success) {
        finalLogHtml = monsterRollResult.logHtml;
        helperSucceeded = true;
        wasMonsterInteractionRoll = true;
      } // Else: Attack sequence halted, helperSucceeded remains false
    } else if (resTypLower === "def" && !hasDifficultyMorph) {
      fMyConsoleLog("üõ°Ô∏è Performing Player Defense Rolls...");
      const monsterDefResult = await fPerformPlayerDefenseRolls(initialLogHtml);
      if (monsterDefResult.success) {
        finalLogHtml = monsterDefResult.logHtml;
        helperSucceeded = true;
        wasMonsterInteractionRoll = true;
      } // Else: Defense sequence halted
    } else if (resTypLower === "dmg" && !hasDifficultyMorph) {
      fMyConsoleLog("üí• Performing Player Damage Rolls...");
      const monsterDmgResult = await fPerformPlayerDamageRolls(initialLogHtml);
      if (monsterDmgResult.success) {
        finalLogHtml = monsterDmgResult.logHtml;
        helperSucceeded = true;
        wasMonsterInteractionRoll = true;
      } // Else: Damage sequence halted
    } else if (resTypLower === "ar" && !hasDifficultyMorph) {
      fMyConsoleLog("üõ°Ô∏è Performing Player Armor Rolls...");
      const monsterArmorResult = await fPerformPlayerArmorRolls(initialLogHtml);
      if (monsterArmorResult.success) {
        finalLogHtml = monsterArmorResult.logHtml;
        helperSucceeded = true;
        wasMonsterInteractionRoll = true;
      } // Else: Armor sequence halted
    } else {
      // Standard roll (includes types with '^' morph or non-monster interaction types)
      fMyConsoleLog("üéØ Performing Standard Roll(s)...");
      finalLogHtml = fPerformStandardRolls(initialLogHtml);
      helperSucceeded = true; // Standard roll always considered successful at this stage
      wasMonsterInteractionRoll = false;
    }

    // If specific roll logic failed (e.g., validation error within helper), halt before applying costs
    if (!helperSucceeded) {
      fMyConsoleLog("   -> Roll sequence halted. Costs NOT applied.");
      gUI.pendingChangesMap = {}; // Clear pending changes
      fSetButtonOrMenuState(null); // Reset button state
      return; // Exit function
    }
    fMyConsoleLog(
      `   -> ${
        wasMonsterInteractionRoll ? "Monster interaction" : "Standard"
      } roll sequence completed.`
    );

    // === 8. Apply Pending Costs ===
    // Apply changes collected during verification, ONLY if roll logic succeeded
    let applyErrors = false;
    if (Object.keys(gUI.pendingChangesMap).length > 0) {
      fMyConsoleLog(
        "‚úÖ Roll sequence successful. Applying Pending Cost Changes..."
      );
      const changeEntries = Object.entries(gUI.pendingChangesMap);
      fMyConsoleLog(
        `   -> Applying ${changeEntries.length} changes from map...`
      );
      // Apply each change using fSetGridValue
      for (const [key, value] of changeEntries) {
        try {
          const keyParts = key.split(",");
          if (keyParts.length !== 2) {
            console.warn(`Invalid key format: "${key}"`);
            applyErrors = true;
            continue;
          }
          const [rowPart, colPart] = keyParts;
          // Attempt to use row part as index, fallback to tag string
          let rowRef = parseInt(rowPart, 10);
          if (isNaN(rowRef) || rowRef < 0) {
            rowRef = rowPart;
          }
          // Apply the change
          if (!fSetGridValue(rowRef, colPart, value)) {
            applyErrors = true;
          }
        } catch (parseError) {
          console.error(`Error processing change key "${key}":`, parseError);
          applyErrors = true;
        }
      }
      gUI.pendingChangesMap = {}; // Clear map after attempting application
      if (applyErrors) {
        fMyConsoleLog(
          "‚ùå Errors occurred while applying cost/state changes AFTER roll success."
        );
        await fShowMessage("Error applying some cost/state changes post-roll.");
      } else {
        fMyConsoleLog("‚úÖ Costs Applied Successfully.");
      }
    } else {
      fMyConsoleLog(
        "‚úÖ Roll sequence successful. No Pending Cost Changes to Apply."
      );
    }

    // === 9. Update Nish Cell (if applicable) ===
    // If the roll was for the Nish ability itself, update the main Nish cell value
    if (isNishAbilityRoll) {
      const finalNishRoll = gUI.roll.resRoll; // Get the final roll result
      // Check if result is a number or empty string before setting
      if (typeof finalNishRoll === "number" || finalNishRoll === "") {
        fMyConsoleLog(
          `   -> Updating ('Nish', 'Nish') cell with final roll result: ${finalNishRoll}`
        );
        if (!fSetGridValue("Nish", "Nish", finalNishRoll)) {
          fMyConsoleLog("      -> ‚ö†Ô∏è Failed to update ('Nish', 'Nish') cell.");
          // Optional: await fShowMessage("Warning: Failed to update the main Nish cell value.");
        }
      } else {
        fMyConsoleLog(
          `   -> Skipping update to ('Nish', 'Nish') cell: Invalid final roll result type (${typeof finalNishRoll}).`
        );
      }
    }

    // === 10. Log Result to Sidebar ===
    if (finalLogHtml) {
      // Optional: Add extra space before specific roll types?
      // if (wasMonsterInteractionRoll || (isNishAbilityRoll && !gUI.buttonOrMenu.isNish)) {
      //      fPrependToSidebar('&nbsp;');
      // }
      fPrependToSidebar(finalLogHtml); // Add the combined log entry
      fShowSidebar(); // Ensure sidebar is visible
    } else {
      fMyConsoleLog("‚ÑπÔ∏è No final log message generated."); // Should be rare
    }
    gUI.roll.htmlHeader = ""; // Clear header buffer after use

    // === 11. Reset Button State ===
    fSetButtonOrMenuState(null);

    fMyConsoleLog(`‚úÖ Roll Dice Action Completed.`);
  } // END fHandleRollDiceAction

  // fAppendToHTMLHeader /////////////////////////////////////////////////////////////
  // Purpose -> Appends a string (typically a cost/status header) to the
  //            gUI.roll.htmlHeader string, adding an HTML line break (<br>).
  //            Used to build the initial part of the sidebar log entry.
  // Inputs  -> newHeader (String): The header string to append.
  // Outputs -> None (Modifies gUI.roll.htmlHeader).
  function fAppendToHTMLHeader(newHeader) {
    // Append the new header text followed by a line break
    gUI.roll.htmlHeader += `${newHeader}<br>`;
  } // END fAppendToHTMLHeader

  // fValidateAbilityCB //////////////////////////////////////////////////////////////
  // Purpose -> Validates that the provided coordinates (r, c) correspond to a valid
  //            Sk1/Sk2 checkbox location based on gUI.range.sk1sk2CheckBoxes.
  //            Shows a message if invalid.
  // Inputs  -> r (Number): 0-based row index.
  //         -> c (Number): 0-based column index.
  // Outputs -> (Promise<Boolean>): Resolves true if coordinates are valid, false otherwise.
  async function fValidateAbilityCB(row, col) {
    // Check if the coordinates fall within any defined Sk checkbox range
    const isValid = fIsSkRadioGroupMember(row, col);

    // Show message if coordinates are not for a valid ability checkbox
    if (!isValid) {
      await fShowMessage("‚ö†Ô∏è Please select a valid Ability checkbox first!");
    }

    return isValid;
  } // END fValidateAbilityCB

  // fResetPopulateNCleanGUIRoll /////////////////////////////////////////////////////
  // Purpose -> Resets the global gUI.roll object and populates it with base data
  //            extracted from the ability/gear row specified by the selected checkbox (r, c).
  //            Cleans and standardizes the extracted data (e.g., trims strings,
  //            parses numbers, defaults empty values). Sets initial resTyp and multiRollCount.
  // Inputs  -> r (Number): Row index of the selected ability/gear.
  //         -> c (Number): Column index of the selected checkbox (determines Sk1 vs Sk2).
  // Outputs -> (Promise<Boolean>): Resolves true if successful, false if an error occurs.
  async function fResetPopulateNCleanGUIRoll(r, c) {
    try {
      // Helper to get value from the specified row `r` and a column tag
      const getVal = (tag) => gUI.arr[r]?.[resolveCol(tag)] ?? "";
      // Determine if Sk1 or Sk2 checkbox was clicked
      const isSk1 = c === resolveCol("Sk1ChkBox");

      // === Initialize gUI.roll with Extracted Data ===
      gUI.roll = {
        ability_R: r,
        sk1CB: isSk1,
        // Get values based on whether Sk1 or Sk2 column was checked
        skMorph: isSk1 ? getVal("Morph1") : getVal("Morph2"),
        skTyp: isSk1 ? getVal("Sk1Typ") : getVal("Sk2Typ"),
        skSk: isSk1 ? getVal("Sk1") : getVal("Sk2"),
        skIsOn: getVal("On"),
        skNameID: getVal("Ability"),
        skAct: isSk1 ? getVal("Act") : "", // Costs usually only apply to Sk1
        skDur: isSk1 ? getVal("Dur") : "",
        skMeta: isSk1 ? getVal("Meta") : "",
        skUses: isSk1 ? getVal("Uses") : "",
        // Initialize derived/calculated fields
        skName: "",
        resTyp: "",
        resSk: "",
        resFlatBase: "",
        resFlatResult: "",
        resDif: "",
        resFocus: "",
        resPlus: "",
        resPlusPlus: "",
        resdctMult: "",
        resMult: "",
        resMultMult: "",
        resCombine: "",
        isUnSk: false,
        multiRollCount: 1, // Default multi-roll count
        roll: "",
        resRoll: "",
        htmlHeader: "",
      };

      const rData = gUI.roll; // Alias for convenience

      // === Clean String Fields ===
      // Remove trailing ID, trim whitespace, remove leading commas from morph
      rData.skName = String(rData.skNameID || "")
        .replace(/\s{2,}_\w{6}$/, "")
        .trim();
      rData.skMorph = String(rData.skMorph || "")
        .trim()
        .replace(/^,+/, "");
      rData.skTyp = String(rData.skTyp || "").trim();
      rData.skIsOn = String(rData.skIsOn || "").trim();
      rData.skDur = String(rData.skDur || "").trim();
      rData.skMeta = String(rData.skMeta || "")
        .trim()
        .toUpperCase(); // Store Meta tag uppercase
      // Ensure skMeta tag is valid, otherwise clear it
      if (rData.skMeta && !(gUI.list?.metaColor || []).includes(rData.skMeta)) {
        rData.skMeta = "";
      }

      // === Clean Numeric Fields ===
      // Convert Sk to number >= 1, else empty string
      const sk = parseInt(rData.skSk, 10);
      rData.skSk = !isNaN(sk) && sk >= 1 ? sk : "";
      // Convert Act to number >= 1, else empty string
      const act = parseInt(String(rData.skAct || "").trim(), 10);
      rData.skAct = !isNaN(act) && act >= 1 ? act : "";
      // Convert Uses to number, allow any integer (including 0 or negative), else empty string
      const uses = parseInt(rData.skUses, 10);
      rData.skUses = !isNaN(uses) ? uses : "";

      // === Set Initial Derived Values ===
      // Default resulting type to the base skill type
      rData.resTyp = rData.skTyp;

      fMyConsoleLog(
        `‚öôÔ∏è Populated & Cleaned gUI.roll for row ${r} (isSk1: ${isSk1})`
      );
      return true; // Indicate success
    } catch (err) {
      // --- Error Handling ---
      console.error(
        "fResetPopulateNCleanGUIRoll: Error processing ability data:",
        err
      );
      fMyConsoleLog(`‚ùå Error populating/cleaning gUI.roll: ${err.message}`);
      // Show error to user via sidebar
      await fShowMessage(`‚ùå Error processing skill data: ${err.message}`);
      return false; // Indicate failure
    }
  } // END fResetPopulateNCleanGUIRoll

  // fVerifyAbility //////////////////////////////////////////////////////////////////
  // Purpose -> Performs basic validation on the populated gUI.roll object, ensuring
  //            the ability has a name and a valid, recognized skill type.
  // Inputs  -> None (Uses gUI.roll and gUI.list).
  // Outputs -> (Promise<Boolean>): Resolves true if ability data is valid, false otherwise.
  async function fVerifyAbility() {
    const { skName, skTyp, sk1CB } = gUI.roll;

    // --- Check Name ---
    // Ability name must exist
    if (!skName) {
      await fShowMessage("‚ö†Ô∏è Please select an Ability with a name!");
      return false;
    }

    // --- Check Type ---
    // Skill Type must be a non-empty string
    if (!skTyp || typeof skTyp !== "string") {
      const is2ndCol = !sk1CB; // Check if Sk2 column was used (often typeless)
      await fShowMessage(
        `‚ö†Ô∏è No skill Typ found${
          is2ndCol ? "<br><br>You may have wanted the 1st column." : ""
        }`
      );
      return false;
    }

    // Skill type must match one of the known types defined in gUI.list.skTyp (case-insensitive)
    const skTypLower = skTyp.trim().toLowerCase();
    const isValidSkTyp = (gUI.list?.skTyp || []).some(
      (type) => type.toLowerCase() === skTypLower
    );
    if (!isValidSkTyp) {
      await fShowMessage(`‚ö†Ô∏è ${skTyp} is an invalid Skill Type!`);
      return false;
    }

    // --- Passed All Checks ---
    return true;
  } // END fVerifyAbility

  // fProcessMorph ///////////////////////////////////////////////////////////////////
  // Purpose -> Parses the ability's morph string (gUI.roll.skMorph), extracting all
  //            modifiers and flags (e.g., '+5', '*2', '^10', 'un', 'free', 'luck', '#3').
  //            Calls helper functions fParseMorphComponents and fApplyMorphResults
  //            to update the `res*` properties within gUI.roll.
  // Inputs  -> None (Reads gUI.roll.skMorph).
  // Outputs -> None (Modifies gUI.roll properties via helper functions).
  async function fProcessMorph() {
    const skMorph = gUI.roll.skMorph || ""; // Get morph string, default to empty

    // === Initialize Accumulator (Moved outside the 'if' block) ===
    // This object holds intermediate results during parsing
    const acc = {
      foundResTyp: false,
      lastResTypMatch: "",
      lastFocusTag: "",
      foundResPlus: false,
      totalPlus: 0,
      combineNumbers: [], // <<< combineNumbers is now always initialized
      foundResPlusPlus: false,
      totalPlusPlus: 0,
      foundResMult: false,
      totalMult: 1.0,
      foundResMultMult: false,
      totalMultMult: 1.0,
      lastFlatBaseMatch: "",
      lastFlatResultMatch: "",
      lastDifMatch: "",
      foundResdctMult: false,
      totalResdctMult: 1.0,
    };

    // === Parse Components (if morph string exists) ===
    if (skMorph) {
      fMyConsoleLog("   -> Processing skMorph string...");
      // Split into components and create lowercased version for checks
      const morphComponents = skMorph
        .split(",")
        .map((x) => x.trim())
        .filter(Boolean);
      const morphLower = morphComponents.map((x) => x.toLowerCase());
      // Parse components and update accumulator/gUI.roll flags
      await fParseMorphComponents(morphComponents, morphLower, acc); // Pass the initialized acc
      fMyConsoleLog("   -> Finished processing skMorph string.");
    } else {
      fMyConsoleLog("‚ÑπÔ∏è No skMorph string to process.");
    }

    // === Apply Results ===
    // Apply accumulated/default results to final gUI.roll.res* fields
    fApplyMorphResults(acc); // Always pass the initialized acc object
  } // END fProcessMorph

  // fParseMorphComponents ///////////////////////////////////////////////////////////
  // Purpose -> Helper for fProcessMorph. Iterates through individual morph string
  //            components, parsing them using regex and updating the accumulator object (`acc`)
  //            or directly setting flags in `gUI.roll` (e.g., isUnSk, isFreeRoll, isLuckedRoll, multiRollCount).
  // Inputs  -> morphComponents (Array): Array of trimmed, non-empty morph components.
  //         -> morphLower (Array): Lowercased version of morphComponents for case-insensitive checks.
  //         -> acc (Object): Accumulator object to store intermediate parsed values.
  // Outputs -> None (Mutates the input `acc` object and `gUI.roll` properties).
  async function fParseMorphComponents(morphComponents, morphLower, acc) {
    // --- Regex Definitions ---
    const plusMinusRegex = /^([-+])(\d+)$/; // e.g., +5, -10
    const numberOnlyRegex = /^\d+$/; // e.g., 20 (for Combine)
    const plusPlusMinusMinusRegex = /^(?:(\+\+)|(--))(\d+)$/; // e.g., ++5, --10
    const multDivRegex = /^([*\/])(\d+(\.\d+)?)$/; // e.g., *1.5, /2
    const multMultDivDivRegex = /^(?:(\*\*)|(\/\/))(\d+(\.\d+)?)$/; // e.g., **1.5, //2
    const equalsRegex = /^=(\d+)$/; // e.g., =50 (Set Base Sk)
    const equalsEqualsRegex = /^==(\d+)$/; // e.g., ==100 (Set Final Roll)
    const caretRegex = /^\^(\d+)$/; // e.g., ^25 (Set Difficulty)
    const dctRegex = /^([-+])(\d+)([dct])$/i; // e.g., +1c, -2t, +3d
    const multiRollRegex = /^#(\d+)$/; // e.g., #3 (Roll 3 times)

    // === Parse Each Component ===
    // Use for...of loop to allow await within the loop (for fShowMessage on errors)
    let index = 0;
    for (const component of morphComponents) {
      const lower = morphLower[index]; // Get lowercased version for checks

      // --- Check Flags (Case-Insensitive) ---
      if (lower === "free") {
        gUI.roll.isFreeRoll = true;
        fMyConsoleLog(`   -> Morph: Free Roll detected.`);
      }
      if (lower === "luck") {
        gUI.roll.isLuckedRoll = true;
        fMyConsoleLog(`   -> Morph: Lucked Roll detected.`);
      }
      if (lower === "un" || lower === "unsk") {
        gUI.roll.isUnSk = true;
      }

      // --- Check Overrides & Modifiers (using Regex) ---
      // Check SkTyp (LAST match wins)
      if ((gUI.list?.skTyp || []).some((t) => t.toLowerCase() === lower)) {
        acc.lastResTypMatch = component; // Store original case
        acc.foundResTyp = true;
      }
      // Check Focus Meta Tag (LAST match wins)
      const focusTag = lower.toUpperCase();
      if ((gUI.list?.metaColor || []).includes(focusTag)) {
        acc.lastFocusTag = focusTag; // Store uppercase tag
      }
      // Check Multi-Roll (#N)
      const multiRollMatch = component.match(multiRollRegex);
      if (multiRollMatch) {
        let count = parseInt(multiRollMatch[1], 10);
        if (!isNaN(count)) {
          if (count > 30) {
            count = 30;
            fMyConsoleLog(`   -> Morph: Multi-Roll capped at 30.`);
          }
          if (count >= 2) {
            gUI.roll.multiRollCount = count;
            fMyConsoleLog(`   -> Morph: Multi-Roll Count set to: ${count}`);
          } else {
            fMyConsoleLog(
              `   -> Morph: Multi-Roll Count ${count} ignored (< 2).`
            );
          }
        } else {
          fMyConsoleLog(
            `   -> Morph: Multi-Roll ignored (invalid number "${multiRollMatch[1]}").`
          );
        }
      }
      // Check resPlus (+/-N)
      const plusMatch = component.match(plusMinusRegex);
      if (plusMatch) {
        const val = parseInt(plusMatch[2], 10);
        acc.totalPlus += plusMatch[1] === "+" ? val : -val;
        acc.foundResPlus = true;
      }
      // Check resCombine (Number only)
      if (numberOnlyRegex.test(component)) {
        acc.combineNumbers.push(parseInt(component, 10));
      }
      // Check resPlusPlus (++ / --N)
      const ppMatch = component.match(plusPlusMinusMinusRegex);
      if (ppMatch) {
        const val = parseInt(ppMatch[3], 10);
        acc.totalPlusPlus += ppMatch[1] === "++" ? val : -val;
        acc.foundResPlusPlus = true;
      }
      // Check resMult (* / /N)
      const m1 = component.match(multDivRegex);
      if (m1) {
        const val = parseFloat(m1[2]);
        if (m1[1] === "*") {
          acc.totalMult *= val;
        } else if (val !== 0) {
          acc.totalMult /= val;
        } else {
          await fShowMessage("‚ùå Morph includes illegal '/0'. Please correct.");
          console.warn("resMult divide by zero:", component);
        }
        acc.foundResMult = true;
      }
      // Check resMultMult (** // //N)
      const m2 = component.match(multMultDivDivRegex);
      if (m2) {
        const val = parseFloat(m2[3]);
        if (m2[1] === "**") {
          acc.totalMultMult *= val;
        } else if (val !== 0) {
          acc.totalMultMult /= val;
        } else {
          await fShowMessage(
            "‚ùå Morph includes illegal '//0'. Please correct."
          );
          console.warn("resMultMult divide by zero:", component);
        }
        acc.foundResMultMult = true;
      }
      // Check resdctMult (+/-Nd/c/t)
      const dctMatch = component.match(dctRegex);
      if (dctMatch) {
        const sign = dctMatch[1];
        const num = parseInt(dctMatch[2], 10);
        const type = dctMatch[3].toLowerCase();
        let multiplier = 1.0;
        if (num !== 0) {
          // Calculate multiplier based on type (c, t, d)
          const isPositive = sign === "+";
          switch (type) {
            case "c":
              const cf = 2 * num;
              multiplier = cf === 0 ? 1 : isPositive ? cf : 1 / cf;
              break;
            case "t":
              const tf = Math.pow(10, num);
              multiplier = isPositive ? tf : 1 / tf;
              break;
            case "d":
              const dt = 1 + num / 3;
              multiplier = dt === 0 ? 1 : isPositive ? dt : 1 / dt;
              break;
          }
          if (!isNaN(multiplier) && isFinite(multiplier) && multiplier > 0) {
            // Apply if valid
            acc.totalResdctMult *= multiplier;
            acc.foundResdctMult = true;
          } else {
            console.warn(
              `Invalid DCT multiplier for "${component}": ${multiplier}.`
            );
          }
        }
      }
      // Check Flat Base (=N) (LAST match wins)
      const eq1 = component.match(equalsRegex);
      if (eq1) acc.lastFlatBaseMatch = eq1[1];
      // Check Flat Result (==N) (LAST match wins)
      const eq2 = component.match(equalsEqualsRegex);
      if (eq2) acc.lastFlatResultMatch = eq2[1];
      // Check Difficulty (^N) (LAST match wins)
      const dif = component.match(caretRegex);
      if (dif) acc.lastDifMatch = dif[1];

      index++; // Increment index for lowercased array access
    } // End component loop
  } // END fParseMorphComponents

  // fApplyMorphResults //////////////////////////////////////////////////////////////
  // Purpose -> Applies the accumulated/parsed morph results from the `acc` object
  //            (populated by fParseMorphComponents) to the final `res*` properties
  //            of the global gUI.roll object. Calculates resCombine.
  // Inputs  -> acc (Object): The accumulator object containing parsed morph results.
  // Outputs -> None (Modifies gUI.roll object properties).
  function fApplyMorphResults(acc) {
    const r = gUI.roll; // Alias for gUI.roll

    // === Apply Flat Base (=N) ===
    // MUST BE FIRST: Sets resFlatBase and potentially overrides skSk.
    if (acc.lastFlatBaseMatch !== "") {
      const num = parseInt(acc.lastFlatBaseMatch, 10);
      if (!isNaN(num)) {
        r.resFlatBase = num;
        r.skSk = num; // Override base skill if flat base is set
      }
    }

    // === Apply Resulting Type ===
    // Use last matched type, otherwise default back to original skTyp.
    if (acc.foundResTyp) {
      r.resTyp = acc.lastResTypMatch || r.skTyp;
    }
    // else: r.resTyp already defaulted to r.skTyp in fResetPopulateNCleanGUIRoll

    // === Apply Focus Meta ===
    // Use last matched valid meta color tag.
    if (acc.lastFocusTag && acc.lastFocusTag !== "") {
      r.resFocus = acc.lastFocusTag; // ('R', 'O', 'Y', 'G', 'B')
    } else {
      r.resFocus = ""; // Ensure cleared if no valid tag found
    }

    // === Apply Additive Skill Modifier (+/-N) ===
    if (acc.foundResPlus) {
      r.resPlus = acc.totalPlus;
    }

    // === Calculate Combined Skill (Diminishing Returns) ===
    // Add base skill (r.skSk, potentially overridden by resFlatBase) to numbers found in morphs.
    if (typeof r.skSk === "number" && r.skSk >= 1) {
      acc.combineNumbers.push(r.skSk);
    }
    // Calculate combined value if any numbers were collected
    if (acc.combineNumbers.length > 0) {
      acc.combineNumbers.sort((a, b) => b - a); // Sort descending
      let value = 0,
        divisor = 1;
      for (const num of acc.combineNumbers) {
        value += num / divisor;
        divisor *= 2; // Diminishing returns divisor
      }
      r.resCombine = Math.round(value); // Round final combined value
    }

    // === Apply Additive Roll Modifier (++ / --N) ===
    if (acc.foundResPlusPlus) {
      r.resPlusPlus = acc.totalPlusPlus;
    }

    // === Apply Multiplicative Skill Modifier (* / /N) ===
    if (acc.foundResMult) {
      r.resMult = Number(acc.totalMult.toFixed(6)); // Apply with precision
    }

    // === Apply Multiplicative Roll Modifier (** // //N) ===
    if (acc.foundResMultMult) {
      r.resMultMult = Number(acc.totalMultMult.toFixed(6)); // Apply with precision
    }

    // === Apply DCT Multiplier (+/-Nd/c/t) ===
    if (acc.foundResdctMult) {
      r.resdctMult = Number(acc.totalResdctMult.toFixed(6)); // Apply with precision
    }

    // === Apply Flat Result Override (==N) ===
    if (acc.lastFlatResultMatch !== "") {
      const num = parseInt(acc.lastFlatResultMatch, 10);
      if (!isNaN(num)) r.resFlatResult = num;
    }

    // === Apply Difficulty (^N) ===
    if (acc.lastDifMatch !== "") {
      const num = parseInt(acc.lastDifMatch, 10);
      if (!isNaN(num)) r.resDif = num;
    }
  } // END fApplyMorphResults

  // fVerifyNSetActMetaLuckUsesOnEtc /////////////////////////////////////////////////
  // Purpose -> Orchestrates the verification of all standard ability costs (Action Points,
  //            Uses, IsOn status update, Skill Meta, Focus Meta) based on the current
  //            gUI.roll state. Uses helper functions (fAct_Verify..., fUses_Verify..., etc.)
  //            which collect pending changes in gUI.pendingChangesMap. If all checks pass
  //            (or are overridden by user prompt), applies all collected changes at once.
  //            Logs relevant headers to the sidebar log buffer (gUI.roll.htmlHeader).
  // Inputs  -> None (Uses gUI.roll, gUI.pendingChangesMap, calls cost verification helpers).
  // Outputs -> (Promise<Boolean>): Resolves true if all costs met/overridden and applied,
  //                                resolves false if verification fails or user cancels.
  async function fVerifyNSetActMetaLuckUsesOnEtc() {
    fMyConsoleLog(
      "üõ°Ô∏è Verifying Costs & Processing 'Is On' (using Change Map)..."
    );

    // === Initialize ===
    gUI.pendingChangesMap = {}; // Clear/init map for pending grid updates { 'r,c': newValue }
    const pendingHeaders = []; // Array for sidebar log header messages

    // Helper to merge changes from verification functions into the main map
    const addChangesToMap = (changesArray) => {
      if (!Array.isArray(changesArray)) return;
      changesArray.forEach((change) => {
        if (
          change &&
          typeof change.r !== "undefined" &&
          typeof change.c !== "undefined"
        ) {
          const key = `${change.r},${change.c}`; // Key combines row/col refs
          gUI.pendingChangesMap[key] = change.value;
          // fMyConsoleLog(`   -> Pending Change Added/Updated: ${key} = ${change.value}`); // Optional debug log
        } else {
          console.warn(
            "addChangesToMap: Invalid change object received:",
            change
          );
        }
      });
    };

    // === Sequentially Verify Costs & Collect Changes/Headers ===
    // Each helper returns { success: Boolean, cancelledByUser?: Boolean, changes: Array, headers: Array }
    // If any verification fails (returns success: false), the whole process halts.

    // 1. Action Points
    const actResult = await fAct_VerifyAndProcessCost();
    if (!actResult.success) return false; // Halt if check failed or user cancelled
    addChangesToMap(actResult.changes);
    pendingHeaders.push(...actResult.headers);

    // 2. Uses
    const usesResult = await fUses_VerifyAndProcessCost(
      gUI.roll.multiRollCount
    ); // Pass multiRollCount
    if (!usesResult.success) return false; // Halt if check failed or user cancelled
    addChangesToMap(usesResult.changes);
    pendingHeaders.push(...usesResult.headers);

    // 3. Is On / Duration
    // This prepares the change to copy Duration -> IsOn if it was an Sk1 roll.
    const isOnResult = await fIsOn_VerifyAndProcessCost();
    addChangesToMap(isOnResult.changes);
    pendingHeaders.push(...isOnResult.headers); // Usually empty

    // 4. Skill Meta Cost (Applies only if Sk1 was used)
    const skMetaResult = await fSkMeta_VerifyAndProcessCost(
      gUI.pendingChangesMap
    );
    if (!skMetaResult.success) return false; // Halt if cost cannot be paid
    addChangesToMap(skMetaResult.changes);
    pendingHeaders.push(...skMetaResult.headers); // Usually empty

    // 5. Focus Meta Cost (Applies if 'Focus' morph was used)
    const focusMetaResult = await fFocus_VerifyAndProcessCost(
      gUI.pendingChangesMap
    );
    if (!focusMetaResult.success) return false; // Halt if cost cannot be paid
    addChangesToMap(focusMetaResult.changes);
    pendingHeaders.push(...focusMetaResult.headers); // Usually empty

    // === Apply All Pending Changes ===
    // This section only runs if all previous verification steps succeeded.
    fMyConsoleLog(
      "‚úÖ All Verifications Passed. Applying Pending Changes from Map..."
    );

    // Prepend collected header messages to the sidebar log buffer
    pendingHeaders.forEach((header) => fAppendToHTMLHeader(header));

    // Apply the collected grid changes from the map
    let applyErrors = false;
    const changeEntries = Object.entries(gUI.pendingChangesMap);
    fMyConsoleLog(`   -> Applying ${changeEntries.length} changes from map...`);

    for (const [key, value] of changeEntries) {
      try {
        const keyParts = key.split(",");
        if (keyParts.length !== 2) {
          // Validate key format
          console.warn(`Invalid key format in pendingChangesMap: "${key}"`);
          applyErrors = true;
          continue;
        }
        const [rowPart, colPart] = keyParts;
        // Determine if rowPart is an index or tag
        let rowRef = parseInt(rowPart, 10);
        if (isNaN(rowRef) || rowRef < 0) {
          rowRef = rowPart;
        } // Use as tag if not valid index

        // Apply change using fSetGridValue
        if (!fSetGridValue(rowRef, colPart, value)) {
          applyErrors = true; // fSetGridValue logs specific errors
          fMyConsoleLog(
            `      -> Error applying change via fSetGridValue for: ${key} = ${value}`
          );
        }
        // Optional success log: else { fMyConsoleLog(`      -> Applied: ${key} = ${value}`); }
      } catch (parseError) {
        console.error(`Error processing change key "${key}":`, parseError);
        applyErrors = true;
      }
    }

    // Clean up the map
    gUI.pendingChangesMap = {};

    // Handle potential errors during the application phase
    if (applyErrors) {
      fMyConsoleLog(
        "‚ùå Errors occurred while applying cost/state changes from the map."
      );
      await fShowMessage(
        "Error applying some cost/state changes. Please check grid state."
      );
      return false; // Indicate overall failure if application had errors
    }

    fMyConsoleLog(
      "‚úÖ Costs Verified & Changes Applied Successfully using Change Map."
    );
    return true; // Signal overall success
  } // END fVerifyNSetActMetaLuckUsesOnEtc

  // fAct_VerifyAndProcessCost ///////////////////////////////////////////////////////
  // Purpose -> Cost Verification Helper: Checks if sufficient Action Points (Act) are
  //            available based on gUI.roll.skAct. Prompts the user if insufficient,
  //            allowing them to proceed with negative AP. Collects the change to AP
  //            and any relevant sidebar log headers, but does NOT apply them directly.
  // Inputs  -> None (Uses gUI.roll, fGetGridValue, fShowPrompt).
  // Outputs -> (Promise<Object>): { success: Boolean, cancelledByUser: Boolean,
  //                                 changes: Array, headers: Array }
  //            'success' is true if cost is met or user overrides.
  //            'cancelledByUser' is true if user declines prompt.
  //            'changes' contains the change object for ('Act', 'ActTot').
  //            'headers' contains potential warning header for negative AP.
  async function fAct_VerifyAndProcessCost() {
    const { skAct, skName } = gUI.roll;
    const actCost = Number(skAct); // Get cost, ensure it's a number
    const changes = []; // Array for pending grid change
    const headers = []; // Array for pending sidebar headers

    // Only process if there's a defined Act cost > 0
    if (actCost > 0) {
      // === Get Current AP ===
      let currentAct = fGetGridValue("Act", "ActTot", true); // Get as number

      // Handle error reading current AP
      if (isNaN(currentAct)) {
        await fShowMessage(
          `‚ùå Error reading current Action Points from cell ('Act', 'ActTot'). Cannot proceed.`
        );
        fMyConsoleLog(
          "üö´ Failed to verify Act cost: Could not read Action Points."
        );
        return {
          success: false,
          cancelledByUser: false,
          changes: [],
          headers: [],
        };
      }

      // === Check Sufficiency & Prompt if Needed ===
      if (actCost > currentAct) {
        fMyConsoleLog(
          `‚ö†Ô∏è Insufficient Action Points (Need ${actCost}, Have ${currentAct})`
        );
        // Prompt user to confirm going negative
        const proceed = await fShowPrompt(
          `Not Enough Action Points (${currentAct}) to use '${skName}' (Cost: ${actCost})<br><br>Do you want to go negative?`
        );

        if (!proceed) {
          // User chose No
          fMyConsoleLog(
            "üö´ User cancelled Act cost due to insufficient points."
          );
          return {
            success: false,
            cancelledByUser: true,
            changes: [],
            headers: [],
          };
        }
        // User chose Yes
        fMyConsoleLog(
          "‚úÖ User chose to proceed despite insufficient Action Points."
        );
        headers.push(`‚ö†Ô∏è NEGATIVE ACT POINTS: ${currentAct - actCost}`); // Add warning header
      }

      // === Prepare Change ===
      // Calculate the new AP total
      const newActTotal = currentAct - actCost;
      // Add the change object to the changes array
      changes.push({ r: "Act", c: "ActTot", value: newActTotal });
      fMyConsoleLog(
        `   -> Action Points: ${currentAct} -> ${newActTotal} (Pending)`
      );
    } else {
      // No cost defined
      fMyConsoleLog("   -> No Action Point cost for this ability.");
    }

    // If execution reaches here, cost was met or overridden
    return {
      success: true,
      cancelledByUser: false,
      changes: changes,
      headers: headers,
    };
  } // END fAct_VerifyAndProcessCost

  // fUses_VerifyAndProcessCost //////////////////////////////////////////////////////
  // Purpose -> Cost Verification Helper: Checks if sufficient Uses are available based
  //            on gUI.roll.skUses and the number of rolls being made (multiRollCount).
  //            Prompts user if insufficient. Calculates the change to Uses but does
  //            NOT apply it directly.
  // Inputs  -> multiRollCount (Number): The total number of rolls for this action.
  // Outputs -> (Promise<Object>): { success: Boolean, cancelledByUser: Boolean,
  //                                 changes: Array, headers: Array }
  //            'success' is true if cost is met or user overrides.
  //            'cancelledByUser' is true if user declines prompt.
  //            'changes' contains the change object for ('ability_R', 'Uses').
  //            'headers' contains potential warning header for negative Uses.
  async function fUses_VerifyAndProcessCost(multiRollCount) {
    const { skUses, skName, ability_R } = gUI.roll; // Get Uses, Name, Row Index
    const changes = [];
    const headers = [];

    // === Check if Uses Cost Applies ===
    const currentUses = Number(skUses); // Convert stored uses to number
    // If 'Uses' field is empty or not a number, assume no cost applies
    if (skUses === "" || isNaN(currentUses)) {
      fMyConsoleLog("   -> No 'Uses' cost defined for this ability.");
      return {
        success: true,
        cancelledByUser: false,
        changes: [],
        headers: [],
      };
    }

    // === Calculate Cost & Check Sufficiency ===
    const totalUsesCost = Math.max(1, multiRollCount); // Minimum cost is 1, scales with multi-roll
    fMyConsoleLog(
      `   -> Uses Check: Current=${currentUses}, Total Cost for ${multiRollCount} rolls=${totalUsesCost}`
    );
    const newUses = currentUses - totalUsesCost; // Calculate result after cost

    // Check if cost exceeds available uses
    if (currentUses < totalUsesCost) {
      fMyConsoleLog(
        `‚ö†Ô∏è Insufficient Uses Left (Need ${totalUsesCost}, Have ${currentUses})`
      );
      // Prompt user to confirm going negative
      const proceed = await fShowPrompt(
        `Not Enough Uses Left (${currentUses}) to use '${skName}' ${multiRollCount} times (Cost: ${totalUsesCost})<br><br>Do you want to go negative?`
      );

      if (!proceed) {
        // User chose No
        fMyConsoleLog(
          "üö´ User cancelled Uses cost due to insufficient points."
        );
        return {
          success: false,
          cancelledByUser: true,
          changes: [],
          headers: [],
        };
      }
      // User chose Yes
      fMyConsoleLog("‚úÖ User chose to proceed despite insufficient Uses.");
      headers.push(`‚ö†Ô∏è NEGATIVE USES: ${newUses}`); // Add warning header
    }

    // === Prepare Change ===
    // Add change object using the original ability row index
    changes.push({ r: ability_R, c: "Uses", value: newUses });
    fMyConsoleLog(
      `   -> Uses: ${currentUses} -> ${newUses} (Pending, cost: ${totalUsesCost})`
    );

    // If execution reaches here, cost was met or overridden
    return {
      success: true,
      cancelledByUser: false,
      changes: changes,
      headers: headers,
    };
  } // END fUses_VerifyAndProcessCost

  // fIsOn_VerifyAndProcessCost //////////////////////////////////////////////////////
  // Purpose -> Cost "Verification" Helper: Prepares the change object to copy the
  //            ability's Duration (gUI.roll.skDur) to its 'Is On' cell, but ONLY if
  //            the roll originated from the Sk1 checkbox (gUI.roll.sk1CB is true).
  //            This effectively sets the duration timer when an Sk1 ability is used.
  // Inputs  -> None (Uses gUI.roll).
  // Outputs -> (Promise<Object>): { success: true, changes: Array, headers: Array }
  //            'changes' contains the change object {r: ability_R, c: 'On', value: skDur} if Sk1 used.
  //            'headers' is always empty.
  // NOTE: Made async for consistency, though not strictly required.
  async function fIsOn_VerifyAndProcessCost() {
    const { skDur, ability_R, sk1CB } = gUI.roll; // Get Duration, Row Index, Sk1 Flag
    const changes = [];
    const headers = []; // Headers not used by this function

    // Only prepare change if Sk1 checkbox triggered the roll
    if (sk1CB === true) {
      // Prepare change to set 'On' column to the ability's duration value
      changes.push({ r: ability_R, c: "On", value: skDur });
      fMyConsoleLog(
        `   -> Is On: Set to Dur value '${skDur}' (Pending, Sk1 condition met)`
      );
    } else {
      // If Sk2 triggered, no duration is set
      fMyConsoleLog(
        `   -> Is On: No change (Condition sk1CB === true not met)`
      );
    }

    // This function always returns success as there's no failure condition
    return { success: true, changes: changes, headers: headers };
  } // END fIsOn_VerifyAndProcessCost

  // fSkMeta_VerifyAndProcessCost ////////////////////////////////////////////////////
  // Purpose -> Cost Verification Helper: Checks and prepares the change for the
  //            ability's innate Meta cost (defined in gUI.roll.skMeta), but only if
  //            the roll originated from the Sk1 checkbox. Uses fSpendOneMeta to find
  //            an available Meta unit (starting from the specified color) considering
  //            pending changes. Halts if cost cannot be paid.
  // Inputs  -> pendingChangesMap (Object): Map of changes pending from previous cost checks.
  // Outputs -> (Promise<Object>): { success: Boolean, changes: Array, headers: Array }
  //            'success' is false if cost cannot be paid.
  //            'changes' contains the change object for the Meta cell if successful.
  //            'headers' is always empty.
  async function fSkMeta_VerifyAndProcessCost(pendingChangesMap) {
    const { sk1CB, skMeta, skName } = gUI.roll; // Get Sk1 flag, Meta cost tag, Ability Name
    const changes = [];
    const headers = []; // Headers not used by this function

    // === 1. Check Sk1 Condition ===
    // Skill Meta cost typically only applies to Sk1 abilities
    if (sk1CB !== true) {
      fMyConsoleLog(
        "   -> SkMeta Cost: Skipped (Condition sk1CB === true not met)"
      );
      return { success: true, changes: [], headers: [] }; // No cost to apply
    }

    // === 2. Check if Meta Cost is Defined ===
    const metaColorTag = String(skMeta || "")
      .trim()
      .toUpperCase(); // Get tag from gUI.roll
    if (!metaColorTag) {
      fMyConsoleLog(
        "   -> SkMeta Cost: Skipped (No Meta Color Tag defined in skMeta field)."
      );
      return { success: true, changes: [], headers: [] }; // No cost to apply
    }

    // === 3. Attempt to Spend Meta ===
    // Call helper to find 1 unit of specified (or higher) meta, considering pending changes
    fMyConsoleLog(
      `   -> SkMeta Cost: Attempting to spend 1 unit of '${metaColorTag}'...`
    );
    const spendResult = await fSpendOneMeta(metaColorTag, pendingChangesMap);

    // === 4. Handle Result ===
    if (spendResult.success) {
      // Meta unit found, add the prepared change object
      fMyConsoleLog("      -> Success: Found 1 unit to spend for SkMeta cost.");
      changes.push(spendResult.change);
      return { success: true, changes: changes, headers: headers };
    } else {
      // Failed (either invalid tag or insufficient meta)
      // fSpendOneMeta shows message for invalid tag; show "Not enough" only if tag was valid
      const metaColors = gUI.list?.metaColor || [];
      const isValidColor = metaColors.some(
        (c) => c.toUpperCase() === metaColorTag
      );
      if (isValidColor) {
        fMyConsoleLog(
          `      -> ‚ùå Failed: Could not find 1 unit of ${metaColorTag} for SkMeta.`
        );
        await fShowMessage(
          `‚ùå Not enough Meta.<br>${skName} needs @${metaColorTag}.`
        );
      }
      return { success: false, changes: [], headers: [] }; // Indicate failure
    }
  } // END fSkMeta_VerifyAndProcessCost

  // fFocus_VerifyAndProcessCost ///////////////////////////////////////////////////
  // Purpose -> Cost Verification Helper: Checks and prepares the change for the Focus
  //            Meta cost, if specified by a morph setting gUI.roll.resFocus to a valid
  //            Meta color tag ('R'...'B'). Uses fSpendOneMeta to find an available unit,
  //            considering pending changes. Halts if cost cannot be paid.
  // Inputs  -> pendingChangesMap (Object): Map of changes pending from previous cost checks.
  // Outputs -> (Promise<Object>): { success: Boolean, changes: Array, headers: Array }
  //            'success' is false if cost cannot be paid or tag is invalid.
  //            'changes' contains the change object for the Meta cell if successful.
  //            'headers' is always empty.
  async function fFocus_VerifyAndProcessCost(pendingChangesMap) {
    const focusColorTag = gUI.roll.resFocus; // Get the Focus tag ('R'..'B' or '')
    const changes = [];
    const headers = []; // Headers not used by this function
    const metaColors = gUI.list?.metaColor; // e.g., ['R','O','Y','G','B']

    // === 1. Check if Focus Cost Applies ===
    if (!focusColorTag || typeof focusColorTag !== "string") {
      fMyConsoleLog(
        "   -> Focus Meta Cost: Skipped (No resFocus tag defined)."
      );
      return { success: true, changes: [], headers: [] }; // No focus cost
    }

    // === 2. Validate Focus Tag ===
    // Check against defined meta colors
    if (!Array.isArray(metaColors) || metaColors.length === 0) {
      console.error(
        "fFocus_VerifyAndProcessCost: gUI.list.metaColor is not defined or empty."
      );
      await fShowMessage("‚ùå Internal Error: Meta color list not defined.");
      return { success: false, changes: [], headers: [] };
    }
    // Ensure tag is one of the allowed colors (case-insensitive check, though stored uppercase)
    const isValidFocusTag = metaColors.includes(focusColorTag.toUpperCase());
    if (!isValidFocusTag) {
      const msg = `Invalid Focus Meta tag specified in morph: '${focusColorTag}'. Allowed: ${metaColors.join(
        ", "
      )}.`;
      console.warn(`fFocus_VerifyAndProcessCost: ${msg}`);
      fMyConsoleLog(`   -> ‚ùå Focus Meta Cost Failed: ${msg}`);
      await fShowMessage(`‚ùå ${msg}`);
      return { success: false, changes: [], headers: [] }; // Fail due to invalid tag
    }

    // === 3. Attempt to Spend Meta ===
    fMyConsoleLog(
      `   -> Focus Meta Cost: Attempting to spend 1 unit of '${focusColorTag}' (Focus)...`
    );
    // Call helper, passing the specific tag and pending changes
    const spendResult = await fSpendOneMeta(focusColorTag, pendingChangesMap);

    // === 4. Handle Result ===
    if (spendResult.success) {
      // Meta unit found, add the prepared change object
      fMyConsoleLog(
        `      -> Success: Found 1 unit of Focus Meta (${focusColorTag}) to spend.`
      );
      changes.push(spendResult.change);
      return { success: true, changes: changes, headers: headers };
    } else {
      // Failed (fSpendOneMeta handles invalid tag message)
      fMyConsoleLog(
        `      -> ‚ùå Failed: Could not find 1 unit of ${focusColorTag} (or higher) to spend for Focus.`
      );
      // Show specific "Not enough" message for Focus cost
      const errorMsg = `‚ùå Not enough Meta.<br>In addition to possible ability meta cost,<br>you are also trying to Focus @${focusColorTag}.`;
      await fShowMessage(errorMsg);
      return { success: false, changes: [], headers: [] }; // Indicate failure
    }
  } // END fFocus_VerifyAndProcessCost

  // fSpendOneMeta ///////////////////////////////////////////////////////////////////
  // Purpose -> Helper to find 1 available unit of Meta (checking Channel pool first,
  //            then Main pool) and prepare the change object for decrementing it.
  //            Starts checking from the specified `metaColor` and cycles upwards if needed
  //            (R -> O -> Y -> G -> B). Considers pending changes from `pendingChangesMap`.
  //            Sets the new value to '' (empty string) if decrementing results in < 1.
  // Inputs  -> metaColor (String): The preferred Meta color TAG ('R'...'B') to start spending from.
  //         -> pendingChangesMap (Object): Map holding pending changes {'rTag,cTag': newValue}.
  // Outputs -> (Promise<Object>): Resolves to { success: true, change: { r, c, value } } if 1 unit found,
  //                               or { success: false } if invalid color or no unit found.
  async function fSpendOneMeta(metaColor, pendingChangesMap) {
    fMyConsoleLog(
      `   -> Attempting to spend 1 Meta unit, starting check from: ${metaColor}`
    );

    // === 1. Validate Input Color Tag ===
    const metaColors = gUI.list?.metaColor; // e.g., ['R','O','Y','G','B']
    // Validate meta color list definition
    if (!Array.isArray(metaColors) || metaColors.length === 0) {
      console.error(
        "fSpendOneMeta: gUI.list.metaColor is not defined or empty."
      );
      await fShowMessage("‚ùå Internal Error: Meta color list not defined.");
      return { success: false };
    }
    // Find the index of the starting color (case-insensitive)
    const inputColorUpper = metaColor?.toUpperCase();
    const startIndex = metaColors.findIndex(
      (color) => color.toUpperCase() === inputColorUpper
    );
    // Validate the input color tag exists in the list
    if (startIndex === -1) {
      fMyConsoleLog(
        `      -> ‚ùå Invalid input: Meta Color '${metaColor}' is not allowed.`
      );
      await fShowMessage(`‚ùå Meta Color '${metaColor}' is not allowed.`);
      return { success: false };
    }
    const validMetaColorTag = metaColors[startIndex]; // Use the correctly cased tag from list
    fMyConsoleLog(
      `      -> Validated start color: ${validMetaColorTag} (Index: ${startIndex})`
    );

    // === Helper to Get Current Value (Considering Pending Changes) ===
    const getCurrentValue = (rowTag, colTag) => {
      const key = `${rowTag},${colTag}`;
      // Check if this cell has a pending change
      if (pendingChangesMap.hasOwnProperty(key)) {
        const pendingValue = Number(pendingChangesMap[key]);
        // Use pending value if it's a number >= 1, otherwise treat as 0
        // (Prevents double-spending from a value already pending decrement to < 1)
        return !isNaN(pendingValue) && pendingValue >= 1 ? pendingValue : 0;
      } else {
        // No pending change, read from grid, default invalid/blank/< 1 to 0
        const gridVal = fGetGridValue(rowTag, colTag, true);
        return gridVal >= 1 ? gridVal : 0; // Only count values >= 1
      }
    };

    // === 2. Cycle Through Colors (From Start Index Upwards) ===
    const numColors = metaColors.length;
    // Loop from the starting color index up to the last color ('B')
    for (let i = startIndex; i < numColors; i++) {
      const currentColorTag = metaColors[i];
      fMyConsoleLog(`         - Checking Color: ${currentColorTag}`);

      // --- Check Channel Pool ---
      const chnlVal = getCurrentValue("chnl", currentColorTag);
      if (chnlVal >= 1) {
        // Found 1+ in Channel pool
        const newVal = chnlVal - 1;
        // Prepare change: new value is newVal, or '' if newVal is 0
        const change = {
          r: "chnl",
          c: currentColorTag,
          value: newVal >= 1 ? newVal : "",
        };
        fMyConsoleLog(
          `           - Found in Channel pool. Preparing change: ${JSON.stringify(
            change
          )}`
        );
        return { success: true, change: change }; // Success!
      }

      // --- Check Main Pool (if not found in Channel) ---
      const metaVal = getCurrentValue("meta", currentColorTag);
      if (metaVal >= 1) {
        // Found 1+ in Main pool
        const newVal = metaVal - 1;
        // Prepare change: new value is newVal, or '' if newVal is 0
        const change = {
          r: "meta",
          c: currentColorTag,
          value: newVal >= 1 ? newVal : "",
        };
        fMyConsoleLog(
          `           - Found in Main pool. Preparing change: ${JSON.stringify(
            change
          )}`
        );
        return { success: true, change: change }; // Success!
      }

      // If not found in either pool for this color, log and continue loop
      fMyConsoleLog(`           - Not found in ${currentColorTag} pools.`);
    } // --- End Color Cycle Loop ---

    // === 3. Not Found ===
    // If loop completes without returning, no unit was found
    fMyConsoleLog(
      `      -> ‚ùå Failed: Could not find 1 unit of Meta to spend after checking colors ${validMetaColorTag} through ${
        metaColors[numColors - 1]
      }.`
    );
    return { success: false }; // Indicate failure
  } // END fSpendOneMeta

  // fPerformStandardRolls ///////////////////////////////////////////////////////////
  // Purpose -> Handles the standard multi-roll loop for abilities targeting a specific
  //            difficulty (either from a '^' morph or for non-monster-interaction types).
  //            Calculates roll results, accumulates wounds for multi-roll AR/DMG,
  //            builds individual log lines, and constructs the final log entry HTML,
  //            including potential total wound display and 'Apply Wounds' button for AR.
  // Inputs  -> initialLogHtml (String): Pre-built log header (costs, title, morph).
  // Outputs -> (String): Complete HTML string for the sidebar log entry.
  function fPerformStandardRolls(initialLogHtml) {
    const multiRollCount = gUI.roll.multiRollCount;
    const resTypLower = (gUI.roll.resTyp || "").toLowerCase();
    const isArmorRoll = resTypLower === "ar";
    const isDamageRoll = resTypLower === "dmg";
    let totalWoundsOverall = 0; // Accumulator for wounds (relevant for multi-roll AR/DMG)

    fMyConsoleLog(
      `üîÑ Starting Standard Roll Loop (${multiRollCount} rolls)...`
    );
    const rollResultLines = []; // Array to hold HTML for each individual roll line

    // === Perform Rolls ===
    for (let rollNum = 1; rollNum <= multiRollCount; rollNum++) {
      const isFirstRoll = rollNum === 1; // Flag for T/C roll on first iteration
      fMyConsoleLog(`   --- Roll ${rollNum} of ${multiRollCount} ---`);

      // Recalculate roll values for this iteration
      fCalcGUIRollResSk(); // Calculate skill after modifiers
      fCalcGUIRollRoll(); // Perform the base die roll
      fCalcGUIRollResRoll(); // Apply roll modifiers

      // === Accumulate Wounds (for multi-roll AR/DMG) ===
      // Only accumulate if more than one roll is happening
      if (multiRollCount > 1) {
        const currentRollResult = gUI.roll.resRoll;
        const difficulty = gUI.roll.resDif;
        let woundsDealtThisRoll = 0;

        if (
          isArmorRoll &&
          typeof currentRollResult === "number" &&
          typeof difficulty === "number" &&
          currentRollResult !== 0
        ) {
          // AR Wounds = -(Difficulty / ArmorRollResult), rounded, min 0 damage taken (max 0 wounds)
          woundsDealtThisRoll = Math.min(
            0,
            Math.round(-(difficulty / currentRollResult))
          );
          fMyConsoleLog(
            `      -> Accumulating AR Wounds: ${woundsDealtThisRoll}`
          );
          totalWoundsOverall += woundsDealtThisRoll;
        } else if (
          isDamageRoll &&
          typeof currentRollResult === "number" &&
          typeof difficulty === "number" &&
          difficulty !== 0
        ) {
          // DMG Wounds = (Roll / ArmorDifficulty), rounded, min 0 damage dealt
          woundsDealtThisRoll = Math.max(
            0,
            Math.round(currentRollResult / difficulty)
          );
          fMyConsoleLog(
            `      -> Accumulating DMG Wounds: +${woundsDealtThisRoll}`
          );
          totalWoundsOverall += woundsDealtThisRoll;
        } else if (isArmorRoll || isDamageRoll) {
          // Log if AR/DMG but inputs were invalid for wound calculation
          fMyConsoleLog(
            `      -> Skipping Wound Accumulation: Invalid input (Dif=${difficulty}, Roll=${currentRollResult})`
          );
        }
      } // End wound accumulation block

      // Build HTML line for this specific roll
      const rollLineHtml = fBuildRollLogHTML(
        rollNum,
        multiRollCount,
        isFirstRoll
      );
      rollResultLines.push(rollLineHtml); // Store the line
    } // --- End Roll Loop ---

    // === Combine Header and Results ===
    let finalLogHtml = initialLogHtml;
    if (rollResultLines.length > 0) {
      if (finalLogHtml) finalLogHtml += "<br>"; // Add separator if header exists
      finalLogHtml += rollResultLines.join("<br>"); // Join individual roll lines
    }

    // === Add Total Wounds Line (if applicable) ===
    // Only add if it was multi-roll AR or DMG
    if (multiRollCount > 1) {
      if (isArmorRoll) {
        finalLogHtml += "<br>‚Üì"; // Separator
        const positiveWoundAmount = Math.abs(totalWoundsOverall); // For button data
        // Add total wounds line with 'Apply' button
        finalLogHtml += `<br><span class="red-bold">Total Wounds to PC = ${totalWoundsOverall}</span> <button class="apply-wounds-btn" data-wound-amount="${positiveWoundAmount}">Apply</button>`;
        fMyConsoleLog(
          `      -> Added Total AR Wounds line: ${totalWoundsOverall} (Button amount: ${positiveWoundAmount})`
        );
      } else if (isDamageRoll) {
        finalLogHtml += "<br>‚Üì"; // Separator
        // Add total damage line (no button needed for monster damage currently)
        finalLogHtml += `<br><span style="font-weight:bold;">Total Wounds = +${totalWoundsOverall}</span>`;
        fMyConsoleLog(
          `      -> Added Total DMG Wounds line: +${totalWoundsOverall}`
        );
      }
    }

    fMyConsoleLog(`‚úÖ Standard Roll Loop Completed.`);
    return finalLogHtml; // Return the complete HTML for the log entry
  } // END fPerformStandardRolls

  // fPerformPlayerAttackRolls ///////////////////////////////////////////////////////
  // Purpose -> Handles 'Atk' rolls against monsters listed in the grid when no explicit
  //            difficulty ('^') morph is present. Uses the 'MonDef' column for difficulty.
  //            Validates targets, performs rolls, counts successes per monster, builds log lines,
  //            stores success results in history, and adds a "Prep Dmg" button if successes occurred.
  //            Falls back to fPerformStandardRolls if no valid monster targets are found.
  // Inputs  -> initialLogHtml (String): Pre-built log header string.
  // Outputs -> (Promise<Object>): { logHtml: String, success: Boolean }
  //            'success' is false if validation fails before rolling.
  async function fPerformPlayerAttackRolls(initialLogHtml) {
    fMyConsoleLog("   -> Entering Player Attack Logic...");

    // === 1. Get Monster Range & Validate ===
    const monsterRangeDef = gUI.range?.monsters;
    if (!monsterRangeDef || !fIsValidRangeObject(monsterRangeDef)) {
      const msg =
        "Monster range definition (gUI.range.monsters) missing/invalid.";
      console.warn(`fPerformPlayerAttackRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", success: false }; // Indicate failure
    }

    // === 2. Resolve Indices ===
    const resolved = fResolveRangeIndices(monsterRangeDef);
    if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
      const msg = `Could not resolve monster range tags: ${JSON.stringify(
        monsterRangeDef
      )}`;
      console.warn(`fPerformPlayerAttackRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", success: false };
    }
    const rMin = Math.min(resolved.r1, resolved.r2);
    const rMax = Math.max(resolved.r1, resolved.r2);
    const cNumMon = resolveCol("NumMon");
    const cMonDef = resolveCol("MonDef"); // Difficulty column for Attack
    const cMonName = resolveCol("MonName");

    if ([cNumMon, cMonDef, cMonName].some(isNaN)) {
      const msg =
        "Could not resolve required monster column tags (NumMon, MonDef, MonName).";
      console.warn(`fPerformPlayerAttackRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", success: false };
    }
    fMyConsoleLog(
      `      -> Monster Table Range: Rows ${rMin}-${rMax}, Cols Def:${cMonDef}, Num:${cNumMon}, Name:${cMonName}`
    );

    // === 3. Identify & Validate Targets ===
    const monsterTargets = []; // Stores { mon_R, numRolls, monName, monDef, numSuccesses }
    const allTargetedRows_R = []; // Stores row indices of ALL valid targets found
    const firstMonsterRowIndex = rMin; // Index of the 'Custom' monster row

    for (let mon_R = rMin; mon_R <= rMax; mon_R++) {
      const isCustomRow = mon_R === firstMonsterRowIndex;
      const numMonRaw = gUI.arr?.[mon_R]?.[cNumMon];
      const numMon = parseInt(numMonRaw, 10); // Number of this monster type present

      // Check if NumMon is valid (1-30)
      if (!isNaN(numMon) && numMon >= 1 && numMon <= 30) {
        fMyConsoleLog(`      -> Row ${mon_R}: Found valid NumMon: ${numMon}`);
        const monDefRaw = gUI.arr?.[mon_R]?.[cMonDef];
        const monDef = Number(monDefRaw); // Monster's Defense value

        // Validate Defense value (must be a non-empty number)
        if (isNaN(monDef) || String(monDefRaw).trim() === "") {
          let errMsg = `‚ùå Invalid Monster Defense ('${monDefRaw}') found in row ${
            mon_R + 1
          }. Cannot complete attack.`;
          if (isCustomRow)
            errMsg = `‚ùå Invalid Monster Defense ('${monDefRaw}') found for Custom Monster. Cannot complete attack.`;
          fMyConsoleLog(`         -> Validation Failed: ${errMsg}`);
          await fShowMessage(errMsg);
          return { logHtml: "", success: false }; // Halt on invalid defense
        }

        // Get monster name, handling custom row naming
        let originalMonName = String(gUI.arr?.[mon_R]?.[cMonName] || "").trim();
        let monName = originalMonName || `Row ${mon_R + 1}`; // Default name if blank
        if (isCustomRow) monName = `Custom ${originalMonName}`.trim(); // Prepend "Custom"

        // Add valid target to list
        monsterTargets.push({
          mon_R,
          numRolls: numMon,
          monName,
          monDef,
          numSuccesses: 0,
        });
        allTargetedRows_R.push(mon_R); // Track all rows targeted
        fMyConsoleLog(
          `         -> Valid Target Added: Name='${monName}', Def=${monDef}, Rolls=${numMon} (Row index ${mon_R} added)`
        );
      } else {
        // Log if NumMon is present but invalid
        if (numMonRaw !== "" && numMonRaw != null)
          fMyConsoleLog(
            `      -> Row ${mon_R}: Skipping - Invalid NumMon value: '${numMonRaw}'`
          );
      }
    } // End target identification loop

    // === 4. Handle No Valid Targets ===
    if (monsterTargets.length === 0) {
      fMyConsoleLog(
        "      -> No valid monster targets found. Performing standard attack roll instead."
      );
      await fShowMessage(
        "‚ÑπÔ∏è No valid monsters found. Performing standard attack roll."
      );
      gUI.roll.resDif = ""; // Ensure difficulty is cleared for standard roll
      fMyConsoleLog("         -> Cleared resDif for standard roll.");
      const standardRollHtml = fPerformStandardRolls(initialLogHtml); // Fallback roll
      return { logHtml: standardRollHtml, success: true };
    }

    // === 5. Perform Rolls Against Valid Targets ===
    fMyConsoleLog(
      `      -> Found ${monsterTargets.length} valid monster target(s).`
    );
    let isOverallFirstRoll = true; // For T/C tracking
    const monsterLogLines = []; // HTML lines for each monster/roll
    const currentAttackResults = []; // Store results only for monsters hit {mon_R, monName, numSuccesses}

    for (const target of monsterTargets) {
      fMyConsoleLog(
        `   --- Attacking: ${target.monName} (Def: ${target.monDef}, Rolls: ${target.numRolls}) ---`
      );
      monsterLogLines.push("‚Üì"); // Separator
      monsterLogLines.push(
        `--- <span style="color: purple; font-weight: bold;">Mon: ${target.monName}</span> (Def: ${target.monDef}) ---`
      );
      gUI.roll.resDif = target.monDef; // Set difficulty for this monster

      // Perform rolls for the number of monsters of this type
      for (let rollNum = 1; rollNum <= target.numRolls; rollNum++) {
        fMyConsoleLog(
          `      -> Roll ${rollNum} of ${target.numRolls} against ${target.monName}...`
        );
        // Recalculate player roll values for this attack
        fCalcGUIRollResSk();
        fCalcGUIRollRoll();
        fCalcGUIRollResRoll();

        const rollResult = gUI.roll.resRoll;
        const difficulty = gUI.roll.resDif;

        // Check for success (Attack Roll >= Monster Defense)
        if (
          typeof rollResult === "number" &&
          typeof difficulty === "number" &&
          rollResult >= difficulty
        ) {
          target.numSuccesses++; // Increment success count for this monster
          fMyConsoleLog(
            `         -> Attack Succeeded! (Roll ${rollResult} >= Def ${difficulty}). Success count: ${target.numSuccesses}`
          );
        } else {
          fMyConsoleLog(
            `         -> Attack Failed! (Roll ${rollResult} < Def ${difficulty})`
          );
        }

        // Build HTML line for this individual roll
        const rollLineHtml = fBuildRollLogHTML(
          rollNum,
          target.numRolls,
          isOverallFirstRoll
        );
        monsterLogLines.push(rollLineHtml);
        if (isOverallFirstRoll) isOverallFirstRoll = false; // T/C only on the very first roll
      } // End inner roll loop

      fMyConsoleLog(
        `   --- Finished Attacking: ${target.monName} (${target.numSuccesses} successes) ---`
      );
      // Add result to temp array only if > 0 successes occurred
      if (target.numSuccesses > 0) {
        fMyConsoleLog(
          `      -> Storing result for ${target.monName}: mon_R=${target.mon_R}, numSuccesses=${target.numSuccesses}`
        );
        currentAttackResults.push({
          mon_R: target.mon_R,
          monName: target.monName,
          numSuccesses: target.numSuccesses,
        });
      }
    } // End monster target loop

    // === 6. Finalize Log, Store Results, Add Button ===
    let finalLogHtml = initialLogHtml + "<br>" + monsterLogLines.join("<br>"); // Combine header and roll lines
    let rollId = null;

    // Add "Prep Dmg" button and store results in history ONLY if there were successes
    if (currentAttackResults.length > 0) {
      rollId = "prep_" + Date.now(); // Generate unique ID
      // Store successful results, original ability row, and all targeted rows
      gUI.monsterRollResultsHistory[rollId] = {
        results: currentAttackResults,
        originalAbilityRow: gUI.roll.ability_R,
        allTargetedRows_R: allTargetedRows_R,
      };
      fMyConsoleLog(
        `   -> Stored attack results in gUI.monsterRollResultsHistory['${rollId}'] (Origin Row: ${
          gUI.roll.ability_R
        }, All Targets: [${allTargetedRows_R.join(", ")}])`
      );
      // Append button to log HTML
      finalLogHtml += ` <button class="prep-dmg-btn" data-roll-id="${rollId}">Prep Dmg</button>`;
      fMyConsoleLog("   -> Added 'Prep Dmg' button to log output.");
    } else {
      fMyConsoleLog(
        "   -> No successes recorded, 'Prep Dmg' button not added, nothing stored in history."
      );
    }

    fMyConsoleLog("   -> Player Attack Logic Complete.");
    return { logHtml: finalLogHtml, success: true }; // Return final log and success status
  } // END fPerformPlayerAttackRolls

  // fPerformPlayerDamageRolls /////////////////////////////////////////////////////
  // Purpose -> Handles 'DMG' rolls against monsters listed in the grid when no explicit
  //            difficulty ('^') morph is present. Uses 'MonAR' column to calculate Armor
  //            Difficulty (AR/10, min 1). Calculates Wounds per roll (Roll / Armor Difficulty),
  //            sums wounds per monster, and builds log lines. Falls back to standard roll
  //            if no valid targets with MonAR are found.
  // Inputs  -> initialLogHtml (String): Pre-built log header string.
  // Outputs -> (Promise<Object>): Resolves with { logHtml: String, success: Boolean }.
  //            'success' is false if validation fails before rolling.
  async function fPerformPlayerDamageRolls(initialLogHtml) {
    fMyConsoleLog("   -> Entering Player Damage Logic...");

    // === 1. Get Monster Range & Validate ===
    const monsterRangeDef = gUI.range?.monsters;
    if (!monsterRangeDef || !fIsValidRangeObject(monsterRangeDef)) {
      const msg =
        "Monster range definition (gUI.range.monsters) missing/invalid.";
      console.warn(`fPerformPlayerDamageRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", success: false };
    }

    // === 2. Resolve Indices (Including MonAR) ===
    const resolved = fResolveRangeIndices(monsterRangeDef);
    if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
      const msg = `Could not resolve monster range tags: ${JSON.stringify(
        monsterRangeDef
      )}`;
      console.warn(`fPerformPlayerDamageRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", success: false };
    }
    const rMin = Math.min(resolved.r1, resolved.r2);
    const rMax = Math.max(resolved.r1, resolved.r2);
    const cNumMon = resolveCol("NumMon");
    const cMonAR = resolveCol("MonAR"); // Difficulty source for Damage
    const cMonName = resolveCol("MonName");

    if ([cNumMon, cMonAR, cMonName].some(isNaN)) {
      const msg =
        "Could not resolve required monster column tags (NumMon, MonAR, MonName).";
      console.warn(`fPerformPlayerDamageRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", success: false };
    }
    fMyConsoleLog(
      `      -> Monster Table Range: Rows ${rMin}-${rMax}, Cols AR:${cMonAR}, Num:${cNumMon}, Name:${cMonName}`
    );

    // === 3. Identify & Validate Targets (Using MonAR) ===
    const monsterTargets = []; // Stores { mon_R, numRolls, monName, calculatedArmor }
    const firstMonsterRowIndex = rMin;

    for (let mon_R = rMin; mon_R <= rMax; mon_R++) {
      const isCustomRow = mon_R === firstMonsterRowIndex;
      const numMonRaw = gUI.arr?.[mon_R]?.[cNumMon];
      const numMon = parseInt(numMonRaw, 10); // Number of monsters

      // Check if NumMon is valid
      if (!isNaN(numMon) && numMon >= 1 && numMon <= 30) {
        fMyConsoleLog(`      -> Row ${mon_R}: Found valid NumMon: ${numMon}`);
        const monARRaw = gUI.arr?.[mon_R]?.[cMonAR]; // Get Base Armor value
        const monARBase = Number(monARRaw);

        // Validate Base Armor (must be non-empty number)
        if (isNaN(monARBase) || String(monARRaw).trim() === "") {
          let errMsg = `‚ùå Invalid Monster Armor value ('${monARRaw}') found in row ${
            mon_R + 1
          }. Cannot complete damage roll.`;
          if (isCustomRow)
            errMsg = `‚ùå Invalid Monster Armor value ('${monARRaw}') found for Custom Monster. Cannot complete damage roll.`;
          fMyConsoleLog(`         -> Validation Failed: ${errMsg}`);
          await fShowMessage(errMsg);
          return { logHtml: "", success: false }; // Halt
        }

        // Calculate final Armor Difficulty for damage rolls (AR/10, min 1, keep 1 decimal)
        const calculatedArmor = Math.max(1, monARBase / 10).toFixed(1);
        fMyConsoleLog(
          `         -> Calculated Armor Difficulty: ${monARBase}/10=${
            monARBase / 10
          } -> max(1, ${monARBase / 10}) -> ${calculatedArmor}`
        );

        // Get monster name
        let originalMonName = String(gUI.arr?.[mon_R]?.[cMonName] || "").trim();
        let monName = originalMonName || `Row ${mon_R + 1}`;
        if (isCustomRow) monName = `Custom ${originalMonName}`.trim();

        // Add valid target
        monsterTargets.push({
          mon_R,
          numRolls: numMon,
          monName,
          calculatedArmor: Number(calculatedArmor),
        });
        fMyConsoleLog(
          `         -> Valid Target Added: Name='${monName}', Calculated AR=${calculatedArmor}, Rolls=${numMon}`
        );
      } else {
        if (numMonRaw !== "" && numMonRaw != null)
          fMyConsoleLog(
            `      -> Row ${mon_R}: Skipping - Invalid NumMon value: '${numMonRaw}'`
          );
      }
    } // End target identification loop

    // === 4. Handle No Valid Targets ===
    if (monsterTargets.length === 0) {
      fMyConsoleLog(
        "      -> No valid monster targets found (with MonAR). Performing standard damage roll instead."
      );
      await fShowMessage(
        "‚ÑπÔ∏è No valid monsters found with Armor values. Performing standard damage roll."
      );
      gUI.roll.resDif = ""; // Clear difficulty for standard roll
      fMyConsoleLog("         -> Cleared resDif for standard roll.");
      const standardRollHtml = fPerformStandardRolls(initialLogHtml); // Fallback roll
      return { logHtml: standardRollHtml, success: true };
    }

    // === 5. Perform Rolls & Build Log ===
    fMyConsoleLog(
      `      -> Found ${monsterTargets.length} valid monster target(s) with Armor values.`
    );
    let isOverallFirstRoll = true; // For T/C tracking
    const monsterLogLines = []; // HTML lines for each monster/roll

    for (const target of monsterTargets) {
      fMyConsoleLog(
        `   --- Damaging: ${target.monName} (Calc AR: ${target.calculatedArmor}, Rolls: ${target.numRolls}) ---`
      );
      let totalWoundsPerMonster = 0; // Accumulator for this monster

      monsterLogLines.push("‚Üì"); // Separator
      monsterLogLines.push(
        `--- <span style="color: purple; font-weight: bold;">Mon: ${target.monName}</span> (AR: ${target.calculatedArmor}) ---`
      );
      gUI.roll.resDif = target.calculatedArmor; // Set difficulty for this monster's damage roll

      // Perform rolls for the number of monsters of this type
      for (let rollNum = 1; rollNum <= target.numRolls; rollNum++) {
        fMyConsoleLog(
          `      -> Damage Roll ${rollNum} of ${target.numRolls} against ${target.monName}...`
        );
        // Recalculate player roll values
        fCalcGUIRollResSk();
        fCalcGUIRollRoll();
        fCalcGUIRollResRoll(); // Player's final damage roll value

        // --- Calculate Wounds (Damage Roll / Calculated Armor, round, min 0) ---
        const rollResult = gUI.roll.resRoll;
        const armorDifficulty = gUI.roll.resDif; // The calculated armor (>= 1)
        let woundsDealt = 0;
        // Only calculate if roll is number and difficulty > 0 (already guaranteed >= 1)
        if (
          typeof rollResult === "number" &&
          typeof armorDifficulty === "number"
        ) {
          woundsDealt = Math.max(0, Math.round(rollResult / armorDifficulty));
        }
        fMyConsoleLog(
          `         -> Wound Calc: Dmg Roll=${rollResult}, calcAR=${armorDifficulty} => Wounds = max(0, round(${rollResult}/${armorDifficulty})) = ${woundsDealt}`
        );
        totalWoundsPerMonster += woundsDealt; // Accumulate wounds for this monster
        // --- End Wound Calculation ---

        // Build HTML line for this individual roll (handles DMG format)
        const rollLineHtml = fBuildRollLogHTML(
          rollNum,
          target.numRolls,
          isOverallFirstRoll
        );
        monsterLogLines.push(rollLineHtml);
        if (isOverallFirstRoll) isOverallFirstRoll = false; // T/C only on first roll
      } // End inner roll loop

      // Add Wound Summation Line for this monster
      monsterLogLines.push(
        `<span style="font-weight:bold;">${target.monName} Total Wounds = +${totalWoundsPerMonster}</span>`
      );
      fMyConsoleLog(
        `   --- Finished Damaging: ${target.monName} (Total Wounds: ${totalWoundsPerMonster}) ---`
      );
    } // End monster target loop

    // === 6. Return Result ===
    const finalLogHtml = initialLogHtml + "<br>" + monsterLogLines.join("<br>"); // Combine header and roll lines
    fMyConsoleLog("   -> Player Damage Logic Complete.");
    return { logHtml: finalLogHtml, success: true }; // Return final log and success status
  } // END fPerformPlayerDamageRolls

  // fPerformPlayerDefenseRolls ////////////////////////////////////////////////////
  // Purpose -> Handles 'Def' rolls against monsters listed in the grid when no explicit
  //            difficulty ('^') morph is present. Uses the 'MonAtk' column for difficulty.
  //            Validates targets, performs rolls, counts defense failures per monster,
  //            builds log lines, stores failure results in history, and adds a "Prep AR"
  //            button if failures occurred. Falls back to standard roll if no valid targets.
  // Inputs  -> initialLogHtml (String): Pre-built log header string.
  // Outputs -> (Promise<Object>): { logHtml: String, success: Boolean }
  //            'success' is false if validation fails before rolling.
  async function fPerformPlayerDefenseRolls(initialLogHtml) {
    fMyConsoleLog("   -> Entering Player Defense Logic...");

    // === 1. Get Monster Range & Validate ===
    const monsterRangeDef = gUI.range?.monsters;
    if (!monsterRangeDef || !fIsValidRangeObject(monsterRangeDef)) {
      const msg =
        "Monster range definition (gUI.range.monsters) missing/invalid.";
      console.warn(`fPerformPlayerDefenseRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", success: false };
    }

    // === 2. Resolve Indices (Including MonAtk) ===
    const resolved = fResolveRangeIndices(monsterRangeDef);
    if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
      const msg = `Could not resolve monster range tags: ${JSON.stringify(
        monsterRangeDef
      )}`;
      console.warn(`fPerformPlayerDefenseRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", success: false };
    }
    const rMin = Math.min(resolved.r1, resolved.r2);
    const rMax = Math.max(resolved.r1, resolved.r2);
    const cNumMon = resolveCol("NumMon");
    const cMonAtk = resolveCol("MonAtk"); // Difficulty column for Defense
    const cMonName = resolveCol("MonName");

    if ([cNumMon, cMonAtk, cMonName].some(isNaN)) {
      const msg =
        "Could not resolve required monster column tags (NumMon, MonAtk, MonName).";
      console.warn(`fPerformPlayerDefenseRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", success: false };
    }
    fMyConsoleLog(
      `      -> Monster Table Range: Rows ${rMin}-${rMax}, Cols Atk:${cMonAtk}, Num:${cNumMon}, Name:${cMonName}`
    );

    // === 3. Identify & Validate Targets (Using MonAtk) ===
    const monsterTargets = []; // Stores { mon_R, numRolls, monName, monAtk, numFailures }
    const allTargetedRows_R = []; // Stores row indices of ALL valid targets found
    const firstMonsterRowIndex = rMin;

    for (let mon_R = rMin; mon_R <= rMax; mon_R++) {
      const isCustomRow = mon_R === firstMonsterRowIndex;
      const numMonRaw = gUI.arr?.[mon_R]?.[cNumMon];
      const numMon = parseInt(numMonRaw, 10); // Number of monsters

      // Check if NumMon is valid
      if (!isNaN(numMon) && numMon >= 1 && numMon <= 30) {
        fMyConsoleLog(`      -> Row ${mon_R}: Found valid NumMon: ${numMon}`);
        const monAtkRaw = gUI.arr?.[mon_R]?.[cMonAtk];
        const monAtk = Number(monAtkRaw); // Monster's Attack value

        // Validate Attack value (must be non-empty number)
        if (isNaN(monAtk) || String(monAtkRaw).trim() === "") {
          let errMsg = `‚ùå Invalid Monster Attack value ('${monAtkRaw}') found in row ${
            mon_R + 1
          }. Cannot complete defense roll.`;
          if (isCustomRow)
            errMsg = `‚ùå Invalid Monster Attack value ('${monAtkRaw}') found for Custom Monster. Cannot complete defense roll.`;
          fMyConsoleLog(`         -> Validation Failed: ${errMsg}`);
          await fShowMessage(errMsg);
          return { logHtml: "", success: false }; // Halt
        }

        // Get monster name
        let originalMonName = String(gUI.arr?.[mon_R]?.[cMonName] || "").trim();
        let monName = originalMonName || `Row ${mon_R + 1}`;
        if (isCustomRow) monName = `Custom ${originalMonName}`.trim();

        // Add valid target
        monsterTargets.push({
          mon_R,
          numRolls: numMon,
          monName,
          monAtk,
          numFailures: 0,
        });
        allTargetedRows_R.push(mon_R); // Track all targeted rows
        fMyConsoleLog(
          `         -> Valid Target Added: Name='${monName}', Atk=${monAtk}, Rolls=${numMon} (Row index ${mon_R} added)`
        );
      } else {
        if (numMonRaw !== "" && numMonRaw != null)
          fMyConsoleLog(
            `      -> Row ${mon_R}: Skipping - Invalid NumMon value: '${numMonRaw}'`
          );
      }
    } // End target identification loop

    // === 4. Handle No Valid Targets ===
    if (monsterTargets.length === 0) {
      fMyConsoleLog(
        "      -> No valid monster targets found (with MonAtk). Performing standard defense roll instead."
      );
      await fShowMessage(
        "‚ÑπÔ∏è No valid monsters found with Attack values. Performing standard defense roll."
      );
      gUI.roll.resDif = ""; // Clear difficulty for standard roll
      fMyConsoleLog("         -> Cleared resDif for standard roll.");
      const standardRollHtml = fPerformStandardRolls(initialLogHtml); // Fallback roll
      return { logHtml: standardRollHtml, success: true };
    }

    // === 5. Perform Rolls & Build Log ===
    fMyConsoleLog(
      `      -> Found ${monsterTargets.length} valid monster target(s) with Attack values.`
    );
    let isOverallFirstRoll = true; // For T/C tracking
    const monsterLogLines = []; // HTML lines for each monster/roll
    const currentDefenseResults = []; // Store results {mon_R, monName, numFailures} only for monsters with failures

    for (const target of monsterTargets) {
      fMyConsoleLog(
        `   --- Defending Against: ${target.monName} (Atk: ${target.monAtk}, Rolls: ${target.numRolls}) ---`
      );
      monsterLogLines.push("‚Üì"); // Separator
      monsterLogLines.push(
        `--- <span style="color: purple; font-weight: bold;">Mon: ${target.monName}</span> (Atk: ${target.monAtk}) ---`
      );
      gUI.roll.resDif = target.monAtk; // Set difficulty for this target

      // Perform rolls for the number of monsters of this type
      for (let rollNum = 1; rollNum <= target.numRolls; rollNum++) {
        fMyConsoleLog(
          `      -> Defense Roll ${rollNum} of ${target.numRolls} against ${target.monName}...`
        );
        // Recalculate player roll values
        fCalcGUIRollResSk();
        fCalcGUIRollRoll();
        fCalcGUIRollResRoll(); // Player's final defense roll

        const rollResult = gUI.roll.resRoll;
        const difficulty = gUI.roll.resDif; // Which is target.monAtk

        // Check for failure (Defense Roll < Monster Attack)
        if (
          typeof rollResult === "number" &&
          typeof difficulty === "number" &&
          rollResult < difficulty
        ) {
          target.numFailures++; // Increment failure count for this monster
          fMyConsoleLog(
            `         -> Defense Failed! (Roll ${rollResult} < Atk ${difficulty}). Failure count: ${target.numFailures}`
          );
        } else {
          fMyConsoleLog(
            `         -> Defense Succeeded! (Roll ${rollResult} >= Atk ${difficulty})`
          );
        }

        // Build HTML line for this individual roll
        const rollLineHtml = fBuildRollLogHTML(
          rollNum,
          target.numRolls,
          isOverallFirstRoll
        );
        monsterLogLines.push(rollLineHtml);
        if (isOverallFirstRoll) isOverallFirstRoll = false; // T/C only on first roll
      } // End inner roll loop

      fMyConsoleLog(
        `   --- Finished Defending Against: ${target.monName} (${target.numFailures} failures) ---`
      );
      // Add result to temp array only if > 0 failures occurred
      if (target.numFailures > 0) {
        currentDefenseResults.push({
          mon_R: target.mon_R,
          monName: target.monName,
          numFailures: target.numFailures, // Store failure count
        });
      }
    } // End monster target loop

    // === 6. Finalize Log, Store Results, Add Button ===
    let finalLogHtml = initialLogHtml + "<br>" + monsterLogLines.join("<br>"); // Combine header and roll lines
    let rollId = null;

    // Add "Prep AR" button and store results in history ONLY if there were failures
    if (currentDefenseResults.length > 0) {
      rollId = "prep_" + Date.now(); // Generate unique ID
      // Store failure results, original ability row, and all targeted rows
      gUI.monsterRollResultsHistory[rollId] = {
        results: currentDefenseResults,
        originalAbilityRow: gUI.roll.ability_R,
        allTargetedRows_R: allTargetedRows_R,
      };
      fMyConsoleLog(
        `   -> Data stored for rollId '${rollId}'. History keys: ${Object.keys(
          gUI.monsterRollResultsHistory
        ).join(", ")}`
      );
      // Append button to log HTML
      finalLogHtml += ` <button class="prep-ar-btn" data-roll-id="${rollId}">Prep AR</button>`;
      fMyConsoleLog("   -> Added 'Prep AR' button to log output.");
    } else {
      fMyConsoleLog("   -> No failures recorded, 'Prep AR' button not added.");
    }

    fMyConsoleLog("   -> Player Defense Logic Complete.");
    return { logHtml: finalLogHtml, success: true }; // Return final log and success status
  } // END fPerformPlayerDefenseRolls

  // fPerformPlayerArmorRolls //////////////////////////////////////////////////////
  // Purpose -> Handles 'AR' (Armor) rolls against monsters listed in the grid when
  //            no explicit difficulty ('^') morph is present. Uses the 'MonDmg' column
  //            for difficulty. Calculates wounds inflicted on the player based on
  //            -(MonDmg / PlayerARRoll), sums wounds per monster and overall, builds
  //            log lines, and adds an "Apply Wounds" button to the total. Falls back
  //            to standard roll if no valid targets with MonDmg are found.
  // Inputs  -> initialLogHtml (String): Pre-built log header string.
  // Outputs -> (Promise<Object>): Resolves with { logHtml: String, success: Boolean }.
  //            'success' is false if validation fails before rolling.
  async function fPerformPlayerArmorRolls(initialLogHtml) {
    fMyConsoleLog("   -> Entering Player Armor Logic...");

    // === 1. Get Monster Range & Validate ===
    const monsterRangeDef = gUI.range?.monsters;
    if (!monsterRangeDef || !fIsValidRangeObject(monsterRangeDef)) {
      const msg =
        "Monster range definition (gUI.range.monsters) missing/invalid.";
      console.warn(`fPerformPlayerArmorRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", success: false };
    }

    // === 2. Resolve Indices (Including MonDmg) ===
    const resolved = fResolveRangeIndices(monsterRangeDef);
    if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
      const msg = `Could not resolve monster range tags: ${JSON.stringify(
        monsterRangeDef
      )}`;
      console.warn(`fPerformPlayerArmorRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", success: false };
    }
    const rMin = Math.min(resolved.r1, resolved.r2);
    const rMax = Math.max(resolved.r1, resolved.r2);
    const cNumMon = resolveCol("NumMon");
    const cMonDmg = resolveCol("MonDmg"); // Difficulty source for Armor
    const cMonName = resolveCol("MonName");

    if ([cNumMon, cMonDmg, cMonName].some(isNaN)) {
      const msg =
        "Could not resolve required monster column tags (NumMon, MonDmg, MonName).";
      console.warn(`fPerformPlayerArmorRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", success: false };
    }
    fMyConsoleLog(
      `      -> Monster Table Range: Rows ${rMin}-${rMax}, Cols Dmg:${cMonDmg}, Num:${cNumMon}, Name:${cMonName}`
    );

    // === 3. Identify & Validate Targets (Using MonDmg) ===
    const monsterTargets = []; // Stores { mon_R, numRolls, monName, monDmg }
    const firstMonsterRowIndex = rMin;

    for (let mon_R = rMin; mon_R <= rMax; mon_R++) {
      const isCustomRow = mon_R === firstMonsterRowIndex;
      const numMonRaw = gUI.arr?.[mon_R]?.[cNumMon];
      const numMon = parseInt(numMonRaw, 10); // Number of monsters

      // Check if NumMon is valid
      if (!isNaN(numMon) && numMon >= 1 && numMon <= 30) {
        fMyConsoleLog(`      -> Row ${mon_R}: Found valid NumMon: ${numMon}`);
        const monDmgRaw = gUI.arr?.[mon_R]?.[cMonDmg]; // Get Monster Damage
        const monDmg = Number(monDmgRaw);

        // Validate Damage value (must be non-empty number)
        if (isNaN(monDmg) || String(monDmgRaw).trim() === "") {
          let errMsg = `‚ùå Invalid Monster Damage ('${monDmgRaw}') found in row ${
            mon_R + 1
          }. Cannot complete armor roll.`;
          if (isCustomRow)
            errMsg = `‚ùå Invalid Monster Damage ('${monDmgRaw}') found for Custom Monster. Cannot complete armor roll.`;
          fMyConsoleLog(`         -> Validation Failed: ${errMsg}`);
          await fShowMessage(errMsg);
          return { logHtml: "", success: false }; // Halt
        }

        // Get monster name
        let originalMonName = String(gUI.arr?.[mon_R]?.[cMonName] || "").trim();
        let monName = originalMonName || `Row ${mon_R + 1}`;
        if (isCustomRow) monName = `Custom ${originalMonName}`.trim();

        // Add valid target
        monsterTargets.push({ mon_R, numRolls: numMon, monName, monDmg });
        fMyConsoleLog(
          `         -> Valid Target Added: Name='${monName}', Dmg=${monDmg}, Rolls=${numMon}`
        );
      } else {
        if (numMonRaw !== "" && numMonRaw != null)
          fMyConsoleLog(
            `      -> Row ${mon_R}: Skipping - Invalid NumMon value: '${numMonRaw}'`
          );
      }
    } // End target identification loop

    // === 4. Handle No Valid Targets ===
    if (monsterTargets.length === 0) {
      fMyConsoleLog(
        "      -> No valid monster targets found (with MonDmg). Performing standard armor roll instead."
      );
      await fShowMessage(
        "‚ÑπÔ∏è No valid monsters found with Damage values. Performing standard armor roll."
      );
      gUI.roll.resDif = ""; // Clear difficulty for standard roll
      fMyConsoleLog("         -> Cleared resDif for standard roll.");
      const standardRollHtml = fPerformStandardRolls(initialLogHtml); // Fallback roll
      return { logHtml: standardRollHtml, success: true };
    }

    // === 5. Perform Rolls & Build Log ===
    fMyConsoleLog(
      `      -> Found ${monsterTargets.length} valid monster target(s) with Damage values.`
    );
    let isOverallFirstRoll = true; // For T/C tracking
    const monsterLogLines = []; // HTML lines for each monster/roll
    let totalWoundsOverall = 0; // Accumulator for total wounds taken by player

    for (const target of monsterTargets) {
      fMyConsoleLog(
        `   --- Rolling Armor vs: ${target.monName} (Dmg: ${target.monDmg}, Rolls: ${target.numRolls}) ---`
      );
      let totalWoundsPerMonster = 0; // Accumulator for this monster

      monsterLogLines.push("‚Üì"); // Separator
      monsterLogLines.push(
        `--- <span style="color: purple; font-weight: bold;">Mon: ${target.monName}</span> (Dmg: ${target.monDmg}) ---`
      );
      gUI.roll.resDif = target.monDmg; // Set difficulty for this armor roll

      // Perform rolls for the number of monsters of this type
      for (let rollNum = 1; rollNum <= target.numRolls; rollNum++) {
        fMyConsoleLog(
          `      -> Armor Roll ${rollNum} of ${target.numRolls} against ${target.monName}...`
        );
        // Recalculate player roll values
        fCalcGUIRollResSk();
        fCalcGUIRollRoll();
        fCalcGUIRollResRoll(); // Player's final armor roll result

        // --- Calculate Wounds Inflicted This Roll ---
        const armorRollResult = gUI.roll.resRoll;
        const monsterDamage = gUI.roll.resDif; // Which is target.monDmg
        let woundsDealt = 0;
        // Formula: -(MonsterDamage / PlayerArmorRoll), rounded, max 0 (min 0 damage taken)
        if (
          typeof armorRollResult === "number" &&
          armorRollResult !== 0 &&
          typeof monsterDamage === "number"
        ) {
          woundsDealt = Math.min(
            0,
            Math.round(-(monsterDamage / armorRollResult))
          );
          fMyConsoleLog(
            `         -> Wound Calc: Dmg=${monsterDamage}, AR Roll=${armorRollResult} => Wounds = min(0, round(-(${monsterDamage}/${armorRollResult}))) = ${woundsDealt}`
          );
        } else {
          fMyConsoleLog(
            `         -> Wound Calc: Invalid input (Dmg=${monsterDamage}, AR Roll=${armorRollResult}). Wounds = 0`
          );
        }
        // Accumulate wounds
        totalWoundsPerMonster += woundsDealt;
        totalWoundsOverall += woundsDealt;
        // --- End Wound Calculation ---

        // Build HTML line for this individual roll (handles AR format)
        const rollLineHtml = fBuildRollLogHTML(
          rollNum,
          target.numRolls,
          isOverallFirstRoll
        );
        monsterLogLines.push(rollLineHtml);
        if (isOverallFirstRoll) isOverallFirstRoll = false; // T/C only on first roll
      } // End inner roll loop

      // Add Wound Summation Line for this specific monster
      monsterLogLines.push(
        `<span style="font-weight:bold;">${target.monName} Wounds to PC = ${totalWoundsPerMonster}</span>`
      );
      fMyConsoleLog(
        `   --- Finished Rolling vs: ${target.monName} (Wounds This Monster: ${totalWoundsPerMonster}) ---`
      );
    } // End monster target loop

    // === 6. Add Overall Wound Summation & Button ===
    monsterLogLines.push("‚Üì"); // Separator
    const positiveWoundAmount = Math.abs(totalWoundsOverall); // Get positive value for button data
    // Add total wounds line (red/bold) and the "Apply" button
    monsterLogLines.push(
      `<span class="red-bold">Total Wounds to PC = ${totalWoundsOverall}</span> <button class="apply-wounds-btn" data-wound-amount="${positiveWoundAmount}">Apply</button>`
    );
    fMyConsoleLog(
      `      -> Overall Wounds Inflicted on PC: ${totalWoundsOverall} (Button amount: ${positiveWoundAmount})`
    );

    // === 7. Return Result ===
    const finalLogHtml = initialLogHtml + "<br>" + monsterLogLines.join("<br>"); // Combine header and roll lines
    fMyConsoleLog("   -> Player Armor Logic Complete.");
    return { logHtml: finalLogHtml, success: true }; // Return final log and success status
  } // END fPerformPlayerArmorRolls

  // fCalcGUIRollResSk ///////////////////////////////////////////////////////////////
  // Purpose -> Calculates the final resulting skill value (gUI.roll.resSk) before the
  //            die roll, applying various morph modifiers (Combine, Mult, dctMult, Plus,
  //            Focus bonus, UnSk penalty) to the base skill value (gUI.roll.skSk or
  //            gUI.roll.resFlatBase). Clamps results >= 1, rounds, stores in gUI.roll.resSk.
  // Inputs  -> None (Reads from gUI.roll properties).
  // Outputs -> None (Writes final calculated value to gUI.roll.resSk).
  function fCalcGUIRollResSk() {
    let currentResSk; // Variable to hold intermediate calculation

    // === Determine Base Skill Value ===
    // Prioritize resCombine (calculated from number morphs + skSk), then skSk (potentially from =N morph)
    if (typeof gUI.roll.resCombine === "number" && gUI.roll.resCombine !== "") {
      currentResSk = gUI.roll.resCombine;
      // fMyConsoleLog("   -> Using resCombine as base for resSk calculation.");
    } else if (typeof gUI.roll.skSk === "number" && gUI.roll.skSk !== "") {
      currentResSk = gUI.roll.skSk;
    } else {
      currentResSk = NaN; // No valid base skill found
    }

    // === Apply Modifiers (only if base is valid number) ===
    if (!isNaN(currentResSk)) {
      // 1. Apply Multiplicative Modifiers first
      // Apply resMult (* / /N morphs)
      if (typeof gUI.roll.resMult === "number" && gUI.roll.resMult !== "") {
        currentResSk *= gUI.roll.resMult;
      }
      // Apply resdctMult (+/-Nd/c/t morphs)
      if (
        typeof gUI.roll.resdctMult === "number" &&
        gUI.roll.resdctMult !== ""
      ) {
        currentResSk *= gUI.roll.resdctMult;
      }

      // 2. Apply Additive Modifiers
      // Apply resPlus (+/-N morphs)
      if (typeof gUI.roll.resPlus === "number" && gUI.roll.resPlus !== "") {
        currentResSk += gUI.roll.resPlus;
      }
      // Apply Focus bonus (based on resFocus tag 'R'...'B')
      const focusTag = gUI.roll.resFocus;
      if (focusTag && typeof focusTag === "string" && gUI.list?.metaColor) {
        const focusIndex = gUI.list.metaColor.indexOf(focusTag.toUpperCase());
        if (focusIndex > -1) {
          // Check if tag was found
          const focusBonus = 5 * (1 + focusIndex); // R=5, O=10, Y=15, G=20, B=25
          currentResSk += focusBonus;
          fMyConsoleLog(
            `      -> Applying Focus Bonus: +${focusBonus} (Tag: ${focusTag}, Index: ${focusIndex})`
          );
        }
      }

      // 3. Apply Unskilled Penalty (if applicable)
      // Halves the skill value AFTER other modifiers
      if (gUI.roll.isUnSk === true) {
        currentResSk *= 0.5;
      }

      // 4. Final Clamping & Rounding
      // Clamp tiny positive values to 1 (minimum skill value)
      if (currentResSk > 0 && currentResSk < 1) {
        currentResSk = 1;
      }
      // Assign final value: round if >= 1, otherwise set to empty string
      if (currentResSk >= 1) {
        // Check >= 1 (implicitly checks !isNaN too)
        gUI.roll.resSk = Math.round(currentResSk);
      } else {
        gUI.roll.resSk = ""; // Invalid result (e.g., negative, NaN, < 1) becomes empty
      }
    } else {
      // If base skill was invalid, resulting skill is empty
      gUI.roll.resSk = "";
    }

    fMyConsoleLog(`‚öôÔ∏è Calculated final resSk: ${gUI.roll.resSk}`);
  } // END fCalcGUIRollResSk

  // fCalcGUIRollRoll ////////////////////////////////////////////////////////////////
  // Purpose -> Calculates the initial "raw" die roll result (stored in gUI.roll.roll)
  //            based on the calculated resulting skill (gUI.roll.resSk) and the final
  //            roll type (gUI.roll.resTyp). Calls the appropriate dice rolling function
  //            (fCSDSk, fCSAtk, fCSDef, etc.).
  // Inputs  -> None (Reads gUI.roll.resSk, gUI.roll.resTyp).
  // Outputs -> None (Writes the raw roll result to gUI.roll.roll).
  function fCalcGUIRollRoll() {
    const resSkValue = gUI.roll.resSk; // The calculated skill value to roll against
    const resTypValue =
      typeof gUI.roll.resTyp === "string"
        ? gUI.roll.resTyp.trim().toLowerCase()
        : ""; // Final roll type

    // === Validate Skill Value ===
    // Must have a valid skill value (number >= 1) to perform a roll
    if (typeof resSkValue !== "number" || resSkValue < 1) {
      gUI.roll.roll = ""; // Set roll to empty if no valid skill
      fMyConsoleLog(
        `‚ÑπÔ∏è Cannot calculate roll: Invalid resSk value (${resSkValue}).`
      );
      return;
    }

    // === Select Roll Function Based on Type ===
    switch (resTypValue) {
      case "": // No type defined
        gUI.roll.roll = "";
        break;
      case "sk": // Standard Skill
      case "atr": // Attribute
      case "str": // Strength (currently uses Sk roll)
        gUI.roll.roll = fCSDSk(resSkValue);
        break;
      case "atk": // Attack
        gUI.roll.roll = fCSAtk(resSkValue);
        break;
      case "dmg": // Damage
        gUI.roll.roll = fCSDDmg(resSkValue);
        break;
      case "def": // Defense
        gUI.roll.roll = fCSDef(resSkValue);
        break;
      case "ar": // Armor (can return decimal)
        gUI.roll.roll = fCSDArmor(resSkValue);
        break;
      case "un": // Unskilled (should ideally be handled by resSk calc)
      case "unsk":
        console.warn(
          `fCalcGUIRollRoll: Roll type '${resTypValue}' used directly. Check morph logic.`
        );
        gUI.roll.roll = fCSDSk(resSkValue); // Fallback to Sk roll
        break;
      default: // Unknown type
        console.warn(
          `fCalcGUIRollRoll: Unknown resTyp '${resTypValue}'. Cannot calculate roll.`
        );
        gUI.roll.roll = "";
        break;
    }

    fMyConsoleLog(`‚öôÔ∏è Calculated roll (${resTypValue}): ${gUI.roll.roll}`);
  } // END fCalcGUIRollRoll

  // fCalcGUIRollResRoll /////////////////////////////////////////////////////////////
  // Purpose -> Calculates the *final* roll result (gUI.roll.resRoll) after applying
  //            any applicable roll modifiers (resMultMult, resPlusPlus, resdctMult)
  //            or overrides (resFlatResult) to the initial raw roll (gUI.roll.roll).
  //            Handles rounding appropriately (AR allows decimals). Clamps result >= 0.
  // Inputs  -> None (Reads gUI.roll properties).
  // Outputs -> None (Writes final calculated value to gUI.roll.resRoll).
  function fCalcGUIRollResRoll() {
    // === 1. Check for Flat Result Override (==N) ===
    // This takes precedence over all other modifiers.
    const flatResult = gUI.roll.resFlatResult;
    if (typeof flatResult === "number" && flatResult !== "") {
      const isArType = (gUI.roll.resTyp || "").toLowerCase() === "ar";
      // Round override appropriately (AR keeps 2 decimals)
      const roundedFlatResult = isArType
        ? Number(flatResult.toFixed(2))
        : Math.round(flatResult);
      // Apply override, ensuring minimum of 0
      gUI.roll.resRoll = Math.max(0, roundedFlatResult);
      fMyConsoleLog(
        `‚öôÔ∏è Calculated resRoll (OVERRIDE ==${flatResult}, ${
          isArType ? "AR-rounded" : "INT-rounded"
        }): ${gUI.roll.resRoll}`
      );
      return; // Exit early
    }

    // === 2. Validate Base Roll Value ===
    const initialRoll = gUI.roll.roll; // Get the raw roll calculated by fCalcGUIRollRoll
    // Check if the raw roll is a valid number
    if (
      typeof initialRoll !== "number" ||
      initialRoll === "" ||
      isNaN(initialRoll)
    ) {
      gUI.roll.resRoll = ""; // Cannot calculate final roll without valid base roll
      fMyConsoleLog(
        `‚ÑπÔ∏è Cannot calculate resRoll: Invalid initial roll value (${initialRoll}).`
      );
      return;
    }

    // === 3. Apply Roll Modifiers ===
    let currentResRoll = initialRoll; // Start with the raw roll

    // Apply resMultMult (** // //N morphs)
    if (
      typeof gUI.roll.resMultMult === "number" &&
      gUI.roll.resMultMult !== ""
    ) {
      currentResRoll *= gUI.roll.resMultMult;
    }
    // Apply resdctMult (+/-Nd/c/t morphs)
    if (typeof gUI.roll.resdctMult === "number" && gUI.roll.resdctMult !== "") {
      currentResRoll *= gUI.roll.resdctMult;
    }
    // Apply resPlusPlus (++ / --N morphs)
    if (
      typeof gUI.roll.resPlusPlus === "number" &&
      gUI.roll.resPlusPlus !== ""
    ) {
      currentResRoll += gUI.roll.resPlusPlus;
    }

    // === 4. Final Rounding, Clamping, and Assignment ===
    if (!isNaN(currentResRoll)) {
      // Check if result is still a valid number
      const isArType = (gUI.roll.resTyp || "").toLowerCase() === "ar";
      // Round AR to 2 decimal places, others to integer
      const roundedResRoll = isArType
        ? Number(currentResRoll.toFixed(2))
        : Math.round(currentResRoll);
      // Assign final result, clamped at minimum 0
      gUI.roll.resRoll = Math.max(0, roundedResRoll);
    } else {
      // If calculation resulted in NaN, set final result to empty
      gUI.roll.resRoll = "";
      console.warn(
        "fCalcGUIRollResRoll: Roll modifier calculation resulted in NaN."
      );
    }

    fMyConsoleLog(`‚öôÔ∏è Calculated final resRoll: ${gUI.roll.resRoll}`);
  } // END fCalcGUIRollResRoll

  // fCalcRollLogPrepend /////////////////////////////////////////////////////////////
  // Purpose -> Builds the final HTML log message for a single roll using
  //            fBuildRollLogHTML and prepends it to the Roll Log sidebar.
  //            Ensures the sidebar is visible.
  // Inputs  -> None (Relies on gUI.roll state populated by previous calculations).
  // Outputs -> None (Modifies sidebar DOM).
  function fCalcRollLogPrepend() {
    // Build the HTML string for the current roll result
    const html = fBuildRollLogHTML(1, 1, true); // Assumes single roll for this direct call context

    // Prepend the generated HTML to the sidebar
    fPrependToSidebar(html);
    // Ensure the sidebar is visible
    fShowSidebar();

    fMyConsoleLog("üì∞ Roll Log message prepended.");
  } // END fCalcRollLogPrepend

  // fBuildRollLogHTML ///////////////////////////////////////////////////////////////
  // Purpose -> Constructs and returns the formatted HTML log line for a *single roll*
  //            result based on the current state of gUI.roll. Handles formatting for
  //            different roll types (standard, AR, DMG), multi-roll prefixes, T/C results,
  //            skill value display (Sk->ResSk), roll value display (~Roll->ResRoll),
  //            difficulty indicators, and success/failure/wound results.
  // Inputs  -> rollNum (Number): Current roll number in a multi-roll sequence (e.g., 1).
  //         -> totalRolls (Number): Total number of rolls in the sequence (e.g., 3).
  //         -> isFirstRoll (Boolean): True if this is the first roll (for T/C).
  // Outputs -> (String): HTML string representing one formatted roll log line.
  function fBuildRollLogHTML(rollNum, totalRolls, isFirstRoll) {
    // === Get Data from gUI.roll ===
    const resTyp = (gUI.roll.resTyp || "").trim(); // Final roll type
    const resTypLower = resTyp.toLowerCase();
    const skSk = gUI.roll.skSk; // Base skill
    const resSk = gUI.roll.resSk; // Skill after mods
    const roll = gUI.roll.roll; // Raw roll result
    const resRoll = gUI.roll.resRoll; // Final roll result after mods/override
    const dif = gUI.roll.resDif; // Difficulty value
    const hasDifficulty =
      (typeof dif === "number" || (typeof dif === "string" && dif !== "")) &&
      dif != null;

    // === Build Log Components ===

    // 1. Base String: Type(Sk->ResSk)
    let rollBase = resTyp;
    if (typeof skSk === "number" && skSk !== "") {
      rollBase += `(${skSk}${
        typeof resSk === "number" && resSk !== "" && resSk !== skSk
          ? `->${resSk}`
          : ""
      })`;
    } else if (typeof resSk === "number" && resSk !== "") {
      rollBase += `(${resSk})`;
    }

    // 2. Roll Result String: ~Roll->ResRoll (unless AR vs Dmg)
    let rollResult = "";
    if (!(resTypLower === "ar" && hasDifficulty)) {
      // AR vs Dmg difficulty shown differently
      if (
        (typeof roll === "number" ||
          (typeof roll === "string" && roll !== "")) &&
        roll != null
      ) {
        rollResult += ` ~${roll}`;
        if (
          (typeof resRoll === "number" ||
            (typeof resRoll === "string" && resRoll !== "")) &&
          resRoll != null &&
          String(resRoll) !== String(roll)
        ) {
          rollResult += `->${resRoll}`; // Show final if different
        }
      } else if (
        (typeof resRoll === "number" ||
          (typeof resRoll === "string" && resRoll !== "")) &&
        resRoll != null
      ) {
        rollResult += ` ~${resRoll}`; // Show final if raw was invalid
      }
    }

    // 3. Difficulty Indicator
    let rollDifIndicator = "";
    if (hasDifficulty) {
      if (resTypLower === "ar") {
        // Format: Dmg/~PlayerARRoll
        rollDifIndicator = ` ${dif}/~${
          typeof resRoll === "number" ? resRoll : "?"
        }`;
      } else if (resTypLower === "dmg") {
        // Format: /ArmorDifficulty
        rollDifIndicator = `/${dif}`;
      } else {
        // Standard Format: ^Difficulty
        rollDifIndicator = ` ^${dif}`;
      }
    }

    // 4. Success/Failure/Wound Delta
    let rollSuccessDelta = "";
    if (hasDifficulty && typeof resRoll === "number") {
      if (resTypLower === "ar") {
        // Calculate AR Wounds
        let wounds = 0;
        if (resRoll !== 0) wounds = Math.min(0, Math.round(-(dif / resRoll)));
        rollSuccessDelta = ` = ${wounds} Wnds`;
      } else if (resTypLower === "dmg") {
        // Calculate DMG Wounds
        let wounds = 0;
        if (dif !== 0) wounds = Math.max(0, Math.round(resRoll / dif));
        rollSuccessDelta = ` = +${wounds} Wounds`;
      } else {
        // Standard Success/Failure Check
        const delta = resRoll - dif;
        rollSuccessDelta = delta >= 0 ? ` =+${delta} ‚úÖ` : ` =${delta} ‚ùå`;
      }
    }

    // === Combine Components ===
    let rollLine =
      `${rollBase}${rollResult}${rollDifIndicator}${rollSuccessDelta}`.trim();

    // === Add T/C Result (First Roll Only) ===
    const tc = isFirstRoll ? fCStc() : "";
    if (rollLine && tc) rollLine += `   ${tc}`; // Add with spacing

    // === Add Multi-Roll Prefix ===
    if (totalRolls > 1) {
      rollLine = `<span class="roll-prefix">${rollNum}></span> ${rollLine}`;
    }

    return rollLine; // Return the complete HTML line
  } // END fBuildRollLogHTML

  // ==========================================================================
  // === Post Combat Buttons         (End of Die Roll Button ) ===
  // ==========================================================================

  // fHandlePrepARClick ////////////////////////////////////////////////////////////
  // Purpose -> Handles clicks on the "Prep AR" button in the sidebar. Reads defense
  //            failure data from gUI.monsterRollResultsHistory using the button's
  //            rollId. Updates 'NumMon' for ALL originally targeted monsters (setting
  //            to failure count or '' if 0). Switches the active checkbox from Sk1 (Def)
  //            to Sk2 (AR) on the original ability row. Disables button and cleans up history.
  // Inputs  -> event (MouseEvent): The click event object.
  // Outputs -> None (Modifies grid data/DOM, gUI state, button state).
  async function fHandlePrepARClick(event) {
    const button = event.target;

    // === 1. Validate Button & State ===
    if (!button || !button.classList.contains("prep-ar-btn")) {
      return; // Exit if not the correct button
    }
    fMyConsoleLog(`üñ±Ô∏è Sidebar 'Prep AR' Button Clicked...`);

    // Prevent double-clicks
    if (button.disabled) {
      fMyConsoleLog("   -> Button already disabled. Ignoring click.");
      return;
    }
    button.disabled = true; // Disable immediately

    // === 2. Get Roll ID & Associated Data ===
    const rollId = button.dataset.rollId;
    if (!rollId) {
      console.error(
        "fHandlePrepARClick: Button is missing 'data-roll-id' attribute."
      );
      fMyConsoleLog("‚ùå Error preparing AR: Button lacks roll ID.");
      await fShowMessage("Error: Cannot identify which roll results to use.");
      button.textContent = "Error (No ID)";
      return;
    }

    const rollData = gUI.monsterRollResultsHistory?.[rollId];
    // Validate required data structure
    if (
      !rollData ||
      !Array.isArray(rollData.results) ||
      typeof rollData.originalAbilityRow !== "number" ||
      !Array.isArray(rollData.allTargetedRows_R)
    ) {
      console.error(
        `fHandlePrepARClick: No valid data found in gUI.monsterRollResultsHistory for rollId '${rollId}'.`,
        rollData
      );
      fMyConsoleLog(
        `‚ùå Error preparing AR: Data for roll ID '${rollId}' not found or invalid.`
      );
      await fShowMessage(
        "Error: Could not find the data associated with this defense roll."
      );
      button.textContent = "Error (No Data)";
      return;
    }

    const failureResults = rollData.results; // Array of { mon_R, monName, numFailures } (only includes failures > 0)
    const originalAbilityRow = rollData.originalAbilityRow; // Row index of the Def ability used
    const allTargetedRows_R = rollData.allTargetedRows_R; // Array of all monster rows involved

    // === 3. Update NumMon for All Targeted Monsters ===
    const cNumMon = resolveCol("NumMon");
    let updateErrors = false;

    if (isNaN(cNumMon)) {
      // Ensure 'NumMon' column resolved
      console.error(
        "fHandlePrepARClick: Could not resolve 'NumMon' column tag."
      );
      fMyConsoleLog("‚ùå Error preparing AR: Could not find 'NumMon' column.");
      await fShowMessage(
        "Error: Could not find the 'NumMon' column in the grid."
      );
      button.textContent = "Error"; // Keep button disabled but indicate error
      // Note: History entry remains here on error
      return;
    }

    // Create a map for quick lookup of failure counts
    const failureMap = new Map();
    failureResults.forEach((res) => failureMap.set(res.mon_R, res.numFailures));

    fMyConsoleLog(
      `   -> Processing ${allTargetedRows_R.length} targeted monster rows for Row ${originalAbilityRow}...`
    );
    // Iterate through ALL originally targeted rows
    allTargetedRows_R.forEach((target_mon_R) => {
      // Get failure count from map (undefined if 0 failures)
      const numFailures = failureMap.get(target_mon_R);
      // Set NumMon to the failure count, or empty string if undefined/zero
      const valueToSet =
        numFailures !== undefined && numFailures > 0 ? numFailures : "";

      fMyConsoleLog(
        `      -> Setting NumMon for row ${target_mon_R} to '${valueToSet}'`
      );
      // Update the grid cell
      if (!fSetGridValue(target_mon_R, cNumMon, valueToSet)) {
        fMyConsoleLog(
          `         -> ‚ö†Ô∏è Failed to set NumMon for row ${target_mon_R}`
        );
        updateErrors = true; // Track if any update fails
      }
    });

    if (updateErrors) {
      // Notify user if any grid updates failed
      await fShowMessage(
        "Warning: Some 'NumMon' values may not have updated correctly."
      );
    }

    // === 4. Switch Active Checkbox from Sk1 (Def) to Sk2 (AR) ===
    const originalSk1ColTag = "Sk1ChkBox"; // Assume Defense is Sk1
    const targetSk2ColTag = "Sk2ChkBox"; // Assume Armor is Sk2

    const originalSk1Col = resolveCol(originalSk1ColTag);
    const targetSk2Col = resolveCol(targetSk2ColTag);

    // Validate column resolution
    if (isNaN(originalSk1Col) || isNaN(targetSk2Col)) {
      const missingTag = isNaN(originalSk1Col)
        ? originalSk1ColTag
        : targetSk2ColTag;
      fMyConsoleLog(
        `   -> Cannot switch checkbox: Could not resolve column tag '${missingTag}'.`
      );
      await fShowMessage(
        `Error: Could not find the ${
          isNaN(originalSk1Col) ? "Defense (Sk1)" : "Armor (Sk2)"
        } column.`
      );
      button.textContent = "Done (CB Fail)"; // Update button text to indicate partial failure
      // Note: History entry remains here on error
      return;
    }

    // --- Perform the Switch ---
    // a) Uncheck old Sk1 box (if needed)
    const oldCellDiv = gUI.grid2D?.[originalAbilityRow]?.[originalSk1Col];
    const oldCheckbox = oldCellDiv?.querySelector('input[type="checkbox"]');
    if (oldCheckbox && oldCheckbox.checked) {
      oldCheckbox.checked = false;
      gUI.arr[originalAbilityRow][originalSk1Col] = false; // Update data model
      fMyConsoleLog(
        `   -> Unchecked original Sk1 checkbox [${originalAbilityRow}, ${originalSk1Col}]`
      );
      // Clear tracker if it pointed to the old box
      if (
        gUI.currentSkRadioChecked.r === originalAbilityRow &&
        gUI.currentSkRadioChecked.c === originalSk1Col
      ) {
        gUI.currentSkRadioChecked = { r: null, c: null };
      }
    } else {
      fMyConsoleLog(
        `   -> Original Sk1 checkbox [${originalAbilityRow}, ${originalSk1Col}] not found or already unchecked.`
      );
    }

    // b) Check new Sk2 box
    const targetCellDiv = gUI.grid2D?.[originalAbilityRow]?.[targetSk2Col];
    const targetCheckbox = targetCellDiv?.querySelector(
      'input[type="checkbox"]'
    );
    if (targetCheckbox) {
      targetCheckbox.checked = true;
      gUI.arr[originalAbilityRow][targetSk2Col] = true; // Update data model
      // c) Update tracker to point to the new Sk2 box
      // (Includes unchecking any *other* box that might have been checked)
      const { r: currentlyCheckedR, c: currentlyCheckedC } =
        gUI.currentSkRadioChecked;
      if (
        currentlyCheckedR !== null &&
        currentlyCheckedC !== null &&
        (currentlyCheckedR !== originalAbilityRow ||
          currentlyCheckedC !== targetSk2Col)
      ) {
        fUncheckOldSkGroupBox(currentlyCheckedR, currentlyCheckedC);
      }
      gUI.currentSkRadioChecked = { r: originalAbilityRow, c: targetSk2Col };
      fMyConsoleLog(
        `   -> Switched active checkbox to Sk2 at [${originalAbilityRow}, ${targetSk2Col}].`
      );
      button.textContent = "AR Prep Done"; // Update button text on success
    } else {
      // Handle error finding the target Sk2 checkbox
      console.error(
        `fHandlePrepARClick: Could not find Sk2 checkbox element at [${originalAbilityRow}, ${targetSk2Col}].`
      );
      fMyConsoleLog(
        `   -> ‚ùå Failed to find Sk2 checkbox element at [${originalAbilityRow}, ${targetSk2Col}].`
      );
      await fShowMessage(
        `Error: Could not find the target Armor checkbox element.`
      );
      gUI.currentSkRadioChecked = { r: null, c: null }; // Clear tracker
      button.textContent = "Done (CB Fail)";
      // Note: History entry remains here on error
      return;
    }

    // === 5. Clean up History ===
    // Remove the processed entry from the history map
    try {
      delete gUI.monsterRollResultsHistory[rollId];
      fMyConsoleLog(`   -> Removed entry for rollId '${rollId}' from history.`);
    } catch (e) {
      console.warn(
        `fHandlePrepARClick: Failed to remove entry for rollId '${rollId}' from history:`,
        e
      );
    }

    fMyConsoleLog("‚úÖ Prep AR action completed.");
  } // END fHandlePrepARClick

  // fHandlePrepDmgClick ///////////////////////////////////////////////////////////
  // Purpose -> Handles clicks on the "Prep Dmg" button in the sidebar. Reads attack
  //            success data from gUI.monsterRollResultsHistory using the button's
  //            rollId. Updates 'NumMon' for ALL originally targeted monsters (setting
  //            to success count or '' if 0). Switches the active checkbox from Sk1 (Atk)
  //            to Sk2 (Dmg) on the original ability row. Disables button and cleans up history.
  // Inputs  -> event (MouseEvent): The click event object.
  // Outputs -> None (Modifies grid data/DOM, gUI state, button state).
  async function fHandlePrepDmgClick(event) {
    const button = event.target;

    // === 1. Validate Button & State ===
    if (!button || !button.classList.contains("prep-dmg-btn")) {
      return; // Exit if not the correct button
    }
    fMyConsoleLog(`üñ±Ô∏è Sidebar 'Prep Dmg' Button Clicked...`);

    // Prevent double-clicks
    if (button.disabled) {
      fMyConsoleLog("   -> Button already disabled. Ignoring click.");
      return;
    }
    button.disabled = true; // Disable immediately

    // === 2. Get Roll ID & Associated Data ===
    const rollId = button.dataset.rollId;
    if (!rollId) {
      console.error(
        "fHandlePrepDmgClick: Button is missing 'data-roll-id' attribute."
      );
      fMyConsoleLog("‚ùå Error preparing Dmg: Button lacks roll ID.");
      await fShowMessage("Error: Cannot identify which roll results to use.");
      button.textContent = "Error (No ID)";
      return;
    }

    fMyConsoleLog(
      `   -> Handling click for rollId '${rollId}'. Available history keys: ${Object.keys(
        gUI.monsterRollResultsHistory || {}
      ).join(", ")}`
    );
    const rollData = gUI.monsterRollResultsHistory?.[rollId];
    fMyConsoleLog(
      `   -> Retrieved rollData for ID '${rollId}': ${JSON.stringify(rollData)}`
    );

    // Validate required data structure
    if (
      !rollData ||
      !Array.isArray(rollData.results) ||
      typeof rollData.originalAbilityRow !== "number" ||
      !Array.isArray(rollData.allTargetedRows_R)
    ) {
      console.error(
        `fHandlePrepDmgClick: No valid data found in gUI.monsterRollResultsHistory for rollId '${rollId}'.`,
        rollData
      );
      fMyConsoleLog(
        `‚ùå Error preparing Dmg: Data for roll ID '${rollId}' not found or invalid.`
      );
      await fShowMessage(
        "Error: Could not find the data associated with this attack roll."
      );
      button.textContent = "Error (No Data)";
      return;
    }

    const successResults = rollData.results; // Array of { mon_R, monName, numSuccesses } (only successes > 0)
    const originalAbilityRow = rollData.originalAbilityRow; // Row index of the Atk ability used
    const allTargetedRows_R = rollData.allTargetedRows_R; // Array of all monster rows involved

    // === 3. Update NumMon for All Targeted Monsters ===
    const cNumMon = resolveCol("NumMon");
    let updateErrors = false;

    if (isNaN(cNumMon)) {
      // Ensure 'NumMon' column resolved
      console.error(
        "fHandlePrepDmgClick: Could not resolve 'NumMon' column tag."
      );
      fMyConsoleLog("‚ùå Error preparing Dmg: Could not find 'NumMon' column.");
      await fShowMessage(
        "Error: Could not find the 'NumMon' column in the grid."
      );
      button.textContent = "Error"; // Keep button disabled but indicate error
      // Note: History entry remains here on error
      return;
    }

    // Create a map for quick lookup of success counts
    const successMap = new Map();
    successResults.forEach((res) =>
      successMap.set(res.mon_R, res.numSuccesses)
    );

    fMyConsoleLog(
      `   -> Processing ${allTargetedRows_R.length} targeted monster rows for Row ${originalAbilityRow}...`
    );
    // Iterate through ALL originally targeted rows
    allTargetedRows_R.forEach((target_mon_R) => {
      // Get success count from map (undefined if 0 successes)
      const numSuccesses = successMap.get(target_mon_R);
      // Set NumMon to the success count, or empty string if undefined/zero
      const valueToSet =
        numSuccesses !== undefined && numSuccesses > 0 ? numSuccesses : "";

      fMyConsoleLog(
        `       -> Processing target row ${target_mon_R}. Successes from map: ${numSuccesses}. Value to set: '${valueToSet}'`
      );
      // Update the grid cell
      if (!fSetGridValue(target_mon_R, cNumMon, valueToSet)) {
        fMyConsoleLog(
          `         -> ‚ö†Ô∏è Failed to set NumMon for row ${target_mon_R}`
        );
        updateErrors = true; // Track if any update fails
      }
    });

    if (updateErrors) {
      // Notify user if any grid updates failed
      await fShowMessage(
        "Warning: Some 'NumMon' values may not have updated correctly."
      );
    }

    // === 4. Switch Active Checkbox from Sk1 (Atk) to Sk2 (Dmg) ===
    const originalSk1ColTag = "Sk1ChkBox"; // Assume Attack is Sk1
    const targetSk2ColTag = "Sk2ChkBox"; // Assume Damage is Sk2

    const originalSk1Col = resolveCol(originalSk1ColTag);
    const targetSk2Col = resolveCol(targetSk2ColTag);

    // Validate column resolution
    if (isNaN(originalSk1Col) || isNaN(targetSk2Col)) {
      const missingTag = isNaN(originalSk1Col)
        ? originalSk1ColTag
        : targetSk2ColTag;
      fMyConsoleLog(
        `   -> Cannot switch checkbox: Could not resolve column tag '${missingTag}'.`
      );
      await fShowMessage(
        `Error: Could not find the ${
          isNaN(originalSk1Col) ? "Attack (Sk1)" : "Damage (Sk2)"
        } column.`
      );
      button.textContent = "Done (CB Fail)"; // Update button text to indicate partial failure
      // Note: History entry remains here on error
      return;
    }

    // --- Perform the Switch ---
    // a) Uncheck old Sk1 box (if needed)
    const oldCellDiv = gUI.grid2D?.[originalAbilityRow]?.[originalSk1Col];
    const oldCheckbox = oldCellDiv?.querySelector('input[type="checkbox"]');
    if (oldCheckbox && oldCheckbox.checked) {
      oldCheckbox.checked = false;
      gUI.arr[originalAbilityRow][originalSk1Col] = false; // Update data model
      fMyConsoleLog(
        `   -> Unchecked original Sk1 checkbox [${originalAbilityRow}, ${originalSk1Col}]`
      );
      // Clear tracker if it pointed to the old box
      if (
        gUI.currentSkRadioChecked.r === originalAbilityRow &&
        gUI.currentSkRadioChecked.c === originalSk1Col
      ) {
        gUI.currentSkRadioChecked = { r: null, c: null };
      }
    } else {
      fMyConsoleLog(
        `   -> Original Sk1 checkbox [${originalAbilityRow}, ${originalSk1Col}] not found or already unchecked.`
      );
    }

    // b) Check new Sk2 box
    const targetCellDiv = gUI.grid2D?.[originalAbilityRow]?.[targetSk2Col];
    const targetCheckbox = targetCellDiv?.querySelector(
      'input[type="checkbox"]'
    );
    if (targetCheckbox) {
      targetCheckbox.checked = true;
      gUI.arr[originalAbilityRow][targetSk2Col] = true; // Update data model
      // c) Update tracker to point to the new Sk2 box
      const { r: currentlyCheckedR, c: currentlyCheckedC } =
        gUI.currentSkRadioChecked;
      if (
        currentlyCheckedR !== null &&
        currentlyCheckedC !== null &&
        (currentlyCheckedR !== originalAbilityRow ||
          currentlyCheckedC !== targetSk2Col)
      ) {
        fUncheckOldSkGroupBox(currentlyCheckedR, currentlyCheckedC);
      }
      gUI.currentSkRadioChecked = { r: originalAbilityRow, c: targetSk2Col };
      fMyConsoleLog(
        `   -> Switched active checkbox to Sk2 at [${originalAbilityRow}, ${targetSk2Col}].`
      );
      button.textContent = "Dmg Prep Done"; // Update button text on success
    } else {
      // Handle error finding the target Sk2 checkbox
      console.error(
        `fHandlePrepDmgClick: Could not find Sk2 checkbox element at [${originalAbilityRow}, ${targetSk2Col}].`
      );
      fMyConsoleLog(
        `   -> ‚ùå Failed to find Sk2 checkbox element at [${originalAbilityRow}, ${targetSk2Col}].`
      );
      await fShowMessage(
        `Error: Could not find the target Damage checkbox element.`
      );
      gUI.currentSkRadioChecked = { r: null, c: null }; // Clear tracker
      button.textContent = "Done (CB Fail)";
      // Note: History entry remains here on error
      return;
    }

    // === 5. Clean up History ===
    // Remove the processed entry from the history map
    try {
      delete gUI.monsterRollResultsHistory[rollId];
      fMyConsoleLog(`   -> Removed entry for rollId '${rollId}' from history.`);
    } catch (e) {
      console.warn(
        `fHandlePrepDmgClick: Failed to remove entry for rollId '${rollId}' from history:`,
        e
      );
    }

    fMyConsoleLog("‚úÖ Prep Dmg action completed.");
  } // END fHandlePrepDmgClick

  // ==========================================================================
  // === Nish         (End of Post Combat Buttons ) ===
  // ==========================================================================

  // fHandleNishButtonClick //////////////////////////////////////////////////////////
  // Purpose -> Handles the click event specifically for the main 'Nish' button.
  //            Sets the Nish button state, programmatically checks the Nish ability's
  //            Sk1 checkbox, executes the core Nish sequence (sidebar divider, meta
  //            channeling, max AP, duration updates), and then triggers the main
  //            roll action handler (fHandleRollDiceAction) for the Nish ability itself.
  // Inputs  -> None.
  // Outputs -> None (Modifies state, DOM, triggers other async functions).
  async function fHandleNishButtonClick(event) {
    // Added event parameter to use stopPropagation
    fMyConsoleLog("üñ±Ô∏è Nish Button Clicked...");
    if (event) event.stopPropagation(); // Prevent potential bubbling if called from event
    fCloseAllDropdowns(); // Close any open menus

    // === 1. Set Button State ===
    fSetButtonOrMenuState("Nish"); // Set gUI.buttonOrMenu.isNish = true

    // === 2. Programmatically Check Nish Checkbox ===
    const nishRowTag = "NishAtr_R";
    const nishColTag = "Sk1ChkBox";
    const r = resolveRow(nishRowTag);
    const c = resolveCol(nishColTag);

    // Validate Nish checkbox coordinates
    if (isNaN(r) || isNaN(c)) {
      console.error(
        `fHandleNishButtonClick: Could not resolve Nish checkbox coordinates (${nishRowTag}, ${nishColTag}).`
      );
      await fShowMessage(`‚ùå Error: Cannot find Nish checkbox definition.`);
      fSetButtonOrMenuState(null); // Reset state on error
      return;
    }

    // Uncheck any previously checked radio button
    const currentChecked = gUI.currentSkRadioChecked;
    if (
      currentChecked.r !== null &&
      currentChecked.c !== null &&
      (currentChecked.r !== r || currentChecked.c !== c)
    ) {
      fUncheckOldSkGroupBox(currentChecked.r, currentChecked.c);
    }

    // Check the Nish box DOM element and update state/tracker
    const nishCellDiv = gUI.grid2D?.[r]?.[c];
    const nishCheckbox = nishCellDiv?.querySelector(
      'input[data-sk-group="true"]'
    );
    if (nishCheckbox) {
      nishCheckbox.checked = true;
      gUI.arr[r][c] = true; // Update data model
      gUI.currentSkRadioChecked = { r, c }; // Update tracker
      fMyConsoleLog(
        `   -> Programmatically checked Nish checkbox [${r}, ${c}].`
      );
    } else {
      // Handle error if checkbox element isn't found
      console.error(
        `fHandleNishButtonClick: Could not find Nish checkbox DOM element at [${r}, ${c}].`
      );
      await fShowMessage(`‚ùå Error: Cannot find Nish checkbox element.`);
      fSetButtonOrMenuState(null); // Reset state on error
      return;
    }

    // === 3. Execute Core Nish Sequence ===
    // (Adds sidebar divider, handles Meta Channeling, sets Max AP, updates Durations)
    await fExecuteNishSequence();

    // === 4. Trigger Main Roll Handler ===
    // fHandleRollDiceAction will now use the Nish row/column and the isNish state
    fMyConsoleLog("   -> Triggering fHandleRollDiceAction for Nish ability...");
    await fHandleRollDiceAction();

    // Note: Button state (isNish) is reset at the end of fHandleRollDiceAction
  } // END fHandleNishButtonClick

  // fExecuteNishSequence ////////////////////////////////////////////////////////////
  // Purpose -> Executes the common sequence of actions required at the start of a Nish
  //            turn (or when Nish ability triggered via Checkbox + Roll/Free/Luck).
  //            Adds sidebar divider, runs Meta Channeling, sets Max Action Points,
  //            and processes IsOn durations. Skips Meta/Duration updates if Luck button was used.
  // Inputs  -> None (Uses gUI.buttonOrMenu state).
  // Outputs -> None (Modifies sidebar, calls other async functions).
  async function fExecuteNishSequence() {
    fMyConsoleLog("üé¨ Executing Nish Sequence...");

    // 1. Add Sidebar Divider
    fPrependToSidebar('<hr class="nish-divider"><br>');
    fMyConsoleLog("   -> Sidebar divider added.");

    // 2. Run Meta Channeling (Skip if Luck button initiated the action)
    if (!gUI.buttonOrMenu.isLuck) {
      await fMetaChannel(); // Rolls for meta gain
      fMyConsoleLog("   -> fMetaChannel executed.");
    } else {
      fMyConsoleLog("   -> Skipping fMetaChannel (Luck trigger).");
    }

    // 3. Set Action Points to Max (Always runs as part of Nish turn start)
    await fAct_SetToMax(); // Calculates Max AP and updates grid
    fMyConsoleLog("   -> fAct_SetToMax executed.");

    // 4. Process 'Is On' / Duration Decrements (Skip if Luck button initiated the action)
    if (!gUI.buttonOrMenu.isLuck) {
      await fIsOn_NewNishSet(); // Decrements positive durations, clears 0/'i'/'p'/'n'
      fMyConsoleLog("   -> fIsOn_NewNishSet executed.");
    } else {
      fMyConsoleLog("   -> Skipping fIsOn_NewNishSet (Luck trigger).");
    }

    fMyConsoleLog("‚úÖ Nish Sequence Execution Complete.");
  } // END fExecuteNishSequence

  // ==========================================================================
  // === Grid Roll (Chaos/d,Sk)          (End of Nish ) ===
  // ==========================================================================

  // fHandleChaosGemClick ////////////////////////////////////////////////////////////
  // Purpose -> Handles a click potentially on a Chaos Gem. Checks if the given coordinates (r, c)
  //            fall within the Chaos Gem range and if the gem has uses and ability text.
  //            If conditions met, decrements uses, logs the ability text to the sidebar,
  //            and returns true. Called by fHandleRollDiceAction.
  // Inputs  -> r (Number): 0-based row index of the clicked cell.
  //         -> c (Number): 0-based column index of the clicked cell.
  // Outputs -> (Promise<Boolean>): Resolves true if a Chaos Gem was successfully processed,
  //                                false otherwise (not a gem, no uses, no text, etc.).
  async function fHandleChaosGemClick(r, c) {
    fMyConsoleLog("üíé Checking for Chaos Gem click...");

    // === 1. Validate Input Coordinates ===
    if (r === null || c === null || isNaN(r) || isNaN(c)) {
      fMyConsoleLog(
        "   -> Cannot check Chaos Gem: Invalid coordinates passed."
      );
      return false; // Invalid input
    }

    // === 2. Get Chaos Gem Range & Validate ===
    const chaosRangeDef = gUI.range?.chaosGems;
    if (!chaosRangeDef || !fIsValidRangeObject(chaosRangeDef)) {
      fMyConsoleLog(
        "   -> Cannot check Chaos Gem: Range definition missing/invalid."
      );
      return false; // No range defined
    }

    // === 3. Resolve Range & Check if Click Was Inside ===
    const resolved = fResolveRangeIndices(chaosRangeDef);
    if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
      fMyConsoleLog(
        `   -> Cannot check Chaos Gem: Failed to resolve range tags: ${JSON.stringify(
          chaosRangeDef
        )}`
      );
      return false; // Invalid tags in definition
    }
    const rMin = Math.min(resolved.r1, resolved.r2);
    const rMax = Math.max(resolved.r1, resolved.r2);
    const cMin = Math.min(resolved.c1, resolved.c2);
    const cMax = Math.max(resolved.c1, resolved.c2);

    // Check if the passed r, c fall within the resolved range
    if (r < rMin || r > rMax || c < cMin || c > cMax) {
      fMyConsoleLog(
        `   -> Click [${r}, ${c}] is outside Chaos Gem range [${rMin}-${rMax}, ${cMin}-${cMax}].`
      );
      return false; // Click was outside the gem area
    }
    fMyConsoleLog(`   -> Click [${r}, ${c}] is inside Chaos Gem range.`);

    // === 4. Check Gem Conditions (Uses & Ability Text) ===
    const usesCol = resolveCol("ChaosUses");
    const abilityCol = resolveCol("ChaosAbility");

    // Ensure column tags resolved correctly
    if (isNaN(usesCol) || isNaN(abilityCol)) {
      fMyConsoleLog(
        "   -> Cannot check Chaos Gem: Could not resolve 'ChaosUses' or 'ChaosAbility' column tags."
      );
      await fShowMessage(
        "Error: Chaos Gem column tags are not defined correctly."
      );
      return false; // Configuration error
    }

    // Check remaining uses
    const currentUses = fGetGridValue(r, usesCol, true); // Get as number
    if (isNaN(currentUses) || currentUses < 1) {
      fMyConsoleLog(
        `   -> Chaos Gem condition unmet: Uses are ${currentUses}.`
      );
      await fShowMessage("Chaos Crystal has no uses left!");
      // Return true here because the *click itself* was handled as a Chaos Gem click,
      // even though it failed due to no uses. This prevents the Roll button from
      // proceeding to check for ad-hoc or ability rolls.
      return true;
    }

    // Check for ability text
    const abilityText = fGetGridValue(r, abilityCol);
    if (!abilityText || String(abilityText).trim() === "") {
      fMyConsoleLog(`   -> Chaos Gem condition unmet: Ability text is empty.`);
      await fShowMessage("Chaos Crystal has no ability text defined!");
      return true; // Handled as a gem click, but failed condition
    }

    // === 5. Conditions Met - Perform Actions ===
    fMyConsoleLog(
      `   -> Chaos Gem conditions met: Uses=${currentUses}, Ability="${String(
        abilityText
      ).substring(0, 30)}..."`
    );
    const newUses = currentUses - 1;

    // Update Grid (decrement uses)
    if (!fSetGridValue(r, usesCol, newUses)) {
      fMyConsoleLog(
        `   -> ‚ùå Failed to update ChaosUses cell [${r}, ${usesCol}].`
      );
      await fShowMessage("Error: Failed to update Chaos Crystal uses.");
      // Still return true as the click was handled
      return true;
    }

    // Build Sidebar Message
    const sidebarMsg = `<span class="blue-bold">Chaos Crystal</span> (${newUses} Uses Left):<br>${String(
      abilityText
    ).trim()}`;
    // Update Sidebar
    fPrependToSidebar(sidebarMsg);
    fShowSidebar();

    fMyConsoleLog("‚úÖ Chaos Gem Used Successfully.");
    return true; // Signal that the gem click was fully processed
  } // END fHandleChaosGemClick

  // fHandleAdHocRoll ////////////////////////////////////////////////////////////////
  // Purpose -> Attempts to parse and roll dice based on cell text content when the
  //            <Roll> button is clicked on a cell outside Ability/Chaos Gem areas.
  //            Checks for exact matches (sk#, XdY+/-Z, #) first, then parses the
  //            text for the first occurrence of sk# or XdY+/-Z. Logs result to sidebar.
  // Inputs  -> cellText (String): The text content of the clicked cell.
  // Outputs -> (Promise<Boolean>): Resolves true if a roll was parsed and logged, false otherwise.
  async function fHandleAdHocRoll(cellText) {
    fMyConsoleLog(`üé≤ Attempting Ad-Hoc Roll for text: "${cellText}"`);

    // === Validate Input ===
    if (typeof cellText !== "string" || !cellText.trim()) {
      fMyConsoleLog("   -> No valid text provided for ad-hoc roll.");
      return false;
    }
    const text = cellText.trim();

    // === Initialize Variables ===
    let rollResult = null; // Stores the numeric roll result
    let logHeader = ""; // Header text for log ('Die Roll', 'Custom Roll Sk')
    let logDetails = ""; // Details of the roll for log (e.g., "Sk(20) ~35")
    let patternMatched = false; // Flag if a parsable pattern was found
    let matchedString = ""; // The specific substring that matched a pattern

    // === Regex Definitions ===
    const skExactPattern = /^sk(\d+)$/i; // Matches 'sk' followed by digits, exactly
    const dieStringExactPattern = /^((\d+)?d(\d+)\s*(?:([-+])\s*(\d+))?)$/i; // Matches XdY+/-Z, exactly
    const numberExactPattern = /^\d+$/; // Matches only digits, exactly
    const parsePattern = /(sk(\d+))|((\d+)?d(\d+)\s*(?:([-+])\s*(\d+))?)/i; // Matches first sk# OR first XdY+/-Z

    // === 1. Check for Exact Matches ===
    let match;
    // Check sk#
    if ((match = text.match(skExactPattern))) {
      const num = parseInt(match[1], 10);
      if (!isNaN(num) && num > 0) {
        rollResult = fCSD(num); // Use fCSD for sk rolls
        logHeader = "Custom Roll Sk";
        matchedString = match[0];
        logDetails = `Sk(${num}) ~${rollResult}`;
        patternMatched = true;
        fMyConsoleLog(
          `   -> Matched EXACT Sk pattern: ${matchedString}. Result: ${rollResult}`
        );
      }
    }
    // Check XdY+/-Z
    else if ((match = text.match(dieStringExactPattern))) {
      matchedString = match[0].trim();
      rollResult = fRollDieString(matchedString); // Use standard d-notation roller
      if (rollResult !== null) {
        logHeader = "Die Roll";
        logDetails = `Die(${matchedString}) ~${rollResult}`;
        patternMatched = true;
        fMyConsoleLog(
          `   -> Matched EXACT Die String pattern: ${matchedString}. Result: ${rollResult}`
        );
      }
    }
    // Check # (treat as d#)
    else if (numberExactPattern.test(text)) {
      const num = parseInt(text, 10);
      if (!isNaN(num) && num > 0) {
        matchedString = `d${num}`;
        rollResult = fRollDieString(matchedString); // Roll d#
        if (rollResult !== null) {
          logHeader = "Die Roll";
          logDetails = `Die(${matchedString}) ~${rollResult}`;
          patternMatched = true;
          fMyConsoleLog(
            `   -> Matched EXACT Number pattern: ${num} (rolled as ${matchedString}). Result: ${rollResult}`
          );
        }
      }
    }

    // === 2. Parse for First Match (if no exact match) ===
    if (!patternMatched) {
      fMyConsoleLog(`   -> No exact match. Parsing text for first pattern...`);
      match = text.match(parsePattern); // Find first sk# OR XdY+/-Z
      if (match) {
        if (match[1]) {
          // Matched sk# pattern within the text
          matchedString = match[1];
          const num = parseInt(match[2], 10);
          if (!isNaN(num) && num > 0) {
            rollResult = fCSD(num);
            logHeader = "Custom Roll Sk";
            logDetails = `Sk(${num}) ~${rollResult}`;
            patternMatched = true;
            fMyConsoleLog(
              `   -> PARSED first Sk pattern: ${matchedString}. Result: ${rollResult}`
            );
          }
        } else if (match[3]) {
          // Matched die string pattern within the text
          matchedString = match[3].trim();
          rollResult = fRollDieString(matchedString);
          if (rollResult !== null) {
            logHeader = "Die Roll";
            logDetails = `Die(${matchedString}) ~${rollResult}`;
            patternMatched = true;
            fMyConsoleLog(
              `   -> PARSED first Die String pattern: ${matchedString}. Result: ${rollResult}`
            );
          }
        }
      } else {
        fMyConsoleLog(`   -> No parsable pattern found within text.`);
      }
    }

    // === 3. Log to Sidebar if Successful ===
    if (patternMatched && rollResult !== null) {
      // Format header based on whether exact match or parse occurred
      let formattedHeader = "";
      const headerSuffix = text === matchedString ? ":" : ` (from "${text}"):`; // Indicate if parsed from larger string
      if (logHeader === "Custom Roll Sk") {
        formattedHeader = `<span class="blue-bold">Custom Roll</span> Sk${headerSuffix}`;
      } else {
        // Die Roll (exact or parsed)
        formattedHeader = `<span class="blue-bold">Die Roll</span>${headerSuffix}`;
      }

      // Add T/C suffix ONLY for Sk rolls
      let tcSuffix = "";
      if (logHeader === "Custom Roll Sk") {
        const tcResult = fCStc();
        if (tcResult) {
          tcSuffix = `   ${tcResult}`;
        } // Add spacing
      }

      // Combine and log
      const finalLogHtml = `${formattedHeader}<br>${logDetails}${tcSuffix}`;
      fPrependToSidebar(finalLogHtml);
      fShowSidebar();
      fMyConsoleLog(`   -> Ad-Hoc Roll logged to sidebar.`);
      return true; // Indicate roll was handled
    }

    // === 4. No Match Found ===
    if (!patternMatched) {
      fMyConsoleLog("   -> No ad-hoc roll pattern matched (exact or parsed).");
    } // Implicit else: pattern matched but rollResult was null (error in fRollDieString)

    return false; // Indicate no valid roll was handled
  } // END fHandleAdHocRoll

  // ==========================================================================
  // === Base Die Rolling          (End of Grid Roll (Chaos/d,Sk)  ) ===
  // ==========================================================================

  // fCSd //////////////////////////////////////////////////////////////////////
  // Purpose -> Standard linear distribution die roll (e.g., 1d6).
  // Inputs  -> die (Number): The number of sides on the die.
  // Outputs -> (Number): The result of the roll (integer from 1 to die).
  function fCSd(die) {
    const numDie = Number(die); // Ensure input is treated as a number

    // Validate input
    if (isNaN(numDie) || numDie < 1) {
      console.error(`fCSd received invalid die size: ${die}`);
      return 1; // Return 1 for invalid input
    }

    // Calculate and return random integer between 1 and numDie (inclusive)
    return Math.floor(Math.random() * numDie) + 1;
  } // END fCSd

  // fCSD //////////////////////////////////////////////////////////////////////
  // Purpose -> Performs a non-linear "exploding" dice roll common in MetaScape,
  //            weighted towards lower results but with potential for high values.
  //            Used for skill/attribute checks (Sk, Atr, Atk, Def). No T/C.
  // Inputs  -> die (Number): The base value (skill/attribute) for the roll.
  // Outputs -> (Number): The integer result of the roll (minimum 1).
  function fCSD(die) {
    const numDie = Number(die); // Ensure input is treated as a number

    // Validate input
    if (isNaN(numDie) || numDie < 1) {
      console.error(`fCSD received invalid die value: ${die}`);
      return 1; // Return 1 for invalid input
    }

    // Generate two random numbers
    const rand1 = Math.random();
    let rand2 = Math.random();

    // Prevent division by zero or near-zero for the second random number
    if (rand2 < 0.0001) rand2 = 0.0001; // Set a minimum divisor

    // Calculate result: (die * rand1) / rand2 + 1, floored
    return Math.floor((numDie * rand1) / rand2) + 1;
  } // END fCSD

  // fCStc /////////////////////////////////////////////////////////////////////
  // Purpose -> Rolls 1d16 to determine Tremendous ('T', roll 1) or Critical ('C', roll 2)
  //            result suffix for sidebar logging.
  // Inputs  -> None.
  // Outputs -> (String): Formatted "T", "C", or "" (empty string).
  function fCStc() {
    const roll = fCSd(16); // Standard d16 roll

    // Return formatted string based on roll result
    return roll === 1
      ? `<span class="tremendous">T</span>` // Roll of 1 is Tremendous
      : roll === 2
      ? `<span class="red-bold">C</span>` // Roll of 2 is Critical
      : ""; // Other rolls result in no suffix
  } // END fCStc

  // fCSdBetween ///////////////////////////////////////////////////////////////
  // Purpose -> Rolls a standard linear die to get a random integer between a
  //            specified low and high value, inclusive.
  // Inputs  -> low (Number): The lowest possible result.
  //         -> high (Number): The highest possible result.
  // Outputs -> (Number): Random integer between low and high (inclusive).
  function fCSdBetween(low, high) {
    const numLow = Number(low);
    const numHigh = Number(high);

    // Validate input range
    if (isNaN(numLow) || isNaN(numHigh) || numLow > numHigh) {
      console.error(`fCSdBetween received invalid range: ${low}-${high}`);
      return numLow; // Return low value on error
    }

    // Calculate number of possible outcomes
    const rangeSize = numHigh - numLow + 1;
    // Roll d(rangeSize) and add (low - 1) to shift range
    return fCSd(rangeSize) + (numLow - 1);
  } // END fCSdBetween

  // fCSDSk ////////////////////////////////////////////////////////////////////
  // Purpose -> Performs a standard MetaScape Skill roll (used for Sk, Atr, Str).
  //            Averages a linear d(die*2) roll and a non-linear fCSD(die) roll.
  // Inputs  -> die (Number): The base skill value.
  // Outputs -> (Number): The rounded integer result of the skill roll.
  function fCSDSk(die) {
    const numDie = Number(die); // Ensure input is treated as a number

    // Validate input
    if (isNaN(numDie) || numDie < 1) {
      console.error(`fCSDSk received invalid die value: ${die}`);
      return 1; // Return 1 for invalid input
    }

    // Calculate average of a linear d(2*die) and a non-linear fCSD(die)
    return Math.round((fCSd(numDie * 2) + fCSD(numDie)) / 2);
  } // END fCSDSk

  // fCSAtk ////////////////////////////////////////////////////////////////////
  // Purpose -> Performs a MetaScape Attack roll. Currently identical to fCSDSk.
  // Inputs  -> die (Number): The base attack skill value.
  // Outputs -> (Number): The rounded integer result of the attack roll.
  function fCSAtk(die) {
    const numDie = Number(die); // Ensure input is treated as a number

    // Validate input
    if (isNaN(numDie) || numDie < 1) {
      console.error(`fCSAtk received invalid die value: ${die}`);
      return 1; // Return 1 for invalid input
    }

    // Currently uses the same calculation as fCSDSk
    return Math.round((fCSd(numDie * 2) + fCSD(numDie)) / 2);
  } // END fCSAtk

  // fCSDef ////////////////////////////////////////////////////////////////////
  // Purpose -> Performs a MetaScape Defense roll. Based on fCSD(die) * 0.75.
  // Inputs  -> die (Number): The base defense value.
  // Outputs -> (Number): The rounded integer result of the defense roll.
  function fCSDef(die) {
    const numDie = Number(die); // Ensure input is treated as a number

    // Validate input
    if (isNaN(numDie) || numDie < 1) {
      console.error(`fCSDef received invalid die value: ${die}`);
      return 1; // Return 1 for invalid input
    }

    // Calculate based on the non-linear roll, scaled down
    return Math.round(fCSD(numDie) * 0.75);
  } // END fCSDef

  // fCSRollUnSkilled //////////////////////////////////////////////////////////
  // Purpose -> Performs an UnSkilled roll. Calculates a reduced 'newDie' value
  //            based on the original skill, then averages two d(newDie*2) rolls
  //            and one fCSD(newDie) roll.
  // Inputs  -> die (Number): The original base skill value before unskilled penalty.
  // Outputs -> (Number): The rounded integer result of the unskilled roll.
  function fCSRollUnSkilled(die) {
    const numDie = Number(die); // Ensure input is treated as a number

    // Validate input
    if (isNaN(numDie) || numDie < 1) {
      console.error(`fCSRollUnSkilled received invalid die value: ${die}`);
      return 1; // Return 1 for invalid input
    }

    // Calculate the reduced die size for unskilled rolls
    // Formula: max(2, min(die/2, 5 + sqrt(die)))
    const newDie = Math.max(2, Math.min(numDie / 2, 5 + Math.sqrt(numDie)));

    // Calculate result based on averaging three rolls with the reduced die size
    return Math.round((fCSd(newDie * 2) + fCSd(newDie * 2) + fCSD(newDie)) / 3);
  } // END fCSRollUnSkilled

  // fCSRollUnSkilledDmg ///////////////////////////////////////////////////////
  // Purpose -> Rolls Unskilled Damage. Currently uses the standard fCSRollUnSkilled method.
  // Inputs  -> pcDmg (Number): The base damage value before unskilled penalty.
  // Outputs -> (Number): The result of the unskilled damage roll.
  function fCSRollUnSkilledDmg(pcDmg) {
    // Currently just calls the standard unskilled roll function
    return fCSRollUnSkilled(pcDmg);
  } // END fCSRollUnSkilledDmg

  // fCSRollUnSkilledArmor /////////////////////////////////////////////////////
  // Purpose -> Rolls Unskilled Armor. Uses fCSRollUnSkilled result divided by 8,
  //            truncated to one decimal place, with a minimum result of 1.0.
  // Inputs  -> pcAR (Number): The base armor value before unskilled penalty.
  // Outputs -> (Number): The result of the unskilled armor roll (min 1.0).
  function fCSRollUnSkilledArmor(pcAR) {
    // Get the base unskilled roll result
    const unskilledRoll = fCSRollUnSkilled(pcAR);

    // Formula: max(1, floor( (UnskilledRoll / 8) * 10 ) / 10 )
    const result = Math.trunc((unskilledRoll / 8) * 10) / 10;

    // Ensure a minimum result of 1.0
    return Math.max(1, result);
  } // END fCSRollUnSkilledArmor

  // fCSDDmg ///////////////////////////////////////////////////////////////////
  // Purpose -> Rolls standard PC Damage. Currently identical to fCSDSk.
  // Inputs  -> pcDmg (Number): The base damage value.
  // Outputs -> (Number): The result of the damage roll.
  function fCSDDmg(pcDmg) {
    // Currently just calls the standard skill roll function
    return fCSDSk(pcDmg);
  } // END fCSDDmg

  // fCSDArmor /////////////////////////////////////////////////////////////////
  // Purpose -> Rolls standard PC Armor. Uses fCSDSk result divided by 15,
  //            truncated to two decimal places, with a minimum result of 1.0.
  // Inputs  -> pcAR (Number): The base armor value.
  // Outputs -> (Number): The result of the armor roll (min 1.0, rounded to two decimals).
  function fCSDArmor(pcAR) {
    // Get the base skill roll result for the armor value
    const skillRoll = fCSDSk(pcAR);

    // Formula: max(1, floor( (SkillRoll / 15) * 100 ) / 100 )
    const result = Math.trunc((skillRoll / 15) * 100) / 100;

    // Ensure a minimum result of 1.0
    return Math.max(1, result);
  } // END fCSDArmor

  // fRollDieString //////////////////////////////////////////////////////////////////
  // Purpose -> Parses a standard RPG die string (e.g., "d6", "2d8", "3d10+5", "1d12-2")
  //            and rolls the dice using fCSd (linear distribution), returning the total.
  // Inputs  -> dieString (String): The dice notation string.
  // Outputs -> (Number | null): The numerical result of the roll, or null if parsing fails.
  function fRollDieString(dieString) {
    // === Validate Input ===
    if (typeof dieString !== "string" || !dieString.trim()) {
      console.warn(
        "fRollDieString: Invalid input - requires a non-empty string."
      );
      return null;
    }

    // === Define Regex ===
    // Captures: [1]=NumDice(opt), [2]=Sides, [3]=ModifierSign(opt), [4]=ModifierValue(opt)
    const dieStringRegex = /^\s*(\d+)?\s*d\s*(\d+)\s*(?:([-+])\s*(\d+))?\s*$/i;
    const match = dieString.trim().match(dieStringRegex);

    // === Validate Match ===
    if (!match) {
      // console.warn(`fRollDieString: Failed to parse die string: "${dieString}"`); // Can be noisy
      return null; // String doesn't match expected format
    }

    // === Extract & Validate Components ===
    const numDice = match[1] ? parseInt(match[1], 10) : 1; // Default 1 die
    const numSides = parseInt(match[2], 10);
    const modifierSign = match[3]; // '+' or '-' or undefined
    const modifierValue = match[4] ? parseInt(match[4], 10) : 0; // Default 0 modifier

    if (
      isNaN(numDice) ||
      numDice < 1 ||
      isNaN(numSides) ||
      numSides < 1 ||
      isNaN(modifierValue)
    ) {
      console.warn(
        `fRollDieString: Invalid numeric components in parsed string "${dieString}"`
      );
      return null; // Invalid numbers parsed
    }

    // === Roll Dice ===
    let total = 0;
    fMyConsoleLog(`   -> Rolling Die String: ${numDice}d${numSides}`);
    for (let i = 0; i < numDice; i++) {
      const roll = fCSd(numSides); // Use standard linear roll
      total += roll;
      // fMyConsoleLog(`      - Roll ${i+1}: ${roll}`); // Optional: Log individual rolls
    }
    fMyConsoleLog(`   -> Base Roll Total: ${total}`);

    // === Apply Modifier ===
    if (modifierSign === "+") {
      total += modifierValue;
      fMyConsoleLog(`   -> Applying Modifier: +${modifierValue} => ${total}`);
    } else if (modifierSign === "-") {
      total -= modifierValue;
      fMyConsoleLog(`   -> Applying Modifier: -${modifierValue} => ${total}`);
    }

    return total;
  } // END fRollDieString

  // ==========================================================================
  // === Message Box             (End of Base Die Rolling ) ===
  // ==========================================================================

  // fShowMessage ///////////////////////////////////////////////////////////////////
  // Purpose -> Displays the message modal box with the provided message and returns
  //            a Promise that resolves when the modal's 'Close' button is clicked
  //            or the modal is closed via other means (handled by fHideMessage).
  // Inputs  -> message (String): The text or HTML to display.
  // Outputs -> (Promise<void>): Resolves when the modal is hidden. Rejects if modal
  //                             elements are not found.
  async function fShowMessage(message) {
    // === Ensure Modal Elements are Cached ===
    // Attempt to cache elements if not already done (e.g., on first call)
    if (!gUI.messageModalOverlay) {
      gUI.messageModalOverlay = document.getElementById("messageModal");
      if (gUI.messageModalOverlay)
        fMyConsoleLog("fShowMessage: Just-in-time cache for #messageModal");
    }
    if (!gUI.messageModalText) {
      gUI.messageModalText = document.getElementById("messageText");
      if (gUI.messageModalText)
        fMyConsoleLog("fShowMessage: Just-in-time cache for #messageText");
    }

    // === Validate Elements ===
    // Check if elements were successfully found/cached
    if (!gUI.messageModalOverlay || !gUI.messageModalText) {
      console.error("Message modal elements not cached or found in the DOM!");
      if (!gUI.messageModalOverlay) console.error("Missing: #messageModal");
      if (!gUI.messageModalText) console.error("Missing: #messageText");
      // Fallback alert could be added here if critical
      return Promise.reject(new Error("Message modal elements not found.")); // Reject promise
    }

    // === Display Modal ===
    // Set message content (allows basic HTML like <br>)
    gUI.messageModalText.innerHTML = message;
    // Show the modal overlay
    gUI.messageModalOverlay.style.display = "flex";

    // === Return Promise ===
    // Create and return a new Promise that will be resolved by fHideMessage
    return new Promise((resolve) => {
      gUI.messagePromiseResolve = resolve; // Store the resolve function globally
    });
  } // END fShowMessage

  // fHideMessage ///////////////////////////////////////////////////////////////////
  // Purpose -> Hides the message modal box and resolves the pending Promise created
  //            by fShowMessage, signaling that the user has acknowledged the message.
  // Inputs  -> None (Uses gUI.messageModalOverlay, gUI.messagePromiseResolve).
  // Outputs -> None (Modifies modal style, resolves Promise).
  function fHideMessage() {
    // Hide the modal overlay element if cached
    if (gUI.messageModalOverlay) {
      gUI.messageModalOverlay.style.display = "none";
    } else {
      // Log error if element isn't found (should be rare)
      console.error(
        "Message modal overlay element (#messageModal) not found when trying to hide."
      );
    }

    // Resolve the pending promise if the resolve function exists
    if (typeof gUI.messagePromiseResolve === "function") {
      gUI.messagePromiseResolve(); // Call the stored resolve function
      gUI.messagePromiseResolve = null; // Clear the stored function
      // fMyConsoleLog("Message Promise Resolved"); // Optional log
    }
  } // END fHideMessage

  // fSetupMessageModalListeners /////////////////////////////////////////////////////
  // Purpose -> Sets up event listeners for closing the message modal:
  //            - Click on the 'Close' button.
  //            - Click on the background overlay.
  //            - Pressing the 'Escape' key.
  //            All actions trigger fHideMessage, which resolves the promise.
  // Inputs  -> None.
  // Outputs -> None (Attaches event listeners).
  function fSetupMessageModalListeners() {
    fMyConsoleLog("üñ±Ô∏è Setting up Message Modal Listeners...");

    // === Get Required Elements ===
    // Fetch elements directly during setup for reliability
    const overlayElement = document.getElementById("messageModal");
    const closeButtonElement = document.getElementById("closeMessageModal");

    // === Validate Elements ===
    if (!overlayElement) {
      console.error(
        "Setup failed: Message modal overlay element (#messageModal) not found *during listener setup*."
      );
      fMyConsoleLog(
        "‚ö†Ô∏è Message Modal Listeners NOT Attached (overlay missing)."
      );
      return;
    }
    if (!closeButtonElement) {
      console.error(
        "Setup failed: Message modal close button (#closeMessageModal) not found *during listener setup*."
      );
      fMyConsoleLog(
        "‚ö†Ô∏è Message Modal Listeners NOT Attached (button missing)."
      );
      return;
    }

    // === Attach Listeners ===
    // Listener for the close button click
    closeButtonElement.addEventListener("click", fHideMessage);

    // Listener for clicking the background overlay
    overlayElement.addEventListener("click", (event) => {
      // Only hide if the click target is the overlay itself, not its content
      if (event.target === overlayElement) {
        fHideMessage();
      }
    });

    // Listener for the Escape key
    document.addEventListener("keydown", (event) => {
      // Only hide if the modal is visible and Escape key is pressed
      if (overlayElement.style.display !== "none" && event.key === "Escape") {
        fHideMessage();
      }
    });

    fMyConsoleLog("‚úÖ Message Modal Listeners Attached.");
  } // END fSetupMessageModalListeners

  // ==========================================================================
  // === Prompt Box              (End of Message Box) ===
  // ==========================================================================

  // fShowPrompt ///////////////////////////////////////////////////////////////////
  // Purpose -> Displays the prompt modal box with a message and Yes/No buttons. Returns
  //            a Promise that resolves with true (Yes) or false (No) based on user choice.
  // Inputs  -> message (String): The text or HTML question/prompt to display.
  // Outputs -> (Promise<Boolean>): Resolves true for 'Yes', false for 'No'. Rejects if
  //                                modal elements are not found.
  async function fShowPrompt(message) {
    // === Ensure Modal Elements are Cached ===
    if (!gUI.promptModalOverlay)
      gUI.promptModalOverlay = document.getElementById("promptModal");
    if (!gUI.promptModalText)
      gUI.promptModalText = document.getElementById("promptText");

    // === Validate Elements ===
    if (!gUI.promptModalOverlay || !gUI.promptModalText) {
      console.error("Prompt modal elements not cached or found in the DOM!");
      if (!gUI.promptModalOverlay) console.error("Missing: #promptModal");
      if (!gUI.promptModalText) console.error("Missing: #promptText");
      return Promise.reject(new Error("Prompt modal elements not found.")); // Reject promise
    }

    // === Display Modal ===
    // Set prompt content (allows HTML)
    gUI.promptModalText.innerHTML = message;
    // Show the modal overlay
    gUI.promptModalOverlay.style.display = "flex";

    // === Return Promise ===
    // Create and return a new Promise; store resolve/reject functions globally
    return new Promise((resolve, reject) => {
      gUI.promptPromiseResolve = resolve; // Store the resolve function
      gUI.promptPromiseReject = reject; // Store the reject function (optional usage)
    });
  } // END fShowPrompt

  // fHandlePromptResponse ///////////////////////////////////////////////////////////
  // Purpose -> Hides the prompt modal and resolves the pending Promise created by
  //            fShowPrompt with the user's boolean response (true for Yes, false for No).
  // Inputs  -> userResponse (Boolean): The user's choice (true/false).
  // Outputs -> None (Modifies modal style, resolves Promise).
  function fHandlePromptResponse(userResponse) {
    // Hide the modal overlay element if cached
    if (gUI.promptModalOverlay) {
      gUI.promptModalOverlay.style.display = "none";
    } else {
      console.error(
        "Prompt modal overlay element (#promptModal) not found when trying to hide."
      );
    }

    // Resolve the pending promise if the resolve function exists
    if (typeof gUI.promptPromiseResolve === "function") {
      gUI.promptPromiseResolve(userResponse); // Resolve with the user's boolean choice
      fMyConsoleLog(`Prompt Promise Resolved with: ${userResponse}`);
    } else {
      // This shouldn't happen if fShowPrompt was called correctly
      console.error(
        "Prompt promise resolve function not found when trying to resolve."
      );
    }

    // Clear the stored resolve/reject functions after use
    gUI.promptPromiseResolve = null;
    gUI.promptPromiseReject = null;
  } // END fHandlePromptResponse

  // fSetupPromptModalListeners //////////////////////////////////////////////////////
  // Purpose -> Sets up event listeners for the prompt modal 'Yes' and 'No' buttons.
  //            Clicks call fHandlePromptResponse with true or false respectively.
  // Inputs  -> None.
  // Outputs -> None (Attaches event listeners).
  function fSetupPromptModalListeners() {
    fMyConsoleLog("üñ±Ô∏è Setting up Prompt Modal Listeners...");

    // === Cache/Get Button Elements ===
    if (!gUI.promptYesButton)
      gUI.promptYesButton = document.getElementById("promptYesButton");
    if (!gUI.promptNoButton)
      gUI.promptNoButton = document.getElementById("promptNoButton");

    // === Validate Elements ===
    if (!gUI.promptYesButton) {
      console.error(
        "Setup failed: Prompt 'Yes' button (#promptYesButton) not found *during listener setup*."
      );
      fMyConsoleLog(
        "‚ö†Ô∏è Prompt Modal Listeners NOT Attached (Yes button missing)."
      );
      return;
    }
    if (!gUI.promptNoButton) {
      console.error(
        "Setup failed: Prompt 'No' button (#promptNoButton) not found *during listener setup*."
      );
      fMyConsoleLog(
        "‚ö†Ô∏è Prompt Modal Listeners NOT Attached (No button missing)."
      );
      return;
    }

    // === Attach Listeners ===
    // Listener for the 'Yes' button -> calls handler with true
    gUI.promptYesButton.addEventListener("click", () =>
      fHandlePromptResponse(true)
    );

    // Listener for the 'No' button -> calls handler with false
    gUI.promptNoButton.addEventListener("click", () =>
      fHandlePromptResponse(false)
    );

    // Optional: Add Escape key listener to default to No?
    // document.addEventListener('keydown', (event) => {
    //   const overlay = gUI.promptModalOverlay; // Use cached ref if needed
    //   if (overlay && overlay.style.display !== 'none' && event.key === 'Escape') {
    //     fHandlePromptResponse(false); // Treat Escape as 'No'
    //   }
    // });

    fMyConsoleLog("‚úÖ Prompt Modal Listeners Attached.");
  } // END fSetupPromptModalListeners
</script>
<script>
  // gamelogic.html //

  // ==========================================================================
  // === Core Ability Roll Logic ===
  // ==========================================================================

  // fMain_AbilityRoll ///////////////////////////////////////////////////////////
  // Purpose -> Top-level handler for initiating an ability/gear roll. Coordinates
  //            validation, data population, morphs, costs, roll logic branching,
  //            cost application, Nish update, and final logging (HTML & plain text)
  //            to sidebar and GMScreen.
  // Inputs  -> None (Relies on gUI state).
  // Outputs -> None (Orchestrates updates to gUI, DOM, sidebar, GMScreen).
  async function fMain_AbilityRoll() {
    fMyConsoleLog("üé≤ Roll Dice Action Triggered");
    let logHtmlToSend = ""; // Store final log HTML for sidebar
    let logTextToSend = ""; // Store final log text for GMScreen update

    try {
      // Add try block for better error handling during the sequence
      // === 1. Initial Validation & Base gUI.roll Setup ===
      const { r, c } = gUI.currentSkRadioChecked;
      if (!(await fIsSk1Sk2RadioCheckbox(r, c))) {
        fSetButtonOrMenuState(null);
        return;
      }
      if (!(await fClearAndSetGUIRoll(r, c))) {
        fSetButtonOrMenuState(null);
        return;
      }
      if (!(await fVerifyAbilityHasSkAndType())) {
        fSetButtonOrMenuState(null);
        return;
      }

      // === 2. Nish Ability Pre-Sequence Check ===
      const nishRowIndex = fResolveRow("NishAtr_R");
      const isNishAbilityRoll = gUI.roll.ability_R === nishRowIndex;
      if (isNishAbilityRoll && !gUI.buttonOrMenu.isNish) {
        fMyConsoleLog(
          "   -> Nish ability triggered via Checkbox + Roll/Free/Luck. Executing Nish sequence first..."
        );
        await fExecuteNishSequence(); // This function also logs to sidebar
      } else if (isNishAbilityRoll && gUI.buttonOrMenu.isNish) {
        fMyConsoleLog(
          "   -> Nish ability triggered via Nish Button. Pre-sequence already executed."
        );
      }

      // === 3. Process Morph String ===
      fMyConsoleLog("   -> Processing morph string...");
      await fProcessMorph();
      if (typeof gUI.roll.multiRollCount === "undefined") {
        gUI.roll.multiRollCount = 1;
      }

      // === 4. Determine Final Flags & Prepare for Costs/Rolls ===
      const multiRollCount = gUI.roll.multiRollCount;
      const isFreeRoll =
        gUI.buttonOrMenu.isFree ||
        gUI.roll.isFreeRoll ||
        (isNishAbilityRoll && gUI.buttonOrMenu.isNish);
      const isLuckedRoll = gUI.buttonOrMenu.isLuck || gUI.roll.isLuckedRoll;
      gUI.roll.isFreeRoll = isFreeRoll;
      gUI.roll.isLuckedRoll = isLuckedRoll;
      const resTyp = gUI.roll.resTyp;
      const hasDifficultyMorph =
        typeof gUI.roll.resDif === "number" && gUI.roll.resDif !== "";

      fMyConsoleLog(
        `   -> Final Roll Type: ${resTyp}, Multi-Roll: ${multiRollCount}, Free: ${isFreeRoll}, Lucked: ${isLuckedRoll}, Difficulty Morph: ${hasDifficultyMorph}`
      );

      const pendingHeadersHtml = []; // Headers for sidebar log (HTML)
      const pendingHeadersText = []; // Headers for sidebar log (Plain Text)
      let allCostsMet = true;
      let userCancelled = false;
      gUI.pendingChangesMap = {};

      const addChangesToMap = (changesArray) => {
        if (!Array.isArray(changesArray)) return;
        changesArray.forEach((change) => {
          if (
            change &&
            typeof change.r !== "undefined" &&
            typeof change.c !== "undefined"
          ) {
            const key = `${change.r},${change.c}`;
            gUI.pendingChangesMap[key] = change.value;
          } else {
            console.warn("addChangesToMap received invalid change:", change);
          }
        });
      };

      // === 5. Add Pre-Cost Headers & Verify Costs ===
      if (isLuckedRoll) {
        pendingHeadersHtml.push(
          '‚ö†Ô∏è <span class="blue-bold">Lucked Roll Below:</span>'
        );
        pendingHeadersText.push("‚ö†Ô∏è Lucked Roll Below:");
      }
      if (isFreeRoll && !(isNishAbilityRoll && gUI.buttonOrMenu.isNish)) {
        pendingHeadersHtml.push(
          '‚ö†Ô∏è <span class="blue-bold">Free Roll Below:</span>'
        );
        pendingHeadersText.push("‚ö†Ô∏è Free Roll Below:");
      }

      // --- Verify Costs (Skip if Free Roll) ---
      if (!isFreeRoll) {
        fMyConsoleLog("üõ°Ô∏è Verifying Costs (Luck and/or Standard)...");
        if (isLuckedRoll) {
          fMyConsoleLog("   -> Verifying Luck Cost...");
          const luckCost = 1;
          const currentLuck = fGetGridValue("LuckBox", "LuckBox", true);
          if (isNaN(currentLuck)) {
            await fShowMessage("‚ùå Error reading current Luck value.");
            fMyConsoleLog(
              "üö´ Failed Luck Cost Verification: Could not read LuckBox."
            );
            allCostsMet = false;
          } else if (currentLuck < luckCost) {
            await fShowMessage("‚ùå Not Enough Luck!");
            fMyConsoleLog(
              "üö´ Failed Luck Cost Verification: Insufficient Luck."
            );
            allCostsMet = false;
          } else {
            const newLuck = currentLuck - luckCost;
            addChangesToMap([{ r: "LuckBox", c: "LuckBox", value: newLuck }]);
            fMyConsoleLog(
              `      -> Luck Cost OK (${currentLuck} -> ${newLuck}). Change added to map.`
            );
          }
        }

        if (!isLuckedRoll && allCostsMet) {
          fMyConsoleLog("   -> Verifying Standard Costs...");
          const usesResult = await fUses_VerifyAndProcessCost(multiRollCount);
          if (!usesResult.success) {
            allCostsMet = false;
            userCancelled = usesResult.cancelledByUser;
          } else {
            addChangesToMap(usesResult.changes);
            pendingHeadersHtml.push(...usesResult.headers);
            pendingHeadersText.push(...usesResult.headersText);
          }

          if (allCostsMet) {
            const actResult = await fAct_VerifyAndProcessCost();
            if (!actResult.success) {
              allCostsMet = false;
              userCancelled = actResult.cancelledByUser;
            } else {
              addChangesToMap(actResult.changes);
              pendingHeadersHtml.push(...actResult.headers);
              pendingHeadersText.push(...actResult.headersText);
            }
          }
          if (allCostsMet) {
            const isOnResult = await fIsOn_VerifyAndProcessCost();
            addChangesToMap(isOnResult.changes);
          }
          if (allCostsMet) {
            const skMetaResult = await fSkMeta_VerifyAndProcessCost(
              gUI.pendingChangesMap
            );
            if (!skMetaResult.success) {
              allCostsMet = false;
            } else {
              addChangesToMap(skMetaResult.changes);
            }
          }
          if (allCostsMet) {
            const focusMetaResult = await fFocus_VerifyAndProcessCost(
              gUI.pendingChangesMap
            );
            if (!focusMetaResult.success) {
              allCostsMet = false;
            } else {
              addChangesToMap(focusMetaResult.changes);
            }
          }
        }

        if (!allCostsMet || userCancelled) {
          const reason = userCancelled
            ? "cost verification cancelled by user"
            : "insufficient resources";
          fMyConsoleLog(
            `üö¶ Halting Roll Dice Action due to ${reason}. Costs NOT applied.`
          );
          gUI.pendingChangesMap = {};
          fSetButtonOrMenuState(null);
          return;
        }
        fMyConsoleLog(
          "‚úÖ All necessary costs verified successfully. Changes prepared in map."
        );
      } else {
        fMyConsoleLog(`‚úÖ Skipping ALL Cost Verification (Free Roll).`);
        gUI.pendingChangesMap = {};
      }
      // --- End Cost Verification ---

      // === 6. Build Initial Log Header ===
      let initialLogHtml = "";
      let initialLogText = "";
      pendingHeadersHtml.forEach(
        (header) => (initialLogHtml += `${header}<br>`)
      );
      pendingHeadersText.forEach((header) => (initialLogText += `${header}\n`));

      let titleHtml = `<span class="sidebar-ability-name">${
        gUI.roll.skName || "Unknown Ability"
      }</span>`;
      let titleText = `${gUI.roll.skName || "Unknown Ability"}`;
      if (gUI.roll.skTyp) {
        titleHtml += ` ${gUI.roll.skTyp}`;
        titleText += ` ${gUI.roll.skTyp}`;
      }
      if (gUI.roll.resTyp && gUI.roll.resTyp !== gUI.roll.skTyp) {
        titleHtml += ` (<span class="red-bold">now</span> ${gUI.roll.resTyp})`;
        titleText += ` (now ${gUI.roll.resTyp})`;
      }
      initialLogHtml += titleHtml;
      initialLogText += titleText;

      const morph =
        typeof gUI.roll.skMorph === "string" && gUI.roll.skMorph !== ","
          ? gUI.roll.skMorph.trim()
          : "";
      if (morph) {
        initialLogHtml += `<br>morph: ${morph}`;
        initialLogText += `\nmorph: ${morph}`;
      }
      initialLogHtml = initialLogHtml.trim();
      initialLogText = initialLogText.trim();

      // gUI.roll.htmlHeader = initialLogHtml; // Not strictly needed anymore

      // === 7. Branch Roll Logic ===
      let finalLogResult = null;
      let helperSucceeded = false;
      let wasMonsterInteractionRoll = false;
      const resTypLower = resTyp.toLowerCase();

      if (resTypLower === "atk" && !hasDifficultyMorph) {
        fMyConsoleLog("‚öîÔ∏è Performing Player Attack Rolls...");
        finalLogResult = await fPerformPlayerAttackRolls(
          initialLogHtml,
          initialLogText
        );
        helperSucceeded = finalLogResult.success;
        if (helperSucceeded) {
          logHtmlToSend = finalLogResult.logHtml;
          logTextToSend = finalLogResult.logText;
          wasMonsterInteractionRoll = true;
        }
      } else if (resTypLower === "def" && !hasDifficultyMorph) {
        fMyConsoleLog("üõ°Ô∏è Performing Player Defense Rolls...");
        finalLogResult = await fPerformPlayerDefenseRolls(
          initialLogHtml,
          initialLogText
        );
        helperSucceeded = finalLogResult.success;
        if (helperSucceeded) {
          logHtmlToSend = finalLogResult.logHtml;
          logTextToSend = finalLogResult.logText;
          wasMonsterInteractionRoll = true;
        }
      } else if (resTypLower === "dmg" && !hasDifficultyMorph) {
        fMyConsoleLog("üí• Performing Player Damage Rolls...");
        finalLogResult = await fPerformPlayerDamageRolls(
          initialLogHtml,
          initialLogText
        );
        helperSucceeded = finalLogResult.success;
        if (helperSucceeded) {
          logHtmlToSend = finalLogResult.logHtml;
          logTextToSend = finalLogResult.logText;
          wasMonsterInteractionRoll = true;
        }
      } else if (resTypLower === "ar" && !hasDifficultyMorph) {
        fMyConsoleLog("üõ°Ô∏è Performing Player Armor Rolls...");
        finalLogResult = await fPerformPlayerArmorRolls(
          initialLogHtml,
          initialLogText
        );
        helperSucceeded = finalLogResult.success;
        if (helperSucceeded) {
          logHtmlToSend = finalLogResult.logHtml;
          logTextToSend = finalLogResult.logText;
          wasMonsterInteractionRoll = true;
        }
      } else {
        fMyConsoleLog("üéØ Performing Standard Roll(s)...");
        finalLogResult = fPerformMultiRolls(initialLogHtml, initialLogText);
        logHtmlToSend = finalLogResult.finalLogHtml;
        logTextToSend = finalLogResult.finalLogText;
        helperSucceeded = true;
        wasMonsterInteractionRoll = false;
      }

      if (!helperSucceeded) {
        fMyConsoleLog("   -> Roll sequence halted. Costs NOT applied.");
        gUI.pendingChangesMap = {};
        fSetButtonOrMenuState(null);
        return;
      }
      fMyConsoleLog(
        `   -> ${
          wasMonsterInteractionRoll ? "Monster interaction" : "Standard"
        } roll sequence completed.`
      );

      // === 8. Apply Pending Costs ===
      let applyErrors = false;
      if (Object.keys(gUI.pendingChangesMap).length > 0) {
        fMyConsoleLog(
          "‚úÖ Roll sequence successful. Applying Pending Cost Changes..."
        );
        const changeEntries = Object.entries(gUI.pendingChangesMap);
        fMyConsoleLog(
          `   -> Applying ${changeEntries.length} changes from map...`
        );
        for (const [key, value] of changeEntries) {
          try {
            const keyParts = key.split(",");
            if (keyParts.length !== 2) {
              console.warn(`Invalid key format: "${key}"`);
              applyErrors = true;
              continue;
            }
            const [rowPart, colPart] = keyParts;
            let rowRef = parseInt(rowPart, 10);
            if (isNaN(rowRef) || rowRef < 0) {
              rowRef = rowPart;
            }
            if (!fSetGridValue(rowRef, colPart, value)) {
              applyErrors = true;
            }
          } catch (parseError) {
            console.error(`Error processing change key "${key}":`, parseError);
            applyErrors = true;
          }
        }
        gUI.pendingChangesMap = {};
        if (applyErrors) {
          fMyConsoleLog(
            "‚ùå Errors occurred while applying cost/state changes."
          );
          await fShowMessage(
            "Error applying some cost/state changes post-roll."
          );
        } else {
          fMyConsoleLog("‚úÖ Costs Applied Successfully.");
        }
      } else {
        fMyConsoleLog(
          "‚úÖ Roll sequence successful. No Pending Cost Changes to Apply."
        );
      }

      // === 9. Update Nish Cell (if applicable) ===
      if (isNishAbilityRoll) {
        const finalNishRoll = gUI.roll.resRoll;
        if (typeof finalNishRoll === "number" || finalNishRoll === "") {
          fMyConsoleLog(
            `   -> Updating ('Nish', 'Nish') cell with final roll result: ${finalNishRoll}`
          );
          if (!fSetGridValue("Nish", "Nish", finalNishRoll)) {
            fMyConsoleLog(
              "      -> ‚ö†Ô∏è Failed to update ('Nish', 'Nish') cell."
            );
          }
        } else {
          fMyConsoleLog(
            `   -> Skipping update to ('Nish', 'Nish') cell: Invalid final roll result type (${typeof finalNishRoll}).`
          );
        }
      }

      // === 10. Log Result to Sidebar ===
      if (logHtmlToSend) {
        fPostToSidebar(logHtmlToSend, logTextToSend);
        fShowSidebar(); // Ensure sidebar is visible
      } else {
        fMyConsoleLog("‚ÑπÔ∏è No final log message generated.");
      }
      // gUI.roll.htmlHeader = ''; // Not needed anymore
    } catch (err) {
      // --- Catch Unexpected Errors ---
      console.error("Critical Error in fMain_AbilityRoll:", err);
      fMyConsoleLog(`‚ùå CRITICAL ERROR during roll action: ${err.message}`);
      await fShowMessage(
        `‚ùå Critical Error during roll: ${err.message}. Please check console.`
      );
      fSetButtonOrMenuState(null);
      // Attempt to send log even after critical error, slightly delayed
      setTimeout(() => fSendLogToGMScreenAndPS(), 0);
      return; // Exit after critical error
    }

    // === 11. Reset Button State & Send Log to GM ===
    fSetButtonOrMenuState(null);
    fMyConsoleLog(`‚úÖ Roll Dice Action Completed.`);

    // Send the final log state to the GMScreen (with slight delay)
    setTimeout(() => fSendLogToGMScreenAndPS(), 0);
  } // END fMain_AbilityRoll

  // fIsSk1Sk2RadioCheckbox //////////////////////////////////////////////////////////////
  // Purpose -> Validates that the provided coordinates (r, c) correspond to a valid
  //            Sk1/Sk2 checkbox location based on gUI.range.sk1sk2CheckBoxes.
  //            Shows a message if invalid.
  // Inputs  -> r (Number): 0-based row index.
  //         -> c (Number): 0-based column index.
  // Outputs -> (Promise<Boolean>): Resolves true if coordinates are valid, false otherwise.
  async function fIsSk1Sk2RadioCheckbox(row, col) {
    // Check if the coordinates fall within any defined Sk checkbox range
    const isValid = fIsSkRadioGroupMember(row, col);

    // Show message if coordinates are not for a valid ability checkbox
    if (!isValid) {
      await fShowMessage("‚ö†Ô∏è Please select a valid Ability checkbox first!");
    }

    return isValid;
  } // END fIsSk1Sk2RadioCheckbox

  // fClearAndSetGUIRoll /////////////////////////////////////////////////////
  // Purpose -> Resets the global gUI.roll object and populates it with base data
  //            extracted from the ability/gear row specified by the selected checkbox (r, c).
  //            Cleans and standardizes the extracted data (e.g., trims strings,
  //            parses numbers, defaults empty values). Sets initial resTyp, multiRollCount,
  //            and the isNish flag.
  // Inputs  -> r (Number): Row index of the selected ability/gear.
  //         -> c (Number): Column index of the selected checkbox (determines Sk1 vs Sk2).
  // Outputs -> (Promise<Boolean>): Resolves true if successful, false if an error occurs.
  async function fClearAndSetGUIRoll(r, c) {
    try {
      // Helper to get value from the specified row `r` and a column tag
      const getVal = (tag) => gUI.arr[r]?.[fResolveCol(tag)] ?? "";
      // Determine if Sk1 or Sk2 checkbox was clicked
      const isSk1 = c === fResolveCol("Sk1ChkBox");

      // === Initialize gUI.roll with Extracted Data ===
      gUI.roll = {
        ability_R: r,
        sk1CB: isSk1,
        // Get values based on whether Sk1 or Sk2 column was checked
        skMorph: isSk1 ? getVal("Morph1") : getVal("Morph2"),
        skTyp: isSk1 ? getVal("Sk1Typ") : getVal("Sk2Typ"),
        skSk: isSk1 ? getVal("Sk1") : getVal("Sk2"),
        skIsOn: getVal("On"),
        skNameID: getVal("Ability"),
        skAct: isSk1 ? getVal("Act") : "", // Costs usually only apply to Sk1
        skDur: isSk1 ? getVal("Dur") : "",
        skMeta: isSk1 ? getVal("Meta") : "",
        skUses: isSk1 ? getVal("Uses") : "",
        // Initialize derived/calculated fields
        skName: "",
        resTyp: "",
        resSk: "",
        resFlatBase: "",
        resFlatResult: "",
        resDif: "",
        resFocus: "",
        resPlus: "",
        resPlusPlus: "",
        resdctMult: "",
        resMult: "",
        resMultMult: "",
        resCombine: "",
        isUnSk: false,
        isNish: false, // <<< Initialized isNish flag
        multiRollCount: 1, // Default multi-roll count
        roll: "",
        resRoll: "",
        htmlHeader: "",
      };

      // --- Set isNish Flag ---
      // Resolve Nish row index and compare with current row 'r'
      const nishRowResolved = fResolveRow("NishAtr_R");
      if (!isNaN(nishRowResolved) && r === nishRowResolved) {
        gUI.roll.isNish = true;
        fMyConsoleLog("   -> Setting gUI.roll.isNish = true");
      }
      // --- End Set isNish Flag ---

      const rData = gUI.roll; // Alias for convenience

      // === Clean String Fields ===
      // Remove trailing ID, trim whitespace, remove leading commas from morph
      rData.skName = String(rData.skNameID || "")
        .replace(/\s{2,}_\w{6}$/, "")
        .trim();
      rData.skMorph = String(rData.skMorph || "")
        .trim()
        .replace(/^,+/, "");
      rData.skTyp = String(rData.skTyp || "").trim();
      rData.skIsOn = String(rData.skIsOn || "").trim();
      rData.skDur = String(rData.skDur || "").trim();
      rData.skMeta = String(rData.skMeta || "")
        .trim()
        .toUpperCase(); // Store Meta tag uppercase
      // Ensure skMeta tag is valid, otherwise clear it
      if (rData.skMeta && !(gUI.list?.metaColor || []).includes(rData.skMeta)) {
        rData.skMeta = "";
      }

      // === Clean Numeric Fields ===
      // Convert Sk to number >= 1, else empty string
      const sk = parseInt(rData.skSk, 10);
      rData.skSk = !isNaN(sk) && sk >= 1 ? sk : "";
      // Convert Act to number >= 1, else empty string
      const act = parseInt(String(rData.skAct || "").trim(), 10);
      rData.skAct = !isNaN(act) && act >= 1 ? act : "";
      // Convert Uses to number, allow any integer (including 0 or negative), else empty string
      const uses = parseInt(rData.skUses, 10);
      rData.skUses = !isNaN(uses) ? uses : "";

      // === Set Initial Derived Values ===
      // Default resulting type to the base skill type
      rData.resTyp = rData.skTyp;

      fMyConsoleLog(
        `‚öôÔ∏è Populated & Cleaned gUI.roll for row ${r} (isSk1: ${isSk1}, isNish: ${gUI.roll.isNish})`
      );
      return true; // Indicate success
    } catch (err) {
      // --- Error Handling ---
      console.error("fClearAndSetGUIRoll: Error processing ability data:", err);
      fMyConsoleLog(`‚ùå Error populating/cleaning gUI.roll: ${err.message}`);
      // Show error to user via sidebar
      await fShowMessage(`‚ùå Error processing skill data: ${err.message}`);
      return false; // Indicate failure
    }
  } // END fClearAndSetGUIRoll

  // fVerifyAbilityHasSkAndType //////////////////////////////////////////////////////////////////
  // Purpose -> Performs basic validation on the populated gUI.roll object, ensuring
  //            the ability has a name and a valid, recognized skill type.
  // Inputs  -> None (Uses gUI.roll and gUI.list).
  // Outputs -> (Promise<Boolean>): Resolves true if ability data is valid, false otherwise.
  async function fVerifyAbilityHasSkAndType() {
    const { skName, skTyp, sk1CB } = gUI.roll;

    // --- Check Name ---
    // Ability name must exist
    if (!skName) {
      await fShowMessage("‚ö†Ô∏è Please select an Ability with a name!");
      return false;
    }

    // --- Check Type ---
    // Skill Type must be a non-empty string
    if (!skTyp || typeof skTyp !== "string") {
      const is2ndCol = !sk1CB; // Check if Sk2 column was used (often typeless)
      await fShowMessage(
        `‚ö†Ô∏è No skill Typ found${
          is2ndCol ? "<br><br>You may have wanted the 1st column." : ""
        }`
      );
      return false;
    }

    // Skill type must match one of the known types defined in gUI.list.skTyp (case-insensitive)
    const skTypLower = skTyp.trim().toLowerCase();
    const isValidSkTyp = (gUI.list?.skTyp || []).some(
      (type) => type.toLowerCase() === skTypLower
    );
    if (!isValidSkTyp) {
      await fShowMessage(`‚ö†Ô∏è ${skTyp} is an invalid Skill Type!`);
      return false;
    }

    // --- Passed All Checks ---
    return true;
  } // END fVerifyAbilityHasSkAndType

  // fProcessMorph ///////////////////////////////////////////////////////////////////
  // Purpose -> Parses the ability's morph string (gUI.roll.skMorph), extracting all
  //            modifiers and flags (e.g., '+5', '*2', '^10', 'un', 'free', 'luck', '#3').
  //            Calls helper functions fParseMorphComponents and fApplyMorphResults
  //            to update the `res*` properties within gUI.roll.
  // Inputs  -> None (Reads gUI.roll.skMorph).
  // Outputs -> None (Modifies gUI.roll properties via helper functions).
  async function fProcessMorph() {
    const skMorph = gUI.roll.skMorph || ""; // Get morph string, default to empty

    // === Initialize Accumulator (Moved outside the 'if' block) ===
    // This object holds intermediate results during parsing
    const acc = {
      foundResTyp: false,
      lastResTypMatch: "",
      lastFocusTag: "",
      foundResPlus: false,
      totalPlus: 0,
      combineNumbers: [], // <<< combineNumbers is now always initialized
      foundResPlusPlus: false,
      totalPlusPlus: 0,
      foundResMult: false,
      totalMult: 1.0,
      foundResMultMult: false,
      totalMultMult: 1.0,
      lastFlatBaseMatch: "",
      lastFlatResultMatch: "",
      lastDifMatch: "",
      foundResdctMult: false,
      totalResdctMult: 1.0,
    };

    // === Parse Components (if morph string exists) ===
    if (skMorph) {
      fMyConsoleLog("   -> Processing skMorph string...");
      // Split into components and create lowercased version for checks
      const morphComponents = skMorph
        .split(",")
        .map((x) => x.trim())
        .filter(Boolean);
      const morphLower = morphComponents.map((x) => x.toLowerCase());
      // Parse components and update accumulator/gUI.roll flags
      await fParseMorphComponents(morphComponents, morphLower, acc); // Pass the initialized acc
      fMyConsoleLog("   -> Finished processing skMorph string.");
    } else {
      fMyConsoleLog("‚ÑπÔ∏è No skMorph string to process.");
    }

    // === Apply Results ===
    // Apply accumulated/default results to final gUI.roll.res* fields
    fApplyMorphResults(acc); // Always pass the initialized acc object
  } // END fProcessMorph

  // fParseMorphComponents ///////////////////////////////////////////////////////////
  // Purpose -> Helper for fProcessMorph. Iterates through individual morph string
  //            components, parsing them using regex and updating the accumulator object (`acc`)
  //            or directly setting flags in `gUI.roll` (e.g., isUnSk, isFreeRoll, isLuckedRoll, multiRollCount).
  // Inputs  -> morphComponents (Array): Array of trimmed, non-empty morph components.
  //         -> morphLower (Array): Lowercased version of morphComponents for case-insensitive checks.
  //         -> acc (Object): Accumulator object to store intermediate parsed values.
  // Outputs -> None (Mutates the input `acc` object and `gUI.roll` properties).
  async function fParseMorphComponents(morphComponents, morphLower, acc) {
    // --- Regex Definitions ---
    const plusMinusRegex = /^([-+])(\d+)$/; // e.g., +5, -10
    const numberOnlyRegex = /^\d+$/; // e.g., 20 (for Combine)
    const plusPlusMinusMinusRegex = /^(?:(\+\+)|(--))(\d+)$/; // e.g., ++5, --10
    const multDivRegex = /^([*\/])(\d+(\.\d+)?)$/; // e.g., *1.5, /2
    const multMultDivDivRegex = /^(?:(\*\*)|(\/\/))(\d+(\.\d+)?)$/; // e.g., **1.5, //2
    const equalsRegex = /^=(\d+)$/; // e.g., =50 (Set Base Sk)
    const equalsEqualsRegex = /^==(\d+)$/; // e.g., ==100 (Set Final Roll)
    const caretRegex = /^\^(\d+)$/; // e.g., ^25 (Set Difficulty)
    const dctRegex = /^([-+])(\d+)([dct])$/i; // e.g., +1c, -2t, +3d
    const multiRollRegex = /^#(\d+)$/; // e.g., #3 (Roll 3 times)

    // === Parse Each Component ===
    // Use for...of loop to allow await within the loop (for fShowMessage on errors)
    let index = 0;
    for (const component of morphComponents) {
      const lower = morphLower[index]; // Get lowercased version for checks

      // --- Check Flags (Case-Insensitive) ---
      if (lower === "free") {
        gUI.roll.isFreeRoll = true;
        fMyConsoleLog(`   -> Morph: Free Roll detected.`);
      }
      if (lower === "luck") {
        gUI.roll.isLuckedRoll = true;
        fMyConsoleLog(`   -> Morph: Lucked Roll detected.`);
      }
      if (lower === "un" || lower === "unsk") {
        gUI.roll.isUnSk = true;
      }

      // --- Check Overrides & Modifiers (using Regex) ---
      // Check SkTyp (LAST match wins)
      if ((gUI.list?.skTyp || []).some((t) => t.toLowerCase() === lower)) {
        acc.lastResTypMatch = component; // Store original case
        acc.foundResTyp = true;
      }
      // Check Focus Meta Tag (LAST match wins)
      const focusTag = lower.toUpperCase();
      if ((gUI.list?.metaColor || []).includes(focusTag)) {
        acc.lastFocusTag = focusTag; // Store uppercase tag
      }
      // Check Multi-Roll (#N)
      const multiRollMatch = component.match(multiRollRegex);
      if (multiRollMatch) {
        let count = parseInt(multiRollMatch[1], 10);
        if (!isNaN(count)) {
          if (count > 30) {
            count = 30;
            fMyConsoleLog(`   -> Morph: Multi-Roll capped at 30.`);
          }
          if (count >= 2) {
            gUI.roll.multiRollCount = count;
            fMyConsoleLog(`   -> Morph: Multi-Roll Count set to: ${count}`);
          } else {
            fMyConsoleLog(
              `   -> Morph: Multi-Roll Count ${count} ignored (< 2).`
            );
          }
        } else {
          fMyConsoleLog(
            `   -> Morph: Multi-Roll ignored (invalid number "${multiRollMatch[1]}").`
          );
        }
      }
      // Check resPlus (+/-N)
      const plusMatch = component.match(plusMinusRegex);
      if (plusMatch) {
        const val = parseInt(plusMatch[2], 10);
        acc.totalPlus += plusMatch[1] === "+" ? val : -val;
        acc.foundResPlus = true;
      }
      // Check resCombine (Number only)
      if (numberOnlyRegex.test(component)) {
        acc.combineNumbers.push(parseInt(component, 10));
      }
      // Check resPlusPlus (++ / --N)
      const ppMatch = component.match(plusPlusMinusMinusRegex);
      if (ppMatch) {
        const val = parseInt(ppMatch[3], 10);
        acc.totalPlusPlus += ppMatch[1] === "++" ? val : -val;
        acc.foundResPlusPlus = true;
      }
      // Check resMult (* / /N)
      const m1 = component.match(multDivRegex);
      if (m1) {
        const val = parseFloat(m1[2]);
        if (m1[1] === "*") {
          acc.totalMult *= val;
        } else if (val !== 0) {
          acc.totalMult /= val;
        } else {
          await fShowMessage("‚ùå Morph includes illegal '/0'. Please correct.");
          console.warn("resMult divide by zero:", component);
        }
        acc.foundResMult = true;
      }
      // Check resMultMult (** // //N)
      const m2 = component.match(multMultDivDivRegex);
      if (m2) {
        const val = parseFloat(m2[3]);
        if (m2[1] === "**") {
          acc.totalMultMult *= val;
        } else if (val !== 0) {
          acc.totalMultMult /= val;
        } else {
          await fShowMessage(
            "‚ùå Morph includes illegal '//0'. Please correct."
          );
          console.warn("resMultMult divide by zero:", component);
        }
        acc.foundResMultMult = true;
      }
      // Check resdctMult (+/-Nd/c/t)
      const dctMatch = component.match(dctRegex);
      if (dctMatch) {
        const sign = dctMatch[1];
        const num = parseInt(dctMatch[2], 10);
        const type = dctMatch[3].toLowerCase();
        let multiplier = 1.0;
        if (num !== 0) {
          // Calculate multiplier based on type (c, t, d)
          const isPositive = sign === "+";
          switch (type) {
            case "c":
              const cf = 2 * num;
              multiplier = cf === 0 ? 1 : isPositive ? cf : 1 / cf;
              break;
            case "t":
              const tf = Math.pow(10, num);
              multiplier = isPositive ? tf : 1 / tf;
              break;
            case "d":
              const dt = 1 + num / 3;
              multiplier = dt === 0 ? 1 : isPositive ? dt : 1 / dt;
              break;
          }
          if (!isNaN(multiplier) && isFinite(multiplier) && multiplier > 0) {
            // Apply if valid
            acc.totalResdctMult *= multiplier;
            acc.foundResdctMult = true;
          } else {
            console.warn(
              `Invalid DCT multiplier for "${component}": ${multiplier}.`
            );
          }
        }
      }
      // Check Flat Base (=N) (LAST match wins)
      const eq1 = component.match(equalsRegex);
      if (eq1) acc.lastFlatBaseMatch = eq1[1];
      // Check Flat Result (==N) (LAST match wins)
      const eq2 = component.match(equalsEqualsRegex);
      if (eq2) acc.lastFlatResultMatch = eq2[1];
      // Check Difficulty (^N) (LAST match wins)
      const dif = component.match(caretRegex);
      if (dif) acc.lastDifMatch = dif[1];

      index++; // Increment index for lowercased array access
    } // End component loop
  } // END fParseMorphComponents

  // fApplyMorphResults //////////////////////////////////////////////////////////////
  // Purpose -> Applies the accumulated/parsed morph results from the `acc` object
  //            (populated by fParseMorphComponents) to the final `res*` properties
  //            of the global gUI.roll object. Calculates resCombine.
  // Inputs  -> acc (Object): The accumulator object containing parsed morph results.
  // Outputs -> None (Modifies gUI.roll object properties).
  function fApplyMorphResults(acc) {
    const r = gUI.roll; // Alias for gUI.roll

    // === Apply Flat Base (=N) ===
    // MUST BE FIRST: Sets resFlatBase and potentially overrides skSk.
    if (acc.lastFlatBaseMatch !== "") {
      const num = parseInt(acc.lastFlatBaseMatch, 10);
      if (!isNaN(num)) {
        r.resFlatBase = num;
        r.skSk = num; // Override base skill if flat base is set
      }
    }

    // === Apply Resulting Type ===
    // Use last matched type, otherwise default back to original skTyp.
    if (acc.foundResTyp) {
      r.resTyp = acc.lastResTypMatch || r.skTyp;
    }
    // else: r.resTyp already defaulted to r.skTyp in fClearAndSetGUIRoll

    // === Apply Focus Meta ===
    // Use last matched valid meta color tag.
    if (acc.lastFocusTag && acc.lastFocusTag !== "") {
      r.resFocus = acc.lastFocusTag; // ('R', 'O', 'Y', 'G', 'B')
    } else {
      r.resFocus = ""; // Ensure cleared if no valid tag found
    }

    // === Apply Additive Skill Modifier (+/-N) ===
    if (acc.foundResPlus) {
      r.resPlus = acc.totalPlus;
    }

    // === Calculate Combined Skill (Diminishing Returns) ===
    // Add base skill (r.skSk, potentially overridden by resFlatBase) to numbers found in morphs.
    if (typeof r.skSk === "number" && r.skSk >= 1) {
      acc.combineNumbers.push(r.skSk);
    }
    // Calculate combined value if any numbers were collected
    if (acc.combineNumbers.length > 0) {
      acc.combineNumbers.sort((a, b) => b - a); // Sort descending
      let value = 0,
        divisor = 1;
      for (const num of acc.combineNumbers) {
        value += num / divisor;
        divisor *= 2; // Diminishing returns divisor
      }
      r.resCombine = Math.round(value); // Round final combined value
    }

    // === Apply Additive Roll Modifier (++ / --N) ===
    if (acc.foundResPlusPlus) {
      r.resPlusPlus = acc.totalPlusPlus;
    }

    // === Apply Multiplicative Skill Modifier (* / /N) ===
    if (acc.foundResMult) {
      r.resMult = Number(acc.totalMult.toFixed(6)); // Apply with precision
    }

    // === Apply Multiplicative Roll Modifier (** // //N) ===
    if (acc.foundResMultMult) {
      r.resMultMult = Number(acc.totalMultMult.toFixed(6)); // Apply with precision
    }

    // === Apply DCT Multiplier (+/-Nd/c/t) ===
    if (acc.foundResdctMult) {
      r.resdctMult = Number(acc.totalResdctMult.toFixed(6)); // Apply with precision
    }

    // === Apply Flat Result Override (==N) ===
    if (acc.lastFlatResultMatch !== "") {
      const num = parseInt(acc.lastFlatResultMatch, 10);
      if (!isNaN(num)) r.resFlatResult = num;
    }

    // === Apply Difficulty (^N) ===
    if (acc.lastDifMatch !== "") {
      const num = parseInt(acc.lastDifMatch, 10);
      if (!isNaN(num)) r.resDif = num;
    }
  } // END fApplyMorphResults

  // fAct_VerifyAndProcessCost ///////////////////////////////////////////////////////
  // Purpose -> Cost Verification Helper: Checks Action Points. Prompts if insufficient.
  //            Collects change to AP and sidebar log headers (HTML & text).
  // Inputs  -> None.
  // Outputs -> (Promise<Object>): { success, cancelledByUser, changes, headers, headersText }
  //            'headers' is HTML, 'headersText' is plain text.
  async function fAct_VerifyAndProcessCost() {
    const { skAct, skName } = gUI.roll;
    const actCost = Number(skAct);
    const changes = [];
    const headers = []; // Array for HTML headers
    const headersText = []; // Array for plain text headers

    if (actCost > 0) {
      let currentAct = fGetGridValue("Act", "ActTot", true);
      if (isNaN(currentAct)) {
        await fShowMessage(
          `‚ùå Error reading current Action Points from cell ('Act', 'ActTot'). Cannot proceed.`
        );
        fMyConsoleLog(
          "üö´ Failed to verify Act cost: Could not read Action Points."
        );
        return {
          success: false,
          cancelledByUser: false,
          changes: [],
          headers: [],
          headersText: [],
        };
      }

      if (actCost > currentAct) {
        fMyConsoleLog(
          `‚ö†Ô∏è Insufficient Action Points (Need ${actCost}, Have ${currentAct})`
        );
        const proceed = await fShowPrompt(
          `Not Enough Action Points (${currentAct}) to use '${skName}' (Cost: ${actCost})<br><br>Do you want to go negative?`
        );
        if (!proceed) {
          fMyConsoleLog(
            "üö´ User cancelled Act cost due to insufficient points."
          );
          return {
            success: false,
            cancelledByUser: true,
            changes: [],
            headers: [],
            headersText: [],
          };
        }
        fMyConsoleLog(
          "‚úÖ User chose to proceed despite insufficient Action Points."
        );
        const warningText = `‚ö†Ô∏è NEGATIVE ACT POINTS: ${currentAct - actCost}`;
        headers.push(`<span class="red-bold">${warningText}</span>`); // HTML version
        headersText.push(warningText); // Plain text version
      }

      const newActTotal = currentAct - actCost;
      changes.push({ r: "Act", c: "ActTot", value: newActTotal });
      fMyConsoleLog(
        `   -> Action Points: ${currentAct} -> ${newActTotal} (Pending)`
      );
    } else {
      fMyConsoleLog("   -> No Action Point cost for this ability.");
    }

    return {
      success: true,
      cancelledByUser: false,
      changes: changes,
      headers: headers,
      headersText: headersText,
    };
  } // END fAct_VerifyAndProcessCost

  // fUses_VerifyAndProcessCost //////////////////////////////////////////////////////
  // Purpose -> Cost Verification Helper: Checks Uses. Prompts if insufficient.
  //            Collects change to Uses and sidebar log headers (HTML & text).
  // Inputs  -> multiRollCount (Number).
  // Outputs -> (Promise<Object>): { success, cancelledByUser, changes, headers, headersText }
  async function fUses_VerifyAndProcessCost(multiRollCount) {
    const { skUses, skName, ability_R } = gUI.roll;
    const changes = [];
    const headers = []; // HTML headers
    const headersText = [];

    const currentUses = Number(skUses);
    if (skUses === "" || isNaN(currentUses)) {
      fMyConsoleLog("   -> No 'Uses' cost defined for this ability.");
      return {
        success: true,
        cancelledByUser: false,
        changes: [],
        headers: [],
        headersText: [],
      };
    }

    const totalUsesCost = Math.max(1, multiRollCount);
    fMyConsoleLog(
      `   -> Uses Check: Current=${currentUses}, Total Cost for ${multiRollCount} rolls=${totalUsesCost}`
    );
    const newUses = currentUses - totalUsesCost;

    if (currentUses < totalUsesCost) {
      fMyConsoleLog(
        `‚ö†Ô∏è Insufficient Uses Left (Need ${totalUsesCost}, Have ${currentUses})`
      );
      const proceed = await fShowPrompt(
        `Not Enough Uses Left (${currentUses}) to use '${skName}' ${multiRollCount} times (Cost: ${totalUsesCost})<br><br>Do you want to go negative?`
      );
      if (!proceed) {
        fMyConsoleLog(
          "üö´ User cancelled Uses cost due to insufficient points."
        );
        return {
          success: false,
          cancelledByUser: true,
          changes: [],
          headers: [],
          headersText: [],
        };
      }
      fMyConsoleLog("‚úÖ User chose to proceed despite insufficient Uses.");
      const warningText = `‚ö†Ô∏è NEGATIVE USES: ${newUses}`;
      headers.push(`<span class="red-bold">${warningText}</span>`); // HTML version
      headersText.push(warningText);
    }

    changes.push({ r: ability_R, c: "Uses", value: newUses });
    fMyConsoleLog(
      `   -> Uses: ${currentUses} -> ${newUses} (Pending, cost: ${totalUsesCost})`
    );
    return {
      success: true,
      cancelledByUser: false,
      changes: changes,
      headers: headers,
      headersText: headersText,
    };
  } // END fUses_VerifyAndProcessCost

  // fIsOn_VerifyAndProcessCost //////////////////////////////////////////////////////
  // Purpose -> Cost "Verification" Helper: Prepares the change object to copy the
  //            ability's Duration (gUI.roll.skDur) to its 'Is On' cell, but ONLY if
  //            the roll originated from the Sk1 checkbox (gUI.roll.sk1CB is true).
  //            This effectively sets the duration timer when an Sk1 ability is used.
  // Inputs  -> None (Uses gUI.roll).
  // Outputs -> (Promise<Object>): { success: true, changes: Array, headers: Array }
  //            'changes' contains the change object {r: ability_R, c: 'On', value: skDur} if Sk1 used.
  //            'headers' is always empty.
  // NOTE: Made async for consistency, though not strictly required.
  async function fIsOn_VerifyAndProcessCost() {
    const { skDur, ability_R, sk1CB } = gUI.roll; // Get Duration, Row Index, Sk1 Flag
    const changes = [];
    const headers = []; // Headers not used by this function

    // Only prepare change if Sk1 checkbox triggered the roll
    if (sk1CB === true) {
      // Prepare change to set 'On' column to the ability's duration value
      changes.push({ r: ability_R, c: "On", value: skDur });
      fMyConsoleLog(
        `   -> Is On: Set to Dur value '${skDur}' (Pending, Sk1 condition met)`
      );
    } else {
      // If Sk2 triggered, no duration is set
      fMyConsoleLog(
        `   -> Is On: No change (Condition sk1CB === true not met)`
      );
    }

    // This function always returns success as there's no failure condition
    return { success: true, changes: changes, headers: headers };
  } // END fIsOn_VerifyAndProcessCost

  // fSkMeta_VerifyAndProcessCost ////////////////////////////////////////////////////
  // Purpose -> Cost Verification Helper: Checks and prepares the change for the
  //            ability's innate Meta cost (defined in gUI.roll.skMeta), but only if
  //            the roll originated from the Sk1 checkbox. Uses fSpendOneMeta to find
  //            an available Meta unit (starting from the specified color) considering
  //            pending changes. Halts if cost cannot be paid.
  // Inputs  -> pendingChangesMap (Object): Map of changes pending from previous cost checks.
  // Outputs -> (Promise<Object>): { success: Boolean, changes: Array, headers: Array }
  //            'success' is false if cost cannot be paid.
  //            'changes' contains the change object for the Meta cell if successful.
  //            'headers' is always empty.
  async function fSkMeta_VerifyAndProcessCost(pendingChangesMap) {
    const { sk1CB, skMeta, skName } = gUI.roll; // Get Sk1 flag, Meta cost tag, Ability Name
    const changes = [];
    const headers = []; // Headers not used by this function

    // === 1. Check Sk1 Condition ===
    // Skill Meta cost typically only applies to Sk1 abilities
    if (sk1CB !== true) {
      fMyConsoleLog(
        "   -> SkMeta Cost: Skipped (Condition sk1CB === true not met)"
      );
      return { success: true, changes: [], headers: [] }; // No cost to apply
    }

    // === 2. Check if Meta Cost is Defined ===
    const metaColorTag = String(skMeta || "")
      .trim()
      .toUpperCase(); // Get tag from gUI.roll
    if (!metaColorTag) {
      fMyConsoleLog(
        "   -> SkMeta Cost: Skipped (No Meta Color Tag defined in skMeta field)."
      );
      return { success: true, changes: [], headers: [] }; // No cost to apply
    }

    // === 3. Attempt to Spend Meta ===
    // Call helper to find 1 unit of specified (or higher) meta, considering pending changes
    fMyConsoleLog(
      `   -> SkMeta Cost: Attempting to spend 1 unit of '${metaColorTag}'...`
    );
    const spendResult = await fSpendOneMeta(metaColorTag, pendingChangesMap);

    // === 4. Handle Result ===
    if (spendResult.success) {
      // Meta unit found, add the prepared change object
      fMyConsoleLog("      -> Success: Found 1 unit to spend for SkMeta cost.");
      changes.push(spendResult.change);
      return { success: true, changes: changes, headers: headers };
    } else {
      // Failed (either invalid tag or insufficient meta)
      // fSpendOneMeta shows message for invalid tag; show "Not enough" only if tag was valid
      const metaColors = gUI.list?.metaColor || [];
      const isValidColor = metaColors.some(
        (c) => c.toUpperCase() === metaColorTag
      );
      if (isValidColor) {
        fMyConsoleLog(
          `      -> ‚ùå Failed: Could not find 1 unit of ${metaColorTag} for SkMeta.`
        );
        await fShowMessage(
          `‚ùå Not enough Meta.<br>${skName} needs @${metaColorTag}.`
        );
      }
      return { success: false, changes: [], headers: [] }; // Indicate failure
    }
  } // END fSkMeta_VerifyAndProcessCost

  // fSpendOneMeta ///////////////////////////////////////////////////////////////////
  // Purpose -> Helper to find 1 available unit of Meta (checking Channel pool first,
  //            then Main pool) and prepare the change object for decrementing it.
  //            Starts checking from the specified `metaColor` and cycles upwards if needed
  //            (R -> O -> Y -> G -> B). Considers pending changes from `pendingChangesMap`.
  //            Sets the new value to '' (empty string) if decrementing results in < 1.
  // Inputs  -> metaColor (String): The preferred Meta color TAG ('R'...'B') to start spending from.
  //         -> pendingChangesMap (Object): Map holding pending changes {'rTag,cTag': newValue}.
  // Outputs -> (Promise<Object>): Resolves to { success: true, change: { r, c, value } } if 1 unit found,
  //                               or { success: false } if invalid color or no unit found.
  async function fSpendOneMeta(metaColor, pendingChangesMap) {
    fMyConsoleLog(
      `   -> Attempting to spend 1 Meta unit, starting check from: ${metaColor}`
    );

    // === 1. Validate Input Color Tag ===
    const metaColors = gUI.list?.metaColor; // e.g., ['R','O','Y','G','B']
    // Validate meta color list definition
    if (!Array.isArray(metaColors) || metaColors.length === 0) {
      console.error(
        "fSpendOneMeta: gUI.list.metaColor is not defined or empty."
      );
      await fShowMessage("‚ùå Internal Error: Meta color list not defined.");
      return { success: false };
    }
    // Find the index of the starting color (case-insensitive)
    const inputColorUpper = metaColor?.toUpperCase();
    const startIndex = metaColors.findIndex(
      (color) => color.toUpperCase() === inputColorUpper
    );
    // Validate the input color tag exists in the list
    if (startIndex === -1) {
      fMyConsoleLog(
        `      -> ‚ùå Invalid input: Meta Color '${metaColor}' is not allowed.`
      );
      await fShowMessage(`‚ùå Meta Color '${metaColor}' is not allowed.`);
      return { success: false };
    }
    const validMetaColorTag = metaColors[startIndex]; // Use the correctly cased tag from list
    fMyConsoleLog(
      `      -> Validated start color: ${validMetaColorTag} (Index: ${startIndex})`
    );

    // === Helper to Get Current Value (Considering Pending Changes) ===
    const getCurrentValue = (rowTag, colTag) => {
      const key = `${rowTag},${colTag}`;
      // Check if this cell has a pending change
      if (pendingChangesMap.hasOwnProperty(key)) {
        const pendingValue = Number(pendingChangesMap[key]);
        // Use pending value if it's a number >= 1, otherwise treat as 0
        // (Prevents double-spending from a value already pending decrement to < 1)
        return !isNaN(pendingValue) && pendingValue >= 1 ? pendingValue : 0;
      } else {
        // No pending change, read from grid, default invalid/blank/< 1 to 0
        const gridVal = fGetGridValue(rowTag, colTag, true);
        return gridVal >= 1 ? gridVal : 0; // Only count values >= 1
      }
    };

    // === 2. Cycle Through Colors (From Start Index Upwards) ===
    const numColors = metaColors.length;
    // Loop from the starting color index up to the last color ('B')
    for (let i = startIndex; i < numColors; i++) {
      const currentColorTag = metaColors[i];
      fMyConsoleLog(`         - Checking Color: ${currentColorTag}`);

      // --- Check Channel Pool ---
      const chnlVal = getCurrentValue("chnl", currentColorTag);
      if (chnlVal >= 1) {
        // Found 1+ in Channel pool
        const newVal = chnlVal - 1;
        // Prepare change: new value is newVal, or '' if newVal is 0
        const change = {
          r: "chnl",
          c: currentColorTag,
          value: newVal >= 1 ? newVal : "",
        };
        fMyConsoleLog(
          `           - Found in Channel pool. Preparing change: ${JSON.stringify(
            change
          )}`
        );
        return { success: true, change: change }; // Success!
      }

      // --- Check Main Pool (if not found in Channel) ---
      const metaVal = getCurrentValue("meta", currentColorTag);
      if (metaVal >= 1) {
        // Found 1+ in Main pool
        const newVal = metaVal - 1;
        // Prepare change: new value is newVal, or '' if newVal is 0
        const change = {
          r: "meta",
          c: currentColorTag,
          value: newVal >= 1 ? newVal : "",
        };
        fMyConsoleLog(
          `           - Found in Main pool. Preparing change: ${JSON.stringify(
            change
          )}`
        );
        return { success: true, change: change }; // Success!
      }

      // If not found in either pool for this color, log and continue loop
      fMyConsoleLog(`           - Not found in ${currentColorTag} pools.`);
    } // --- End Color Cycle Loop ---

    // === 3. Not Found ===
    // If loop completes without returning, no unit was found
    fMyConsoleLog(
      `      -> ‚ùå Failed: Could not find 1 unit of Meta to spend after checking colors ${validMetaColorTag} through ${
        metaColors[numColors - 1]
      }.`
    );
    return { success: false }; // Indicate failure
  } // END fSpendOneMeta

  // fFocus_VerifyAndProcessCost ///////////////////////////////////////////////////
  // Purpose -> Cost Verification Helper: Checks and prepares the change for the Focus
  //            Meta cost, if specified by a morph setting gUI.roll.resFocus to a valid
  //            Meta color tag ('R'...'B'). Uses fSpendOneMeta to find an available unit,
  //            considering pending changes. Halts if cost cannot be paid.
  // Inputs  -> pendingChangesMap (Object): Map of changes pending from previous cost checks.
  // Outputs -> (Promise<Object>): { success: Boolean, changes: Array, headers: Array }
  //            'success' is false if cost cannot be paid or tag is invalid.
  //            'changes' contains the change object for the Meta cell if successful.
  //            'headers' is always empty.
  async function fFocus_VerifyAndProcessCost(pendingChangesMap) {
    const focusColorTag = gUI.roll.resFocus; // Get the Focus tag ('R'..'B' or '')
    const changes = [];
    const headers = []; // Headers not used by this function
    const metaColors = gUI.list?.metaColor; // e.g., ['R','O','Y','G','B']

    // === 1. Check if Focus Cost Applies ===
    if (!focusColorTag || typeof focusColorTag !== "string") {
      fMyConsoleLog(
        "   -> Focus Meta Cost: Skipped (No resFocus tag defined)."
      );
      return { success: true, changes: [], headers: [] }; // No focus cost
    }

    // === 2. Validate Focus Tag ===
    // Check against defined meta colors
    if (!Array.isArray(metaColors) || metaColors.length === 0) {
      console.error(
        "fFocus_VerifyAndProcessCost: gUI.list.metaColor is not defined or empty."
      );
      await fShowMessage("‚ùå Internal Error: Meta color list not defined.");
      return { success: false, changes: [], headers: [] };
    }
    // Ensure tag is one of the allowed colors (case-insensitive check, though stored uppercase)
    const isValidFocusTag = metaColors.includes(focusColorTag.toUpperCase());
    if (!isValidFocusTag) {
      const msg = `Invalid Focus Meta tag specified in morph: '${focusColorTag}'. Allowed: ${metaColors.join(
        ", "
      )}.`;
      console.warn(`fFocus_VerifyAndProcessCost: ${msg}`);
      fMyConsoleLog(`   -> ‚ùå Focus Meta Cost Failed: ${msg}`);
      await fShowMessage(`‚ùå ${msg}`);
      return { success: false, changes: [], headers: [] }; // Fail due to invalid tag
    }

    // === 3. Attempt to Spend Meta ===
    fMyConsoleLog(
      `   -> Focus Meta Cost: Attempting to spend 1 unit of '${focusColorTag}' (Focus)...`
    );
    // Call helper, passing the specific tag and pending changes
    const spendResult = await fSpendOneMeta(focusColorTag, pendingChangesMap);

    // === 4. Handle Result ===
    if (spendResult.success) {
      // Meta unit found, add the prepared change object
      fMyConsoleLog(
        `      -> Success: Found 1 unit of Focus Meta (${focusColorTag}) to spend.`
      );
      changes.push(spendResult.change);
      return { success: true, changes: changes, headers: headers };
    } else {
      // Failed (fSpendOneMeta handles invalid tag message)
      fMyConsoleLog(
        `      -> ‚ùå Failed: Could not find 1 unit of ${focusColorTag} (or higher) to spend for Focus.`
      );
      // Show specific "Not enough" message for Focus cost
      const errorMsg = `‚ùå Not enough Meta.<br>In addition to possible ability meta cost,<br>you are also trying to Focus @${focusColorTag}.`;
      await fShowMessage(errorMsg);
      return { success: false, changes: [], headers: [] }; // Indicate failure
    }
  } // END fFocus_VerifyAndProcessCost

  // fPerformMultiRolls ///////////////////////////////////////////////////////////
  // Purpose -> Handles the standard multi-roll loop for abilities targeting a specific
  //            difficulty. Calculates roll results, accumulates wounds, builds log lines
  //            (HTML & plain text), constructs the final log entry HTML, including
  //            wound totals and 'Apply Wounds' button for AR. Returns both HTML and plain text.
  // Inputs  -> initialLogHtml (String): Pre-built HTML log header.
  //         -> initialLogText (String): Pre-built Plain Text log header.
  // Outputs -> (Object): { finalLogHtml: String, finalLogText: String }
  function fPerformMultiRolls(initialLogHtml, initialLogText) {
    const multiRollCount = gUI.roll.multiRollCount;
    const resTypLower = (gUI.roll.resTyp || "").toLowerCase();
    const isArmorRoll = resTypLower === "ar";
    const isDamageRoll = resTypLower === "dmg";
    let totalWoundsOverall = 0; // Accumulator for wounds (relevant for multi-roll AR/DMG)

    fMyConsoleLog(
      `üîÑ Starting Standard Roll Loop (${multiRollCount} rolls)...`
    );
    const rollResultLinesHtml = []; // Array to hold HTML for each roll line
    const rollResultLinesText = []; // Array to hold plain text for each roll line

    // === Perform Rolls ===
    for (let rollNum = 1; rollNum <= multiRollCount; rollNum++) {
      const isFirstRoll = rollNum === 1;
      fMyConsoleLog(`   --- Roll ${rollNum} of ${multiRollCount} ---`);
      fCalcGUIRollResSk(); // Calculate skill after modifiers
      fCalcGUIRollRoll(); // Perform the base die roll
      fCalcGUIRollResRoll(); // Apply roll modifiers

      // === Accumulate Wounds (for multi-roll AR/DMG) ===
      if (multiRollCount > 1) {
        const currentRollResult = gUI.roll.resRoll;
        const difficulty = gUI.roll.resDif;
        let woundsDealtThisRoll = 0;

        if (
          isArmorRoll &&
          typeof currentRollResult === "number" &&
          typeof difficulty === "number" &&
          currentRollResult !== 0
        ) {
          woundsDealtThisRoll = Math.min(
            0,
            Math.round(-(difficulty / currentRollResult))
          );
          fMyConsoleLog(
            `      -> Accumulating AR Wounds: ${woundsDealtThisRoll}`
          );
          totalWoundsOverall += woundsDealtThisRoll;
        } else if (
          isDamageRoll &&
          typeof currentRollResult === "number" &&
          typeof difficulty === "number" &&
          difficulty !== 0
        ) {
          woundsDealtThisRoll = Math.max(
            0,
            Math.round(currentRollResult / difficulty)
          );
          fMyConsoleLog(
            `      -> Accumulating DMG Wounds: +${woundsDealtThisRoll}`
          );
          totalWoundsOverall += woundsDealtThisRoll;
        } else if (isArmorRoll || isDamageRoll) {
          fMyConsoleLog(
            `      -> Skipping Wound Accumulation: Invalid input (Dif=${difficulty}, Roll=${currentRollResult})`
          );
        }
      } // End wound accumulation block

      // Build HTML and Plain Text lines for this specific roll
      const { html: rollLineHtml, plainText: rollLineText } =
        fBuildSidebarHTMLAndSimpleText(rollNum, multiRollCount, isFirstRoll);
      rollResultLinesHtml.push(rollLineHtml); // Store HTML line
      rollResultLinesText.push(rollLineText); // Store Plain Text line
    } // --- End Roll Loop ---

    // === Combine Header and Results ===
    let finalLogHtml = initialLogHtml;
    let finalLogText = initialLogText;
    if (rollResultLinesHtml.length > 0) {
      if (finalLogHtml) finalLogHtml += "<br>"; // Add separator if header exists
      finalLogHtml += rollResultLinesHtml.join("<br>"); // Join HTML lines
    }
    if (rollResultLinesText.length > 0) {
      if (finalLogText) finalLogText += "\n"; // Add separator if header exists
      finalLogText += rollResultLinesText.join("\n"); // Join Plain Text lines
    }

    // === Add Total Wounds Line (if applicable) ===
    if (multiRollCount > 1) {
      if (isArmorRoll) {
        finalLogHtml += "<br>‚Üì"; // HTML Separator
        finalLogText += "\n‚Üì"; // Text Separator
        const positiveWoundAmount = Math.abs(totalWoundsOverall);
        // Add total wounds line with 'Apply' button to HTML
        finalLogHtml += `<br><span class="red-bold">Total Wounds to PC = ${totalWoundsOverall}</span> <button class="apply-wounds-btn" data-wound-amount="${positiveWoundAmount}">Apply</button>`;
        // Add plain text version (without button)
        finalLogText += `\nTotal Wounds to PC = ${totalWoundsOverall}`;
        fMyConsoleLog(
          `      -> Added Total AR Wounds line: ${totalWoundsOverall} (Button amount: ${positiveWoundAmount})`
        );
      } else if (isDamageRoll) {
        finalLogHtml += "<br>‚Üì"; // HTML Separator
        finalLogText += "\n‚Üì"; // Text Separator
        // Add total damage line (no button needed for monster damage currently)
        finalLogHtml += `<br><span style="font-weight:bold;">Total Wounds = +${totalWoundsOverall}</span>`;
        finalLogText += `\nTotal Wounds = +${totalWoundsOverall}`;
        fMyConsoleLog(
          `      -> Added Total DMG Wounds line: +${totalWoundsOverall}`
        );
      }
    }

    fMyConsoleLog(`‚úÖ Standard Roll Loop Completed.`);
    // Return object with both HTML and Plain Text
    return { finalLogHtml, finalLogText };
  } // END fPerformMultiRolls

  // fPerformPlayerAttackRolls ///////////////////////////////////////////////////////
  // Purpose -> Handles 'Atk' rolls against monsters. Validates targets, performs rolls,
  //            counts successes, builds log lines (HTML & text), stores results, adds
  //            "Prep Dmg" button. Falls back to standard rolls if needed.
  // Inputs  -> initialLogHtml (String): Pre-built HTML log header.
  //         -> initialLogText (String): Pre-built Plain Text log header.
  // Outputs -> (Promise<Object>): { logHtml: String, logText: String, success: Boolean }
  async function fPerformPlayerAttackRolls(initialLogHtml, initialLogText) {
    fMyConsoleLog("   -> Entering Player Attack Logic...");
    // === 1. Get Monster Range & Validate ===
    const monsterRangeDef = gUI.range?.monsters;
    if (
      !monsterRangeDef ||
      !fDoesObjectHaveR1C1R2C2Properties(monsterRangeDef)
    ) {
      const msg =
        "Monster range definition (gUI.range.monsters) missing/invalid.";
      console.warn(`fPerformPlayerAttackRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", logText: "", success: false }; // Indicate failure
    }

    // === 2. Resolve Indices ===
    const resolved = fConvertsR1C1R2C2TagOrNumToIndices(monsterRangeDef);
    if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
      const msg = `Could not resolve monster range tags: ${JSON.stringify(
        monsterRangeDef
      )}`;
      console.warn(`fPerformPlayerAttackRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", logText: "", success: false };
    }
    const rMin = Math.min(resolved.r1, resolved.r2);
    const rMax = Math.max(resolved.r1, resolved.r2);
    const cNumMon = fResolveCol("NumMon");
    const cMonDef = fResolveCol("MonDef"); // Difficulty column for Attack
    const cMonName = fResolveCol("MonName");
    if ([cNumMon, cMonDef, cMonName].some(isNaN)) {
      const msg =
        "Could not resolve required monster column tags (NumMon, MonDef, MonName).";
      console.warn(`fPerformPlayerAttackRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", logText: "", success: false };
    }
    fMyConsoleLog(
      `      -> Monster Table Range: Rows ${rMin}-${rMax}, Cols Def:${cMonDef}, Num:${cNumMon}, Name:${cMonName}`
    );

    // === 3. Identify & Validate Targets ===
    const monsterTargets = [];
    const allTargetedRows_R = [];
    const firstMonsterRowIndex = rMin;

    for (let mon_R = rMin; mon_R <= rMax; mon_R++) {
      const isCustomRow = mon_R === firstMonsterRowIndex;
      const numMonRaw = gUI.arr?.[mon_R]?.[cNumMon];
      const numMon = parseInt(numMonRaw, 10);

      if (!isNaN(numMon) && numMon >= 1 && numMon <= 30) {
        fMyConsoleLog(`      -> Row ${mon_R}: Found valid NumMon: ${numMon}`);
        const monDefRaw = gUI.arr?.[mon_R]?.[cMonDef];
        const monDef = Number(monDefRaw);

        if (isNaN(monDef) || String(monDefRaw).trim() === "") {
          let errMsg = `‚ùå Invalid Monster Defense ('${monDefRaw}') found in row ${
            mon_R + 1
          }. Cannot complete attack.`;
          if (isCustomRow)
            errMsg = `‚ùå Invalid Monster Defense ('${monDefRaw}') found for Custom Monster. Cannot complete attack.`;
          fMyConsoleLog(`         -> Validation Failed: ${errMsg}`);
          await fShowMessage(errMsg);
          return { logHtml: "", logText: "", success: false }; // Halt
        }

        let originalMonName = String(gUI.arr?.[mon_R]?.[cMonName] || "").trim();
        let monName = originalMonName || `Row ${mon_R + 1}`;
        if (isCustomRow) monName = `Custom ${originalMonName}`.trim();

        monsterTargets.push({
          mon_R,
          numRolls: numMon,
          monName,
          monDef,
          numSuccesses: 0,
        });
        allTargetedRows_R.push(mon_R);
        fMyConsoleLog(
          `         -> Valid Target Added: Name='${monName}', Def=${monDef}, Rolls=${numMon} (Row index ${mon_R} added)`
        );
      } else {
        if (numMonRaw !== "" && numMonRaw != null)
          fMyConsoleLog(
            `      -> Row ${mon_R}: Skipping - Invalid NumMon value: '${numMonRaw}'`
          );
      }
    } // End target identification loop

    // === 4. Handle No Valid Targets (Fallback to Standard Roll) ===
    if (monsterTargets.length === 0) {
      fMyConsoleLog(
        "      -> No valid monster targets found. Performing standard attack roll instead."
      );
      await fShowMessage(
        "‚ÑπÔ∏è No valid monsters found. Performing standard attack roll."
      );
      gUI.roll.resDif = ""; // Ensure difficulty is cleared
      fMyConsoleLog("         -> Cleared resDif for standard roll.");
      const { finalLogHtml, finalLogText } = fPerformMultiRolls(
        initialLogHtml,
        initialLogText
      );
      return { logHtml: finalLogHtml, logText: finalLogText, success: true };
    }

    // === 5. Perform Rolls Against Valid Targets ===
    fMyConsoleLog(
      `      -> Found ${monsterTargets.length} valid monster target(s).`
    );
    let isOverallFirstRoll = true;
    const monsterLogLinesHtml = [];
    const monsterLogLinesText = [];
    const currentAttackResults = [];

    for (const target of monsterTargets) {
      fMyConsoleLog(
        `   --- Attacking: ${target.monName} (Def: ${target.monDef}, Rolls: ${target.numRolls}) ---`
      );
      monsterLogLinesHtml.push("‚Üì"); // HTML Separator
      monsterLogLinesText.push("‚Üì"); // <<< USE '‚Üì' for Plain Text Separator >>>
      monsterLogLinesHtml.push(
        `--- <span style="color: purple; font-weight: bold;">Mon: ${target.monName}</span> (Def: ${target.monDef}) ---`
      );
      monsterLogLinesText.push(
        `--- Mon: ${target.monName} (Def: ${target.monDef}) ---`
      );
      gUI.roll.resDif = target.monDef; // Set difficulty

      for (let rollNum = 1; rollNum <= target.numRolls; rollNum++) {
        fMyConsoleLog(
          `      -> Roll ${rollNum} of ${target.numRolls} against ${target.monName}...`
        );
        fCalcGUIRollResSk();
        fCalcGUIRollRoll();
        fCalcGUIRollResRoll();

        const rollResult = gUI.roll.resRoll;
        const difficulty = gUI.roll.resDif;
        if (
          typeof rollResult === "number" &&
          typeof difficulty === "number" &&
          rollResult >= difficulty
        ) {
          target.numSuccesses++;
          fMyConsoleLog(
            `         -> Attack Succeeded! (Roll ${rollResult} >= Def ${difficulty}). Success count: ${target.numSuccesses}`
          );
        } else {
          fMyConsoleLog(
            `         -> Attack Failed! (Roll ${rollResult} < Def ${difficulty})`
          );
        }

        const { html: rollLineHtml, plainText: rollLineText } =
          fBuildSidebarHTMLAndSimpleText(
            rollNum,
            target.numRolls,
            isOverallFirstRoll
          );
        monsterLogLinesHtml.push(rollLineHtml);
        monsterLogLinesText.push(rollLineText);
        if (isOverallFirstRoll) isOverallFirstRoll = false;
      } // End inner roll loop

      fMyConsoleLog(
        `   --- Finished Attacking: ${target.monName} (${target.numSuccesses} successes) ---`
      );
      if (target.numSuccesses > 0) {
        fMyConsoleLog(
          `      -> Storing result for ${target.monName}: mon_R=${target.mon_R}, numSuccesses=${target.numSuccesses}`
        );
        currentAttackResults.push({
          mon_R: target.mon_R,
          monName: target.monName,
          numSuccesses: target.numSuccesses,
        });
      }
    } // End monster target loop

    // === 6. Finalize Log, Store Results, Add Button ===
    let finalLogHtml =
      initialLogHtml + "<br>" + monsterLogLinesHtml.join("<br>");
    let finalLogText = initialLogText + "\n" + monsterLogLinesText.join("\n");
    let rollId = null;

    if (currentAttackResults.length > 0) {
      rollId = "prep_" + Date.now();
      gUI.monsterRollResultsHistory[rollId] = {
        results: currentAttackResults,
        originalAbilityRow: gUI.roll.ability_R,
        allTargetedRows_R: allTargetedRows_R,
      };
      fMyConsoleLog(
        `   -> Stored attack results in gUI.monsterRollResultsHistory['${rollId}']`
      );
      finalLogHtml += ` <button class="prep-dmg-btn" data-roll-id="${rollId}">Prep Dmg</button>`;
      finalLogText += ` [Prep Dmg Available]`;
      fMyConsoleLog("   -> Added 'Prep Dmg' button to HTML log output.");
    } else {
      fMyConsoleLog(
        "   -> No successes recorded, 'Prep Dmg' button not added."
      );
    }

    fMyConsoleLog("   -> Player Attack Logic Complete.");
    return { logHtml: finalLogHtml, logText: finalLogText, success: true };
  } // END fPerformPlayerAttackRolls

  // fPerformPlayerDamageRolls /////////////////////////////////////////////////////
  // Purpose -> Handles 'DMG' rolls against monsters. Uses 'MonAR' for difficulty.
  //            Calculates Wounds, builds log lines (HTML & text), sums wounds per monster.
  //            Falls back to standard roll if needed.
  // Inputs  -> initialLogHtml (String): Pre-built HTML log header.
  //         -> initialLogText (String): Pre-built Plain Text log header.
  // Outputs -> (Promise<Object>): Resolves with { logHtml: String, logText: String, success: Boolean }.
  async function fPerformPlayerDamageRolls(initialLogHtml, initialLogText) {
    fMyConsoleLog("   -> Entering Player Damage Logic...");
    // === 1. Get Monster Range & Validate ===
    const monsterRangeDef = gUI.range?.monsters;
    if (
      !monsterRangeDef ||
      !fDoesObjectHaveR1C1R2C2Properties(monsterRangeDef)
    ) {
      const msg =
        "Monster range definition (gUI.range.monsters) missing/invalid.";
      console.warn(`fPerformPlayerDamageRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", logText: "", success: false };
    }

    // === 2. Resolve Indices (Including MonAR) ===
    const resolved = fConvertsR1C1R2C2TagOrNumToIndices(monsterRangeDef);
    if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
      const msg = `Could not resolve monster range tags: ${JSON.stringify(
        monsterRangeDef
      )}`;
      console.warn(`fPerformPlayerDamageRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", logText: "", success: false };
    }
    const rMin = Math.min(resolved.r1, resolved.r2);
    const rMax = Math.max(resolved.r1, resolved.r2);
    const cNumMon = fResolveCol("NumMon");
    const cMonAR = fResolveCol("MonAR"); // Difficulty source for Damage
    const cMonName = fResolveCol("MonName");
    if ([cNumMon, cMonAR, cMonName].some(isNaN)) {
      const msg =
        "Could not resolve required monster column tags (NumMon, MonAR, MonName).";
      console.warn(`fPerformPlayerDamageRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", logText: "", success: false };
    }
    fMyConsoleLog(
      `      -> Monster Table Range: Rows ${rMin}-${rMax}, Cols AR:${cMonAR}, Num:${cNumMon}, Name:${cMonName}`
    );

    // === 3. Identify & Validate Targets (Using MonAR) ===
    const monsterTargets = [];
    const firstMonsterRowIndex = rMin;
    for (let mon_R = rMin; mon_R <= rMax; mon_R++) {
      const isCustomRow = mon_R === firstMonsterRowIndex;
      const numMonRaw = gUI.arr?.[mon_R]?.[cNumMon];
      const numMon = parseInt(numMonRaw, 10);

      if (!isNaN(numMon) && numMon >= 1 && numMon <= 30) {
        fMyConsoleLog(`      -> Row ${mon_R}: Found valid NumMon: ${numMon}`);
        const monARRaw = gUI.arr?.[mon_R]?.[cMonAR];
        const monARBase = Number(monARRaw);
        if (isNaN(monARBase) || String(monARRaw).trim() === "") {
          let errMsg = `‚ùå Invalid Monster Armor value ('${monARRaw}') found in row ${
            mon_R + 1
          }. Cannot complete damage roll.`;
          if (isCustomRow)
            errMsg = `‚ùå Invalid Monster Armor value ('${monARRaw}') found for Custom Monster. Cannot complete damage roll.`;
          fMyConsoleLog(`         -> Validation Failed: ${errMsg}`);
          await fShowMessage(errMsg);
          return { logHtml: "", logText: "", success: false }; // Halt
        }

        const calculatedArmor = Math.max(1, monARBase / 10).toFixed(1);
        fMyConsoleLog(
          `         -> Calculated Armor Difficulty: ${monARBase}/10=${
            monARBase / 10
          } -> max(1, ${monARBase / 10}) -> ${calculatedArmor}`
        );
        let originalMonName = String(gUI.arr?.[mon_R]?.[cMonName] || "").trim();
        let monName = originalMonName || `Row ${mon_R + 1}`;
        if (isCustomRow) monName = `Custom ${originalMonName}`.trim();
        monsterTargets.push({
          mon_R,
          numRolls: numMon,
          monName,
          calculatedArmor: Number(calculatedArmor),
        });
        fMyConsoleLog(
          `         -> Valid Target Added: Name='${monName}', Calculated AR=${calculatedArmor}, Rolls=${numMon}`
        );
      } else {
        if (numMonRaw !== "" && numMonRaw != null)
          fMyConsoleLog(
            `      -> Row ${mon_R}: Skipping - Invalid NumMon value: '${numMonRaw}'`
          );
      }
    } // End target identification loop

    // === 4. Handle No Valid Targets (Fallback to Standard Roll) ===
    if (monsterTargets.length === 0) {
      fMyConsoleLog(
        "      -> No valid monster targets found (with MonAR). Performing standard damage roll instead."
      );
      await fShowMessage(
        "‚ÑπÔ∏è No valid monsters found with Armor values. Performing standard damage roll."
      );
      gUI.roll.resDif = "";
      fMyConsoleLog("         -> Cleared resDif for standard roll.");
      const { finalLogHtml, finalLogText } = fPerformMultiRolls(
        initialLogHtml,
        initialLogText
      );
      return { logHtml: finalLogHtml, logText: finalLogText, success: true };
    }

    // === 5. Perform Rolls & Build Log ===
    fMyConsoleLog(
      `      -> Found ${monsterTargets.length} valid monster target(s) with Armor values.`
    );
    let isOverallFirstRoll = true;
    const monsterLogLinesHtml = [];
    const monsterLogLinesText = [];

    for (const target of monsterTargets) {
      fMyConsoleLog(
        `   --- Damaging: ${target.monName} (Calc AR: ${target.calculatedArmor}, Rolls: ${target.numRolls}) ---`
      );
      let totalWoundsPerMonster = 0;

      monsterLogLinesHtml.push("‚Üì"); // HTML separator
      monsterLogLinesText.push("‚Üì"); // <<< USE '‚Üì' for Plain Text Separator >>>
      monsterLogLinesHtml.push(
        `--- <span style="color: purple; font-weight: bold;">Mon: ${target.monName}</span> (AR: ${target.calculatedArmor}) ---`
      );
      monsterLogLinesText.push(
        `--- Mon: ${target.monName} (AR: ${target.calculatedArmor}) ---`
      );
      gUI.roll.resDif = target.calculatedArmor; // Set difficulty

      for (let rollNum = 1; rollNum <= target.numRolls; rollNum++) {
        fMyConsoleLog(
          `      -> Damage Roll ${rollNum} of ${target.numRolls} against ${target.monName}...`
        );
        fCalcGUIRollResSk();
        fCalcGUIRollRoll();
        fCalcGUIRollResRoll();

        const rollResult = gUI.roll.resRoll;
        const armorDifficulty = gUI.roll.resDif;
        let woundsDealt = 0;
        if (
          typeof rollResult === "number" &&
          typeof armorDifficulty === "number"
        ) {
          woundsDealt = Math.max(0, Math.round(rollResult / armorDifficulty));
        }
        fMyConsoleLog(
          `         -> Wound Calc: Dmg Roll=${rollResult}, calcAR=${armorDifficulty} => Wounds = max(0, round(${rollResult}/${armorDifficulty})) = ${woundsDealt}`
        );
        totalWoundsPerMonster += woundsDealt;

        const { html: rollLineHtml, plainText: rollLineText } =
          fBuildSidebarHTMLAndSimpleText(
            rollNum,
            target.numRolls,
            isOverallFirstRoll
          );
        monsterLogLinesHtml.push(rollLineHtml);
        monsterLogLinesText.push(rollLineText);
        if (isOverallFirstRoll) isOverallFirstRoll = false;
      } // End inner roll loop

      monsterLogLinesHtml.push(
        `<span style="font-weight:bold;">${target.monName} Total Wounds = +${totalWoundsPerMonster}</span>`
      );
      monsterLogLinesText.push(
        `${target.monName} Total Wounds = +${totalWoundsPerMonster}`
      );
      fMyConsoleLog(
        `   --- Finished Damaging: ${target.monName} (Total Wounds: ${totalWoundsPerMonster}) ---`
      );
    } // End monster target loop

    // === 6. Return Result ===
    const finalLogHtml =
      initialLogHtml + "<br>" + monsterLogLinesHtml.join("<br>");
    const finalLogText = initialLogText + "\n" + monsterLogLinesText.join("\n");
    fMyConsoleLog("   -> Player Damage Logic Complete.");
    return { logHtml: finalLogHtml, logText: finalLogText, success: true };
  } // END fPerformPlayerDamageRolls

  // fPerformPlayerDefenseRolls ////////////////////////////////////////////////////
  // Purpose -> Handles 'Def' rolls against monsters. Uses 'MonAtk' for difficulty.
  //            Counts failures, builds log lines (HTML & text), stores results, adds
  //            "Prep AR" button. Falls back to standard roll if needed.
  // Inputs  -> initialLogHtml (String): Pre-built HTML log header.
  //         -> initialLogText (String): Pre-built Plain Text log header.
  // Outputs -> (Promise<Object>): { logHtml: String, logText: String, success: Boolean }
  async function fPerformPlayerDefenseRolls(initialLogHtml, initialLogText) {
    fMyConsoleLog("   -> Entering Player Defense Logic...");
    // === 1. Get Monster Range & Validate ===
    const monsterRangeDef = gUI.range?.monsters;
    if (
      !monsterRangeDef ||
      !fDoesObjectHaveR1C1R2C2Properties(monsterRangeDef)
    ) {
      const msg =
        "Monster range definition (gUI.range.monsters) missing/invalid.";
      console.warn(`fPerformPlayerDefenseRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", logText: "", success: false };
    }

    // === 2. Resolve Indices (Including MonAtk) ===
    const resolved = fConvertsR1C1R2C2TagOrNumToIndices(monsterRangeDef);
    if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
      const msg = `Could not resolve monster range tags: ${JSON.stringify(
        monsterRangeDef
      )}`;
      console.warn(`fPerformPlayerDefenseRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", logText: "", success: false };
    }
    const rMin = Math.min(resolved.r1, resolved.r2);
    const rMax = Math.max(resolved.r1, resolved.r2);
    const cNumMon = fResolveCol("NumMon");
    const cMonAtk = fResolveCol("MonAtk"); // Difficulty column for Defense
    const cMonName = fResolveCol("MonName");
    if ([cNumMon, cMonAtk, cMonName].some(isNaN)) {
      const msg =
        "Could not resolve required monster column tags (NumMon, MonAtk, MonName).";
      console.warn(`fPerformPlayerDefenseRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", logText: "", success: false };
    }
    fMyConsoleLog(
      `      -> Monster Table Range: Rows ${rMin}-${rMax}, Cols Atk:${cMonAtk}, Num:${cNumMon}, Name:${cMonName}`
    );

    // === 3. Identify & Validate Targets (Using MonAtk) ===
    const monsterTargets = [];
    const allTargetedRows_R = [];
    const firstMonsterRowIndex = rMin;
    for (let mon_R = rMin; mon_R <= rMax; mon_R++) {
      const isCustomRow = mon_R === firstMonsterRowIndex;
      const numMonRaw = gUI.arr?.[mon_R]?.[cNumMon];
      const numMon = parseInt(numMonRaw, 10);

      if (!isNaN(numMon) && numMon >= 1 && numMon <= 30) {
        fMyConsoleLog(`      -> Row ${mon_R}: Found valid NumMon: ${numMon}`);
        const monAtkRaw = gUI.arr?.[mon_R]?.[cMonAtk];
        const monAtk = Number(monAtkRaw);

        if (isNaN(monAtk) || String(monAtkRaw).trim() === "") {
          let errMsg = `‚ùå Invalid Monster Attack value ('${monAtkRaw}') found in row ${
            mon_R + 1
          }. Cannot complete defense roll.`;
          if (isCustomRow)
            errMsg = `‚ùå Invalid Monster Attack value ('${monAtkRaw}') found for Custom Monster. Cannot complete defense roll.`;
          fMyConsoleLog(`         -> Validation Failed: ${errMsg}`);
          await fShowMessage(errMsg);
          return { logHtml: "", logText: "", success: false }; // Halt
        }

        let originalMonName = String(gUI.arr?.[mon_R]?.[cMonName] || "").trim();
        let monName = originalMonName || `Row ${mon_R + 1}`;
        if (isCustomRow) monName = `Custom ${originalMonName}`.trim();
        monsterTargets.push({
          mon_R,
          numRolls: numMon,
          monName,
          monAtk,
          numFailures: 0,
        });
        allTargetedRows_R.push(mon_R);
        fMyConsoleLog(
          `         -> Valid Target Added: Name='${monName}', Atk=${monAtk}, Rolls=${numMon} (Row index ${mon_R} added)`
        );
      } else {
        if (numMonRaw !== "" && numMonRaw != null)
          fMyConsoleLog(
            `      -> Row ${mon_R}: Skipping - Invalid NumMon value: '${numMonRaw}'`
          );
      }
    } // End target identification loop

    // === 4. Handle No Valid Targets (Fallback to Standard Roll) ===
    if (monsterTargets.length === 0) {
      fMyConsoleLog(
        "      -> No valid monster targets found (with MonAtk). Performing standard defense roll instead."
      );
      await fShowMessage(
        "‚ÑπÔ∏è No valid monsters found with Attack values. Performing standard defense roll."
      );
      gUI.roll.resDif = "";
      fMyConsoleLog("         -> Cleared resDif for standard roll.");
      const { finalLogHtml, finalLogText } = fPerformMultiRolls(
        initialLogHtml,
        initialLogText
      );
      return { logHtml: finalLogHtml, logText: finalLogText, success: true };
    }

    // === 5. Perform Rolls & Build Log ===
    fMyConsoleLog(
      `      -> Found ${monsterTargets.length} valid monster target(s) with Attack values.`
    );
    let isOverallFirstRoll = true;
    const monsterLogLinesHtml = [];
    const monsterLogLinesText = [];
    const currentDefenseResults = [];

    for (const target of monsterTargets) {
      fMyConsoleLog(
        `   --- Defending Against: ${target.monName} (Atk: ${target.monAtk}, Rolls: ${target.numRolls}) ---`
      );
      monsterLogLinesHtml.push("‚Üì"); // HTML separator
      monsterLogLinesText.push("‚Üì"); // <<< USE '‚Üì' for Plain Text Separator >>>
      monsterLogLinesHtml.push(
        `--- <span style="color: purple; font-weight: bold;">Mon: ${target.monName}</span> (Atk: ${target.monAtk}) ---`
      );
      monsterLogLinesText.push(
        `--- Mon: ${target.monName} (Atk: ${target.monAtk}) ---`
      );
      gUI.roll.resDif = target.monAtk; // Set difficulty

      for (let rollNum = 1; rollNum <= target.numRolls; rollNum++) {
        fMyConsoleLog(
          `      -> Defense Roll ${rollNum} of ${target.numRolls} against ${target.monName}...`
        );
        fCalcGUIRollResSk();
        fCalcGUIRollRoll();
        fCalcGUIRollResRoll();

        const rollResult = gUI.roll.resRoll;
        const difficulty = gUI.roll.resDif;

        if (
          typeof rollResult === "number" &&
          typeof difficulty === "number" &&
          rollResult < difficulty
        ) {
          target.numFailures++;
          fMyConsoleLog(
            `         -> Defense Failed! (Roll ${rollResult} < Atk ${difficulty}). Failure count: ${target.numFailures}`
          );
        } else {
          fMyConsoleLog(
            `         -> Defense Succeeded! (Roll ${rollResult} >= Atk ${difficulty})`
          );
        }

        const { html: rollLineHtml, plainText: rollLineText } =
          fBuildSidebarHTMLAndSimpleText(
            rollNum,
            target.numRolls,
            isOverallFirstRoll
          );
        monsterLogLinesHtml.push(rollLineHtml);
        monsterLogLinesText.push(rollLineText);
        if (isOverallFirstRoll) isOverallFirstRoll = false;
      } // End inner roll loop

      fMyConsoleLog(
        `   --- Finished Defending Against: ${target.monName} (${target.numFailures} failures) ---`
      );
      if (target.numFailures > 0) {
        currentDefenseResults.push({
          mon_R: target.mon_R,
          monName: target.monName,
          numFailures: target.numFailures,
        });
      }
    } // End monster target loop

    // === 6. Finalize Log, Store Results, Add Button ===
    let finalLogHtml =
      initialLogHtml + "<br>" + monsterLogLinesHtml.join("<br>");
    let finalLogText = initialLogText + "\n" + monsterLogLinesText.join("\n");
    let rollId = null;

    if (currentDefenseResults.length > 0) {
      rollId = "prep_" + Date.now();
      gUI.monsterRollResultsHistory[rollId] = {
        results: currentDefenseResults,
        originalAbilityRow: gUI.roll.ability_R,
        allTargetedRows_R: allTargetedRows_R,
      };
      fMyConsoleLog(
        `   -> Data stored for rollId '${rollId}'. History keys: ${Object.keys(
          gUI.monsterRollResultsHistory
        ).join(", ")}`
      );
      finalLogHtml += ` <button class="prep-ar-btn" data-roll-id="${rollId}">Prep AR</button>`;
      finalLogText += ` [Prep AR Available]`;
      fMyConsoleLog("   -> Added 'Prep AR' button to log output.");
    } else {
      fMyConsoleLog("   -> No failures recorded, 'Prep AR' button not added.");
    }

    fMyConsoleLog("   -> Player Defense Logic Complete.");
    return { logHtml: finalLogHtml, logText: finalLogText, success: true };
  } // END fPerformPlayerDefenseRolls

  // fPerformPlayerArmorRolls //////////////////////////////////////////////////////
  // Purpose -> Handles 'AR' rolls against monsters. Uses 'MonDmg' for difficulty.
  //            Calculates wounds to player, builds log lines (HTML & text), sums wounds,
  //            adds "Apply Wounds" button. Falls back to standard roll if needed.
  // Inputs  -> initialLogHtml (String): Pre-built HTML log header.
  //         -> initialLogText (String): Pre-built Plain Text log header.
  // Outputs -> (Promise<Object>): Resolves with { logHtml: String, logText: String, success: Boolean }.
  async function fPerformPlayerArmorRolls(initialLogHtml, initialLogText) {
    fMyConsoleLog("   -> Entering Player Armor Logic...");
    // === 1. Get Monster Range & Validate ===
    const monsterRangeDef = gUI.range?.monsters;
    if (
      !monsterRangeDef ||
      !fDoesObjectHaveR1C1R2C2Properties(monsterRangeDef)
    ) {
      const msg =
        "Monster range definition (gUI.range.monsters) missing/invalid.";
      console.warn(`fPerformPlayerArmorRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", logText: "", success: false };
    }

    // === 2. Resolve Indices (Including MonDmg) ===
    const resolved = fConvertsR1C1R2C2TagOrNumToIndices(monsterRangeDef);
    if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
      const msg = `Could not resolve monster range tags: ${JSON.stringify(
        monsterRangeDef
      )}`;
      console.warn(`fPerformPlayerArmorRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", logText: "", success: false };
    }
    const rMin = Math.min(resolved.r1, resolved.r2);
    const rMax = Math.max(resolved.r1, resolved.r2);
    const cNumMon = fResolveCol("NumMon");
    const cMonDmg = fResolveCol("MonDmg"); // Difficulty source for Armor
    const cMonName = fResolveCol("MonName");
    if ([cNumMon, cMonDmg, cMonName].some(isNaN)) {
      const msg =
        "Could not resolve required monster column tags (NumMon, MonDmg, MonName).";
      console.warn(`fPerformPlayerArmorRolls: ${msg}`);
      await fShowMessage(`‚ùå Error: ${msg}`);
      return { logHtml: "", logText: "", success: false };
    }
    fMyConsoleLog(
      `      -> Monster Table Range: Rows ${rMin}-${rMax}, Cols Dmg:${cMonDmg}, Num:${cNumMon}, Name:${cMonName}`
    );

    // === 3. Identify & Validate Targets (Using MonDmg) ===
    const monsterTargets = [];
    const firstMonsterRowIndex = rMin;
    for (let mon_R = rMin; mon_R <= rMax; mon_R++) {
      const isCustomRow = mon_R === firstMonsterRowIndex;
      const numMonRaw = gUI.arr?.[mon_R]?.[cNumMon];
      const numMon = parseInt(numMonRaw, 10);

      if (!isNaN(numMon) && numMon >= 1 && numMon <= 30) {
        fMyConsoleLog(`      -> Row ${mon_R}: Found valid NumMon: ${numMon}`);
        const monDmgRaw = gUI.arr?.[mon_R]?.[cMonDmg];
        const monDmg = Number(monDmgRaw);
        if (isNaN(monDmg) || String(monDmgRaw).trim() === "") {
          let errMsg = `‚ùå Invalid Monster Damage ('${monDmgRaw}') found in row ${
            mon_R + 1
          }. Cannot complete armor roll.`;
          if (isCustomRow)
            errMsg = `‚ùå Invalid Monster Damage ('${monDmgRaw}') found for Custom Monster. Cannot complete armor roll.`;
          fMyConsoleLog(`         -> Validation Failed: ${errMsg}`);
          await fShowMessage(errMsg);
          return { logHtml: "", logText: "", success: false }; // Halt
        }

        let originalMonName = String(gUI.arr?.[mon_R]?.[cMonName] || "").trim();
        let monName = originalMonName || `Row ${mon_R + 1}`;
        if (isCustomRow) monName = `Custom ${originalMonName}`.trim();
        monsterTargets.push({ mon_R, numRolls: numMon, monName, monDmg });
        fMyConsoleLog(
          `         -> Valid Target Added: Name='${monName}', Dmg=${monDmg}, Rolls=${numMon}`
        );
      } else {
        if (numMonRaw !== "" && numMonRaw != null)
          fMyConsoleLog(
            `      -> Row ${mon_R}: Skipping - Invalid NumMon value: '${numMonRaw}'`
          );
      }
    } // End target identification loop

    // === 4. Handle No Valid Targets (Fallback to Standard Roll) ===
    if (monsterTargets.length === 0) {
      fMyConsoleLog(
        "      -> No valid monster targets found (with MonDmg). Performing standard armor roll instead."
      );
      await fShowMessage(
        "‚ÑπÔ∏è No valid monsters found with Damage values. Performing standard armor roll."
      );
      gUI.roll.resDif = "";
      fMyConsoleLog("         -> Cleared resDif for standard roll.");
      const { finalLogHtml, finalLogText } = fPerformMultiRolls(
        initialLogHtml,
        initialLogText
      );
      return { logHtml: finalLogHtml, logText: finalLogText, success: true };
    }

    // === 5. Perform Rolls & Build Log ===
    fMyConsoleLog(
      `      -> Found ${monsterTargets.length} valid monster target(s) with Damage values.`
    );
    let isOverallFirstRoll = true;
    const monsterLogLinesHtml = [];
    const monsterLogLinesText = [];
    let totalWoundsOverall = 0;

    for (const target of monsterTargets) {
      fMyConsoleLog(
        `   --- Rolling Armor vs: ${target.monName} (Dmg: ${target.monDmg}, Rolls: ${target.numRolls}) ---`
      );
      let totalWoundsPerMonster = 0;

      monsterLogLinesHtml.push("‚Üì"); // HTML separator
      monsterLogLinesText.push("‚Üì"); // <<< USE '‚Üì' for Plain Text Separator >>>
      monsterLogLinesHtml.push(
        `--- <span style="color: purple; font-weight: bold;">Mon: ${target.monName}</span> (Dmg: ${target.monDmg}) ---`
      );
      monsterLogLinesText.push(
        `--- Mon: ${target.monName} (Dmg: ${target.monDmg}) ---`
      );
      gUI.roll.resDif = target.monDmg; // Set difficulty

      for (let rollNum = 1; rollNum <= target.numRolls; rollNum++) {
        fMyConsoleLog(
          `      -> Armor Roll ${rollNum} of ${target.numRolls} against ${target.monName}...`
        );
        fCalcGUIRollResSk();
        fCalcGUIRollRoll();
        fCalcGUIRollResRoll();

        const armorRollResult = gUI.roll.resRoll;
        const monsterDamage = gUI.roll.resDif;
        let woundsDealt = 0;
        if (
          typeof armorRollResult === "number" &&
          armorRollResult !== 0 &&
          typeof monsterDamage === "number"
        ) {
          woundsDealt = Math.min(
            0,
            Math.round(-(monsterDamage / armorRollResult))
          );
          fMyConsoleLog(
            `         -> Wound Calc: Dmg=${monsterDamage}, AR Roll=${armorRollResult} => Wounds = min(0, round(-(${monsterDamage}/${armorRollResult}))) = ${woundsDealt}`
          );
        } else {
          fMyConsoleLog(
            `         -> Wound Calc: Invalid input (Dmg=${monsterDamage}, AR Roll=${armorRollResult}). Wounds = 0`
          );
        }
        totalWoundsPerMonster += woundsDealt;
        totalWoundsOverall += woundsDealt;

        const { html: rollLineHtml, plainText: rollLineText } =
          fBuildSidebarHTMLAndSimpleText(
            rollNum,
            target.numRolls,
            isOverallFirstRoll
          );
        monsterLogLinesHtml.push(rollLineHtml);
        monsterLogLinesText.push(rollLineText);
        if (isOverallFirstRoll) isOverallFirstRoll = false;
      } // End inner roll loop

      monsterLogLinesHtml.push(
        `<span style="font-weight:bold;">${target.monName} Wounds to PC = ${totalWoundsPerMonster}</span>`
      );
      monsterLogLinesText.push(
        `${target.monName} Wounds to PC = ${totalWoundsPerMonster}`
      );
      fMyConsoleLog(
        `   --- Finished Rolling vs: ${target.monName} (Wounds This Monster: ${totalWoundsPerMonster}) ---`
      );
    } // End monster target loop

    // === 6. Add Overall Wound Summation & Button ===
    monsterLogLinesHtml.push("‚Üì"); // HTML separator
    monsterLogLinesText.push("‚Üì"); // <<< USE '‚Üì' for Plain Text Separator >>>
    const positiveWoundAmount = Math.abs(totalWoundsOverall);
    monsterLogLinesHtml.push(
      `<span class="red-bold">Total Wounds to PC = ${totalWoundsOverall}</span> <button class="apply-wounds-btn" data-wound-amount="${positiveWoundAmount}">Apply</button>`
    );
    monsterLogLinesText.push(`Total Wounds to PC = ${totalWoundsOverall}`); // Plain text version
    fMyConsoleLog(
      `      -> Overall Wounds Inflicted on PC: ${totalWoundsOverall} (Button amount: ${positiveWoundAmount})`
    );

    // === 7. Return Result ===
    const finalLogHtml =
      initialLogHtml + "<br>" + monsterLogLinesHtml.join("<br>");
    const finalLogText = initialLogText + "\n" + monsterLogLinesText.join("\n");
    fMyConsoleLog("   -> Player Armor Logic Complete.");
    return { logHtml: finalLogHtml, logText: finalLogText, success: true };
  } // END fPerformPlayerArmorRolls

  // fCalcGUIRollResSk ///////////////////////////////////////////////////////////////
  // Purpose -> Calculates the final resulting skill value (gUI.roll.resSk) before the
  //            die roll, applying various morph modifiers (Combine, Mult, dctMult, Plus,
  //            Focus bonus, UnSk penalty) to the base skill value (gUI.roll.skSk or
  //            gUI.roll.resFlatBase). Clamps results >= 1, rounds, stores in gUI.roll.resSk.
  // Inputs  -> None (Reads from gUI.roll properties).
  // Outputs -> None (Writes final calculated value to gUI.roll.resSk).
  function fCalcGUIRollResSk() {
    let currentResSk; // Variable to hold intermediate calculation

    // === Determine Base Skill Value ===
    // Prioritize resCombine (calculated from number morphs + skSk), then skSk (potentially from =N morph)
    if (typeof gUI.roll.resCombine === "number" && gUI.roll.resCombine !== "") {
      currentResSk = gUI.roll.resCombine;
      // fMyConsoleLog("   -> Using resCombine as base for resSk calculation.");
    } else if (typeof gUI.roll.skSk === "number" && gUI.roll.skSk !== "") {
      currentResSk = gUI.roll.skSk;
    } else {
      currentResSk = NaN; // No valid base skill found
    }

    // === Apply Modifiers (only if base is valid number) ===
    if (!isNaN(currentResSk)) {
      // 1. Apply Multiplicative Modifiers first
      // Apply resMult (* / /N morphs)
      if (typeof gUI.roll.resMult === "number" && gUI.roll.resMult !== "") {
        currentResSk *= gUI.roll.resMult;
      }
      // Apply resdctMult (+/-Nd/c/t morphs)
      if (
        typeof gUI.roll.resdctMult === "number" &&
        gUI.roll.resdctMult !== ""
      ) {
        currentResSk *= gUI.roll.resdctMult;
      }

      // 2. Apply Additive Modifiers
      // Apply resPlus (+/-N morphs)
      if (typeof gUI.roll.resPlus === "number" && gUI.roll.resPlus !== "") {
        currentResSk += gUI.roll.resPlus;
      }
      // Apply Focus bonus (based on resFocus tag 'R'...'B')
      const focusTag = gUI.roll.resFocus;
      if (focusTag && typeof focusTag === "string" && gUI.list?.metaColor) {
        const focusIndex = gUI.list.metaColor.indexOf(focusTag.toUpperCase());
        if (focusIndex > -1) {
          // Check if tag was found
          const focusBonus = 5 * (1 + focusIndex); // R=5, O=10, Y=15, G=20, B=25
          currentResSk += focusBonus;
          fMyConsoleLog(
            `      -> Applying Focus Bonus: +${focusBonus} (Tag: ${focusTag}, Index: ${focusIndex})`
          );
        }
      }

      // 3. Apply Unskilled Penalty (if applicable)
      // Halves the skill value AFTER other modifiers
      if (gUI.roll.isUnSk === true) {
        currentResSk *= 0.5;
      }

      // 4. Final Clamping & Rounding
      // Clamp tiny positive values to 1 (minimum skill value)
      if (currentResSk > 0 && currentResSk < 1) {
        currentResSk = 1;
      }
      // Assign final value: round if >= 1, otherwise set to empty string
      if (currentResSk >= 1) {
        // Check >= 1 (implicitly checks !isNaN too)
        gUI.roll.resSk = Math.round(currentResSk);
      } else {
        gUI.roll.resSk = ""; // Invalid result (e.g., negative, NaN, < 1) becomes empty
      }
    } else {
      // If base skill was invalid, resulting skill is empty
      gUI.roll.resSk = "";
    }

    fMyConsoleLog(`‚öôÔ∏è Calculated final resSk: ${gUI.roll.resSk}`);
  } // END fCalcGUIRollResSk

  // fCalcGUIRollRoll ////////////////////////////////////////////////////////////////
  // Purpose -> Calculates the initial "raw" die roll result (stored in gUI.roll.roll)
  //            based on the calculated resulting skill (gUI.roll.resSk) and the final
  //            roll type (gUI.roll.resTyp). Calls the appropriate dice rolling function
  //            (fSkRoll, fAtkRoll, fDefRoll, etc.).
  // Inputs  -> None (Reads gUI.roll.resSk, gUI.roll.resTyp).
  // Outputs -> None (Writes the raw roll result to gUI.roll.roll).
  function fCalcGUIRollRoll() {
    const resSkValue = gUI.roll.resSk; // The calculated skill value to roll against
    const resTypValue =
      typeof gUI.roll.resTyp === "string"
        ? gUI.roll.resTyp.trim().toLowerCase()
        : ""; // Final roll type

    // === Validate Skill Value ===
    // Must have a valid skill value (number >= 1) to perform a roll
    if (typeof resSkValue !== "number" || resSkValue < 1) {
      gUI.roll.roll = ""; // Set roll to empty if no valid skill
      fMyConsoleLog(
        `‚ÑπÔ∏è Cannot calculate roll: Invalid resSk value (${resSkValue}).`
      );
      return;
    }

    // === Select Roll Function Based on Type ===
    switch (resTypValue) {
      case "": // No type defined
        gUI.roll.roll = "";
        break;
      case "tc": // tremendous/crit roll
      case "sk": // Standard Skill
      case "atr": // Attribute
      case "str": // Strength (currently uses Sk roll)
        gUI.roll.roll = fSkRoll(resSkValue);
        break;
      case "atk": // Attack
        gUI.roll.roll = fAtkRoll(resSkValue);
        break;
      case "dmg": // Damage
        gUI.roll.roll = fDmgRoll(resSkValue);
        break;
      case "def": // Defense
        gUI.roll.roll = fDefRoll(resSkValue);
        break;
      case "ar": // Armor (can return decimal)
        gUI.roll.roll = fARRoll(resSkValue);
        break;
      case "un": // Unskilled (should ideally be handled by resSk calc)
      case "unsk":
        console.warn(
          `fCalcGUIRollRoll: Roll type '${resTypValue}' used directly. Check morph logic.`
        );
        gUI.roll.roll = fSkRoll(resSkValue); // Fallback to Sk roll
        break;
      default: // Unknown type
        console.warn(
          `fCalcGUIRollRoll: Unknown resTyp '${resTypValue}'. Cannot calculate roll.`
        );
        gUI.roll.roll = "";
        break;
    }

    fMyConsoleLog(`‚öôÔ∏è Calculated roll (${resTypValue}): ${gUI.roll.roll}`);
  } // END fCalcGUIRollRoll

  // fCalcGUIRollResRoll /////////////////////////////////////////////////////////////
  // Purpose -> Calculates the *final* roll result (gUI.roll.resRoll) after applying
  //            any applicable roll modifiers (resMultMult, resPlusPlus, resdctMult)
  //            or overrides (resFlatResult) to the initial raw roll (gUI.roll.roll).
  //            Handles rounding appropriately (AR allows decimals). Clamps result >= 0.
  // Inputs  -> None (Reads gUI.roll properties).
  // Outputs -> None (Writes final calculated value to gUI.roll.resRoll).
  function fCalcGUIRollResRoll() {
    // === 1. Check for Flat Result Override (==N) ===
    // This takes precedence over all other modifiers.
    const flatResult = gUI.roll.resFlatResult;
    if (typeof flatResult === "number" && flatResult !== "") {
      const isArType = (gUI.roll.resTyp || "").toLowerCase() === "ar";
      // Round override appropriately (AR keeps 2 decimals)
      const roundedFlatResult = isArType
        ? Number(flatResult.toFixed(2))
        : Math.round(flatResult);
      // Apply override, ensuring minimum of 0
      gUI.roll.resRoll = Math.max(0, roundedFlatResult);
      fMyConsoleLog(
        `‚öôÔ∏è Calculated resRoll (OVERRIDE ==${flatResult}, ${
          isArType ? "AR-rounded" : "INT-rounded"
        }): ${gUI.roll.resRoll}`
      );
      return; // Exit early
    }

    // === 2. Validate Base Roll Value ===
    const initialRoll = gUI.roll.roll; // Get the raw roll calculated by fCalcGUIRollRoll
    // Check if the raw roll is a valid number
    if (
      typeof initialRoll !== "number" ||
      initialRoll === "" ||
      isNaN(initialRoll)
    ) {
      gUI.roll.resRoll = ""; // Cannot calculate final roll without valid base roll
      fMyConsoleLog(
        `‚ÑπÔ∏è Cannot calculate resRoll: Invalid initial roll value (${initialRoll}).`
      );
      return;
    }

    // === 3. Apply Roll Modifiers ===
    let currentResRoll = initialRoll; // Start with the raw roll

    // Apply resMultMult (** // //N morphs)
    if (
      typeof gUI.roll.resMultMult === "number" &&
      gUI.roll.resMultMult !== ""
    ) {
      currentResRoll *= gUI.roll.resMultMult;
    }
    // Apply resdctMult (+/-Nd/c/t morphs)
    if (typeof gUI.roll.resdctMult === "number" && gUI.roll.resdctMult !== "") {
      currentResRoll *= gUI.roll.resdctMult;
    }
    // Apply resPlusPlus (++ / --N morphs)
    if (
      typeof gUI.roll.resPlusPlus === "number" &&
      gUI.roll.resPlusPlus !== ""
    ) {
      currentResRoll += gUI.roll.resPlusPlus;
    }

    // === 4. Final Rounding, Clamping, and Assignment ===
    if (!isNaN(currentResRoll)) {
      // Check if result is still a valid number
      const isArType = (gUI.roll.resTyp || "").toLowerCase() === "ar";
      // Round AR to 2 decimal places, others to integer
      const roundedResRoll = isArType
        ? Number(currentResRoll.toFixed(2))
        : Math.round(currentResRoll);
      // Assign final result, clamped at minimum 0
      gUI.roll.resRoll = Math.max(0, roundedResRoll);
    } else {
      // If calculation resulted in NaN, set final result to empty
      gUI.roll.resRoll = "";
      console.warn(
        "fCalcGUIRollResRoll: Roll modifier calculation resulted in NaN."
      );
    }

    fMyConsoleLog(`‚öôÔ∏è Calculated final resRoll: ${gUI.roll.resRoll}`);
  } // END fCalcGUIRollResRoll

  // fBuildSidebarHTMLAndSimpleText ///////////////////////////////////////////////////////////////
  // Purpose -> Constructs formatted HTML and plain text log lines for a *single roll*
  //            result based on the current state of gUI.roll. Handles different roll
  //            types, multi-roll prefixes, T/C results, skill/roll values, difficulty,
  //            and success/failure/wound results. Calls fNishTorCText if appropriate.
  // Inputs  -> rollNum (Number): Current roll number in a multi-roll sequence (e.g., 1).
  //         -> totalRolls (Number): Total number of rolls in the sequence (e.g., 3).
  //         -> isFirstRoll (Boolean): True if this is the first roll (for T/C).
  // Outputs -> (Object): { html: String, plainText: String } containing the formatted lines.
  function fBuildSidebarHTMLAndSimpleText(rollNum, totalRolls, isFirstRoll) {
    // === Get Data from gUI.roll ===
    const resTyp = (gUI.roll.resTyp || "").trim();
    const resTypLower = resTyp.toLowerCase();
    const skSk = gUI.roll.skSk;
    const resSk = gUI.roll.resSk;
    const roll = gUI.roll.roll;
    const resRoll = gUI.roll.resRoll;
    const dif = gUI.roll.resDif;
    const hasDifficulty =
      (typeof dif === "number" || (typeof dif === "string" && dif !== "")) &&
      dif != null;

    // === Build Log Components (HTML and Plain Text simultaneously) ===
    let htmlLine = "";
    let textLine = "";

    // 1. Base String: Type(Sk->ResSk)
    let htmlBase = resTyp;
    let textBase = resTyp;
    if (typeof skSk === "number" && skSk !== "") {
      const resSkDiff =
        typeof resSk === "number" && resSk !== "" && resSk !== skSk;
      htmlBase += `(${skSk}${resSkDiff ? `->${resSk}` : ""})`;
      textBase += `(${skSk}${resSkDiff ? `->${resSk}` : ""})`;
    } else if (typeof resSk === "number" && resSk !== "") {
      htmlBase += `(${resSk})`;
      textBase += `(${resSk})`;
    }

    // 2. Roll Result String: ~Roll->ResRoll (unless AR vs Dmg)
    let htmlRollResult = "";
    let textRollResult = "";
    if (!(resTypLower === "ar" && hasDifficulty)) {
      const rollStr =
        (typeof roll === "number" ||
          (typeof roll === "string" && roll !== "")) &&
        roll != null
          ? String(roll)
          : "";
      const resRollStr =
        (typeof resRoll === "number" ||
          (typeof resRoll === "string" && resRoll !== "")) &&
        resRoll != null
          ? String(resRoll)
          : "";
      const showFinal = resRollStr !== "" && resRollStr !== rollStr;
      if (rollStr) {
        htmlRollResult += ` ~${rollStr}${showFinal ? `->${resRollStr}` : ""}`;
        textRollResult += ` ~${rollStr}${showFinal ? `->${resRollStr}` : ""}`;
      } else if (resRollStr) {
        htmlRollResult += ` ~${resRollStr}`;
        textRollResult += ` ~${resRollStr}`;
      }
    }

    // 3. Difficulty Indicator
    let htmlDifIndicator = "";
    let textDifIndicator = "";
    if (hasDifficulty) {
      const difStr = String(dif);
      const resRollStr = typeof resRoll === "number" ? String(resRoll) : "?";
      if (resTypLower === "ar") {
        htmlDifIndicator = ` ${difStr}/~${resRollStr}`;
        textDifIndicator = ` ${difStr}/~${resRollStr}`;
      } else if (resTypLower === "dmg") {
        htmlDifIndicator = `/${difStr}`;
        textDifIndicator = `/${difStr}`;
      } else {
        htmlDifIndicator = ` ^${difStr}`;
        textDifIndicator = ` ^${difStr}`;
      }
    }

    // 4. Success/Failure/Wound Delta
    let htmlSuccessDelta = "";
    let textSuccessDelta = "";
    if (hasDifficulty && typeof resRoll === "number") {
      let wounds;
      if (resTypLower === "ar") {
        // Calculate AR Wounds
        wounds = resRoll !== 0 ? Math.min(0, Math.round(-(dif / resRoll))) : 0;
        htmlSuccessDelta = ` = ${wounds} Wnds`;
        textSuccessDelta = ` = ${wounds} Wnds`;
      } else if (resTypLower === "dmg") {
        // Calculate DMG Wounds
        wounds = dif !== 0 ? Math.max(0, Math.round(resRoll / dif)) : 0;
        htmlSuccessDelta = ` = +${wounds} Wounds`;
        textSuccessDelta = ` = +${wounds} Wounds`;
      } else {
        // Standard Success/Failure Check
        const delta = resRoll - dif;
        if (delta >= 0) {
          htmlSuccessDelta = ` =+${delta} ‚úÖ`;
          textSuccessDelta = ` =+${delta} ‚úÖ`;
        } else {
          htmlSuccessDelta = ` =${delta} ‚ùå`;
          textSuccessDelta = ` =${delta} ‚ùå`;
        }
      }
    }

    // === Combine Components ===
    htmlLine =
      `${htmlBase}${htmlRollResult}${htmlDifIndicator}${htmlSuccessDelta}`.trim();
    textLine =
      `${textBase}${textRollResult}${textDifIndicator}${textSuccessDelta}`.trim();

    // === Add T/C Result (First Roll Only) ===
    const tc = isFirstRoll ? fTC() : ""; // Determine T/C result
    const tcText = tc ? (tc.includes("red-bold") ? " C" : " T") : ""; // Plain text version
    if (tc) {
      htmlLine += `   ${tc}`;
      textLine += ` ${tcText}`; // Append plain text T/C
    }

    // === ADDED: Call Nish T/C Text Function ===
    if (gUI.roll.isNish && tc !== "") {
      // Only call if it's a Nish roll AND T/C occurred
      const tOrCParam = tc.includes("red-bold") ? "c" : "t"; // Determine parameter
      fMyConsoleLog(
        `   -> Nish roll T/C detected. Calling fNishTorCText('${tOrCParam}')...`
      );
      fNishTorCText(tOrCParam); // Call the function (async, but don't await)
    }
    // === END ADDED ===

    // === Add Multi-Roll Prefix ===
    let htmlPrefix = "";
    let textPrefix = "";
    if (totalRolls > 1) {
      htmlPrefix = `<span class="roll-prefix">${rollNum}></span> `;
      textPrefix = `${rollNum}> `;
    }

    // Return object with both versions
    return {
      html: `${htmlPrefix}${htmlLine}`,
      plainText: `${textPrefix}${textLine}`,
    };
  } // END fBuildSidebarHTMLAndSimpleText

  // ==========================================================================
  // === Post-Combat Preparation Handlers ===
  // ==========================================================================

  // fHandlePrepARClick ////////////////////////////////////////////////////////////
  // Purpose -> Handles clicks on the "Prep AR" button in the sidebar. Reads defense
  //            failure data from gUI.monsterRollResultsHistory using the button's
  //            rollId. Updates 'NumMon' for ALL originally targeted monsters (setting
  //            to failure count or '' if 0). Switches the active checkbox from Sk1 (Def)
  //            to Sk2 (AR) on the original ability row. Disables button and cleans up history.
  // Inputs  -> event (MouseEvent): The click event object.
  // Outputs -> None (Modifies grid data/DOM, gUI state, button state).
  async function fHandlePrepARClick(event) {
    const button = event.target;

    // === 1. Validate Button & State ===
    if (!button || !button.classList.contains("prep-ar-btn")) {
      return; // Exit if not the correct button
    }
    fMyConsoleLog(`üñ±Ô∏è Sidebar 'Prep AR' Button Clicked...`);

    // Prevent double-clicks
    if (button.disabled) {
      fMyConsoleLog("   -> Button already disabled. Ignoring click.");
      return;
    }
    button.disabled = true; // Disable immediately

    // === 2. Get Roll ID & Associated Data ===
    const rollId = button.dataset.rollId;
    if (!rollId) {
      console.error(
        "fHandlePrepARClick: Button is missing 'data-roll-id' attribute."
      );
      fMyConsoleLog("‚ùå Error preparing AR: Button lacks roll ID.");
      await fShowMessage("Error: Cannot identify which roll results to use.");
      button.textContent = "Error (No ID)";
      return;
    }

    const rollData = gUI.monsterRollResultsHistory?.[rollId];
    // Validate required data structure
    if (
      !rollData ||
      !Array.isArray(rollData.results) ||
      typeof rollData.originalAbilityRow !== "number" ||
      !Array.isArray(rollData.allTargetedRows_R)
    ) {
      console.error(
        `fHandlePrepARClick: No valid data found in gUI.monsterRollResultsHistory for rollId '${rollId}'.`,
        rollData
      );
      fMyConsoleLog(
        `‚ùå Error preparing AR: Data for roll ID '${rollId}' not found or invalid.`
      );
      await fShowMessage(
        "Error: Could not find the data associated with this defense roll."
      );
      button.textContent = "Error (No Data)";
      return;
    }

    const failureResults = rollData.results; // Array of { mon_R, monName, numFailures } (only includes failures > 0)
    const originalAbilityRow = rollData.originalAbilityRow; // Row index of the Def ability used
    const allTargetedRows_R = rollData.allTargetedRows_R; // Array of all monster rows involved

    // === 3. Update NumMon for All Targeted Monsters ===
    const cNumMon = fResolveCol("NumMon");
    let updateErrors = false;

    if (isNaN(cNumMon)) {
      // Ensure 'NumMon' column resolved
      console.error(
        "fHandlePrepARClick: Could not resolve 'NumMon' column tag."
      );
      fMyConsoleLog("‚ùå Error preparing AR: Could not find 'NumMon' column.");
      await fShowMessage(
        "Error: Could not find the 'NumMon' column in the grid."
      );
      button.textContent = "Error"; // Keep button disabled but indicate error
      // Note: History entry remains here on error
      return;
    }

    // Create a map for quick lookup of failure counts
    const failureMap = new Map();
    failureResults.forEach((res) => failureMap.set(res.mon_R, res.numFailures));

    fMyConsoleLog(
      `   -> Processing ${allTargetedRows_R.length} targeted monster rows for Row ${originalAbilityRow}...`
    );
    // Iterate through ALL originally targeted rows
    allTargetedRows_R.forEach((target_mon_R) => {
      // Get failure count from map (undefined if 0 failures)
      const numFailures = failureMap.get(target_mon_R);
      // Set NumMon to the failure count, or empty string if undefined/zero
      const valueToSet =
        numFailures !== undefined && numFailures > 0 ? numFailures : "";

      fMyConsoleLog(
        `      -> Setting NumMon for row ${target_mon_R} to '${valueToSet}'`
      );
      // Update the grid cell
      if (!fSetGridValue(target_mon_R, cNumMon, valueToSet)) {
        fMyConsoleLog(
          `         -> ‚ö†Ô∏è Failed to set NumMon for row ${target_mon_R}`
        );
        updateErrors = true; // Track if any update fails
      }
    });

    if (updateErrors) {
      // Notify user if any grid updates failed
      await fShowMessage(
        "Warning: Some 'NumMon' values may not have updated correctly."
      );
    }

    // === 4. Switch Active Checkbox from Sk1 (Def) to Sk2 (AR) ===
    const originalSk1ColTag = "Sk1ChkBox"; // Assume Defense is Sk1
    const targetSk2ColTag = "Sk2ChkBox"; // Assume Armor is Sk2

    const originalSk1Col = fResolveCol(originalSk1ColTag);
    const targetSk2Col = fResolveCol(targetSk2ColTag);

    // Validate column resolution
    if (isNaN(originalSk1Col) || isNaN(targetSk2Col)) {
      const missingTag = isNaN(originalSk1Col)
        ? originalSk1ColTag
        : targetSk2ColTag;
      fMyConsoleLog(
        `   -> Cannot switch checkbox: Could not resolve column tag '${missingTag}'.`
      );
      await fShowMessage(
        `Error: Could not find the ${
          isNaN(originalSk1Col) ? "Defense (Sk1)" : "Armor (Sk2)"
        } column.`
      );
      button.textContent = "Done (CB Fail)"; // Update button text to indicate partial failure
      // Note: History entry remains here on error
      return;
    }

    // --- Perform the Switch ---
    // a) Uncheck old Sk1 box (if needed)
    const oldCellDiv = gUI.grid2D?.[originalAbilityRow]?.[originalSk1Col];
    const oldCheckbox = oldCellDiv?.querySelector('input[type="checkbox"]');
    if (oldCheckbox && oldCheckbox.checked) {
      oldCheckbox.checked = false;
      gUI.arr[originalAbilityRow][originalSk1Col] = false; // Update data model
      fMyConsoleLog(
        `   -> Unchecked original Sk1 checkbox [${originalAbilityRow}, ${originalSk1Col}]`
      );
      // Clear tracker if it pointed to the old box
      if (
        gUI.currentSkRadioChecked.r === originalAbilityRow &&
        gUI.currentSkRadioChecked.c === originalSk1Col
      ) {
        gUI.currentSkRadioChecked = { r: null, c: null };
      }
    } else {
      fMyConsoleLog(
        `   -> Original Sk1 checkbox [${originalAbilityRow}, ${originalSk1Col}] not found or already unchecked.`
      );
    }

    // b) Check new Sk2 box
    const targetCellDiv = gUI.grid2D?.[originalAbilityRow]?.[targetSk2Col];
    const targetCheckbox = targetCellDiv?.querySelector(
      'input[type="checkbox"]'
    );
    if (targetCheckbox) {
      targetCheckbox.checked = true;
      gUI.arr[originalAbilityRow][targetSk2Col] = true; // Update data model
      // c) Update tracker to point to the new Sk2 box
      // (Includes unchecking any *other* box that might have been checked)
      const { r: currentlyCheckedR, c: currentlyCheckedC } =
        gUI.currentSkRadioChecked;
      if (
        currentlyCheckedR !== null &&
        currentlyCheckedC !== null &&
        (currentlyCheckedR !== originalAbilityRow ||
          currentlyCheckedC !== targetSk2Col)
      ) {
        fUncheckOldSkGroupBox(currentlyCheckedR, currentlyCheckedC);
      }
      gUI.currentSkRadioChecked = { r: originalAbilityRow, c: targetSk2Col };
      fMyConsoleLog(
        `   -> Switched active checkbox to Sk2 at [${originalAbilityRow}, ${targetSk2Col}].`
      );
      button.textContent = "AR Prep Done"; // Update button text on success
    } else {
      // Handle error finding the target Sk2 checkbox
      console.error(
        `fHandlePrepARClick: Could not find Sk2 checkbox element at [${originalAbilityRow}, ${targetSk2Col}].`
      );
      fMyConsoleLog(
        `   -> ‚ùå Failed to find Sk2 checkbox element at [${originalAbilityRow}, ${targetSk2Col}].`
      );
      await fShowMessage(
        `Error: Could not find the target Armor checkbox element.`
      );
      gUI.currentSkRadioChecked = { r: null, c: null }; // Clear tracker
      button.textContent = "Done (CB Fail)";
      // Note: History entry remains here on error
      return;
    }

    // Post text to Firestore
    fHandleAutoSaveTextToFirestore();

    // === 5. Clean up History ===
    // Remove the processed entry from the history map
    try {
      delete gUI.monsterRollResultsHistory[rollId];
      fMyConsoleLog(`   -> Removed entry for rollId '${rollId}' from history.`);
    } catch (e) {
      console.warn(
        `fHandlePrepARClick: Failed to remove entry for rollId '${rollId}' from history:`,
        e
      );
    }

    fMyConsoleLog("‚úÖ Prep AR action completed.");
  } // END fHandlePrepARClick

  // fHandlePrepDmgClick ///////////////////////////////////////////////////////////
  // Purpose -> Handles clicks on the "Prep Dmg" button in the sidebar. Reads attack
  //            success data from gUI.monsterRollResultsHistory using the button's
  //            rollId. Updates 'NumMon' for ALL originally targeted monsters (setting
  //            to success count or '' if 0). Switches the active checkbox from Sk1 (Atk)
  //            to Sk2 (Dmg) on the original ability row. Disables button and cleans up history.
  // Inputs  -> event (MouseEvent): The click event object.
  // Outputs -> None (Modifies grid data/DOM, gUI state, button state).
  async function fHandlePrepDmgClick(event) {
    const button = event.target;

    // === 1. Validate Button & State ===
    if (!button || !button.classList.contains("prep-dmg-btn")) {
      return; // Exit if not the correct button
    }
    fMyConsoleLog(`üñ±Ô∏è Sidebar 'Prep Dmg' Button Clicked...`);

    // Prevent double-clicks
    if (button.disabled) {
      fMyConsoleLog("   -> Button already disabled. Ignoring click.");
      return;
    }
    button.disabled = true; // Disable immediately

    // === 2. Get Roll ID & Associated Data ===
    const rollId = button.dataset.rollId;
    if (!rollId) {
      console.error(
        "fHandlePrepDmgClick: Button is missing 'data-roll-id' attribute."
      );
      fMyConsoleLog("‚ùå Error preparing Dmg: Button lacks roll ID.");
      await fShowMessage("Error: Cannot identify which roll results to use.");
      button.textContent = "Error (No ID)";
      return;
    }

    fMyConsoleLog(
      `   -> Handling click for rollId '${rollId}'. Available history keys: ${Object.keys(
        gUI.monsterRollResultsHistory || {}
      ).join(", ")}`
    );
    const rollData = gUI.monsterRollResultsHistory?.[rollId];
    fMyConsoleLog(
      `   -> Retrieved rollData for ID '${rollId}': ${JSON.stringify(rollData)}`
    );

    // Validate required data structure
    if (
      !rollData ||
      !Array.isArray(rollData.results) ||
      typeof rollData.originalAbilityRow !== "number" ||
      !Array.isArray(rollData.allTargetedRows_R)
    ) {
      console.error(
        `fHandlePrepDmgClick: No valid data found in gUI.monsterRollResultsHistory for rollId '${rollId}'.`,
        rollData
      );
      fMyConsoleLog(
        `‚ùå Error preparing Dmg: Data for roll ID '${rollId}' not found or invalid.`
      );
      await fShowMessage(
        "Error: Could not find the data associated with this attack roll."
      );
      button.textContent = "Error (No Data)";
      return;
    }

    const successResults = rollData.results; // Array of { mon_R, monName, numSuccesses } (only successes > 0)
    const originalAbilityRow = rollData.originalAbilityRow; // Row index of the Atk ability used
    const allTargetedRows_R = rollData.allTargetedRows_R; // Array of all monster rows involved

    // === 3. Update NumMon for All Targeted Monsters ===
    const cNumMon = fResolveCol("NumMon");
    let updateErrors = false;

    if (isNaN(cNumMon)) {
      // Ensure 'NumMon' column resolved
      console.error(
        "fHandlePrepDmgClick: Could not resolve 'NumMon' column tag."
      );
      fMyConsoleLog("‚ùå Error preparing Dmg: Could not find 'NumMon' column.");
      await fShowMessage(
        "Error: Could not find the 'NumMon' column in the grid."
      );
      button.textContent = "Error"; // Keep button disabled but indicate error
      // Note: History entry remains here on error
      return;
    }

    // Create a map for quick lookup of success counts
    const successMap = new Map();
    successResults.forEach((res) =>
      successMap.set(res.mon_R, res.numSuccesses)
    );

    fMyConsoleLog(
      `   -> Processing ${allTargetedRows_R.length} targeted monster rows for Row ${originalAbilityRow}...`
    );
    // Iterate through ALL originally targeted rows
    allTargetedRows_R.forEach((target_mon_R) => {
      // Get success count from map (undefined if 0 successes)
      const numSuccesses = successMap.get(target_mon_R);
      // Set NumMon to the success count, or empty string if undefined/zero
      const valueToSet =
        numSuccesses !== undefined && numSuccesses > 0 ? numSuccesses : "";

      fMyConsoleLog(
        `       -> Processing target row ${target_mon_R}. Successes from map: ${numSuccesses}. Value to set: '${valueToSet}'`
      );
      // Update the grid cell
      if (!fSetGridValue(target_mon_R, cNumMon, valueToSet)) {
        fMyConsoleLog(
          `         -> ‚ö†Ô∏è Failed to set NumMon for row ${target_mon_R}`
        );
        updateErrors = true; // Track if any update fails
      }
    });

    if (updateErrors) {
      // Notify user if any grid updates failed
      await fShowMessage(
        "Warning: Some 'NumMon' values may not have updated correctly."
      );
    }

    // === 4. Switch Active Checkbox from Sk1 (Atk) to Sk2 (Dmg) ===
    const originalSk1ColTag = "Sk1ChkBox"; // Assume Attack is Sk1
    const targetSk2ColTag = "Sk2ChkBox"; // Assume Damage is Sk2

    const originalSk1Col = fResolveCol(originalSk1ColTag);
    const targetSk2Col = fResolveCol(targetSk2ColTag);

    // Validate column resolution
    if (isNaN(originalSk1Col) || isNaN(targetSk2Col)) {
      const missingTag = isNaN(originalSk1Col)
        ? originalSk1ColTag
        : targetSk2ColTag;
      fMyConsoleLog(
        `   -> Cannot switch checkbox: Could not resolve column tag '${missingTag}'.`
      );
      await fShowMessage(
        `Error: Could not find the ${
          isNaN(originalSk1Col) ? "Attack (Sk1)" : "Damage (Sk2)"
        } column.`
      );
      button.textContent = "Done (CB Fail)"; // Update button text to indicate partial failure
      // Note: History entry remains here on error
      return;
    }

    // --- Perform the Switch ---
    // a) Uncheck old Sk1 box (if needed)
    const oldCellDiv = gUI.grid2D?.[originalAbilityRow]?.[originalSk1Col];
    const oldCheckbox = oldCellDiv?.querySelector('input[type="checkbox"]');
    if (oldCheckbox && oldCheckbox.checked) {
      oldCheckbox.checked = false;
      gUI.arr[originalAbilityRow][originalSk1Col] = false; // Update data model
      fMyConsoleLog(
        `   -> Unchecked original Sk1 checkbox [${originalAbilityRow}, ${originalSk1Col}]`
      );
      // Clear tracker if it pointed to the old box
      if (
        gUI.currentSkRadioChecked.r === originalAbilityRow &&
        gUI.currentSkRadioChecked.c === originalSk1Col
      ) {
        gUI.currentSkRadioChecked = { r: null, c: null };
      }
    } else {
      fMyConsoleLog(
        `   -> Original Sk1 checkbox [${originalAbilityRow}, ${originalSk1Col}] not found or already unchecked.`
      );
    }

    // b) Check new Sk2 box
    const targetCellDiv = gUI.grid2D?.[originalAbilityRow]?.[targetSk2Col];
    const targetCheckbox = targetCellDiv?.querySelector(
      'input[type="checkbox"]'
    );
    if (targetCheckbox) {
      targetCheckbox.checked = true;
      gUI.arr[originalAbilityRow][targetSk2Col] = true; // Update data model
      // c) Update tracker to point to the new Sk2 box
      const { r: currentlyCheckedR, c: currentlyCheckedC } =
        gUI.currentSkRadioChecked;
      if (
        currentlyCheckedR !== null &&
        currentlyCheckedC !== null &&
        (currentlyCheckedR !== originalAbilityRow ||
          currentlyCheckedC !== targetSk2Col)
      ) {
        fUncheckOldSkGroupBox(currentlyCheckedR, currentlyCheckedC);
      }
      gUI.currentSkRadioChecked = { r: originalAbilityRow, c: targetSk2Col };
      fMyConsoleLog(
        `   -> Switched active checkbox to Sk2 at [${originalAbilityRow}, ${targetSk2Col}].`
      );
      button.textContent = "Dmg Prep Done"; // Update button text on success
    } else {
      // Handle error finding the target Sk2 checkbox
      console.error(
        `fHandlePrepDmgClick: Could not find Sk2 checkbox element at [${originalAbilityRow}, ${targetSk2Col}].`
      );
      fMyConsoleLog(
        `   -> ‚ùå Failed to find Sk2 checkbox element at [${originalAbilityRow}, ${targetSk2Col}].`
      );
      await fShowMessage(
        `Error: Could not find the target Damage checkbox element.`
      );
      gUI.currentSkRadioChecked = { r: null, c: null }; // Clear tracker
      button.textContent = "Done (CB Fail)";
      // Note: History entry remains here on error
      return;
    }

    // Post text to Firestore
    fHandleAutoSaveTextToFirestore();

    // === 5. Clean up History ===
    // Remove the processed entry from the history map
    try {
      delete gUI.monsterRollResultsHistory[rollId];
      fMyConsoleLog(`   -> Removed entry for rollId '${rollId}' from history.`);
    } catch (e) {
      console.warn(
        `fHandlePrepDmgClick: Failed to remove entry for rollId '${rollId}' from history:`,
        e
      );
    }

    fMyConsoleLog("‚úÖ Prep Dmg action completed.");
  } // END fHandlePrepDmgClick

  // ==========================================================================
  // === Nish Turn Logic ===
  // ==========================================================================

  // fHandleNishButtonClick //////////////////////////////////////////////////////////
  // Purpose -> Handles the click event specifically for the main 'Nish' button.
  //            Sets the Nish button state, programmatically checks the Nish ability's
  //            Sk1 checkbox, executes the core Nish sequence (sidebar divider, meta
  //            channeling, max AP, duration updates), and then triggers the main
  //            roll action handler (fMain_AbilityRoll) for the Nish ability itself.
  // Inputs  -> None.
  // Outputs -> None (Modifies state, DOM, triggers other async functions).
  async function fHandleNishButtonClick(event) {
    // Added event parameter to use stopPropagation
    fMyConsoleLog("üñ±Ô∏è Nish Button Clicked...");
    if (event) event.stopPropagation(); // Prevent potential bubbling if called from event
    fCloseAllDropdowns(); // Close any open menus

    // === 1. Set Button State ===
    fSetButtonOrMenuState("Nish"); // Set gUI.buttonOrMenu.isNish = true

    // === 2. Programmatically Check Nish Checkbox ===
    const nishRowTag = "NishAtr_R";
    const nishColTag = "Sk1ChkBox";
    const r = fResolveRow(nishRowTag);
    const c = fResolveCol(nishColTag);

    // Validate Nish checkbox coordinates
    if (isNaN(r) || isNaN(c)) {
      console.error(
        `fHandleNishButtonClick: Could not resolve Nish checkbox coordinates (${nishRowTag}, ${nishColTag}).`
      );
      await fShowMessage(`‚ùå Error: Cannot find Nish checkbox definition.`);
      fSetButtonOrMenuState(null); // Reset state on error
      return;
    }

    // Uncheck any previously checked radio button
    const currentChecked = gUI.currentSkRadioChecked;
    if (
      currentChecked.r !== null &&
      currentChecked.c !== null &&
      (currentChecked.r !== r || currentChecked.c !== c)
    ) {
      fUncheckOldSkGroupBox(currentChecked.r, currentChecked.c);
    }

    // Check the Nish box DOM element and update state/tracker
    const nishCellDiv = gUI.grid2D?.[r]?.[c];
    const nishCheckbox = nishCellDiv?.querySelector(
      'input[data-sk-group="true"]'
    );
    if (nishCheckbox) {
      nishCheckbox.checked = true;
      gUI.arr[r][c] = true; // Update data model
      gUI.currentSkRadioChecked = { r, c }; // Update tracker
      fMyConsoleLog(
        `   -> Programmatically checked Nish checkbox [${r}, ${c}].`
      );
    } else {
      // Handle error if checkbox element isn't found
      console.error(
        `fHandleNishButtonClick: Could not find Nish checkbox DOM element at [${r}, ${c}].`
      );
      await fShowMessage(`‚ùå Error: Cannot find Nish checkbox element.`);
      fSetButtonOrMenuState(null); // Reset state on error
      return;
    }

    // === 3. Execute Core Nish Sequence ===
    // (Adds sidebar divider, handles Meta Channeling, sets Max AP, updates Durations)
    await fExecuteNishSequence();

    // === 4. Trigger Main Roll Handler ===
    // fMain_AbilityRoll will now use the Nish row/column and the isNish state
    fMyConsoleLog("   -> Triggering fMain_AbilityRoll for Nish ability...");
    await fMain_AbilityRoll();

    // Note: Button state (isNish) is reset at the end of fMain_AbilityRoll
  } // END fHandleNishButtonClick

  // fExecuteNishSequence ////////////////////////////////////////////////////////////
  // Purpose -> Executes the common sequence of actions required at the start of a Nish
  //            turn. Adds sidebar divider, runs Meta Channeling, sets Max AP, and
  //            processes IsOn durations. Skips Meta/Duration if Luck was used.
  // Inputs  -> None (Uses gUI.buttonOrMenu state).
  // Outputs -> None (Modifies sidebar, calls other async functions).
  async function fExecuteNishSequence() {
    fMyConsoleLog("üé¨ Executing Nish Sequence...");
    // 1. Add Sidebar Divider (HTML and Plain Text)
    // Use '======================' for the plain text version
    fPostToSidebar(
      '<hr class="nish-divider"><br>',
      "\n======================\n"
    );
    fMyConsoleLog("   -> Sidebar divider added.");

    // 2. Run Meta Channeling (Skip if Luck button initiated the action)
    if (!gUI.buttonOrMenu.isLuck) {
      await fMetaChannel(); // This function logs its own message
      fMyConsoleLog("   -> fMetaChannel executed.");
    } else {
      fMyConsoleLog("   -> Skipping fMetaChannel (Luck trigger).");
    }

    // 3. Set Action Points to Max (Always runs as part of Nish turn start)
    await fAct_SetToMax(); // Doesn't log to sidebar currently
    fMyConsoleLog("   -> fAct_SetToMax executed.");

    // 4. Process 'Is On' / Duration Decrements (Skip if Luck button initiated the action)
    if (!gUI.buttonOrMenu.isLuck) {
      await fIsOn_NewNishSet(); // Doesn't log to sidebar currently
      fMyConsoleLog("   -> fIsOn_NewNishSet executed.");
    } else {
      fMyConsoleLog("   -> Skipping fIsOn_NewNishSet (Luck trigger).");
    }

    fMyConsoleLog("‚úÖ Nish Sequence Execution Complete.");
    // Note: No fSendLogToGMScreenAndPS here, as it's often called by another function (fHandleNishButtonClick or fMain_AbilityRoll)
    // which will handle the final send.
  } // END fExecuteNishSequence

  // fNishTorCText ///////////////////////////////////////////////////////////////
  // Purpose -> Selects and displays a random Tremendous ('t') or Critical ('c') Nish
  //            result from the dbCritFSData cache to the sidebar.
  // Inputs  -> tOrC (String): 't' for Tremendous, 'c' for Critical (case-insensitive).
  // Outputs -> None (Posts result to sidebar via fPostToSidebar if successful).
  // Notes   -> Logic is similar to fHandleGMAward.
  async function fNishTorCText(tOrC) {
    const funcName = "fNishTorCText";
    fMyConsoleLog(
      `‚öôÔ∏è ${funcName}: Processing Nish T/C result for input '${tOrC}'...`
    );

    // --- 1. Validate Input ---
    const inputLower = String(tOrC ?? "").toLowerCase();
    if (inputLower !== "t" && inputLower !== "c") {
      fMyConsoleLog(
        `   -> ${funcName}: Invalid input '${tOrC}'. Must be 't' or 'c'. Aborting.`
      );
      return;
    }

    // --- 2. Validate Cache ---
    const cacheKey = "dbCritFSData";
    const cache = gUI[cacheKey];
    if (
      !cache ||
      !cache.text ||
      !Array.isArray(cache.text) ||
      !cache.colTagsMap ||
      !cache.rowTagsMap
    ) {
      const errorMsg = `Cannot get Nish T/C text: Required cache gUI['${cacheKey}'] is missing or invalid.`;
      console.error(`${funcName}: ${errorMsg}`);
      fMyConsoleLog(`   -> ‚ùå ${funcName} Error: ${errorMsg}`);
      // No user message needed here as this is usually part of another roll sequence.
      return;
    }

    // --- 3. Determine Column Tag and Title ---
    const columnTag = inputLower === "t" ? "NishTrem" : "NishCrit";
    const titleText =
      inputLower === "t" ? "Tremendous Nish:" : "Critical Nish:";
    const titleHtml = `<span class="red-bold">${titleText}</span>`; // Use red-bold for both per request

    // --- 4. Resolve Tags & Indices ---
    const startRowTag = "RowBeforeFirstDataRow";
    const resultColIndex = fResolveFSDataCol(cacheKey, columnTag);
    const startRowIndex = fResolveFSDataRow(cacheKey, startRowTag) + 1;

    if (isNaN(resultColIndex)) {
      fMyConsoleLog(
        `   -> ‚ùå ${funcName} Error: Column tag '${columnTag}' not found in ${cacheKey}.`
      );
      return;
    }
    if (isNaN(startRowIndex)) {
      fMyConsoleLog(
        `   -> ‚ùå ${funcName} Error: Start row tag '${startRowTag}' not found in ${cacheKey}.`
      );
      return;
    }
    fMyConsoleLog(
      `   -> Resolved '${columnTag}' to index ${resultColIndex}, '${startRowTag}' to index ${startRowIndex}.`
    );

    // --- 5. Extract, Filter, and Select Award ---
    const resultsList = [];
    const numRows = cache.text.length;
    for (let r = startRowIndex; r < numRows; r++) {
      const cellValue = cache.text[r]?.[resultColIndex];
      const trimmedValue = String(cellValue ?? "").trim();
      if (trimmedValue !== "") {
        resultsList.push(trimmedValue);
      }
    }

    if (resultsList.length === 0) {
      fMyConsoleLog(
        `   -> ${funcName}: No valid results found in '${columnTag}' column starting from row '${startRowTag}'. Skipping display.`
      );
      return;
    }

    const randomIndex = Math.floor(Math.random() * resultsList.length);
    const selectedResult = resultsList[randomIndex];
    fMyConsoleLog(`   -> Randomly selected result: "${selectedResult}"`);

    // --- 6. Format and Post to Sidebar ---
    const sidebarMsgHtml = `${titleHtml}<br>${selectedResult}`;
    const sidebarMsgText = `${titleText}\n${selectedResult}`; // Plain text version
    fPostToSidebar(sidebarMsgHtml, sidebarMsgText);
    fShowSidebar(); // Ensure sidebar is visible

    fMyConsoleLog(`‚úÖ ${funcName}: Completed.`);
  } // END fNishTorCText

  // ==========================================================================
  // === Grid Interaction & Ad-Hoc Rolls ===
  // ==========================================================================

  // fUpdateMonsterTable ////////////////////////////////////////////////////////
  // Purpose -> Processes monster data received from the GM Screen DB and populates
  //            the client-side Turbo monster table (gUI.range.monsters), *skipping the
  //            first row (CustMon)*. Handles active monster filtering, custom monster
  //            naming/skipping (trims "Mon: " prefix, removes trailing ' _'/'   '),
  //            data mapping, SIZE parsing, and overflow warnings.
  // Inputs  -> gmDataArray (Array[][]): 2D array of monster data from the GM Screen.
  //         -> gmColTags (Object): Map of GM Screen column tags to indices { tagName: index }.
  //         -> gmRowTags (Object): Map of GM Screen row tags to indices { tagName: index }.
  // Outputs -> None (Modifies Turbo grid data/DOM via fSetGridValue, potentially calls fShowMessage).
  async function fUpdateMonsterTable(gmDataArray, gmColTags, gmRowTags) {
    fMyConsoleLog("üß¨ Processing GM Monster Data for Turbo Table...");
    // === 1. Validate Inputs ===
    if (!Array.isArray(gmDataArray)) {
      fMyConsoleLog(
        "‚ùå fUpdateMonsterTable Error: gmDataArray is not an array."
      );
      await fShowMessage(
        "Error: Invalid monster data received from server (not an array)."
      );
      return;
    }
    if (typeof gmColTags !== "object" || gmColTags === null) {
      fMyConsoleLog(
        "‚ùå fUpdateMonsterTable Error: gmColTags is not a valid object."
      );
      await fShowMessage(
        "Error: Invalid column tag mapping received from server."
      );
      return;
    }
    if (typeof gmRowTags !== "object" || gmRowTags === null) {
      fMyConsoleLog(
        "‚ùå fUpdateMonsterTable Error: gmRowTags is not a valid object."
      );
      await fShowMessage(
        "Error: Invalid row tag mapping received from server."
      );
      return;
    }

    // === 2. Resolve Turbo Table Boundaries ===
    const turboRangeDef = gUI.range?.monsters;
    if (!turboRangeDef || !fDoesObjectHaveR1C1R2C2Properties(turboRangeDef)) {
      fMyConsoleLog(
        "‚ùå fUpdateMonsterTable Error: Turbo monster range (gUI.range.monsters) invalid."
      );
      await fShowMessage(
        "Error: Turbo monster table range definition is missing."
      );
      return;
    }
    const turboMon_R_start = fResolveRow(turboRangeDef.r1); // The 'CustMon' row index
    const turboMon_R_end = fResolveRow(turboRangeDef.r2); // The 'LastMon_R' row index
    const turbo_c1 = fResolveCol(turboRangeDef.c1);
    const turbo_c2 = fResolveCol(turboRangeDef.c2);
    if ([turboMon_R_start, turboMon_R_end, turbo_c1, turbo_c2].some(isNaN)) {
      fMyConsoleLog(
        "‚ùå fUpdateMonsterTable Error: Could not resolve Turbo monster range boundaries."
      );
      await fShowMessage(
        "Error: Could not resolve Turbo monster table boundaries."
      );
      return;
    }
    const turboTableAvailableRows = turboMon_R_end - (turboMon_R_start + 1) + 1;
    const turboFill_R_start = turboMon_R_start + 1;
    fMyConsoleLog(
      `   -> Turbo Table: CustMon Row=${turboMon_R_start}, LastMon Row=${turboMon_R_end}.`
    );
    fMyConsoleLog(
      `   -> Filling starts at row ${turboFill_R_start}. Available Rows for DB monsters: ${turboTableAvailableRows}.`
    );

    // === 3. Resolve Necessary GM Screen Tags (Columns & Rows) ===
    // --- Column Tags ---
    const requiredGmColTags = [
      "ActiveMonTF",
      "MonCustName",
      "MonName",
      "Vit",
      "Atk",
      "Dmg",
      "Def",
      "Ar",
      "Pic",
      "Notes",
    ];
    const resolvedGmColIndices = {};
    let missingColTag = null;
    for (const tag of requiredGmColTags) {
      const index = gmColTags?.[tag];
      if (typeof index === "number" && !isNaN(index)) {
        resolvedGmColIndices[tag] = index;
      } else {
        if (gmColTags?.hasOwnProperty(tag)) {
          fMyConsoleLog(
            `   -> Warning: GM Column tag '${tag}' exists but index is invalid: ${index}`
          );
        }
        missingColTag = tag;
        break;
      }
    }
    if (missingColTag) {
      fMyConsoleLog(
        `‚ùå fUpdateMonsterTable Error: Missing required GM Screen column tag or invalid index for: '${missingColTag}'.`
      );
      await fShowMessage(
        `Error: GM Screen data is missing expected column tag or index for: ${missingColTag}.`
      );
      return;
    }
    fMyConsoleLog(
      `   -> Resolved GM Column Indices: ${JSON.stringify(
        resolvedGmColIndices
      )}`
    );

    // --- Row Tags (for custom monster boundaries) ---
    const custMonFirst_R_idx_raw = gmRowTags["CustMonFirst_R"];
    const monTblLast_R_idx_raw = gmRowTags["MonTblLast_R"];
    const hasCustomBounds =
      typeof custMonFirst_R_idx_raw === "number" &&
      typeof monTblLast_R_idx_raw === "number";
    if (hasCustomBounds) {
      fMyConsoleLog(
        `   -> Received GM Custom Monster Row Indices (relative presumed): ${custMonFirst_R_idx_raw} to ${monTblLast_R_idx_raw}`
      );
    } else {
      fMyConsoleLog(
        `   -> Warning: Could not resolve GM custom monster row boundary tags ('CustMonFirst_R', 'MonTblLast_R'). Custom monster logic may be inaccurate.`
      );
    }

    // === 4. Iterate and Populate Turbo Table ===
    let turboMon_R = turboFill_R_start;
    let isOverflowing = false;
    let monstersAdded = 0;
    let errorsSettingValue = 0;
    const activeColIdx = resolvedGmColIndices["ActiveMonTF"];

    for (let db_idx = 0; db_idx < gmDataArray.length; db_idx++) {
      const dbMon_R = gmDataArray[db_idx];

      // --- Log the value being checked for isActive ---
      const isActiveVal = dbMon_R?.[activeColIdx];
      // if (db_idx < 5) { // Keep logging limited if needed
      //      fMyConsoleLog(`      -> Checking GM row ${db_idx}: ActiveMonTF col (${activeColIdx}) raw value = '${isActiveVal}' (Type: ${typeof isActiveVal})`);
      // }

      // --- Check if Active (More Robust Check) ---
      const isActive =
        isActiveVal === true || String(isActiveVal).toUpperCase() === "TRUE";
      if (!isActive) {
        continue;
      }
      // fMyConsoleLog(`      -> GM row ${db_idx} IS Active. Processing...`); // Can be verbose

      // --- Determine if Custom Monster Row ---
      const isCustomMonsterRow =
        hasCustomBounds &&
        db_idx >= custMonFirst_R_idx_raw &&
        db_idx <= monTblLast_R_idx_raw;
      // if(isCustomMonsterRow && db_idx < 5){ // Log if it thinks one of the first few is custom
      //     fMyConsoleLog(`         -> Identified GM row ${db_idx} as Custom Monster Row.`);
      // }

      // --- Get Names & Apply Custom Skip Logic ---
      const monCustName = String(
        dbMon_R[resolvedGmColIndices["MonCustName"]] ?? ""
      ).trim();
      const monName = String(
        dbMon_R[resolvedGmColIndices["MonName"]] ?? ""
      ).trim();
      if (isCustomMonsterRow && !monCustName) {
        // fMyConsoleLog(`      -> Skipping GM row ${db_idx}: Is custom monster row but has no 'MonCustName'.`); // Verbose
        continue;
      }
      let finalMonsterName =
        monCustName || monName || `Unnamed Monster ${db_idx + 1}`; // Use custom, fallback to standard, then generic

      // Trim "Mon: " prefix
      const prefix = "Mon: ";
      if (finalMonsterName.startsWith(prefix)) {
        finalMonsterName = finalMonsterName.substring(prefix.length);
      }

      // Find the index of the first occurrence of " _" or "   "and delete from there to end of finalMonsterName
      const indexOfUnderscore = finalMonsterName.indexOf(" _");
      const indexOfSpaces = finalMonsterName.indexOf("   ");
      let trimIndex = -1;
      // Determine which pattern occurs first, if any
      if (indexOfUnderscore !== -1 && indexOfSpaces !== -1) {
        // Both patterns found, find the one that appears earlier
        trimIndex = Math.min(indexOfUnderscore, indexOfSpaces);
      } else if (indexOfUnderscore !== -1) {
        // Only underscore pattern found
        trimIndex = indexOfUnderscore;
      } else if (indexOfSpaces !== -1) {
        // Only spaces pattern found
        trimIndex = indexOfSpaces;
      }
      // If one of the patterns was found, trim the string from that index onwards
      if (trimIndex !== -1) {
        finalMonsterName = finalMonsterName.substring(0, trimIndex);
      }

      // --- Check Turbo Table Capacity ---
      if (turboMon_R > turboMon_R_end) {
        isOverflowing = true;
        fMyConsoleLog(
          `   -> Turbo table overflow detected at GM row index ${db_idx}. Attempting to write to row ${turboMon_R}, but last available is ${turboMon_R_end}.`
        );
        break; // Stop processing rows
      }
      // fMyConsoleLog(`         -> Mapping to Turbo Row ${turboMon_R} (Name: ${finalMonsterName})`); // Verbose

      // --- Extract & Map Data ---
      const vit = dbMon_R[resolvedGmColIndices["Vit"]];
      const atk = dbMon_R[resolvedGmColIndices["Atk"]];
      const dmg = dbMon_R[resolvedGmColIndices["Dmg"]];
      const def = dbMon_R[resolvedGmColIndices["Def"]];
      const ar = dbMon_R[resolvedGmColIndices["Ar"]];
      const pic = isCustomMonsterRow
        ? ""
        : dbMon_R[resolvedGmColIndices["Pic"]];
      const notes = String(dbMon_R[resolvedGmColIndices["Notes"]] ?? "");

      // --- Parse Size ---
      let size = "";
      const sizePrefix = "SIZE: ";
      const sizeIndex = notes.toUpperCase().indexOf(sizePrefix);
      if (sizeIndex !== -1) {
        const lineEndIndex = notes.indexOf("\n", sizeIndex);
        const sizeText =
          lineEndIndex === -1
            ? notes.substring(sizeIndex + sizePrefix.length)
            : notes.substring(sizeIndex + sizePrefix.length, lineEndIndex);
        size = sizeText.trim();
      }
      if (isCustomMonsterRow) size = "";

      // --- Set Values in Turbo Grid ---
      let rowUpdateSuccess = true;
      rowUpdateSuccess &&= fSetGridValue(
        turboMon_R,
        "MonName",
        finalMonsterName
      );
      rowUpdateSuccess &&= fSetGridValue(turboMon_R, "MonVit", vit);
      rowUpdateSuccess &&= fSetGridValue(turboMon_R, "MonAtk", atk);
      rowUpdateSuccess &&= fSetGridValue(turboMon_R, "MonDmg", dmg);
      rowUpdateSuccess &&= fSetGridValue(turboMon_R, "MonDef", def);
      rowUpdateSuccess &&= fSetGridValue(turboMon_R, "MonAR", ar);
      rowUpdateSuccess &&= fSetGridValue(turboMon_R, "MonPic", pic);
      rowUpdateSuccess &&= fSetGridValue(turboMon_R, "MonSize", size);
      rowUpdateSuccess &&= fSetGridValue(turboMon_R, "NumMon", ""); // Clear NumMon

      if (rowUpdateSuccess) {
        monstersAdded++;
      } else {
        errorsSettingValue++;
        fMyConsoleLog(
          `      -> ‚ö†Ô∏è Error setting some values for Turbo row ${turboMon_R}.`
        );
      }

      // Increment Turbo row pointer
      turboMon_R++;
    } // End loop through gmDataArray

    // === 5. Show Overflow Message if Needed ===
    if (isOverflowing) {
      const message = `‚ö†Ô∏è Too many active monsters on GM Screen!
 <br>Only the first ${turboTableAvailableRows} could be loaded. Please ask the GM to reduce active monsters.`;
      fMyConsoleLog(`   -> ${message.replace("<br>", " ")}`);
      await fShowMessage(message);
    }

    fMyConsoleLog(
      `‚úÖ Monster Table Update Complete. Added: ${monstersAdded} monsters.${
        errorsSettingValue > 0
          ? ` (${errorsSettingValue} errors setting values)`
          : ""
      }${isOverflowing ? " (Overflow occurred)" : ""}`
    );
  } // END fUpdateMonsterTable

  // fHandleChaosGemClick ////////////////////////////////////////////////////////////
  // Purpose -> Handles Chaos Gem clicks. Decrements uses, logs ability text (with icon) to sidebar.
  // Inputs  -> r (Number), c (Number).
  // Outputs -> (Promise<Boolean>): True if Chaos Gem processed, false otherwise.
  async function fHandleChaosGemClick(r, c) {
    fMyConsoleLog("üíé Checking for Chaos Gem click...");
    // === 1. Validate Input Coordinates ===
    if (r === null || c === null || isNaN(r) || isNaN(c)) {
      fMyConsoleLog(
        "   -> Cannot check Chaos Gem: Invalid coordinates passed."
      );
      return false;
    }

    // === 2. Get Chaos Gem Range & Validate ===
    const chaosRangeDef = gUI.range?.chaosGems;
    if (!chaosRangeDef || !fDoesObjectHaveR1C1R2C2Properties(chaosRangeDef)) {
      fMyConsoleLog(
        "   -> Cannot check Chaos Gem: Range definition missing/invalid."
      );
      return false;
    }

    // === 3. Resolve Range & Check if Click Was Inside ===
    const resolved = fConvertsR1C1R2C2TagOrNumToIndices(chaosRangeDef);
    if ([resolved.r1, resolved.c1, resolved.r2, resolved.c2].some(isNaN)) {
      fMyConsoleLog(
        `   -> Cannot check Chaos Gem: Failed to resolve range tags: ${JSON.stringify(
          chaosRangeDef
        )}`
      );
      return false;
    }
    const rMin = Math.min(resolved.r1, resolved.r2);
    const rMax = Math.max(resolved.r1, resolved.r2);
    const cMin = Math.min(resolved.c1, resolved.c2);
    const cMax = Math.max(resolved.c1, resolved.c2);
    if (r < rMin || r > rMax || c < cMin || c > cMax) {
      fMyConsoleLog(`   -> Click [${r}, ${c}] is outside Chaos Gem range.`);
      return false;
    }
    fMyConsoleLog(`   -> Click [${r}, ${c}] is inside Chaos Gem range.`);

    // === 4. Check Gem Conditions (Uses & Ability Text) ===
    const usesCol = fResolveCol("ChaosUses");
    const abilityCol = fResolveCol("ChaosAbility");
    if (isNaN(usesCol) || isNaN(abilityCol)) {
      fMyConsoleLog(
        "   -> Cannot check Chaos Gem: Could not resolve 'ChaosUses' or 'ChaosAbility' column tags."
      );
      await fShowMessage(
        "Error: Chaos Gem column tags are not defined correctly."
      );
      return false;
    }

    const currentUses = fGetGridValue(r, usesCol, true);
    if (isNaN(currentUses) || currentUses < 1) {
      fMyConsoleLog(
        `   -> Chaos Gem condition unmet: Uses are ${currentUses}.`
      );
      await fShowMessage("Chaos Crystal has no uses left!");
      return true;
    }

    const abilityText = fGetGridValue(r, abilityCol);
    if (!abilityText || String(abilityText).trim() === "") {
      fMyConsoleLog(`   -> Chaos Gem condition unmet: Ability text is empty.`);
      await fShowMessage("Chaos Crystal has no ability text defined!");
      return true;
    }

    // === 5. Conditions Met - Perform Actions ===
    fMyConsoleLog(
      `   -> Chaos Gem conditions met: Uses=${currentUses}, Ability="${String(
        abilityText
      ).substring(0, 30)}..."`
    );
    const newUses = currentUses - 1;

    // Update Grid (decrement uses)
    if (!fSetGridValue(r, usesCol, newUses)) {
      fMyConsoleLog(
        `   -> ‚ùå Failed to update ChaosUses cell [${r}, ${usesCol}].`
      );
      await fShowMessage("Error: Failed to update Chaos Crystal uses.");
      return true;
    }

    // Build Sidebar Message (HTML and Plain Text)
    const trimmedAbilityText = String(abilityText).trim();
    const sidebarMsgHtml = `üíé <span class="blue-bold">Chaos Crystal</span> (${newUses} Uses Left):<br>${trimmedAbilityText}`;
    const sidebarMsgText = `üíé Chaos Crystal (${newUses} Uses Left):\n${trimmedAbilityText}`;

    // Update Sidebar
    fPostToSidebar(sidebarMsgHtml, sidebarMsgText);
    fShowSidebar();

    fMyConsoleLog("‚úÖ Chaos Gem Used Successfully.");

    // Send log update to GMScreen (with slight delay)
    setTimeout(() => fSendLogToGMScreenAndPS(), 0);

    return true; // Signal that the gem click was fully processed
  } // END fHandleChaosGemClick

  // fHandleAdHocRoll ////////////////////////////////////////////////////////////////
  // Purpose -> Parses and rolls dice based on cell text content (sk#, XdY+/-Z, #).
  //            Logs result (HTML & plain text) to sidebar, including die icon.
  // Inputs  -> cellText (String): The text content of the clicked cell.
  // Outputs -> (Promise<Boolean>): True if roll was parsed and logged, false otherwise.
  async function fHandleAdHocRoll(cellText) {
    fMyConsoleLog(`üé≤ Attempting Ad-Hoc Roll for text: "${cellText}"`);
    if (typeof cellText !== "string" || !cellText.trim()) {
      fMyConsoleLog("   -> No valid text provided for ad-hoc roll.");
      return false;
    }
    const text = cellText.trim();

    let rollResult = null;
    let logHeaderHtml = "";
    let logHeaderText = "";
    let logDetailsHtml = "";
    let logDetailsText = "";
    let patternMatched = false;
    let matchedString = "";

    const skExactPattern = /^sk(\d+)$/i;
    const dieStringExactPattern = /^((\d+)?d(\d+)\s*(?:([-+])\s*(\d+))?)$/i;
    const numberExactPattern = /^\d+$/;
    const parsePattern = /(sk(\d+))|((\d+)?d(\d+)\s*(?:([-+])\s*(\d+))?)/i;

    let match;
    // === 1. Check for Exact Matches ===
    if ((match = text.match(skExactPattern))) {
      const num = parseInt(match[1], 10);
      if (!isNaN(num) && num > 0) {
        rollResult = fMetaDieRoll(num);
        matchedString = match[0];
        logHeaderHtml = 'üé≤ <span class="blue-bold">Custom Roll</span> Sk';
        logHeaderText = "üé≤ Custom Roll Sk";
        logDetailsHtml = `Sk(${num}) ~${rollResult}`;
        logDetailsText = `Sk(${num}) ~${rollResult}`;
        patternMatched = true;
        fMyConsoleLog(
          `   -> Matched EXACT Sk pattern: ${matchedString}. Result: ${rollResult}`
        );
      }
    } else if ((match = text.match(dieStringExactPattern))) {
      matchedString = match[0].trim();
      rollResult = fRollRPGDieString(matchedString);
      if (rollResult !== null) {
        logHeaderHtml = 'üé≤ <span class="blue-bold">Die Roll</span>';
        logHeaderText = "üé≤ Die Roll";
        logDetailsHtml = `Die(${matchedString}) ~${rollResult}`;
        logDetailsText = `Die(${matchedString}) ~${rollResult}`;
        patternMatched = true;
        fMyConsoleLog(
          `   -> Matched EXACT Die String pattern: ${matchedString}. Result: ${rollResult}`
        );
      }
    } else if (numberExactPattern.test(text)) {
      const num = parseInt(text, 10);
      if (!isNaN(num) && num > 0) {
        matchedString = `d${num}`;
        rollResult = fRollRPGDieString(matchedString);
        if (rollResult !== null) {
          logHeaderHtml = 'üé≤ <span class="blue-bold">Die Roll</span>';
          logHeaderText = "üé≤ Die Roll";
          logDetailsHtml = `Die(${matchedString}) ~${rollResult}`;
          logDetailsText = `Die(${matchedString}) ~${rollResult}`;
          patternMatched = true;
          fMyConsoleLog(
            `   -> Matched EXACT Number pattern: ${num} (rolled as ${matchedString}). Result: ${rollResult}`
          );
        }
      }
    }

    // === 2. Parse for First Match (if no exact match) ===
    if (!patternMatched) {
      fMyConsoleLog(`   -> No exact match. Parsing text for first pattern...`);
      match = text.match(parsePattern);
      if (match) {
        if (match[1]) {
          // Matched sk#
          matchedString = match[1];
          const num = parseInt(match[2], 10);
          if (!isNaN(num) && num > 0) {
            rollResult = fMetaDieRoll(num);
            logHeaderHtml = 'üé≤ <span class="blue-bold">Custom Roll</span> Sk';
            logHeaderText = "üé≤ Custom Roll Sk";
            logDetailsHtml = `Sk(${num}) ~${rollResult}`;
            logDetailsText = `Sk(${num}) ~${rollResult}`;
            patternMatched = true;
            fMyConsoleLog(
              `   -> PARSED first Sk pattern: ${matchedString}. Result: ${rollResult}`
            );
          }
        } else if (match[3]) {
          // Matched die string
          matchedString = match[3].trim();
          rollResult = fRollRPGDieString(matchedString);
          if (rollResult !== null) {
            logHeaderHtml = 'üé≤ <span class="blue-bold">Die Roll</span>';
            logHeaderText = "üé≤ Die Roll";
            logDetailsHtml = `Die(${matchedString}) ~${rollResult}`;
            logDetailsText = `Die(${matchedString}) ~${rollResult}`;
            patternMatched = true;
            fMyConsoleLog(
              `   -> PARSED first Die String pattern: ${matchedString}. Result: ${rollResult}`
            );
          }
        }
      } else {
        fMyConsoleLog(`   -> No parsable pattern found within text.`);
      }
    }

    // === 3. Log to Sidebar if Successful ===
    if (patternMatched && rollResult !== null) {
      const headerSuffixHtml =
        text === matchedString ? ":" : ` (from "${text}"):`;
      const headerSuffixText =
        text === matchedString ? ":" : ` (from "${text}"):`;
      const formattedHeaderHtml = `${logHeaderHtml}${headerSuffixHtml}`;
      const formattedHeaderText = `${logHeaderText}${headerSuffixText}`; // Icon is already in logHeaderText

      let tcSuffixHtml = "";
      let tcSuffixText = "";
      if (logHeaderText.startsWith("üé≤ Custom Roll Sk")) {
        // Check text version for Sk roll
        const tcResult = fTC();
        if (tcResult) {
          tcSuffixHtml = `   ${tcResult}`;
          tcSuffixText = tcResult.includes("red-bold") ? " C" : " T";
        }
      }

      const finalLogHtml = `${formattedHeaderHtml}<br>${logDetailsHtml}${tcSuffixHtml}`;
      const finalLogText = `${formattedHeaderText}\n${logDetailsText}${
        tcSuffixText ? " " + tcSuffixText : ""
      }`;
      fPostToSidebar(finalLogHtml, finalLogText);
      fShowSidebar();
      fMyConsoleLog(`   -> Ad-Hoc Roll logged to sidebar.`);

      // Send log update to GMScreen (with slight delay)
      setTimeout(() => fSendLogToGMScreenAndPS(), 0);

      return true; // Indicate roll was handled
    }

    // === 4. No Match Found ===
    if (!patternMatched) {
      fMyConsoleLog("   -> No ad-hoc roll pattern matched (exact or parsed).");
    }
    return false; // Indicate no valid roll was handled
  } // END fHandleAdHocRoll

  // fCalcGearLine ///////////////////////////////////////////////////////////////////
  // Purpose -> Handles edits to gear-related input cells (PossNum, PossWorn, PossPerOff).
  //            Validates the new input value, updates the edited cell in the grid,
  //            triggers fRefreshGearLineCalcs to update derived values, and if successful,
  //            triggers fCalculatesEnc_MR_AP for the overall totals. Reverts changes on failure.
  // Inputs  -> r (Number): The 0-based row index of the edited cell.
  //         -> c (Number): The 0-based column index of the edited cell.
  //         -> newValue (Any): The proposed new value for the edited cell.
  //         -> oldValue (Any): The previous value of the edited cell (for reverting).
  // Outputs -> (Promise<Any | null>): Resolves with the validated `newValue` if successful, or `null`
  //                                  if validation or subsequent calculations fail (signaling not
  //                                  to update gUI.arr in caller).
  async function fCalcGearLine(r, c, newValue, oldValue) {
    const funcName = "fCalcGearLine";
    fMyConsoleLog(
      `‚öñÔ∏è ${funcName}: Handling edit for cell [${r}, ${c}] with new value: "${newValue}" (Old: "${oldValue}")`
    );

    // --- Column Tags for Input Validation & Derived Values ---
    const possNumColTag = "PossNum";
    const possWornColTag = "PossWorn";
    const possPerOffColTag = "PossPerOff";
    const possEncColTag = "PossEnc";
    const possCrTotColTag = "PossCrTot";
    const possAPTotColTag = "PossAPTot";
    const gearColumnsToCalculate = [
      possNumColTag,
      possWornColTag,
      possPerOffColTag,
    ]; // Input columns

    // === 1. Basic Pre-checks ===
    const possNameVal = fGetGridValue(r, "Ability"); // Check if an item is selected
    const gearID = fGetIDFromNameID(possNameVal);
    const gearCache = gUI.dbGearFSData;

    if (!gearID) {
      fMyConsoleLog(
        `   -> Skipping ${funcName}: PossName invalid or missing ID for row ${r}.`
      );
      await fShowMessage(
        "Cannot modify gear numbers/status until a valid item with an ID is selected in the 'Ability' column."
      );
      fRevertCellDOM(r, c, oldValue); // Revert the change in the DOM
      return null; // Signal failure to caller
    }
    if (!gearCache || !gearCache.text || !gearCache.colTagsMap) {
      fMyConsoleLog(
        `   -> ‚ùå Error: DB/Gear cache (gUI.dbGearFSData) not loaded or invalid.`
      );
      await fShowMessage(
        "Error: Gear definition cache not loaded. Cannot calculate gear line."
      );
      fRevertCellDOM(r, c, oldValue);
      return null;
    }

    // === 2. Determine Edited Column & Validate Input ===
    const editedColTag = Object.keys(gUI.colTag).find(
      (tag) => gUI.colTag[tag] === c
    );
    let validatedValue = newValue; // Assume valid initially
    let validationError = "";

    if (!gearColumnsToCalculate.includes(editedColTag)) {
      fMyConsoleLog(
        `   -> ‚ùå Error: ${funcName} called unexpectedly for non-gear-input column: ${editedColTag}`
      );
      fRevertCellDOM(r, c, oldValue);
      return null;
    }

    // --- Perform Input Validation based on Column ---
    switch (editedColTag) {
      case possNumColTag:
        const numInput = Number(newValue);
        if (isNaN(numInput) || !Number.isInteger(numInput) || numInput < 0) {
          validationError = `Invalid number ("${newValue}"). '${possNumColTag}' must be a whole number >= 0.`;
          validatedValue = null; // Mark as invalid
        } else {
          validatedValue = numInput; // Store the valid number
        }
        break;
      case possWornColTag:
        // newValue is expected to be boolean true/false from checkbox handler
        if (typeof newValue !== "boolean") {
          // Fallback conversion if somehow called with string/other
          validatedValue = String(newValue).toUpperCase() === "TRUE";
        } else {
          validatedValue = newValue; // Already boolean
        }
        break;
      case possPerOffColTag:
        const perOffInput = String(newValue ?? "").trim();
        // Allow empty string OR a valid percentage format
        if (
          perOffInput !== "" &&
          (!perOffInput.endsWith("%") || isNaN(parseFloat(perOffInput)))
        ) {
          validationError = `Invalid format ("${newValue}"). '${possPerOffColTag}' must be blank or a percentage (e.g., 50%).`;
          validatedValue = null; // Mark as invalid
        } else {
          validatedValue = perOffInput; // Store valid string (empty or 'X%')
        }
        break;
    }

    // --- Handle Input Validation Failure ---
    if (validatedValue === null) {
      fMyConsoleLog(`   -> ‚ùå Input Validation Failed: ${validationError}`);
      await fShowMessage(validationError);
      fRevertCellDOM(r, c, oldValue); // Revert the change in the DOM
      return null; // Signal failure to the caller
    }

    // === 3. Get Current Derived Values (BEFORE applying changes) ===
    // These are needed by the helper to revert if *it* fails
    const previousEnc = fGetGridValue(r, possEncColTag);
    const previousCr = fGetGridValue(r, possCrTotColTag);
    const previousAp = fGetGridValue(r, possAPTotColTag);

    // === 4. Update the Edited Cell's Value (Input Validation Passed) ===
    if (!fSetGridValue(r, c, validatedValue)) {
      fMyConsoleLog(
        `   -> ‚ùå Error setting validated value for edited cell [${r}, ${c}].`
      );
      await fShowMessage(
        `Error updating edited cell [${r}, ${c}] with validated value.`
      );
      // No need to revert DOM here as fSetGridValue failed, but signal failure
      return null;
    }
    fMyConsoleLog(
      `   -> Successfully updated edited cell [${r}, ${c}] with validated value: "${validatedValue}"`
    );

    // === 5. Refresh Derived Calculations via Helper ===
    const refreshSuccess = fRefreshGearLineCalcs(
      r,
      previousEnc,
      previousCr,
      previousAp
    ); // Call the helper

    // === 6. Recalculate Overall Totals OR Revert Edited Cell on Failure ===
    if (refreshSuccess) {
      // Refresh helper succeeded and updated derived cells
      fMyConsoleLog(
        `   -> Triggering fCalculatesEnc_MR_AP after successful refresh for row ${r}...`
      );
      await fCalculatesEnc_MR_AP(); // Update overall totals
      fMyConsoleLog(`‚úÖ ${funcName} completed successfully for [${r}, ${c}].`);
      return validatedValue; // Return validated value on full success
    } else {
      // Refresh helper failed and reverted derived cells
      fMyConsoleLog(
        `   -> ‚ùå Error occurred during fRefreshGearLineCalcs for row ${r}.`
      );
      // fRefreshGearLineCalcs logs its error & possibly shows msg
      // CRITICAL: Revert the originally edited cell back to its old value
      fMyConsoleLog(
        `      -> Reverting edited cell [${r}, ${c}] back to old value: "${oldValue}"`
      );
      fSetGridValue(r, c, oldValue); // Revert the initial change
      return null; // Signal failure
    }
  } // END fCalcGearLine

  // fRefreshGearLineCalcs ///////////////////////////////////////////////////////
  // Purpose -> Helper to calculate and update derived gear values (Enc, CR Total, AP Total)
  //            for a specific row `r`. Reverts derived values to provided 'old' values
  //            if calculation prerequisites are missing or invalid.
  // Inputs  -> r (Number): The 0-based row index of the gear line to refresh.
  //         -> oldEnc (Any): The value of 'PossEnc' before the initiating change.
  //         -> oldCr (Any): The value of 'PossCrTot' before the initiating change.
  //         -> oldAp (Any): The value of 'PossAPTot' before the initiating change.
  // Outputs -> (Boolean): True if calculations and updates succeeded, false otherwise.
  // Note    -> Called by fCalcGearLine after an input change and potentially by other functions
  //            like fTotalRereshOfAllAbilitiesAndAllGear in the future.
  function fRefreshGearLineCalcs(r, oldEnc, oldCr, oldAp) {
    const funcName = "fRefreshGearLineCalcs";
    fMyConsoleLog(
      `   -> ${funcName}: Refreshing derived calculations for row ${r}...`
    );

    // === Column Tags ===
    const possNameColTag = "Ability";
    const possNumColTag = "PossNum";
    const possWornColTag = "PossWorn";
    const possPerOffColTag = "PossPerOff";
    const possEncColTag = "PossEnc";
    const possCrTotColTag = "PossCrTot";
    const possAPTotColTag = "PossAPTot";

    // === 1. Get Current Input Values from Grid ===
    const possNameVal = fGetGridValue(r, possNameColTag);
    const calc_possNumVal = fGetGridValue(r, possNumColTag, true) || 0; // Default to 0 if invalid
    const calc_isWornVal = fGetGridValue(r, possWornColTag) || false; // Default to false
    const calc_perOffVal = fGetGridValue(r, possPerOffColTag) || ""; // Default to empty string

    // === 2. Validate Prerequisites (Gear ID & Cache) ===
    const gearID = fGetIDFromNameID(possNameVal);
    const gearCache = gUI.dbGearFSData;
    let validationFailed = false;

    if (!gearID) {
      fMyConsoleLog(
        `      -> ${funcName} Validation Failed: Cannot extract Gear ID from "${possNameVal}" for row ${r}.`
      );
      validationFailed = true;
    } else if (!gearCache || !gearCache.text || !gearCache.colTagsMap) {
      fMyConsoleLog(
        `      -> ${funcName} Validation Failed: DB/Gear cache (gUI.dbGearFSData) not loaded or invalid.`
      );
      validationFailed = true;
    }

    if (validationFailed) {
      fMyConsoleLog(
        `      -> Reverting derived cells for row ${r} to old values.`
      );
      fSetGridValue(r, possEncColTag, oldEnc);
      fSetGridValue(r, possCrTotColTag, oldCr);
      fSetGridValue(r, possAPTotColTag, oldAp);
      // Optional: Show a message to the user? Depends on how critical this is.
      // await fShowMessage("Error: Cannot calculate gear values due to missing ID or cache.");
      return false; // Indicate failure
    }

    // === 3. Get Constants from Gear Cache ===
    fMyConsoleLog(`      -> ${funcName}: Using Gear ID: ${gearID}`);
    const wornEnc = Number(fGetVal_GUICache(gearID, "WornEnc", gearCache) || 0);
    const itemEnc = Number(fGetVal_GUICache(gearID, "ItemEnc", gearCache) || 0);
    const crEach = Number(fGetVal_GUICache(gearID, "ItemCR", gearCache) || 0);
    const apEach = Number(fGetVal_GUICache(gearID, "AP", gearCache) || 0);
    fMyConsoleLog(
      `      -> DB Constants: WornEnc=${wornEnc}, ItemEnc=${itemEnc}, CrEach=${crEach}, APEach=${apEach}`
    );

    // === 4. Perform Calculations ===
    const encEachVal = calc_isWornVal && wornEnc !== 0 ? wornEnc : itemEnc;
    const gearEncTot = calc_possNumVal * encEachVal;
    fMyConsoleLog(
      `         -> Enc Calc: EncEach=${encEachVal}, Total=${gearEncTot}`
    );

    let parsedPercent = 1.0;
    if (typeof calc_perOffVal === "string" && calc_perOffVal.endsWith("%")) {
      const numPart = parseFloat(calc_perOffVal);
      if (!isNaN(numPart)) {
        parsedPercent = (100 - numPart) / 100;
      }
    }
    const rawCrTotal = calc_possNumVal * crEach * parsedPercent;
    const gearTotCr = isNaN(rawCrTotal) ? 0 : Math.round(rawCrTotal);
    fMyConsoleLog(
      `         -> CR Calc: CrEach=${crEach}, Num=${calc_possNumVal}, PercMult=${parsedPercent.toFixed(
        2
      )} => Raw=${rawCrTotal} => Final=${gearTotCr}`
    );

    const gearAPTot = calc_possNumVal * apEach;
    fMyConsoleLog(
      `         -> AP Calc: APEach=${apEach}, Num=${calc_possNumVal} => Total=${gearAPTot}`
    );

    // === 5. Update Grid Cells for Derived Values ===
    let updateSuccess = true;
    fMyConsoleLog(`      -> Updating calculated cells for row ${r}...`);
    // Use &&= to short-circuit if any update fails
    updateSuccess &&= fSetGridValue(r, possEncColTag, gearEncTot);
    updateSuccess &&= fSetGridValue(r, possCrTotColTag, gearTotCr);
    updateSuccess &&= fSetGridValue(r, possAPTotColTag, gearAPTot);

    if (!updateSuccess) {
      fMyConsoleLog(
        `      -> ‚ùå ${funcName}: Error occurred during fSetGridValue updates for derived cells on row ${r}.`
      );
      // Revert derived cells on update failure
      fSetGridValue(r, possEncColTag, oldEnc);
      fSetGridValue(r, possCrTotColTag, oldCr);
      fSetGridValue(r, possAPTotColTag, oldAp);
      return false; // Indicate failure
    }

    fMyConsoleLog(
      `   -> ${funcName}: Refresh finished successfully for row ${r}.`
    );
    return true; // Indicate success
  } // END fRefreshGearLineCalcs
</script>
